THREE.ColladaExporter=class{parse(e,t,r={}){""!==(r=Object.assign({version:"1.4.1",author:null,textureDirectory:""},r)).textureDirectory&&(r.textureDirectory=`${r.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const a=r.version;if("1.4.1"!==a&&"1.5.0"!==a)return console.warn(`ColladaExporter : Version ${a} not supported for export. Only 1.4.1 and 1.5.0.`),null;let n,i;function s(e,t){return n=n||document.createElement("canvas"),i=i||n.getContext("2d"),n.width=e.width,n.height=e.height,i.drawImage(e,0,0),function(e){const t=atob(e),r=new Uint8Array(t.length);for(let e=0,a=r.length;e<a;e++)r[e]=t.charCodeAt(e);return r}(n.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,""))}const o=["getX","getY","getZ","getW"];function c(e){if(e.isInterleavedBufferAttribute){const t=new e.array.constructor(e.count*e.itemSize),r=e.itemSize;for(let a=0,n=e.count;a<n;a++)for(let n=0;n<r;n++)t[a*r+n]=e[o[n]](a);return t}return e.array}function l(e,t,r){return Array.isArray(e)?e.slice(t,t+r):new e.constructor(e.buffer,t*e.BYTES_PER_ELEMENT,r)}function u(e,t,r,a){const n=c(e);return`<source id="${t}"><float_array id="${t}-array" count="${n.length}">`+n.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(n.length/e.itemSize)}" stride="${e.itemSize}">`+r.map(e=>`<param name="${e}" type="${a}" />`).join("")+"</accessor></technique_common></source>"}let m;function p(e){let t=$.get(e);if(null==t){t=`image-${h.length+1}`;const n="png",i=e.name||t;let o=`<image id="${t}" name="${i}">`;o+="1.5.0"===a?`<init_from><ref>${r.textureDirectory}${i}.${n}</ref></init_from>`:`<init_from>${r.textureDirectory}${i}.${n}</init_from>`,o+="</image>",h.push(o),$.set(e,t),g.push({directory:r.textureDirectory,name:i,ext:n,data:s(e.image,n),original:e})}return t}const f=new WeakMap,d=new WeakMap,$=new WeakMap,g=[],h=[],y=[],_=[],x=[],b=function e(t){let r=`<node name="${t.name}">`;if(r+=function(e){return e.updateMatrix(),m=m||new THREE.Matrix4,m.copy(e.matrix),m.transpose(),`<matrix>${m.toArray().join(" ")}</matrix>`}(t),!0===t.isMesh&&null!==t.geometry){const e=function(e){let t=f.get(e);if(!t){const r=e;if(!0!==r.isBufferGeometry)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const a=`Mesh${y.length+1}`,n=r.index?r.index.count*r.index.itemSize:r.attributes.position.count,i=null!=r.groups&&0!==r.groups.length?r.groups:[{start:0,count:n,materialIndex:0}];let s=`<geometry id="${a}"${e.name?` name="${e.name}"`:""}><mesh>`;const o=`${a}-position`,m=`${a}-vertices`;s+=u(r.attributes.position,o,["X","Y","Z"],"float"),s+=`<vertices id="${m}"><input semantic="POSITION" source="#${o}" /></vertices>`;let p=`<input semantic="VERTEX" source="#${m}" offset="0" />`;if("normal"in r.attributes){const e=`${a}-normal`;s+=u(r.attributes.normal,e,["X","Y","Z"],"float"),p+=`<input semantic="NORMAL" source="#${e}" offset="0" />`}if("uv"in r.attributes){const e=`${a}-texcoord`;s+=u(r.attributes.uv,e,["S","T"],"float"),p+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="0" />`}if("uv2"in r.attributes){const e=`${a}-texcoord2`;s+=u(r.attributes.uv2,e,["S","T"],"float"),p+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="1" />`}if("color"in r.attributes){const e=`${a}-color`;s+=u(r.attributes.color,e,["X","Y","Z"],"uint8"),p+=`<input semantic="COLOR" source="#${e}" offset="0" />`}let d=null;if(r.index)d=c(r.index);else{d=new Array(n);for(let e=0,t=d.length;e<t;e++)d[e]=e}for(let e=0,t=i.length;e<t;e++){const t=i[e],r=l(d,t.start,t.count),a=r.length/3;s+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${a}">`,s+=p,s+=`<p>${r.join(" ")}</p>`,s+="</triangles>"}s+="</mesh></geometry>",y.push(s),t={meshid:a,bufferGeometry:r},f.set(e,t)}return t}(t.geometry),a=e.meshid,n=e.bufferGeometry;let i,s=null;const o=t.material||new THREE.MeshBasicMaterial,m=Array.isArray(o)?o:[o];i=n.groups.length>m.length?new Array(n.groups.length):new Array(m.length),s=i.fill().map((e,t)=>function(e){let t=d.get(e);if(null==t){t=`Mat${_.length+1}`;let r="phong";!0===e.isMeshLambertMaterial?r="lambert":!0===e.isMeshBasicMaterial&&(r="constant",null!==e.map&&console.warn("ColladaExporter: Texture maps not supported with THREE.MeshBasicMaterial."));const a=e.emissive?e.emissive:new THREE.Color(0,0,0),n=e.color?e.color:new THREE.Color(0,0,0),i=e.specular?e.specular:new THREE.Color(1,1,1),s=e.shininess||0,o=e.reflectivity||0;let c="";!0===e.transparent&&(c+="<transparent>"+(e.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",e.opacity<1&&(c+=`<transparency><float>${e.opacity}</float></transparency>`));const l=`<technique sid="common"><${r}><emission>`+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${a.r} ${a.g} ${a.b} 1</color>`)+"</emission>"+("constant"!==r?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${n.r} ${n.g} ${n.b} 1</color>`)+"</diffuse>":"")+("constant"!==r?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===r?`<specular><color sid="specular">${i.r} ${i.g} ${i.b} 1</color></specular><shininess>`+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${s}</float>`)+"</shininess>":"")+`<reflective><color>${n.r} ${n.g} ${n.b} 1</color></reflective>`+`<reflectivity><float>${o}</float></reflectivity>`+c+`</${r}></technique>`,u=`<effect id="${t}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${p(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${p(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${p(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${p(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+l+(e.side===THREE.DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",m=`<material id="${t}"${e.name?` name="${e.name}"`:""}><instance_effect url="#${t}-effect" /></material>`;x.push(m),_.push(u),d.set(e,t)}return t}(m[t%m.length])),r+=`<instance_geometry url="#${a}">`+(null!=s?"<bind_material><technique_common>"+s.map((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return t.children.forEach(t=>r+=e(t)),r+="</node>",r}(e);let E=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===a?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${a}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==r.author?`<author>${r.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified><up_axis>Y_UP</up_axis></asset>`;E+=`<library_images>${h.join("")}</library_images>`,E+=`<library_effects>${_.join("")}</library_effects>`,E+=`<library_materials>${x.join("")}</library_materials>`,E+=`<library_geometries>${y.join("")}</library_geometries>`,E+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${b}</visual_scene></library_visual_scenes>`,E+='<scene><instance_visual_scene url="#Scene"/></scene>',E+="</COLLADA>";const w={data:function(e){const t=/^<\//,r=/(\?>$)|(\/>$)/,a=/<[^>]+>[^<]*<\/[^<]+>/,n=(e,t)=>t>0?e+n(e,t-1):"";let i=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map(e=>{a.test(e)||r.test(e)||!t.test(e)||i--;const s=`${n("  ",i)}${e}`;return a.test(e)||r.test(e)||t.test(e)||i++,s}).join("\n")}(E),textures:g};return"function"==typeof t&&requestAnimationFrame(()=>t(w)),w}};