"use strict";const CONSTANTS=Object.freeze({_CSGDEBUG:!1,defaultResolution2D:32,defaultResolution3D:12,EPS:1e-5,angleEPS:.1,areaEPS:49916708323414084e-28,all:0,top:1,bottom:2,left:3,right:4,front:5,back:6}),IsFloat=function(t){return!isNaN(t)||t===1/0||t===-1/0},Plane=function(t,e){this.normal=t,this.w=e};Plane.fromVector3Ds=function(t,e,n){let o=e.minus(t).cross(n.minus(t)).unit();return new Plane(o,o.dot(t))},Plane.prototype={flipped:function(){return new Plane(this.normal.negated(),-this.w)},getTag:function(){let t=this.tag;return t||(t=window.getTag(),this.tag=t),t},equals:function(t){return this.normal.equals(t.normal)&&this.w===t.w},splitLineBetweenPoints:function(t,e){let n=e.minus(t),o=(this.w-this.normal.dot(t))/this.normal.dot(n);return isNaN(o)&&(o=0),o>1&&(o=1),o<0&&(o=0),t.plus(n.times(o))},signedDistanceToPoint:function(t){return this.normal.dot(t)-this.w},mirrorPoint:function(t){let e=this.signedDistanceToPoint(t);return t.minus(this.normal.times(2*e))}};let Polygon=function(t,e,n){if(this.vertices=t,this.shared={color:e?e.color:null,getHash:function(){return this.color?this.color.join("/"):this.color},getTag:function(){let t=this.tag;return t||(t=getTag(),this.tag=t),t}},this.plane=arguments.length>=3?n:Plane.fromVector3Ds(t[0].pos,t[1].pos,t[2].pos),CONSTANTS._CSGDEBUG&&!this.checkIfConvex())throw new Error("Not convex!")};Polygon.prototype={boundingSphere:function(){if(!this.cachedBoundingSphere){let t=this.boundingBox(),e=t[0].plus(t[1]).times(.5),n=t[1].minus(e).length();this.cachedBoundingSphere=[e,n]}return this.cachedBoundingSphere},boundingBox:function(){if(!this.cachedBoundingBox){let t,e,n=this.vertices,o=n.length;t=0===o?new Vector(0,0,0):n[0].pos,e=t;for(let r=1;r<o;r++){let o=n[r].pos;t=t.min(o),e=e.max(o)}this.cachedBoundingBox=[t,e]}return this.cachedBoundingBox},flipped:function(){let t=this.vertices.map(function(t){return t.flipped()});return t.reverse(),new Polygon(t,this.shared)}};const Vector=function(t,e,n){if(3===arguments.length)this._x=parseFloat(t),this._y=parseFloat(e),this._z=parseFloat(n);else if(2===arguments.length)this._x=parseFloat(t),this._y=parseFloat(e),this._z=0;else{var o=!0;if(1===arguments.length)if("object"==typeof t)t instanceof Vector?(this._x=t._x,this._y=t._y,this._z=t._z):t instanceof Array?t.length<2||t.length>3?o=!1:(this._x=parseFloat(t[0]),this._y=parseFloat(t[1]),3===t.length?this._z=parseFloat(t[2]):this._z=0):"x"in t&&"y"in t?(this._x=parseFloat(t.x),this._y=parseFloat(t.y),this._z="z"in t?parseFloat(t.z):0):"_x"in t&&"_y"in t?(this._x=parseFloat(t._x),this._y=parseFloat(t._y),this._z="_z"in t?parseFloat(t._z):0):o=!1;else{var r=parseFloat(t);this._x=r,this._y=r,this._z=r}else o=!1;if(!o)throw new Error("wrong arguments");IsFloat(this._x)&&IsFloat(this._y)&&IsFloat(this._z)||(o=!1)}};Vector.Create=function(t,e,n){var o=Object.create(Vector.prototype);return o._x=t,o._y=e,o._z=n,o},Vector.prototype={get x(){return this._x},get y(){return this._y},get z(){return this._z},set x(t){throw new Error("Vector is immutable")},set y(t){throw new Error("Vector is immutable")},set z(t){throw new Error("Vector is immutable")},clone:function(){return Vector.Create(this._x,this._y,this._z)},negated:function(){return Vector.Create(-this._x,-this._y,-this._z)},abs:function(){return Vector.Create(Math.abs(this._x),Math.abs(this._y),Math.abs(this._z))},plus:function(t){return Vector.Create(this._x+t._x,this._y+t._y,this._z+t._z)},minus:function(t){return Vector.Create(this._x-t._x,this._y-t._y,this._z-t._z)},times:function(t){return Vector.Create(this._x*t,this._y*t,this._z*t)},dividedBy:function(t){return Vector.Create(this._x/t,this._y/t,this._z/t)},dot:function(t){return this._x*t._x+this._y*t._y+this._z*t._z},lerp:function(t,e){return this.plus(t.minus(this).times(e))},lengthSquared:function(){return this.dot(this)},length:function(){return Math.sqrt(this.lengthSquared())},unit:function(){return this.dividedBy(this.length())},cross:function(t){return Vector.Create(this._y*t._z-this._z*t._y,this._z*t._x-this._x*t._z,this._x*t._y-this._y*t._x)},distanceTo:function(t){return this.minus(t).length()},distanceToSquared:function(t){return this.minus(t).lengthSquared()},equals:function(t){return this._x===t._x&&this._y===t._y&&this._z===t._z},multiply4x4:function(t){return t.leftMultiply1x3Vector(this)},randomNonParallelVector:function(){var t=this.abs();return t._x<=t._y&&t._x<=t._z?Vector.Create(1,0,0):t._y<=t._x&&t._y<=t._z?Vector.Create(0,1,0):Vector.Create(0,0,1)},min:function(t){return Vector.Create(Math.min(this._x,t._x),Math.min(this._y,t._y),Math.min(this._z,t._z))},max:function(t){return Vector.Create(Math.max(this._x,t._x),Math.max(this._y,t._y),Math.max(this._z,t._z))}};const Vertex=function(t){this.pos=t};Vertex.fromObject=function(t){var e=new Vector(t.pos);return new Vertex(e)},Vertex.prototype={flipped:function(){return this},getTag:function(){var t=this.tag;return t||(t=window.getTag(),this.tag=t),t},interpolate:function(t,e){var n=this.pos.lerp(t.pos,e);return new Vertex(n)}};let CSG=function(){this.polygons=[],this.properties=new Properties};CSG.prototype={union:function(t){let e,n;for(t instanceof Array?(e=t.slice(0),e.push(this)):e=[this,t],n=1;n<e.length;n+=2)e.push(e[n-1].unionSub(e[n]));return e[n-1]},unionSub:function(t){if(this.mayOverlap(t)){let e=new Tree(this.polygons),n=new Tree(t.polygons);e.clipTo(n,!1),n.clipTo(e),n.invert(),n.clipTo(e),n.invert();let o=e.allPolygons().concat(n.allPolygons()),r=this.fromPolygons(o);return r.properties=this.properties._merge(t.properties),r}{let e=this.polygons.concat(t.polygons),n=this.fromPolygons(e);return n.properties=this.properties._merge(t.properties),n}},subtract:function(t){let e;e=t instanceof Array?t:[t];let n=this;for(let t=0;t<e.length;t++){let o=t===e.length-1;n=n.subtractSub(e[t],o,o)}return n},subtractSub:function(t){let e=new Tree(this.polygons),n=new Tree(t.polygons);e.invert(),e.clipTo(n),n.clipTo(e,!0),e.addPolygons(n.allPolygons()),e.invert();let o=this.fromPolygons(e.allPolygons());return o.properties=this.properties._merge(t.properties),o},intersect:function(t){let e;e=t instanceof Array?t:[t];let n=this;for(let t=0;t<e.length;t++){let o=t===e.length-1;n=n.intersectSub(e[t],o,o)}return n},intersectSub:function(t){let e=new Tree(this.polygons),n=new Tree(t.polygons);e.invert(),n.clipTo(e),n.invert(),e.clipTo(n),n.clipTo(e),e.addPolygons(n.allPolygons()),e.invert();let o=this.fromPolygons(e.allPolygons());return o.properties=this.properties._merge(t.properties),o},fromPolygons:function(t){let e=new CSG;return e.polygons=t,e},bounds:function(t=this){if(!t.cachedBoundingBox){let e=new Vector(0,0,0),n=new Vector(0,0,0),o=t.polygons,r=o.length;for(let t=0;t<r;t++){let r=o[t].boundingBox();0===t?(e=r[0],n=r[1]):(e=e.min(r[0]),n=n.max(r[1]))}t.cachedBoundingBox=[e,n]}return t.cachedBoundingBox},getBounds:function(){return this.bounds()},mayOverlap:function(t){if(0===this.polygons.length||0===t.polygons.length)return!1;{let e=this.bounds(),n=this.bounds(t);return!(e[1].x<n[0].x)&&(!(e[0].x>n[1].x)&&(!(e[1].y<n[0].y)&&(!(e[0].y>n[1].y)&&(!(e[1].z<n[0].z)&&!(e[0].z>n[1].z)))))}},setColor:function(t){this.polygons.forEach(e=>{e.shared.color=t})}};const Properties=function(){};function splitPolygonByPlane(t,e){let n={type:null,front:null,back:null},o=t.normal,r=e.vertices,i=r.length;if(e.plane.equals(t))n.type=0;else{let s=t.w,l=!1,h=!1,a=[],p=-CONSTANTS.EPS;for(let t=0;t<i;t++){let e=o.dot(r[t].pos)-s,n=e<0;a.push(n),e>CONSTANTS.EPS&&(l=!0),e<p&&(h=!0)}if(l||h)if(h)if(l){n.type=4;let o=[],s=[],l=a[0];for(let e=0;e<i;e++){let n=r[e],h=e+1;h>=i&&(h=0);let p=a[h];if(l===p)l?s.push(n):o.push(n);else{let e=n.pos,i=r[h].pos,a=t.splitLineBetweenPoints(e,i),p=new Vertex(a);l?(s.push(n),s.push(p),o.push(p)):(o.push(n),o.push(p),s.push(p))}l=p}let h=CONSTANTS.EPS*CONSTANTS.EPS;if(s.length>=3){let t=s[s.length-1];for(let e=0;e<s.length;e++){let n=s[e];n.pos.distanceToSquared(t.pos)<h&&(s.splice(e,1),e--),t=n}}if(o.length>=3){let t=o[o.length-1];for(let e=0;e<o.length;e++){let n=o[e];n.pos.distanceToSquared(t.pos)<h&&(o.splice(e,1),e--),t=n}}o.length>=3&&(n.front=new Polygon(o,e.shared,e.plane)),s.length>=3&&(n.back=new Polygon(s,e.shared,e.plane))}else n.type=3;else n.type=2;else{let t=o.dot(e.plane.normal);n.type=t>=0?0:1}}return n}Properties.prototype={_transform:function(t){let e=new Properties;return Properties.transformObj(this,e,t),e},_merge:function(t){let e=new Properties;return Properties.cloneObj(this,e),Properties.addFrom(e,t),e}},Properties.transformObj=function(t,e,n){for(let o in t){if("_transform"===o)continue;if("_merge"===o)continue;let r=t[o],i=r;"object"==typeof r&&("transform"in r&&"function"==typeof r.transform?i=r.transform(n):r instanceof Array?(i=[],Properties.transformObj(r,i,n)):r instanceof Properties&&(i=new Properties,Properties.transformObj(r,i,n))),e[o]=i}},Properties.cloneObj=function(t,e){for(let n in t){if("_transform"===n)continue;if("_merge"===n)continue;let o=t[n],r=o;if("object"==typeof o)if(o instanceof Array){r=[];for(let t=0;t<o.length;t++)r.push(o[t])}else o instanceof Properties&&(r=new Properties,Properties.cloneObj(o,r));e[n]=r}},Properties.addFrom=function(t,e){for(let n in e)"_transform"!==n&&"_merge"!==n&&(n in t&&"object"==typeof t[n]&&t[n]instanceof Properties&&"object"==typeof e[n]&&e[n]instanceof Properties?Properties.addFrom(t[n],e[n]):n in t||(t[n]=e[n]))};const PolygonTreeNode=function(){this.parent=null,this.children=[],this.polygon=null,this.removed=!1};PolygonTreeNode.prototype={addPolygons:function(t){if(!this.isRootNode())throw new Error("Assertion failed");let e=this;t.map(function(t){e.addChild(t)})},remove:function(){if(!this.removed){if(this.removed=!0,CONSTANTS._CSGDEBUG){if(this.isRootNode())throw new Error("Assertion failed");if(this.children.length)throw new Error("Assertion failed")}let t=this.parent.children,e=t.indexOf(this);if(e<0)throw new Error("Assertion failed");t.splice(e,1),this.parent.recursivelyInvalidatePolygon()}},isRemoved:function(){return this.removed},isRootNode:function(){return!this.parent},invert:function(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()},getPolygon:function(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon},getPolygons:function(t){let e,n,o,r,i=[this],s=[i];for(e=0;e<s.length;++e)for(i=s[e],n=0,o=i.length;n<o;n++)r=i[n],r.polygon?t.push(r.polygon):s.push(r.children)},splitByPlane:function(t,e,n,o,r){if(this.children.length){let i,s,l,h,a,p=[this.children];for(i=0;i<p.length;i++)for(a=p[i],s=0,l=a.length;s<l;s++)h=a[s],h.children.length?p.push(h.children):h._splitByPlane(t,e,n,o,r)}else this._splitByPlane(t,e,n,o,r)},_splitByPlane:function(t,e,n,o,r){let i=this.polygon;if(i){let s=i.boundingSphere(),l=s[1]+CONSTANTS.EPS,h=t.normal,a=s[0],p=h.dot(a)-t.w;if(p>l)o.push(this);else if(p<-l)r.push(this);else{let s=splitPolygonByPlane(t,i);switch(s.type){case 0:e.push(this);break;case 1:n.push(this);break;case 2:o.push(this);break;case 3:r.push(this);break;case 4:if(s.front){let t=this.addChild(s.front);o.push(t)}if(s.back){let t=this.addChild(s.back);r.push(t)}}}}},addChild:function(t){let e=new PolygonTreeNode;return e.parent=this,e.polygon=t,this.children.push(e),e},invertSub:function(){let t,e,n,o,r=[this],i=[r];for(t=0;t<i.length;t++)for(r=i[t],e=0,n=r.length;e<n;e++)o=r[e],o.polygon&&(o.polygon=o.polygon.flipped()),i.push(o.children)},recursivelyInvalidatePolygon:function(){let t=this;for(;t.polygon;)t.polygon=null,t.parent&&(t=t.parent)}};const Tree=function(t){this.polygonTree=new PolygonTreeNode,this.rootnode=new Node(null),t&&this.addPolygons(t)};Tree.prototype={invert:function(){this.polygonTree.invert(),this.rootnode.invert()},clipTo:function(t,e){e=!!e,this.rootnode.clipTo(t,e)},allPolygons:function(){let t=[];return this.polygonTree.getPolygons(t),t},addPolygons:function(t){let e=this,n=t.map(function(t){return e.polygonTree.addChild(t)});this.rootnode.addPolygonTreeNodes(n)}};const Node=function(t){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=t};Node.prototype={invert:function(){let t,e=[this];for(let n=0;n<e.length;n++){t=e[n],t.plane&&(t.plane=t.plane.flipped()),t.front&&e.push(t.front),t.back&&e.push(t.back);let o=t.front;t.front=t.back,t.back=o}},clipPolygons:function(t,e){let n,o={node:this,polygontreenodes:t},r=[];do{if(n=o.node,t=o.polygontreenodes,n.plane){let o=[],i=[],s=e?o:i,l=n.plane,h=t.length;for(let e=0;e<h;e++){let n=t[e];n.isRemoved()||n.splitByPlane(l,s,o,i,o)}n.front&&i.length>0&&r.push({node:n.front,polygontreenodes:i});let a=o.length;if(n.back&&a>0)r.push({node:n.back,polygontreenodes:o});else for(let t=0;t<a;t++)o[t].remove()}o=r.pop()}while(void 0!==o)},clipTo:function(t,e){let n=this,o=[];do{n.polygontreenodes.length>0&&t.rootnode.clipPolygons(n.polygontreenodes,e),n.front&&o.push(n.front),n.back&&o.push(n.back),n=o.pop()}while(void 0!==n)},addPolygonTreeNodes:function(t){let e,n={node:this,polygontreenodes:t},o=[];do{if(e=n.node,0===(t=n.polygontreenodes).length){n=o.pop();continue}let r=e;if(!e.plane){let n=t[0].getPolygon().plane;e.plane=n}let i=[],s=[];for(let e=0,n=t.length;e<n;++e)t[e].splitByPlane(r.plane,r.polygontreenodes,s,i,s);i.length>0&&(e.front||(e.front=new Node(e)),o.push({node:e.front,polygontreenodes:i})),s.length>0&&(e.back||(e.back=new Node(e)),o.push({node:e.back,polygontreenodes:s})),n=o.pop()}while(void 0!==n)}};const importThreeGeometry=t=>{if(t instanceof CSG)return t;const e=new CSG,n=t.index?t.index.array:[],o=t.attributes.position.array,r=(t,e=0)=>o[3*n[t]+e],i=t=>new Vertex(new Vector(r(t),r(t,1),r(t,2))),s=t=>new Vertex(new Vector(o[t],o[t+1],o[t+2])),l=t=>[i(t),i(t+1),i(t+2)];if(n.length)for(let t=0;t<n.length;t+=3)e.polygons.push(new Polygon(l(t)));else for(let t=0;t<o.length;t+=9)e.polygons.push(new Polygon([s(t),s(t+3),s(t+6)]));return e.isCanonicalized=!1,e.isRetesselated=!1,e},exportThreeGeometry=t=>{if(!(t instanceof CSG))return t;const e=new THREE.BufferGeometry,n=[],o=[];let r,i=!1;return t.polygons.forEach(t=>{t.shared.color?(r=[t.shared.color[0],t.shared.color[1],t.shared.color[2]],i=!0):r=[1,1,1];for(let e=0;e<t.vertices.length-2;e++){[0,e+1,e+2].forEach(e=>{["x","y","z"].forEach(o=>{n.push(t.vertices[e].pos[o])})});for(let t=0;t<3;t++)o.push(...r)}}),e.setAttribute("position",new THREE.BufferAttribute(new Float32Array(n),3)),i&&e.setAttribute("color",new THREE.BufferAttribute(new Float32Array(o),3)),e.computeVertexNormals(),e},prepareObjects=(t,e)=>t.map((t,n)=>{const o=importThreeGeometry(t);return e[n]&&o.setColor([e[n].r,e[n].g,e[n].b,1]),o}),runOperation=(t,e,n=[])=>(e=prepareObjects(e,n)).shift()[t](e);window.staticTag=1,window.getTag=()=>window.staticTag++;const CSG$1={BufferGeometry:exportThreeGeometry,union:runOperation.bind(void 0,"union"),subtract:runOperation.bind(void 0,"subtract"),intersect:runOperation.bind(void 0,"intersect")};window.CSG=CSG$1,module.exports=CSG$1;