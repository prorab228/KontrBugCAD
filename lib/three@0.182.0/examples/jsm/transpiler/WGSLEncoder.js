import{REVISION}from"three/webgpu";import{VariableDeclaration,Accessor}from"./AST.js";import{isExpression}from"./TranspilerUtils.js";const typeMap={float:"f32",int:"i32",uint:"u32",bool:"bool",vec2:"vec2f",ivec2:"vec2i",uvec2:"vec2u",bvec2:"vec2b",vec3:"vec3f",ivec3:"vec3i",uvec3:"vec3u",bvec3:"vec3b",vec4:"vec4f",ivec4:"vec4i",uvec4:"vec4u",bvec4:"vec4b",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>",texture:"texture_2d<f32>",textureCube:"texture_cube<f32>",texture3D:"texture_3d<f32>"},wgslLib={abs:"abs",acos:"acos",asin:"asin",atan:"atan",atan2:"atan2",ceil:"ceil",clamp:"clamp",cos:"cos",cross:"cross",degrees:"degrees",distance:"distance",dot:"dot",exp:"exp",exp2:"exp2",faceforward:"faceForward",floor:"floor",fract:"fract",inverse:"inverse",inversesqrt:"inverseSqrt",length:"length",log:"log",log2:"log2",max:"max",min:"min",mix:"mix",normalize:"normalize",pow:"pow",radians:"radians",reflect:"reflect",refract:"refract",round:"round",sign:"sign",sin:"sin",smoothstep:"smoothstep",sqrt:"sqrt",step:"step",tan:"tan",transpose:"transpose",trunc:"trunc",dFdx:"dpdx",dFdy:"dpdy",fwidth:"fwidth",texture:"textureSample",texture2D:"textureSample",texture3D:"textureSample",textureCube:"textureSample",textureLod:"textureSampleLevel",texelFetch:"textureLoad",textureGrad:"textureSampleGrad",floatBitsToInt:"bitcast<i32>",floatBitsToUint:"bitcast<u32>",intBitsToFloat:"bitcast<f32>",uintBitsToFloat:"bitcast<f32>"};class WGSLEncoder{constructor(){this.tab="",this.functions=new Map,this.uniforms=[],this.varyings=[],this.structs=new Map,this.polyfills=new Map,this.groupIndex=0}getWgslType(t){return typeMap[t]||t}emitExpression(t){if(!t)return"";let e;if(t.isAccessor){const s=this.uniforms.find(e=>e.name===t.property);if(s&&!s.type.includes("texture"))return`uniforms.${t.property}`;e=t.property}else if(t.isNumber)e=t.value,"float"!==t.type||e.includes(".")||(e+=".0");else if(t.isOperator){const s=this.emitExpression(t.left),i=this.emitExpression(t.right);e=`${s} ${t.type} ${i}`,!0!==t.parent.isAssignment&&t.parent.isOperator&&(e=`( ${e} )`)}else if(t.isFunctionCall){const s=wgslLib[t.name]||t.name;if("mod"===s){const s=t.params.map(t=>this.emitExpression(t)),i=t.params.map(t=>t.getType()),n="mod_"+i.join("_");!1===this.polyfills.has(n)&&this.polyfills.set(n,`fn ${n}( x: ${this.getWgslType(i[0])}, y: ${this.getWgslType(i[1])} ) -> ${this.getWgslType(i[0])} {\n\n\treturn x - y * floor( x / y );\n\n}`),e=`${n}( ${s.join(", ")} )`}else if(s.startsWith("bitcast")){const i=t.params.map(t=>this.emitExpression(t)).join(","),n=t.params.map(t=>t.getType());if(/.*vec[234]/.test(n[0])){const t=s.substring(8,s.length-1);e=`bitcast<${n[0].substring(-1)}<${t}>>`}else e=s;e+=`( ${i} )`}else if(s.startsWith("texture"))e=this.emitTextureAccess(t);else{const i=t.params.map(t=>this.emitExpression(t));e=typeMap[s]?this.getWgslType(s):s,i.length>0?e+="( "+i.join(", ")+" )":e+="()"}}else if(t.isReturn)e="return",t.value&&(e+=" "+this.emitExpression(t.value));else if(t.isDiscard)e="discard";else if(t.isBreak)!0!==t.parent.isSwitchCase&&(e="break");else if(t.isContinue)e="continue";else if(t.isAccessorElements){e=this.emitExpression(t.object);for(const s of t.elements){const t=this.emitExpression(s.value);s.isStaticElement?e+="."+t:s.isDynamicElement&&(e+=`[${t}]`)}}else if(t.isFor)e=this.emitFor(t);else if(t.isWhile)e=this.emitWhile(t);else if(t.isSwitch)e=this.emitSwitch(t);else if(t.isVariableDeclaration)e=this.emitVariables(t);else{if(t.isUniform)return this.uniforms.push(t),"";if(t.isVarying)return this.varyings.push(t),"";if(t.isStructDefinition)e=this.emitStructDefinition(t);else if(t.isTernary){const s=this.emitExpression(t.cond),i=this.emitExpression(t.left);e=`select( ${this.emitExpression(t.right)}, ${i}, ${s} )`}else if(t.isConditional)e=this.emitConditional(t);else if(t.isUnary){const s=this.emitExpression(t.expression);if("++"===t.type||"--"===t.type){e=`${s} = ${s} ${"++"===t.type?"+":"-"} 1`}else e=`${t.type}${s}`}else console.warn("Unknown node type in WGSL Encoder:",t),e=`/* unknown node: ${t.constructor.name} */`}return e}emitTextureAccess(t){const e=wgslLib[t.name],s=this.emitExpression(t.params[0]),i=this.emitExpression(t.params[1]),n=`${s}_sampler`;let r;switch(t.name){case"texture":case"texture2D":case"texture3D":case"textureCube":if(r=`${e}(${s}, ${n}, ${i}`,3===t.params.length){r=`textureSampleBias(${s}, ${n}, ${i}, ${this.emitExpression(t.params[2])})`}else r+=")";break;case"textureLod":r=`${e}(${s}, ${n}, ${i}, ${this.emitExpression(t.params[2])})`;break;case"textureGrad":r=`${e}(${s}, ${n}, ${i}, ${this.emitExpression(t.params[2])}, ${this.emitExpression(t.params[3])})`;break;case"texelFetch":r=`${e}(${s}, ${this.emitExpression(t.params[1])}, ${t.params.length>2?this.emitExpression(t.params[2]):"0"})`;break;default:r=`/* unsupported texture op: ${t.name} */`}return r}emitBody(t){let e="";this.tab+="\t";for(const s of t){if(e+=this.emitExtraLine(s,t),s.isComment){e+=this.emitComment(s,t);continue}const i=this.emitExpression(s);i&&(e+=this.tab+i,i.endsWith("}")||i.endsWith("{")||(e+=";"),e+="\n")}return this.tab=this.tab.slice(0,-1),e.slice(0,-1)}emitConditional(t){let e=`if ( ${this.emitExpression(t.cond)} ) {\n\n${this.emitBody(t.body)}\n\n${this.tab}}`,s=t;for(;s.elseConditional;){s=s.elseConditional;const t=this.emitBody(s.body);if(s.cond){e+=` else if ( ${this.emitExpression(s.cond)} ) {\n\n${t}\n\n${this.tab}}`}else e+=` else {\n\n${t}\n\n${this.tab}}`}return e}emitFor(t){return`for ( ${this.emitExpression(t.initialization)}; ${this.emitExpression(t.condition)}; ${this.emitExpression(t.afterthought)} ) {\n\n${this.emitBody(t.body)}\n\n${this.tab}}`}emitWhile(t){return`while ( ${this.emitExpression(t.condition)} ) {\n\n${this.emitBody(t.body)}\n\n${this.tab}}`}emitSwitch(t){let e=`switch ( ${this.emitExpression(t.discriminant)} ) {\n\n`;this.tab+="\t";for(const s of t.cases){const t=this.emitBody(s.body);if(s.isDefault)e+=`${this.tab}default: {\n\n${t}\n\n${this.tab}}\n\n`;else{const i=s.conditions.map(t=>this.emitExpression(t)).join(", ");e+=`${this.tab}case ${i}: {\n\n${t}\n\n${this.tab}}\n\n`}}return this.tab=this.tab.slice(0,-1),e+=`${this.tab}}`,e}emitVariables(t){const e=[];let s=t;for(;s;){const t=this.getWgslType(s.type);let i,n="";s.value&&(n=` = ${this.emitExpression(s.value)}`),s.linker&&(i=s.linker.assignments.length>0?"var":s.value&&s.value.isNumericExpression?"const":"let"),e.push(`${i} ${s.name}: ${t}${n}`),s=s.next}return e.join(";\n"+this.tab)}emitStructDefinition(t){const{name:e,members:s}=t;let i=`struct ${e} {\n`;for(let t=0;t<s.length;t+=1){const e=s[t];i+=`${this.tab}\t${e.name}: ${this.getWgslType(e.type)}`;i+=t!=s.length-1?",\n":"\n"}return i+=this.tab+"}",i}emitFunction(t){const e=t.name,s=this.getWgslType(t.type),i=[],n=[...t.body];for(const e of t.params){const t=e.name;let s=this.getWgslType(e.type);if("inout"!==e.qualifier&&"out"!==e.qualifier)if(e.linker&&e.linker.assignments.length>0){const r=`${t}_in`;i.push(`${r}: ${s}`);const o=new Accessor(r);o.isAccessor=!0,o.property=r;const a=new VariableDeclaration(e.type,e.name,o);a.linker={assignments:[!0]},n.unshift(a)}else i.push(`${t}: ${s}`);else s=`ptr<function, ${s}>`,i.push(`${t}: ${s}`)}return`fn ${e}(${i.length>0?" "+i.join(", ")+" ":""})${s&&"void"!==s?` -> ${s}`:""} {\n\n${this.emitBody(n)}\n\n${this.tab}}`}emitComment(t,e){const s=e.indexOf(t),i=e[s-1],n=e[s+1];let r="";return i&&isExpression(i)&&(r+="\n"),r+=this.tab+t.comment.replace(/\n/g,"\n"+this.tab)+"\n",n&&isExpression(n)&&(r+="\n"),r}emitExtraLine(t,e){const s=e.indexOf(t),i=e[s-1];if(void 0===i)return"";if(t.isReturn)return"\n";const n=isExpression(i),r=isExpression(t);return n!==r||!n&&!r?"\n":""}emit(t){const e="// Three.js Transpiler r"+REVISION+"\n\n";let s="",i="",n="";for(const e of t.body)e.isFunctionDeclaration?this.functions.set(e.name,e):e.isUniform?this.uniforms.push(e):e.isVarying&&this.varyings.push(e);if(this.uniforms.length>0){let t=0;const e=[],i=[];for(const s of this.uniforms)s.type.includes("texture")?(i.push(`@group(${this.groupIndex}) @binding(${t++}) var ${s.name}: ${this.getWgslType(s.type)};`),i.push(`@group(${this.groupIndex}) @binding(${t++}) var ${s.name}_sampler: sampler;`)):e.push(`\t${s.name}: ${this.getWgslType(s.type)},`);e.length>0&&(s+="struct Uniforms {\n",s+=e.join("\n"),s+="\n};\n",s+=`@group(${this.groupIndex}) @binding(${t++}) var<uniform> uniforms: Uniforms;\n\n`),s+=i.join("\n")+"\n\n"}if(this.varyings.length>0){s+="struct Varyings {\n";let t=0;for(const e of this.varyings)s+=`\t@location(${t++}) ${e.name}: ${this.getWgslType(e.type)},\n`;s+="};\n\n"}for(const e of t.body)i+=this.emitExtraLine(e,t.body),e.isFunctionDeclaration?i+=this.emitFunction(e)+"\n":e.isComment?i+=this.emitComment(e,t.body):e.isUniform||e.isVarying||(i+=this.emitExpression(e)+";\n");for(const t of this.polyfills.values())n=`${t}\n\n`;return e+n+s+i.trimEnd()+"\n"}}export default WGSLEncoder;