import{HalfFloatType,Vector2,RenderTarget,RendererUtils,QuadMesh,NodeMaterial,TempNode,NodeUpdateType,Matrix4,DepthTexture}from"three/webgpu";import{add,float,If,Fn,max,nodeObject,texture,uniform,uv,vec2,vec4,luminance,convertToTexture,passTexture,velocity,getViewPosition,viewZToPerspectiveDepth,struct,ivec2,mix}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2;let _rendererState;class TRAANode extends TempNode{static get type(){return"TRAANode"}constructor(e,t,r,s){super("vec4"),this.isTRAANode=!0,this.updateBeforeType=NodeUpdateType.FRAME,this.beautyNode=e,this.depthNode=t,this.velocityNode=r,this.camera=s,this.depthThreshold=5e-4,this.edgeDepthDiff=.001,this.maxVelocityLength=128,this.useSubpixelCorrection=!0,this._jitterIndex=0,this._invSize=uniform(new Vector2),this._historyRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType,depthTexture:new DepthTexture}),this._historyRenderTarget.texture.name="TRAANode.history",this._resolveRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType}),this._resolveRenderTarget.texture.name="TRAANode.resolve",this._resolveMaterial=new NodeMaterial,this._resolveMaterial.name="TRAA.resolve",this._textureNode=passTexture(this,this._resolveRenderTarget.texture),this._originalProjectionMatrix=new Matrix4,this._cameraNearFar=uniform(new Vector2),this._cameraWorldMatrix=uniform(new Matrix4),this._cameraWorldMatrixInverse=uniform(new Matrix4),this._cameraProjectionMatrixInverse=uniform(new Matrix4),this._previousCameraWorldMatrix=uniform(new Matrix4),this._previousCameraProjectionMatrixInverse=uniform(new Matrix4),this._previousDepthNode=texture(new DepthTexture(1,1)),this._needsPostProcessingSync=!1}getTextureNode(){return this._textureNode}setSize(e,t){this._historyRenderTarget.setSize(e,t),this._resolveRenderTarget.setSize(e,t),this._invSize.value.set(1/e,1/t)}setViewOffset(e,t){this.camera.updateProjectionMatrix(),this._originalProjectionMatrix.copy(this.camera.projectionMatrix),velocity.setProjectionMatrix(this._originalProjectionMatrix);const r={fullWidth:e,fullHeight:t,offsetX:0,offsetY:0,width:e,height:t},s=_haltonOffsets[this._jitterIndex];this.camera.setViewOffset(r.fullWidth,r.fullHeight,r.offsetX+s[0]-.5,r.offsetY+s[1]-.5,r.width,r.height)}clearViewOffset(){this.camera.clearViewOffset(),velocity.setProjectionMatrix(null),this._jitterIndex++,this._jitterIndex=this._jitterIndex%(_haltonOffsets.length-1)}updateBefore(e){const{renderer:t}=e;this._previousCameraWorldMatrix.value.copy(this._cameraWorldMatrix.value),this._previousCameraProjectionMatrixInverse.value.copy(this._cameraProjectionMatrixInverse.value),this._cameraNearFar.value.set(this.camera.near,this.camera.far),this._cameraWorldMatrix.value.copy(this.camera.matrixWorld),this._cameraWorldMatrixInverse.value.copy(this.camera.matrixWorldInverse),this._cameraProjectionMatrixInverse.value.copy(this.camera.projectionMatrixInverse);const r=this.beautyNode.isRTTNode?this.beautyNode.renderTarget:this.beautyNode.passNode.renderTarget,s=r.texture.width,i=r.texture.height;!0===this._needsPostProcessingSync&&(this.setViewOffset(s,i),this._needsPostProcessingSync=!1),_rendererState=RendererUtils.resetRendererState(t,_rendererState);const a=this._historyRenderTarget.width!==s||this._historyRenderTarget.height!==i;this.setSize(s,i),!0===a&&(t.setRenderTarget(this._historyRenderTarget),t.clear(),t.setRenderTarget(this._resolveRenderTarget),t.clear(),t.copyTextureToTexture(r.texture,this._historyRenderTarget.texture)),t.setRenderTarget(this._resolveRenderTarget),_quadMesh.material=this._resolveMaterial,_quadMesh.name="TRAA",_quadMesh.render(t),t.setRenderTarget(null),t.copyTextureToTexture(this._resolveRenderTarget.texture,this._historyRenderTarget.texture);const o=t.getDrawingBufferSize(_size);if(this._historyRenderTarget.height===o.height&&this._historyRenderTarget.width===o.width){const e=this.depthNode.value;t.copyTextureToTexture(e,this._historyRenderTarget.depthTexture),this._previousDepthNode.value=this._historyRenderTarget.depthTexture}RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=e.context.postProcessing;t&&(this._needsPostProcessingSync=!0,t.context.onBeforePostProcessing=()=>{const t=e.renderer.getDrawingBufferSize(_size);this.setViewOffset(t.width,t.height)},t.context.onAfterPostProcessing=()=>{this.clearViewOffset()});const r=struct({closestDepth:"float",closestPositionTexel:"vec2",farthestDepth:"float"}),s=Fn(([e])=>{const t=float(2).toVar(),s=vec2(0).toVar(),i=float(-1).toVar();for(let r=-1;r<=1;++r)for(let a=-1;a<=1;++a){const o=e.add(vec2(r,a)).toVar(),n=this.depthNode.load(o).r.toVar();If(n.lessThan(t),()=>{t.assign(n),s.assign(o)}),If(n.greaterThan(i),()=>{i.assign(n)})}return r(t,s,i)}),i=e=>{const t=this._previousDepthNode.sample(e).r,r=getViewPosition(e,t,this._previousCameraProjectionMatrixInverse),s=this._previousCameraWorldMatrix.mul(vec4(r,1)).xyz,i=this._cameraWorldMatrixInverse.mul(vec4(s,1)).z;return viewZToPerspectiveDepth(i,this._cameraNearFar.x,this._cameraNearFar.y)},a=Fn(([e,t,r,s])=>{const i=s.rgb.add(r.rgb).mul(.5),a=s.rgb.sub(r.rgb).mul(.5).add(1e-7),o=t.sub(vec4(i,e.a)),n=o.xyz.div(a).abs(),h=max(n.x,n.y,n.z);return h.greaterThan(1).select(vec4(i,e.a).add(o.div(h)),t)}).setLayout({name:"clipAABB",type:"vec4",inputs:[{name:"currentColor",type:"vec4"},{name:"historyColor",type:"vec4"},{name:"minColor",type:"vec4"},{name:"maxColor",type:"vec4"}]}),o=Fn(([e,t,r,s])=>{const i=[[-1,-1],[-1,1],[1,-1],[1,1],[1,0],[0,-1],[0,1],[-1,0]],o=t.toVar(),n=t.pow2().toVar();for(const[t,r]of i){const s=this.beautyNode.offset(ivec2(t,r)).load(e).max(0);o.addAssign(s),n.addAssign(s.pow2())}const h=float(i.length+1),d=o.div(h),l=n.div(h).sub(d.pow2()).max(0).sqrt().mul(s),u=d.sub(l),c=d.add(l);return a(d.clamp(u,c),r,u,c)}),n=Fn(([e,t])=>{const r=e.mul(t).fract().abs(),s=max(r,r.oneMinus());return s.x.mul(s.y).oneMinus().div(.75)}).setLayout({name:"subpixelCorrection",type:"float",inputs:[{name:"velocityUV",type:"vec2"},{name:"textureSize",type:"ivec2"}]}),h=Fn(([e,t,r])=>{const s=r.oneMinus(),i=e.mul(float(1).div(max(e.r,e.g,e.b).add(1))),a=t.mul(float(1).div(max(t.r,t.g,t.b).add(1))),o=luminance(i.rgb),n=luminance(a.rgb);return r.mulAssign(float(1).div(o.add(1))),s.mulAssign(float(1).div(n.add(1))),add(e.mul(r),t.mul(s)).div(max(r.add(s),1e-5)).toVar()}),d=texture(this._historyRenderTarget.texture),l=Fn(()=>{const e=uv(),t=this.beautyNode.size(),r=e.mul(t),a=s(r),l=a.get("closestDepth"),u=a.get("closestPositionTexel"),c=a.get("farthestDepth"),x=this.velocityNode.load(u).xy.mul(vec2(.5,-.5)),p=e.sub(x),m=i(p),v=p.greaterThanEqual(0).all().and(p.lessThanEqual(1).all()),f=c.sub(l).greaterThan(this.edgeDepthDiff),g=l.sub(m).greaterThan(this.depthThreshold),T=v.and(f.or(g.not())),_=this.beautyNode.sample(e),y=d.sample(e.sub(x)),M=e.sub(p).mul(t).length().div(this.maxVelocityLength).saturate(),R=float(.05).toVar();this.useSubpixelCorrection&&R.addAssign(n(x,t).mul(.25)),R.assign(T.select(R.add(M).saturate(),1));const w=mix(.5,1,M.oneMinus().pow2()),N=o(r,_,y,w);return h(_,N,R)});return this._resolveMaterial.colorNode=l(),this._textureNode}dispose(){this._historyRenderTarget.dispose(),this._resolveRenderTarget.dispose(),this._resolveMaterial.dispose()}}export default TRAANode;function _halton(e,t){let r=1,s=0;for(;e>0;)r/=t,s+=r*(e%t),e=Math.floor(e/t);return s}const _haltonOffsets=Array.from({length:32},(e,t)=>[_halton(t+1,2),_halton(t+1,3)]);export const traa=(e,t,r,s)=>nodeObject(new TRAANode(convertToTexture(e),t,r,s));