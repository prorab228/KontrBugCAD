import{RedFormat,RenderTarget,Vector2,RendererUtils,QuadMesh,TempNode,NodeMaterial,NodeUpdateType,UnsignedByteType}from"three/webgpu";import{reference,viewZToPerspectiveDepth,logarithmicDepthToViewZ,getScreenPosition,getViewPosition,float,Break,Loop,int,max,abs,If,interleavedGradientNoise,screenCoordinate,nodeObject,Fn,passTexture,uv,uniform,perspectiveDepthToViewZ,orthographicDepthToViewZ,vec2,lightPosition,lightTargetPosition,fract,rand,mix}from"three/tsl";const _quadMesh=new QuadMesh,_size=new Vector2,_spatialOffsets=[0,.5,.25,.75];let _rendererState;class SSSNode extends TempNode{static get type(){return"SSSNode"}constructor(e,t,r){super("float"),this.depthNode=e,this.maxDistance=uniform(.1,"float"),this.thickness=uniform(.01,"float"),this.shadowIntensity=uniform(1,"float"),this.quality=uniform(.5),this.resolutionScale=1,this.useTemporalFiltering=!1,this.updateBeforeType=NodeUpdateType.FRAME,this._cameraViewMatrix=uniform(t.matrixWorldInverse),this._cameraProjectionMatrix=uniform(t.projectionMatrix),this._cameraProjectionMatrixInverse=uniform(t.projectionMatrixInverse),this._cameraNear=reference("near","float",t),this._cameraFar=reference("far","float",t),this._resolution=uniform(new Vector2),this._temporalOffset=uniform(0),this._frameId=uniform(0),this._mainLight=r,this._camera=t,this._sssRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,format:RedFormat,type:UnsignedByteType}),this._sssRenderTarget.texture.name="SSS",this._material=new NodeMaterial,this._material.name="SSS",this._textureNode=passTexture(this,this._sssRenderTarget.texture)}getTextureNode(){return this._textureNode}setSize(e,t){e=Math.round(this.resolutionScale*e),t=Math.round(this.resolutionScale*t),this._resolution.value.set(e,t),this._sssRenderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=t.getDrawingBufferSize(_size);if(this.setSize(r.width,r.height),!0===this.useTemporalFiltering){const t=e.frameId;this._temporalOffset.value=_spatialOffsets[t%4],this._frameId=e.frameId}else this._temporalOffset.value=0,this._frameId=0;_quadMesh.material=this._material,_quadMesh.name="SSS",t.setClearColor(16777215,1),t.setRenderTarget(this._sssRenderTarget),_quadMesh.render(t),RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=uv(),r=Fn(([e])=>{let t;return t=this._camera.isPerspectiveCamera?perspectiveDepthToViewZ(e,this._cameraNear,this._cameraFar):orthographicDepthToViewZ(e,this._cameraNear,this._cameraFar),t}),a=t=>{const r=this.depthNode.sample(t).r;if(!0===e.renderer.logarithmicDepthBuffer){const e=logarithmicDepthToViewZ(r,this._cameraNear,this._cameraFar);return viewZToPerspectiveDepth(e,this._cameraNear,this._cameraFar)}return r},i=Fn(()=>{const e=a(t).toVar();e.greaterThanEqual(1).discard();const i=getViewPosition(t,e,this._cameraProjectionMatrixInverse).toVar("rayStartPosition"),s=this._cameraViewMatrix.transformDirection(lightPosition(this._mainLight).sub(lightTargetPosition(this._mainLight))).toConst("rayDirection"),o=i.add(s.mul(this.maxDistance)).toConst("rayEndPosition"),n=screenCoordinate.xy.toVar(),h=getScreenPosition(o,this._cameraProjectionMatrix).mul(this._resolution).toVar(),d=h.sub(n).length().toVar(),m=h.x.sub(n.x).toVar(),l=h.y.sub(n.y).toVar(),c=int(max(abs(m),abs(l)).mul(this.quality.clamp())).toConst(),u=m.div(c).toVar(),f=l.div(c).toVar(),_=interleavedGradientNoise(screenCoordinate),p=fract(_.add(this._temporalOffset)).add(rand(t.add(this._frameId))).toConst("offset"),g=float(0).toVar();return Loop(c,({i:e})=>{const t=vec2(n.x.add(u.mul(float(e).add(p))),n.y.add(f.mul(float(e).add(p)))).toVar();If(t.x.lessThan(0).or(t.x.greaterThan(this._resolution.x)).or(t.y.lessThan(0)).or(t.y.greaterThan(this._resolution.y)),()=>{Break()});const s=t.div(this._resolution),h=a(s).toConst(),m=r(h).toConst("fragmentViewZ"),l=t.sub(n).length().div(d).toVar(),c=mix(i,o,l).z.sub(m).negate();If(c.greaterThan(0).and(c.lessThan(this.thickness)),()=>{g.assign(this.shadowIntensity),Break()})}),g.oneMinus()});return this._material.fragmentNode=i().context(e.getSharedContext()),this._material.needsUpdate=!0,this._textureNode}dispose(){this._sssRenderTarget.dispose(),this._material.dispose()}}export default SSSNode;export const sss=(e,t,r)=>nodeObject(new SSSNode(e,t,r));