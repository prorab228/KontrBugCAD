import{RenderTarget,Vector2,QuadMesh,NodeMaterial,RendererUtils,TempNode,NodeUpdateType}from"three/webgpu";import{nodeObject,Fn,float,uv,texture,passTexture,sign,max,convertToTexture}from"three/tsl";const _size=new Vector2,_quadMesh=new QuadMesh;let _rendererState;class AfterImageNode extends TempNode{static get type(){return"AfterImageNode"}constructor(e,t=float(.96)){super("vec4"),this.textureNode=e,this.damp=t,this._compRT=new RenderTarget(1,1,{depthBuffer:!1}),this._compRT.texture.name="AfterImageNode.comp",this._oldRT=new RenderTarget(1,1,{depthBuffer:!1}),this._oldRT.texture.name="AfterImageNode.old",this._textureNode=passTexture(this,this._compRT.texture),this._textureNodeOld=texture(this._oldRT.texture),this.updateBeforeType=NodeUpdateType.FRAME}getTextureNode(){return this._textureNode}setSize(e,t){this._compRT.setSize(e,t),this._oldRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=this.textureNode.value.type;this._compRT.texture.type=r,this._oldRT.texture.type=r,t.getDrawingBufferSize(_size),this.setSize(_size.x,_size.y),this._textureNode.value=this._compRT.texture,this._textureNodeOld.value=this._oldRT.texture,_quadMesh.material=this._materialComposed,_quadMesh.name="AfterImage",t.setRenderTarget(this._compRT),_quadMesh.render(t);const s=this._oldRT;this._oldRT=this._compRT,this._compRT=s,RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=this.textureNode,r=this._textureNodeOld;r.uvNode=t.uvNode||uv();const s=Fn(()=>{const e=r.sample().toVar(),s=t.sample().toVar(),o=float(.1).toConst(),d=max(sign(e.sub(o)),0);return e.mulAssign(this.damp.mul(d)),max(s,e)}),o=this._materialComposed||(this._materialComposed=new NodeMaterial);o.name="AfterImage",o.fragmentNode=s();return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._compRT.dispose(),this._oldRT.dispose()}}export const afterImage=(e,t)=>nodeObject(new AfterImageNode(convertToTexture(e),nodeObject(t)));export default AfterImageNode;