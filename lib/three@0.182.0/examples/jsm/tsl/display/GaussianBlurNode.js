import{RenderTarget,Vector2,NodeMaterial,RendererUtils,QuadMesh,TempNode,NodeUpdateType}from"three/webgpu";import{nodeObject,Fn,float,uv,uniform,convertToTexture,vec2,vec4,passTexture,premultiplyAlpha,unpremultiplyAlpha}from"three/tsl";const _quadMesh=new QuadMesh;let _rendererState;class GaussianBlurNode extends TempNode{static get type(){return"GaussianBlurNode"}constructor(e,t=null,r=4,s={}){super("vec4"),this.textureNode=e,this.directionNode=t,this.sigma=r,this._invSize=uniform(new Vector2),this._passDirection=uniform(new Vector2),this._horizontalRT=new RenderTarget(1,1,{depthBuffer:!1}),this._horizontalRT.texture.name="GaussianBlurNode.horizontal",this._verticalRT=new RenderTarget(1,1,{depthBuffer:!1}),this._verticalRT.texture.name="GaussianBlurNode.vertical",this._textureNode=passTexture(this,this._verticalRT.texture),this._textureNode.uvNode=e.uvNode,this.updateBeforeType=NodeUpdateType.FRAME,this.resolutionScale=s.resolutionScale||1,this.premultipliedAlpha=s.premultipliedAlpha||!1}setSize(e,t){e=Math.max(Math.round(e*this.resolutionScale),1),t=Math.max(Math.round(t*this.resolutionScale),1),this._invSize.value.set(1/e,1/t),this._horizontalRT.setSize(e,t),this._verticalRT.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=this.textureNode,s=r.value,i=r.value;_quadMesh.material=this._material,this.setSize(s.image.width,s.image.height);const a=s.type;this._horizontalRT.texture.type=a,this._verticalRT.texture.type=a,t.setRenderTarget(this._horizontalRT),this._passDirection.value.set(1,0),_quadMesh.name="Gaussian Blur [ Horizontal Pass ]",_quadMesh.render(t),r.value=this._horizontalRT.texture,t.setRenderTarget(this._verticalRT),this._passDirection.value.set(0,1),_quadMesh.name="Gaussian Blur [ Vertical Pass ]",_quadMesh.render(t),r.value=i,RendererUtils.restoreRendererState(t,_rendererState)}getTextureNode(){return this._textureNode}setup(e){const t=this.textureNode,r=uv(),s=vec2(this.directionNode||1);let i,a;this.premultipliedAlpha?(i=e=>premultiplyAlpha(t.sample(e)),a=e=>unpremultiplyAlpha(e)):(i=e=>t.sample(e),a=e=>e);const o=Fn(()=>{const e=3+2*this.sigma,t=this._getCoefficients(e),o=this._invSize,n=s.mul(this._passDirection),u=vec4(i(r).mul(t[0])).toVar();for(let s=1;s<e;s++){const e=float(s),a=float(t[s]),l=vec2(n.mul(o.mul(e))).toVar(),d=i(r.add(l)),h=i(r.sub(l));u.addAssign(d.add(h).mul(a))}return a(u)}),n=this._material||(this._material=new NodeMaterial);n.fragmentNode=o().context(e.getSharedContext()),n.name="Gaussian_blur",n.needsUpdate=!0;return e.getNodeProperties(this).textureNode=t,this._textureNode}dispose(){this._horizontalRT.dispose(),this._verticalRT.dispose()}_getCoefficients(e){const t=[],r=e/3;for(let s=0;s<e;s++)t.push(.39894*Math.exp(-.5*s*s/(r*r))/r);return t}get resolution(){return console.warn('THREE.GaussianBlurNode: The "resolution" property has been renamed to "resolutionScale" and is now of type `number`.'),new Vector2(this.resolutionScale,this.resolutionScale)}set resolution(e){console.warn('THREE.GaussianBlurNode: The "resolution" property has been renamed to "resolutionScale" and is now of type `number`.'),this.resolutionScale=e.x}}export default GaussianBlurNode;export const gaussianBlur=(e,t,r,s={})=>nodeObject(new GaussianBlurNode(convertToTexture(e),t,r,s));export function premultipliedGaussianBlur(e,t,r){return console.warn('THREE.TSL: "premultipliedGaussianBlur()" is deprecated. Use "gaussianBlur()" with "premultipliedAlpha: true" option instead.'),gaussianBlur(e,t,r,{premultipliedAlpha:!0})}