import{HalfFloatType,RenderTarget,Vector2,RendererUtils,QuadMesh,TempNode,NodeMaterial,NodeUpdateType,LinearFilter,LinearMipmapLinearFilter}from"three/webgpu";import{texture,reference,viewZToPerspectiveDepth,logarithmicDepthToViewZ,getScreenPosition,getViewPosition,sqrt,mul,div,cross,float,Continue,Break,Loop,int,max,abs,sub,If,dot,reflect,normalize,screenCoordinate,nodeObject,Fn,passTexture,uv,uniform,perspectiveDepthToViewZ,orthographicDepthToViewZ,vec2,vec3,vec4}from"three/tsl";import{boxBlur}from"./boxBlur.js";const _quadMesh=new QuadMesh,_size=new Vector2;let _rendererState;class SSRNode extends TempNode{static get type(){return"SSRNode"}constructor(e,t,r,a,s=null,i=null){if(super("vec4"),this.colorNode=e,this.depthNode=t,this.normalNode=r,this.metalnessNode=a,this.roughnessNode=s,this.resolutionScale=1,this.updateBeforeType=NodeUpdateType.FRAME,this.maxDistance=uniform(1),this.thickness=uniform(.1),this.opacity=uniform(1),this.quality=uniform(.5),this.blurQuality=uniform(2),null===i){if(!this.colorNode.passNode||!0!==this.colorNode.passNode.isPassNode)throw new Error("THREE.TSL: No camera found. ssr() requires a camera.");i=this.colorNode.passNode.camera}this.camera=i,this._blurSpread=uniform(1),this._cameraProjectionMatrix=uniform(i.projectionMatrix),this._cameraProjectionMatrixInverse=uniform(i.projectionMatrixInverse),this._cameraNear=reference("near","float",i),this._cameraFar=reference("far","float",i),this._isPerspectiveCamera=uniform(!0===i.isPerspectiveCamera),this._resolution=uniform(new Vector2),this._ssrRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType}),this._ssrRenderTarget.texture.name="SSRNode.SSR",this._blurRenderTarget=new RenderTarget(1,1,{depthBuffer:!1,type:HalfFloatType,minFilter:LinearMipmapLinearFilter,magFilter:LinearFilter}),this._blurRenderTarget.texture.name="SSRNode.Blur",this._blurRenderTarget.texture.mipmaps.push({},{},{},{},{}),this._ssrMaterial=new NodeMaterial,this._ssrMaterial.name="SSRNode.SSR",this._blurMaterial=new NodeMaterial,this._blurMaterial.name="SSRNode.Blur",this._copyMaterial=new NodeMaterial,this._copyMaterial.name="SSRNode.Copy",this._textureNode=passTexture(this,this._ssrRenderTarget.texture);let o=null;if(null!==this.roughnessNode){const e=this._blurRenderTarget.texture.mipmaps.length-1,t=float(this.roughnessNode).mul(e).clamp(0,e);o=passTexture(this,this._blurRenderTarget.texture).level(t)}this._blurredTextureNode=o}getTextureNode(){return null!==this.roughnessNode?this._blurredTextureNode:this._textureNode}setSize(e,t){e=Math.round(this.resolutionScale*e),t=Math.round(this.resolutionScale*t),this._resolution.value.set(e,t),this._ssrRenderTarget.setSize(e,t),this._blurRenderTarget.setSize(e,t)}updateBefore(e){const{renderer:t}=e;_rendererState=RendererUtils.resetRendererState(t,_rendererState);const r=this._ssrRenderTarget,a=this._blurRenderTarget,s=t.getDrawingBufferSize(_size);if(_quadMesh.material=this._ssrMaterial,this.setSize(s.width,s.height),t.setMRT(null),t.setClearColor(0,0),t.setRenderTarget(r),_quadMesh.name="SSR [ Reflections ]",_quadMesh.render(t),null!==this.roughnessNode)for(let e=0;e<a.texture.mipmaps.length;e++)_quadMesh.material=0===e?this._copyMaterial:this._blurMaterial,this._blurSpread.value=e,t.setRenderTarget(a,0,e),_quadMesh.name="SSR [ Blur Level "+e+" ]",_quadMesh.render(t);RendererUtils.restoreRendererState(t,_rendererState)}setup(e){const t=uv(),r=Fn(([e,t,r])=>cross(e.sub(t),e.sub(r)).length().div(r.sub(t).length())),a=Fn(([e,t,r])=>{const a=mul(r.x,t.x).add(mul(r.y,t.y)).add(mul(r.z,t.z)).negate().toVar(),s=sqrt(mul(r.x,r.x).add(mul(r.y,r.y)).add(mul(r.z,r.z))).toVar();return div(mul(r.x,e.x).add(mul(r.y,e.y)).add(mul(r.z,e.z)).add(a),s)}),s=Fn(([e])=>{let t;return t=this.camera.isPerspectiveCamera?perspectiveDepthToViewZ(e,this._cameraNear,this._cameraFar):orthographicDepthToViewZ(e,this._cameraNear,this._cameraFar),t}),i=t=>{const r=this.depthNode.sample(t).r;if(!0===e.renderer.logarithmicDepthBuffer){const e=logarithmicDepthToViewZ(r,this._cameraNear,this._cameraFar);return viewZToPerspectiveDepth(e,this._cameraNear,this._cameraFar)}return r},o=Fn(()=>{const e=float(this.metalnessNode);e.equal(0).discard();const o=i(t).toVar(),n=getViewPosition(t,o,this._cameraProjectionMatrixInverse).toVar(),l=this.normalNode.rgb.normalize().toVar(),d=(this.camera.isPerspectiveCamera?normalize(n):vec3(0,0,-1)).toVar(),h=reflect(d,l).toVar(),u=this.maxDistance.div(dot(d.negate(),l)).toVar(),c=n.add(h.mul(u)).toVar();If(this._isPerspectiveCamera.and(c.z.greaterThan(this._cameraNear.negate())),()=>{const e=sub(this._cameraNear.negate(),n.z).div(h.z);c.assign(n.add(h.mul(e)))});const m=screenCoordinate.xy.toVar(),p=getScreenPosition(c,this._cameraProjectionMatrix).mul(this._resolution).toVar(),_=p.sub(m).length().toVar(),g=p.x.sub(m.x).toVar(),f=p.y.sub(m.y).toVar(),x=int(max(abs(g),abs(f)).mul(this.quality.clamp())).toConst(),N=g.div(x).toVar(),T=f.div(x).toVar(),b=vec4(0).toVar();return Loop(x,({i:t})=>{const o=vec2(m.x.add(N.mul(float(t))),m.y.add(T.mul(float(t)))).toVar();If(o.x.lessThan(0).or(o.x.greaterThan(this._resolution.x)).or(o.y.lessThan(0)).or(o.y.greaterThan(this._resolution.y)),()=>{Break()});const u=o.div(this._resolution),p=i(u).toVar(),g=s(p).toVar(),f=float(0).toVar(),x=o.sub(m).length().div(_);If(this._isPerspectiveCamera,()=>{const e=float(1).div(n.z).toVar();f.assign(float(1).div(e.add(x.mul(float(1).div(c.z).sub(e)))))}).Else(()=>{f.assign(n.z.add(x.mul(c.z.sub(n.z))))}),If(f.lessThanEqual(g),()=>{const t=getViewPosition(u,p,this._cameraProjectionMatrixInverse).toVar(),s=r(t,n,c).toVar(),i=vec2(o.x.add(1),o.y).toVar().div(this._resolution),m=getViewPosition(i,p,this._cameraProjectionMatrixInverse).toVar().x.sub(t.x).toVar();m.mulAssign(3);const _=max(m,this.thickness).toVar();If(s.lessThanEqual(_),()=>{const r=this.normalNode.sample(u).rgb.normalize().toVar();If(dot(h,r).greaterThanEqual(0),()=>{Continue()});const s=a(t,n,l).toVar();If(s.greaterThan(this.maxDistance),()=>{Break()});const i=this.opacity.mul(e).toVar(),o=float(1).sub(s.div(this.maxDistance)).toVar(),c=o.mul(o);i.mulAssign(c);const m=div(dot(d,h).add(1),2);i.mulAssign(m);const p=this.colorNode.sample(u);b.assign(vec4(p.rgb,i)),Break()})})}),b});this._ssrMaterial.fragmentNode=o().context(e.getSharedContext()),this._ssrMaterial.needsUpdate=!0;const n=texture(this._ssrRenderTarget.texture);return this._blurMaterial.fragmentNode=boxBlur(n,{size:this.blurQuality,separation:this._blurSpread}),this._blurMaterial.needsUpdate=!0,this._copyMaterial.fragmentNode=n,this._copyMaterial.needsUpdate=!0,this.getTextureNode()}dispose(){this._ssrRenderTarget.dispose(),this._blurRenderTarget.dispose(),this._ssrMaterial.dispose(),this._blurMaterial.dispose(),this._copyMaterial.dispose()}}export default SSRNode;export const ssr=(e,t,r,a,s=null,i=null)=>nodeObject(new SSRNode(nodeObject(e),nodeObject(t),nodeObject(r),nodeObject(a),nodeObject(s),i));