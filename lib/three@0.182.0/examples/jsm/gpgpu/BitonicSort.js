import{Fn,uvec2,If,instancedArray,instanceIndex,invocationLocalIndex,Loop,workgroupArray,workgroupBarrier,workgroupId,uint,select,min,max}from"three/tsl";const StepType={NONE:0,SWAP_LOCAL:1,DISPERSE_LOCAL:2,FLIP_GLOBAL:3,DISPERSE_GLOBAL:4};export const getBitonicFlipIndices=Fn(([e,t])=>{const i=e.mul(2).div(t).mul(t),s=t.div(2),n=uvec2(e.mod(s),t.sub(e.mod(s)).sub(1));return n.x.addAssign(i),n.y.addAssign(i),n}).setLayout({name:"getBitonicFlipIndices",type:"uvec2",inputs:[{name:"index",type:"uint"},{name:"blockHeight",type:"uint"}]});export const getBitonicDisperseIndices=Fn(([e,t])=>{const i=e.mul(2).div(t).mul(t),s=t.div(2),n=uvec2(e.mod(s),e.mod(s).add(s));return n.x.addAssign(i),n.y.addAssign(i),n}).setLayout({name:"getBitonicDisperseIndices",type:"uvec2",inputs:[{name:"index",type:"uint"},{name:"blockHeight",type:"uint"}]});export class BitonicSort{constructor(e,t,i={}){this.renderer=e,this.dataBuffer=t,this.count=t.value.count,this.dispatchSize=this.count/2,this.workgroupSize=i.workgroupSize?Math.min(this.dispatchSize,i.workgroupSize):Math.min(this.dispatchSize,64),this.localStorage=workgroupArray(t.nodeType,2*this.workgroupSize),this._tempArray=new Uint32Array(this.count);for(let e=0;e<this.count;e++)this._tempArray[e]=0;this.tempBuffer=instancedArray(this.count,t.nodeType).setName("TempStorage"),this.infoStorage=instancedArray(new Uint32Array([1,2,2]),"uint").setName("BitonicSortInfo"),this.swapOpCount=this._getSwapOpCount(),this.stepCount=this._getStepCount(),this.readBufferName="Data",this.flipGlobalNodes={Data:this._getFlipGlobal(this.dataBuffer,this.tempBuffer),Temp:this._getFlipGlobal(this.tempBuffer,this.dataBuffer)},this.disperseGlobalNodes={Data:this._getDisperseGlobal(this.dataBuffer,this.tempBuffer),Temp:this._getDisperseGlobal(this.tempBuffer,this.dataBuffer)},this.swapLocalFn=this._getSwapLocal(),this.disperseLocalNodes={Data:this._getDisperseLocal(this.dataBuffer),Temp:this._getDisperseLocal(this.tempBuffer)},this.setAlgoFn=this._getSetAlgoFn(),this.alignFn=this._getAlignFn(),this.resetFn=this._getResetFn(),this.currentDispatch=0,this.globalOpsRemaining=0,this.globalOpsInSpan=0}_getSwapOpCount(){const e=Math.log2(this.count);return e*(e+1)/2}_getStepCount(){const e=Math.log2(this.count)-Math.log2(2*this.workgroupSize);let t=1,i=0;for(let s=1;s<=e;s++)t+=1,t+=i,t+=1,i+=1;return t}_globalCompareAndSwapTSL(e,t,i,s){const n=i.element(e),o=i.element(t);s.element(e).assign(min(n,o)),s.element(t).assign(max(n,o))}_localCompareAndSwapTSL(e,t){const{localStorage:i}=this,s=i.element(e).toVar(),n=i.element(t).toVar();i.element(e).assign(min(s,n)),i.element(t).assign(max(s,n))}_getDisperseGlobal(e,t){const{infoStorage:i}=this,s=i.element(1);return Fn(()=>{const i=getBitonicDisperseIndices(instanceIndex,s);this._globalCompareAndSwapTSL(i.x,i.y,e,t)})().compute(this.dispatchSize,[this.workgroupSize])}_getFlipGlobal(e,t){const{infoStorage:i}=this,s=i.element(1);return Fn(()=>{const i=getBitonicFlipIndices(instanceIndex,s);this._globalCompareAndSwapTSL(i.x,i.y,e,t)})().compute(this.dispatchSize,[this.workgroupSize])}_getSwapLocal(){const{localStorage:e,dataBuffer:t,workgroupSize:i}=this;return Fn(()=>{const s=uint(i).mul(2).mul(workgroupId.x).toVar(),n=invocationLocalIndex.mul(2),o=invocationLocalIndex.mul(2).add(1);e.element(n).assign(t.element(s.add(n))),e.element(o).assign(t.element(s.add(o))),workgroupBarrier();const a=uint(2);Loop({start:uint(2),end:uint(2*i),type:"uint",condition:"<=",update:"<<= 1"},()=>{workgroupBarrier();const e=getBitonicFlipIndices(invocationLocalIndex,a);this._localCompareAndSwapTSL(e.x,e.y);const t=a.div(2);Loop({start:t,end:uint(1),type:"uint",condition:">",update:">>= 1"},()=>{workgroupBarrier();const e=getBitonicDisperseIndices(invocationLocalIndex,t);this._localCompareAndSwapTSL(e.x,e.y),t.divAssign(2)}),a.shiftLeftAssign(1)}),workgroupBarrier(),t.element(s.add(n)).assign(e.element(n)),t.element(s.add(o)).assign(e.element(o))})().compute(this.dispatchSize,[this.workgroupSize])}_getDisperseLocal(e){const{localStorage:t,workgroupSize:i}=this;return Fn(()=>{const s=uint(i).mul(2).mul(workgroupId.x).toVar(),n=invocationLocalIndex.mul(2),o=invocationLocalIndex.mul(2).add(1);t.element(n).assign(e.element(s.add(n))),t.element(o).assign(e.element(s.add(o))),workgroupBarrier();const a=uint(2*i);Loop({start:a,end:uint(1),type:"uint",condition:">",update:">>= 1"},()=>{workgroupBarrier();const e=getBitonicDisperseIndices(invocationLocalIndex,a);this._localCompareAndSwapTSL(e.x,e.y),a.divAssign(2)}),workgroupBarrier(),e.element(s.add(n)).assign(t.element(n)),e.element(s.add(o)).assign(t.element(o))})().compute(this.dispatchSize,[this.workgroupSize])}_getResetFn(){return Fn(()=>{const{infoStorage:e}=this,t=e.element(0),i=e.element(1),s=e.element(2);t.assign(StepType.SWAP_LOCAL),i.assign(2),s.assign(2)})().compute(1)}_getAlignFn(){const{dataBuffer:e,tempBuffer:t}=this;return Fn(()=>{e.element(instanceIndex).assign(t.element(instanceIndex))})().compute(this.count,[this.workgroupSize])}_getSetAlgoFn(){return Fn(()=>{const{infoStorage:e,workgroupSize:t}=this,i=e.element(0),s=e.element(1),n=e.element(2);If(i.equal(StepType.SWAP_LOCAL),()=>{const e=uint(4*t);i.assign(StepType.FLIP_GLOBAL),s.assign(e),n.assign(e)}).ElseIf(i.equal(StepType.DISPERSE_LOCAL),()=>{i.assign(StepType.FLIP_GLOBAL);const e=n.mul(2);s.assign(e),n.assign(e)}).Else(()=>{const e=s.div(2);i.assign(select(e.lessThanEqual(uint(2*t)),StepType.DISPERSE_LOCAL,StepType.DISPERSE_GLOBAL).uniformFlow()),s.assign(e)})})().compute(1)}computeStep(e){if(0===this.currentDispatch)e.compute(this.swapLocalFn),this.globalOpsRemaining=1,this.globalOpsInSpan=1;else if(this.globalOpsRemaining>0){const t=this.globalOpsRemaining===this.globalOpsInSpan?"Flip":"Disperse";e.compute("Flip"===t?this.flipGlobalNodes[this.readBufferName]:this.disperseGlobalNodes[this.readBufferName]),"Data"===this.readBufferName?this.readBufferName="Temp":this.readBufferName="Data",this.globalOpsRemaining-=1}else{e.compute(this.disperseLocalNodes[this.readBufferName]);const t=this.globalOpsInSpan+1;this.globalOpsInSpan=t,this.globalOpsRemaining=t}this.currentDispatch+=1,this.currentDispatch===this.stepCount?("Temp"===this.readBufferName&&(e.compute(this.alignFn),this.readBufferName="Data"),e.compute(this.resetFn),this.currentDispatch=0,this.globalOpsRemaining=0,this.globalOpsInSpan=0):e.compute(this.setAlgoFn)}compute(e){this.globalOpsRemaining=0,this.globalOpsInSpan=0,this.currentDispatch=0;for(let t=0;t<this.stepCount;t++)this.computeStep(e)}}