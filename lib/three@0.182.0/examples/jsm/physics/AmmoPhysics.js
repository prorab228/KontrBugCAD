async function AmmoPhysics(){if("Ammo"in window==!1)return void console.error("AmmoPhysics: Couldn't find Ammo.js");const t=await Ammo(),e=new t.btDefaultCollisionConfiguration,n=new t.btCollisionDispatcher(e),o=new t.btDbvtBroadphase,i=new t.btSequentialImpulseConstraintSolver,s=new t.btDiscreteDynamicsWorld(n,o,i,e);s.setGravity(new t.btVector3(0,-9.8,0));const r=new t.btTransform;const c=[],a=new WeakMap;function d(e,n=0,o=0){const i=function(e){const n=e.parameters;if("BoxGeometry"===e.type){const e=void 0!==n.width?n.width/2:.5,o=void 0!==n.height?n.height/2:.5,i=void 0!==n.depth?n.depth/2:.5,s=new t.btBoxShape(new t.btVector3(e,o,i));return s.setMargin(.05),s}if("SphereGeometry"===e.type||"IcosahedronGeometry"===e.type){const e=void 0!==n.radius?n.radius:1,o=new t.btSphereShape(e);return o.setMargin(.05),o}return console.error("AmmoPhysics: Unsupported geometry type:",e.type),null}(e.geometry);null!==i&&(e.isInstancedMesh?function(e,n,o,i){const r=e.instanceMatrix.array,d=[];for(let c=0;c<e.count;c++){const e=16*c,a=new t.btTransform;a.setFromOpenGLMatrix(r.slice(e,e+16));const u=new t.btDefaultMotionState(a),l=new t.btVector3(0,0,0);n.calculateLocalInertia(o,l);const y=new t.btRigidBodyConstructionInfo(o,u,n,l);y.set_m_restitution(i);const m=new t.btRigidBody(y);s.addRigidBody(m),d.push(m)}o>0&&(c.push(e),a.set(e,d))}(e,i,n,o):e.isMesh&&function(e,n,o,i){const r=e.position,d=e.quaternion,u=new t.btTransform;u.setIdentity(),u.setOrigin(new t.btVector3(r.x,r.y,r.z)),u.setRotation(new t.btQuaternion(d.x,d.y,d.z,d.w));const l=new t.btDefaultMotionState(u),y=new t.btVector3(0,0,0);n.calculateLocalInertia(o,y);const m=new t.btRigidBodyConstructionInfo(o,l,n,y);m.set_m_restitution(i);const w=new t.btRigidBody(m);s.addRigidBody(w),o>0&&(c.push(e),a.set(e,w))}(e,i,n,o))}let u=0;return setInterval(function(){const t=performance.now();if(u>0){const e=(t-u)/1e3;s.stepSimulation(e,10);for(let t=0,e=c.length;t<e;t++){const e=c[t];if(e.isInstancedMesh){const t=e.instanceMatrix.array,n=a.get(e);for(let e=0;e<n.length;e++){n[e].getMotionState().getWorldTransform(r);compose(r.getOrigin(),r.getRotation(),t,16*e)}e.instanceMatrix.needsUpdate=!0,e.computeBoundingSphere()}else if(e.isMesh){a.get(e).getMotionState().getWorldTransform(r);const t=r.getOrigin(),n=r.getRotation();e.position.set(t.x(),t.y(),t.z()),e.quaternion.set(n.x(),n.y(),n.z(),n.w())}}}u=t},1e3/60),{addScene:function(t){t.traverse(function(t){if(t.isMesh){const e=t.userData.physics;e&&d(t,e.mass,e.restitution)}})},addMesh:d,setMeshPosition:function(e,n,o=0){if(e.isInstancedMesh){const i=a.get(e)[o];i.setAngularVelocity(new t.btVector3(0,0,0)),i.setLinearVelocity(new t.btVector3(0,0,0)),r.setIdentity(),r.setOrigin(new t.btVector3(n.x,n.y,n.z)),i.setWorldTransform(r)}else if(e.isMesh){const o=a.get(e);o.setAngularVelocity(new t.btVector3(0,0,0)),o.setLinearVelocity(new t.btVector3(0,0,0)),r.setIdentity(),r.setOrigin(new t.btVector3(n.x,n.y,n.z)),o.setWorldTransform(r)}}}}function compose(t,e,n,o){const i=e.x(),s=e.y(),r=e.z(),c=e.w(),a=i+i,d=s+s,u=r+r,l=i*a,y=i*d,m=i*u,w=s*d,f=s*u,g=r*u,h=c*a,p=c*d,b=c*u;n[o+0]=1-(w+g),n[o+1]=y+b,n[o+2]=m-p,n[o+3]=0,n[o+4]=y-b,n[o+5]=1-(l+g),n[o+6]=f+h,n[o+7]=0,n[o+8]=m+p,n[o+9]=f-h,n[o+10]=1-(l+w),n[o+11]=0,n[o+12]=t.x(),n[o+13]=t.y(),n[o+14]=t.z(),n[o+15]=1}export{AmmoPhysics};