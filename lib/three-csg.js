"use strict";import*as THREE from"three";let{BufferGeometry:BufferGeometry,Vector3:Vector3,Vector2:Vector2}=THREE;import{CSG,Vertex,Vector,Polygon}from"./csg-lib.js";CSG.fromGeometry=function(e,t){let r=[];if(e.isGeometry){let o=e.faces,a=e.vertices,n=["a","b","c"];for(let i=0;i<o.length;i++){let l=o[i],s=[];for(let t=0;t<3;t++)s.push(new Vertex(a[l[n[t]]],l.vertexNormals[t],e.faceVertexUvs[0][i][t]));r.push(new Polygon(s,t))}}else if(e.isBufferGeometry){let o,a=e.attributes.position,n=e.attributes.normal,i=e.attributes.uv,l=e.attributes.color;if(e.index)o=e.index.array;else{o=new Array(a.array.length/a.itemSize|0);for(let e=0;e<o.length;e++)o[e]=e}let s=o.length/3|0;r=new Array(s);for(let e=0,s=0,p=o.length;e<p;e+=3,s++){let p=new Array(3);for(let t=0;t<3;t++){let r=o[e+t],s=3*r,y=2*r,u=a.array[s],c=a.array[s+1],f=a.array[s+2],m=n.array[s],h=n.array[s+1],w=n.array[s+2];p[t]=new Vertex({x:u,y:c,z:f},{x:m,y:h,z:w},i&&{x:i.array[y],y:i.array[y+1],z:0},l&&{x:l.array[y],y:l.array[y+1],z:l.array[y+2]})}r[s]=new Polygon(p,t)}}else console.error("Unsupported CSG input type:"+e.type);return CSG.fromPolygons(r)};let ttvv0=new THREE.Vector3,tmpm3=new THREE.Matrix3;CSG.fromMesh=function(e,t){let r=CSG.fromGeometry(e.geometry,t);tmpm3.getNormalMatrix(e.matrix);for(let t=0;t<r.polygons.length;t++){let o=r.polygons[t];for(let t=0;t<o.vertices.length;t++){let r=o.vertices[t];r.pos.copy(ttvv0.copy(r.pos).applyMatrix4(e.matrix)),r.normal.copy(ttvv0.copy(r.normal).applyMatrix3(tmpm3))}}return r};let nbuf3=e=>({top:0,array:new Float32Array(e),write:function(e){this.array[this.top++]=e.x,this.array[this.top++]=e.y,this.array[this.top++]=e.z}}),nbuf2=e=>({top:0,array:new Float32Array(e),write:function(e){this.array[this.top++]=e.x,this.array[this.top++]=e.y}});CSG.toGeometry=function(e,t=!0){let r,o,a=e.polygons;if(t){let e=0;a.forEach(t=>e+=t.vertices.length-2),r=new THREE.BufferGeometry;let t,n,i=nbuf3(3*e*3),l=nbuf3(3*e*3),s=[];if(a.forEach(r=>{let o=r.vertices,a=o.length;void 0!==r.shared&&(s[r.shared]||(s[r.shared]=[])),a&&(void 0!==o[0].color&&(n||(n=nbuf3(3*e*3))),void 0!==o[0].uv&&(t||(t=nbuf2(2*e*3))));for(let e=3;e<=a;e++)void 0!==r.shared&&s[r.shared].push(i.top/3,i.top/3+1,i.top/3+2),i.write(o[0].pos),i.write(o[e-2].pos),i.write(o[e-1].pos),l.write(o[0].normal),l.write(o[e-2].normal),l.write(o[e-1].normal),t&&o[0].uv&&(t.write(o[0].uv)||t.write(o[e-2].uv)||t.write(o[e-1].uv)),n&&(n.write(o[0].color)||n.write(o[e-2].color)||n.write(o[e-1].color))}),r.setAttribute("position",new THREE.BufferAttribute(i.array,3)),r.setAttribute("normal",new THREE.BufferAttribute(l.array,3)),t&&r.setAttribute("uv",new THREE.BufferAttribute(t.array,2)),n&&r.setAttribute("color",new THREE.BufferAttribute(n.array,3)),s.length){let e=[],t=0;for(let o=0;o<s.length;o++)r.addGroup(t,s[o].length,o),t+=s[o].length,e=e.concat(s[o]);r.setIndex(e)}o=r}else{r=new Geometry;let e=r.vertices,t=r.faceVertexUvs[0];for(let o=0;o<a.length;o++){let n=a[o],i=n.vertices,l=e.length,s=i.length;for(let t=0;t<s;t++)e.push((new THREE.Vector3).copy(i[t].pos));for(let e=3;e<=s;e++){let o=new THREE.Face3,a=[];t.push(a);let s=o.vertexNormals;o.a=l,o.b=l+e-2,o.c=l+e-1,s.push((new THREE.Vector3).copy(i[0].normal)),s.push((new THREE.Vector3).copy(i[e-2].normal)),s.push((new THREE.Vector3).copy(i[e-1].normal)),a.push((new THREE.Vector3).copy(i[0].uv)),a.push((new THREE.Vector3).copy(i[e-2].uv)),a.push((new THREE.Vector3).copy(i[e-1].uv)),o.normal=(new THREE.Vector3).copy(n.plane.normal),r.faces.push(o)}}r=(new THREE.BufferGeometry).fromGeometry(r),r.verticesNeedUpdate=r.elementsNeedUpdate=r.normalsNeedUpdate=!0}return r},CSG.toMesh=function(e,t=new THREE.Matrix4,r){let o=CSG.toGeometry(e),a=(new THREE.Matrix4).copy(t).invert();o.applyMatrix4(a),o.computeBoundingSphere(),o.computeBoundingBox();let n=new THREE.Mesh(o,r);return n.matrix.copy(t),n.matrix.decompose(n.position,n.quaternion,n.scale),n.rotation.setFromQuaternion(n.quaternion),n.updateMatrixWorld(),n.castShadow=n.receiveShadow=!0,n};import"./csg-worker.js";export default CSG;