import{BufferAttribute as t,Vector3 as e,Ray as n,Vector2 as r,Vector4 as i,Mesh as o,Matrix4 as s,Line3 as a,Plane as c,Triangle as l,DoubleSide as u,Matrix3 as d,BufferGeometry as h,Group as g,Color as f,MeshPhongMaterial as p,MathUtils as m,LineSegments as y,LineBasicMaterial as b,InstancedMesh as w,SphereGeometry as x,MeshBasicMaterial as A}from"/npm/three@0.175.0/+esm";import{MeshBVH as v,ExtendedTriangle as S}from"/npm/three-mesh-bvh@0.9.0/+esm";const T=1e-6,M=Math.pow(10,-Math.log10(T)),B=5e-7*M;function z(t){return~~(t*M+B)}function E(t){return`${z(t.x)},${z(t.y)},${z(t.z)}`}function I(t){return`${z(t.x)},${z(t.y)},${z(t.z)},${z(t.w)}`}function C(t,e,n){n.direction.subVectors(e,t).normalize();const r=t.dot(n.direction);return n.origin.copy(t).addScaledVector(n.direction,-r),n}function _(){return"undefined"!=typeof SharedArrayBuffer}function G(t){if(t.buffer instanceof SharedArrayBuffer)return t;const e=t.constructor,n=t.buffer,r=new SharedArrayBuffer(n.byteLength),s=new Uint8Array(n);return new Uint8Array(r).set(s,0),new e(r)}function V(e,n){if(!e.index){const r=e.attributes.position.count,s=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(r,n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);e.setIndex(new t(s,1));for(let t=0;t<r;t++)s[t]=t}}function P(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}const j=new e;function k(t){return t%3}function X(t,e){return t.start-e.start}function D(t,e){return j.subVectors(e,t.origin).dot(t.direction)}const $=1e-5,W=1e-4;class N{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,n=t.clone();n.direction.multiplyScalar(-1);let r=1/0,s=null;for(let a=0,l=e.length;a<l;a++){const l=e[a];if(i(l,t)&&i(l,n))continue;const c=o(l,t),u=o(l,n),d=Math.min(c,u);d<r&&(r=d,s=l)}return s;function i(t,e){const n=t.origin.distanceTo(e.origin)>$;return t.direction.angleTo(e.direction)>W||n}function o(t,e){const n=t.origin.distanceTo(e.origin),r=t.direction.angleTo(e.direction);return n/$+r/W}}}const R=new e,F=new e,U=new n;function O(t,e,n){const r=t.attributes,s=t.index,i=r.position,o=new Map,a=new Map,l=Array.from(e),c=new N;for(let t=0,e=l.length;t<e;t++){const e=l[t],n=~~(e/3),r=k(e);let o,u=3*n+r,d=3*n+(r+1)%3;s&&(u=s.getX(u),d=s.getX(d)),R.fromBufferAttribute(i,u),F.fromBufferAttribute(i,d),C(R,F,U);let h=c.findClosestRay(U);null===h&&(h=U.clone(),c.addRay(h)),a.has(h)||a.set(h,{forward:[],reverse:[],ray:h}),o=a.get(h);let g=D(h,R),f=D(h,F);g>f&&([g,f]=[f,g]),U.direction.dot(h.direction)<0?o.reverse.push({start:g,end:f,index:e}):o.forward.push({start:g,end:f,index:e})}return a.forEach(({forward:t,reverse:e},r)=>{!function(t,e,n,r=1e-8){t.sort(X),e.sort(X);for(let r=0;r<t.length;r++){const s=t[r];for(let a=0;a<e.length;a++){const l=e[a];if(l.start>s.end);else{if(s.end<l.start||l.end<s.start)continue;if(s.start<=l.start&&s.end>=l.end)i(l.end,s.end)||t.splice(r+1,0,{start:l.end,end:s.end,index:s.index}),s.end=l.start,l.start=0,l.end=0;else if(s.start>=l.start&&s.end<=l.end)i(s.end,l.end)||e.splice(a+1,0,{start:s.end,end:l.end,index:l.index}),l.end=s.start,s.start=0,s.end=0;else if(s.start<=l.start&&s.end<=l.end){const t=s.end;s.end=l.start,l.start=t}else{if(!(s.start>=l.start&&s.end>=l.end))throw new Error;{const t=l.end;l.end=s.start,s.start=t}}}if(n.has(s.index)||n.set(s.index,[]),n.has(l.index)||n.set(l.index,[]),n.get(s.index).push(l.index),n.get(l.index).push(s.index),o(l)&&(e.splice(a,1),a--),o(s)){t.splice(r,1),r--;break}}}function s(t){for(let e=0;e<t.length;e++)o(t[e])&&(t.splice(e,1),e--)}function i(t,e){return Math.abs(e-t)<r}function o(t){return Math.abs(t.end-t.start)<r}s(t),s(e)}(t,e,o,n),0===t.length&&0===e.length&&a.delete(r)}),{disjointConnectivityMap:o,fragmentMap:a}}const L=new r,H=new e,q=new i,Y=["","",""];class Z{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:~~(n/3)}getSiblingEdgeIndex(t,e){const n=this.data[3*t+e];return-1===n?-1:n%3}getDisjointSiblingTriangleIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map(t=>~~(t/3)):[]}getDisjointSiblingEdgeIndices(t,e){const n=3*t+e,r=this.disjointConnections.get(n);return r?r.map(t=>t%3):[]}isFullyConnected(){return 0===this.unmatchedEdges}updateFrom(t){const{useAllAttributes:e,useDrawRange:n,matchDisjointEdges:r,degenerateEpsilon:s}=this,i=e?function(t){let e="";for(let r=0,s=l.length;r<s;r++){const s=a[l[r]];let i;switch(s.itemSize){case 1:i=z(s.getX(t));break;case 2:i=`${z((n=L.fromBufferAttribute(s,t)).x)},${z(n.y)}`;break;case 3:i=E(H.fromBufferAttribute(s,t));break;case 4:i=I(q.fromBufferAttribute(s,t))}""!==e&&(e+="|"),e+=i}var n;return e}:function(t){return H.fromBufferAttribute(u,t),E(H)},o=new Map,{attributes:a}=t,l=e?Object.keys(a):null,c=t.index,u=a.position;let d=P(t);const h=d;let g=0;n&&(g=t.drawRange.start,t.drawRange.count!==1/0&&(d=~~(t.drawRange.count/3)));let f=this.data;(!f||f.length<3*h)&&(f=new Int32Array(3*h)),f.fill(-1);let p=0,m=new Set;for(let t=g,e=3*d+g;t<e;t+=3){const e=t;for(let t=0;t<3;t++){let n=e+t;c&&(n=c.getX(n)),Y[t]=i(n)}for(let t=0;t<3;t++){const n=(t+1)%3,r=Y[t],s=Y[n],i=`${s}_${r}`;if(o.has(i)){const n=e+t,r=o.get(i);f[n]=r,f[r]=n,o.delete(i),p+=2,m.delete(r)}else{const n=`${r}_${s}`,i=e+t;o.set(n,i),m.add(i)}}}if(r){const{fragmentMap:e,disjointConnectivityMap:n}=O(t,m,s);m.clear(),e.forEach(({forward:t,reverse:e})=>{t.forEach(({index:t})=>m.add(t)),e.forEach(({index:t})=>m.add(t))}),this.unmatchedDisjointEdges=e,this.disjointConnections=n,p=3*d-m.size}this.matchedEdges=p,this.unmatchedEdges=m.size,this.data=f}}class K extends o{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new s,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,r=e.elements;for(let t=0;t<16;t++)if(n[t]!==r[t])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,n=_();if(n)for(const t in e){const n=e[t];if(n.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");n.array=G(n.array)}if(t.boundsTree||(V(t,{useSharedArrayBuffer:n}),t.boundsTree=new v(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:n})),t.halfEdges||(t.halfEdges=new Z(t)),!t.groupIndices){const e=P(t),n=new Uint16Array(e),r=t.groups;for(let t=0,e=r.length;t<e;t++){const{start:e,count:s}=r[t];for(let r=e/3,i=(e+s)/3;r<i;r++)n[r]=t}t.groupIndices=n}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const J=new e,Q=new e,tt=new e;function et(t,e=1e-14){J.subVectors(t.b,t.a),Q.subVectors(t.c,t.a),tt.subVectors(t.b,t.c);const n=J.angleTo(Q),r=J.angleTo(tt),s=Math.PI-n-r;return Math.abs(n)<e||Math.abs(r)<e||Math.abs(s)<e||t.a.distanceToSquared(t.b)<e||t.a.distanceToSquared(t.c)<e||t.b.distanceToSquared(t.c)<e}const nt=1e-10,rt=1e-10,it=new a,ot=new a,st=new e,at=new e,ct=new e,lt=new c,ut=new S;class dt{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new l),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class ht{constructor(){this.trianglePool=new dt,this.triangles=[],this.normal=new e,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:n,normal:r}=this;if(Array.isArray(t))for(let s=0,i=t.length;s<i;s++){const i=t[s];if(0===s)i.getNormal(r);else if(Math.abs(1-i.getNormal(st).dot(r))>nt)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const o=n.getTriangle();o.copy(i),e.push(o)}else{t.getNormal(r);const s=n.getTriangle();s.copy(t),e.push(s)}}splitByTriangle(t){const{normal:e,triangles:n}=this;if(t.getNormal(at).normalize(),Math.abs(1-Math.abs(at.dot(e)))<1e-10){this.coplanarTriangleUsed=!0;for(let t=0,e=n.length;t<e;t++)n[t].coplanarCount=0;const e=[t.a,t.b,t.c];for(let n=0;n<3;n++){const r=(n+1)%3,s=e[n],i=e[r];st.subVectors(i,s).normalize(),ct.crossVectors(at,st),lt.setFromNormalAndCoplanarPoint(ct,s),this.splitByPlane(lt,t)}}else t.getPlane(lt),this.splitByPlane(lt,t)}splitByPlane(t,e){const{triangles:n,trianglePool:r}=this;ut.copy(e),ut.needsUpdate=!0;for(let e=0,s=n.length;e<s;e++){const i=n[e];if(!ut.intersectsTriangle(i,it,!0))continue;const{a:o,b:a,c:l}=i;let c=0,u=-1,d=!1,h=[],g=[];const f=[o,a,l];for(let e=0;e<3;e++){const n=(e+1)%3;it.start.copy(f[e]),it.end.copy(f[n]);const r=t.distanceToPoint(it.start),s=t.distanceToPoint(it.end);if(Math.abs(r)<rt&&Math.abs(s)<rt){d=!0;break}if(r>0?h.push(e):g.push(e),Math.abs(r)<rt)continue;let i=!!t.intersectLine(it,st);!i&&Math.abs(s)<rt&&(st.copy(it.end),i=!0),!i||st.distanceTo(it.start)<nt||(st.distanceTo(it.end)<nt&&(u=e),0===c?ot.start.copy(st):ot.end.copy(st),c++)}if(!d&&2===c&&ot.distance()>rt)if(-1!==u){u=(u+1)%3;let t=0;t===u&&(t=(t+1)%3);let o=t+1;o===u&&(o=(o+1)%3);const a=r.getTriangle();a.a.copy(f[o]),a.b.copy(ot.end),a.c.copy(ot.start),et(a)||n.push(a),i.a.copy(f[t]),i.b.copy(ot.start),i.c.copy(ot.end),et(i)&&(n.splice(e,1),e--,s--)}else{const t=h.length>=2?g[0]:h[0];if(0===t){let t=ot.start;ot.start=ot.end,ot.end=t}const o=(t+1)%3,a=(t+2)%3,l=r.getTriangle(),c=r.getTriangle();f[o].distanceToSquared(ot.start)<f[a].distanceToSquared(ot.end)?(l.a.copy(f[o]),l.b.copy(ot.start),l.c.copy(ot.end),c.a.copy(f[o]),c.b.copy(f[a]),c.c.copy(ot.start)):(l.a.copy(f[a]),l.b.copy(ot.start),l.c.copy(ot.end),c.a.copy(f[o]),c.b.copy(f[a]),c.c.copy(ot.end)),i.a.copy(f[t]),i.b.copy(ot.end),i.c.copy(ot.start),et(l)||n.push(l),et(c)||n.push(c),et(i)&&(n.splice(e,1),e--,s--)}else 3===c&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}class gt{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(0!==this.length)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,n=new e(new(_()?SharedArrayBuffer:ArrayBuffer)(4+(r=~~(r=t*e.BYTES_PER_ELEMENT))-r%4));var r;this.array&&n.set(this.array,0),this.array=n}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:n}=this;n+t.length>e.length&&(this.expand(),e=this.array);for(let r=0,s=t.length;r<s;r++)e[n+r]=t[r];this.length+=t.length}clear(){this.length=0}}class ft{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:n}=this;let r=0;for(let s=0;s<e;s++)r+=n[s][t].length;return r}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const n=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const t={};e.push(t);for(const e in n){const r=n[e],s=new gt(r.type);s.itemSize=r.itemSize,s.normalized=r.normalized,t[e]=s}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:n}=this;if(!n[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,n,r){const{groupAttributes:s}=this,i=s[0][t];if(i){if(i.type!==e)for(let i=0,o=s.length;i<o;i++){const o=s[i][t];o.setType(e),o.itemSize=n,o.normalized=r}}else for(let i=0,o=s.length;i<o;i++){const o=new gt(e);o.itemSize=n,o.normalized=r,s[i][t]=o}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(t=>{for(const e in t)t[e].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class pt{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:n,ids:r}=this;n[t]||(n[t]=[],r.push(t)),n[t].push(e)}}const mt=0,yt=1,bt=2,wt=3,xt=4,At=5,vt=6,St=new n,Tt=new s,Mt=new l,Bt=new e,zt=new i,Et=new i,It=new i,Ct=new i,_t=new i,Gt=new i,Vt=new a,Pt=new e,jt=1e-8,kt=-1;let Xt=null;function Dt(t){Xt=t}function $t(t,e){t.getMidpoint(St.origin),t.getNormal(St.direction);const n=e.raycastFirst(St,u);return Boolean(n&&St.direction.dot(n.face.normal)>0)?-1:1}function Wt(t,e){function n(){return Math.random()-.5}t.getNormal(Pt),St.direction.copy(Pt),t.getMidpoint(St.origin);let r=0,s=1/0;for(let t=0;t<3;t++){St.direction.x+=n()*jt,St.direction.y+=n()*jt,St.direction.z+=n()*jt,St.direction.multiplyScalar(-1);const i=e.raycastFirst(St,u);if(Boolean(i&&St.direction.dot(i.face.normal)>0)&&r++,null!==i&&(s=Math.min(s,i.distance)),s<=1e-15)return i.face.normal.dot(Pt)>0?2:-2;if(r/3>.5||(t-r+1)/3>.5)break}return r/3>.5?-1:1}function Nt(t,e,n,r,s,i,o=!1){const a=n.attributes,l=n.index,c=3*t,u=l.getX(c+0),d=l.getX(c+1),h=l.getX(c+2);for(const t in i){const n=a[t],l=i[t];if(!(t in a))throw new Error(`CSG Operations: Attribute ${t} not available on geometry.`);const c=n.itemSize;"position"===t?(Mt.a.fromBufferAttribute(n,u).applyMatrix4(r),Mt.b.fromBufferAttribute(n,d).applyMatrix4(r),Mt.c.fromBufferAttribute(n,h).applyMatrix4(r),Ut(Mt.a,Mt.b,Mt.c,e,3,l,o)):"normal"===t?(Mt.a.fromBufferAttribute(n,u).applyNormalMatrix(s),Mt.b.fromBufferAttribute(n,d).applyNormalMatrix(s),Mt.c.fromBufferAttribute(n,h).applyNormalMatrix(s),o&&(Mt.a.multiplyScalar(-1),Mt.b.multiplyScalar(-1),Mt.c.multiplyScalar(-1)),Ut(Mt.a,Mt.b,Mt.c,e,3,l,o,!0)):(zt.fromBufferAttribute(n,u),Et.fromBufferAttribute(n,d),It.fromBufferAttribute(n,h),Ut(zt,Et,It,e,c,l,o))}}function Rt(t,e,n,r,s,i,o,a=!1){Ot(t,r,s,i,o,a),Ot(a?n:e,r,s,i,o,a),Ot(a?e:n,r,s,i,o,a)}function Ft(t,e,n=!1){switch(t){case 0:if(1===e||2===e&&!n)return 1;break;case 1:if(n){if(-1===e)return 0}else if(1===e||-2===e)return 1;break;case 2:if(n){if(1===e||-2===e)return 1}else if(-1===e)return 0;break;case 4:if(-1===e)return 0;if(1===e)return 1;break;case 3:if(-1===e||2===e&&!n)return 1;break;case 5:if(!n&&(1===e||-2===e))return 1;break;case 6:if(!n&&(-1===e||2===e))return 1;break;default:throw new Error(`Unrecognized CSG operation enum "${t}".`)}return 2}function Ut(t,e,n,r,s,i,o=!1,a=!1){const l=t=>{i.push(t.x),s>1&&i.push(t.y),s>2&&i.push(t.z),s>3&&i.push(t.w)};Ct.set(0,0,0,0).addScaledVector(t,r.a.x).addScaledVector(e,r.a.y).addScaledVector(n,r.a.z),_t.set(0,0,0,0).addScaledVector(t,r.b.x).addScaledVector(e,r.b.y).addScaledVector(n,r.b.z),Gt.set(0,0,0,0).addScaledVector(t,r.c.x).addScaledVector(e,r.c.y).addScaledVector(n,r.c.z),a&&(Ct.normalize(),_t.normalize(),Gt.normalize()),l(Ct),o?(l(Gt),l(_t)):(l(_t),l(Gt))}function Ot(t,e,n,r,s,i=!1){for(const o in s){const a=e[o],l=s[o];if(!(o in e))throw new Error(`CSG Operations: Attribute ${o} no available on geometry.`);const c=a.itemSize;"position"===o?(Bt.fromBufferAttribute(a,t).applyMatrix4(n),l.push(Bt.x,Bt.y,Bt.z)):"normal"===o?(Bt.fromBufferAttribute(a,t).applyNormalMatrix(r),i&&Bt.multiplyScalar(-1),l.push(Bt.x,Bt.y,Bt.z)):(l.push(a.getX(t)),c>1&&l.push(a.getY(t)),c>2&&l.push(a.getZ(t)),c>3&&l.push(a.getW(t)))}}class Lt{constructor(t){this.triangle=(new l).copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=(new l).copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const n in e)t.push(e[n]);return t}}class Ht{constructor(){this.data={}}addTriangleIntersection(t,e,n,r){const{data:s}=this;s[t]||(s[t]=new Lt(e)),s[t].addTriangle(n,r)}getTrianglesAsArray(t=null){const{data:e}=this,n=[];if(null!==t)t in e&&n.push(e[t].triangle);else for(const t in e)n.push(e[t].triangle);return n}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(t=>parseInt(t)):[]}getIntersectionsAsArray(t=null,e=null){const{data:n}=this,r=new Set,s=[],i=t=>{if(n[t])if(null!==e)n[t].intersects[e]&&s.push(n[t].intersects[e]);else{const e=n[t].intersects;for(const t in e)r.has(t)||(r.add(t),s.push(e[t]))}};if(null!==t)i(t);else for(const t in n)i(t);return s}reset(){this.data={}}}class qt{constructor(){this.enabled=!1,this.triangleIntersectsA=new Ht,this.triangleIntersectsB=new Ht,this.intersectionEdges=[]}addIntersectingTriangles(t,e,n,r){const{triangleIntersectsA:s,triangleIntersectsB:i}=this;s.addTriangleIntersection(t,e,n,r),i.addTriangleIntersection(n,r,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Dt(this))}complete(){this.enabled&&Dt(null)}}const Yt=new s,Zt=new d,Kt=new l,Jt=new l,Qt=new l,te=new l,ee=[],ne=[];function re(t){for(const e of t)return e}function ie(t,e,n,r,s,i={}){const{useGroups:o=!0}=i,{aIntersections:a,bIntersections:l}=function(t,e){const n=new pt,r=new pt;return Tt.copy(t.matrixWorld).invert().multiply(e.matrixWorld),t.geometry.boundsTree.bvhcast(e.geometry.boundsTree,Tt,{intersectsTriangles(s,i,o,a){if(!et(s)&&!et(i)){let l=s.intersectsTriangle(i,Vt,!0);if(!l){const t=s.plane,e=i.plane,n=t.normal,r=e.normal;1===n.dot(r)&&Math.abs(t.constant-e.constant)<1e-14&&(l=!0)}if(l){let l=t.geometry.boundsTree.resolveTriangleIndex(o),c=e.geometry.boundsTree.resolveTriangleIndex(a);n.add(l,c),r.add(c,l),Xt&&(Xt.addEdge(Vt),Xt.addIntersectingTriangles(o,s,a,i))}}return!1}}),{aIntersections:n,bIntersections:r}}(t,e);let c;return c=o?0:-1,oe(t,e,a,n,!1,r,s,c),se(t,e,a,n,!1,s,c),-1!==n.findIndex(t=>6!==t&&5!==t)&&(c=o?t.geometry.groups.length||1:-1,oe(e,t,l,n,!0,r,s,c),se(e,t,l,n,!0,s,c)),ee.length=0,ne.length=0,{groups:[],materials:null}}function oe(t,e,n,r,s,i,o,a=0){const l=t.matrixWorld.determinant()<0;Yt.copy(e.matrixWorld).invert().multiply(t.matrixWorld),Zt.getNormalMatrix(t.matrixWorld).multiplyScalar(l?-1:1);const c=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes.position,h=e.geometry.boundsTree,g=e.geometry.index,f=e.geometry.attributes.position,p=n.ids,m=n.intersectionSet;for(let e=0,n=p.length;e<n;e++){const n=p[e],y=-1===a?0:c[n]+a,b=3*n,w=u.getX(b+0),x=u.getX(b+1),A=u.getX(b+2);Kt.a.fromBufferAttribute(d,w).applyMatrix4(Yt),Kt.b.fromBufferAttribute(d,x).applyMatrix4(Yt),Kt.c.fromBufferAttribute(d,A).applyMatrix4(Yt),i.reset(),i.initialize(Kt);const S=m[n];for(let t=0,e=S.length;t<e;t++){const e=3*S[t],n=g.getX(e+0),r=g.getX(e+1),s=g.getX(e+2);Jt.a.fromBufferAttribute(f,n),Jt.b.fromBufferAttribute(f,r),Jt.c.fromBufferAttribute(f,s),i.splitByTriangle(Jt)}const v=i.triangles;for(let e=0,a=v.length;e<a;e++){const a=v[e],c=i.coplanarTriangleUsed?Wt(a,h):$t(a,h);ee.length=0,ne.length=0;for(let t=0,e=r.length;t<e;t++){const e=Ft(r[t],c,s);2!==e&&(ne.push(e),ee.push(o[t].getGroupAttrSet(y)))}if(0!==ee.length){Kt.getBarycoord(a.a,te.a),Kt.getBarycoord(a.b,te.b),Kt.getBarycoord(a.c,te.c);for(let e=0,r=ee.length;e<r;e++){const r=ee[e],s=0===ne[e];Nt(n,te,t.geometry,t.matrixWorld,Zt,r,l!==s)}}}}return p.length}function se(t,e,n,r,s,i,o=0){const a=t.matrixWorld.determinant()<0;Yt.copy(e.matrixWorld).invert().multiply(t.matrixWorld),Zt.getNormalMatrix(t.matrixWorld).multiplyScalar(a?-1:1);const l=e.geometry.boundsTree,c=t.geometry.groupIndices,u=t.geometry.index,d=t.geometry.attributes,h=d.position,g=[],f=t.geometry.halfEdges,p=new Set;for(let e=0,r=P(t.geometry);e<r;e++)e in n.intersectionSet||p.add(e);for(;p.size>0;){const e=re(p);p.delete(e),g.push(e);const n=3*e,m=u.getX(n+0),y=u.getX(n+1),b=u.getX(n+2);Qt.a.fromBufferAttribute(h,m).applyMatrix4(Yt),Qt.b.fromBufferAttribute(h,y).applyMatrix4(Yt),Qt.c.fromBufferAttribute(h,b).applyMatrix4(Yt);const w=$t(Qt,l);ne.length=0,ee.length=0;for(let t=0,e=r.length;t<e;t++){const e=Ft(r[t],w,s);2!==e&&(ne.push(e),ee.push(i[t]))}for(;g.length>0;){const e=g.pop();for(let t=0;t<3;t++){const n=f.getSiblingTriangleIndex(e,t);-1!==n&&p.has(n)&&(g.push(n),p.delete(n))}if(0!==ee.length){const n=3*e,r=u.getX(n+0),s=u.getX(n+1),i=u.getX(n+2),l=-1===o?0:c[e]+o;if(Qt.a.fromBufferAttribute(h,r),Qt.b.fromBufferAttribute(h,s),Qt.c.fromBufferAttribute(h,i),!et(Qt))for(let e=0,n=ee.length;e<n;e++){const n=ne[e],o=ee[e].getGroupAttrSet(l),c=0===n;Rt(r,s,i,d,t.matrixWorld,Zt,o,c!==a)}}}}}function ae(t,e){let n=e;return Array.isArray(e)||(n=[],t.forEach(t=>{n[t.materialIndex]=e})),n}class ce{constructor(){this.triangleSplitter=new ht,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new qt}getGroupRanges(t){return this.useGroups&&0!==t.groups.length?t.groups.map(t=>({...t})):[{start:0,count:1/0,materialIndex:0}]}evaluate(e,n,r,s=new K){let i=!0;if(Array.isArray(r)||(r=[r]),Array.isArray(s)||(s=[s],i=!1),s.length!==r.length)throw new Error("Evaluator: operations and target array passed as different sizes.");e.prepareGeometry(),n.prepareGeometry();const{triangleSplitter:o,attributeData:a,attributes:l,useGroups:c,consolidateGroups:u,debug:d}=this;for(;a.length<s.length;)a.push(new ft);s.forEach((t,n)=>{!function(t,e,n,r){n.clear();const s=t.attributes;for(let t=0,e=r.length;t<e;t++){const e=r[t],i=s[e];n.initializeArray(e,i.array.constructor,i.itemSize,i.normalized)}for(const t in n.attributes)r.includes(t)||n.delete(t);for(const t in e.attributes)r.includes(t)||(e.deleteAttribute(t),e.dispose())}(e.geometry,t.geometry,a[n],l)}),d.init(),ie(e,n,r,o,a,{useGroups:c}),d.complete();const h=this.getGroupRanges(e.geometry),g=ae(h,e.material),f=this.getGroupRanges(n.geometry),p=ae(f,n.material);f.forEach(t=>t.materialIndex+=g.length);let m=[...h,...f].map((t,e)=>({...t,index:e}));if(c){const t=[...g,...p];u&&(m=m.map(e=>{const n=t[e.materialIndex];return e.materialIndex=t.indexOf(n),e}).sort((t,e)=>t.materialIndex-e.materialIndex));const e=[];for(let n=0,r=t.length;n<r;n++){let r=!1;for(let t=0,s=m.length;t<s;t++){const s=m[t];s.materialIndex===n&&(r=!0,s.materialIndex=e.length)}r&&e.push(t[n])}s.forEach(t=>{t.material=e})}else m=[{start:0,count:1/0,index:0,materialIndex:0}],s.forEach(t=>{t.material=g[0]});return s.forEach((e,n)=>{const r=e.geometry;!function(e,n,r){let s=!1,i=-1;const o=e.attributes,a=n.groupAttributes[0];for(const l in a){const a=n.getTotalLength(l),c=n.getType(l),u=n.getItemSize(l),d=n.getNormalized(l);let h=o[l];(!h||h.array.length<a)&&(h=new t(new c(a),u,d),e.setAttribute(l,h),s=!0);let g=0;for(let t=0,e=Math.min(r.length,n.groupCount);t<e;t++){const e=r[t].index,{array:s,type:i,length:o}=n.groupAttributes[e][l],a=new i(s.buffer,0,o);h.array.set(a,g),g+=a.length}h.needsUpdate=!0,i=a/h.itemSize}if(e.index){const t=e.index.array;if(t.length<i)e.index=null,s=!0;else for(let e=0,n=t.length;e<n;e++)t[e]=e}let l=0;e.clearGroups();for(let t=0,s=Math.min(r.length,n.groupCount);t<s;t++){const{index:s,materialIndex:i}=r[t],o=n.getCount(s);0!==o&&(e.addGroup(l,o,i),l+=o)}e.setDrawRange(0,i),e.boundsTree=null,s&&e.dispose()}(r,a[n],m),u&&function(t){for(let e=0;e<t.length-1;e++){const n=t[e],r=t[e+1];if(n.materialIndex===r.materialIndex){const s=n.start,i=r.start+r.count;r.start=s,r.count=i-s,t.splice(e,1),e--}}}(r.groups)}),i?s:s[0]}evaluateHierarchy(t,e=new K){t.updateMatrixWorld(!0);const n=(t,e)=>{const r=t.children;for(let t=0,s=r.length;t<s;t++){const s=r[t];s.isOperationGroup?n(s,e):e(s)}},r=t=>{const e=t.children;let s=!1;for(let t=0,n=e.length;t<n;t++){const n=e[t];s=r(n)||s}const i=t.isDirty();if(i&&t.markUpdated(),s&&!t.isOperationGroup){let e;return n(t,n=>{e=e?this.evaluate(e,n,n.operation):this.evaluate(t,n,n.operation)}),t._cachedGeometry=e.geometry,t._cachedMaterials=e.material,!0}return s||i};return r(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}class le extends K{constructor(...t){super(...t),this.isOperation=!0,this.operation=0,this._cachedGeometry=new h,this._cachedMaterials=null,this._previousOperation=null}markUpdated(){super.markUpdated(),this._previousOperation=this.operation}isDirty(){return this.operation!==this._previousOperation||super.isDirty()}insertBefore(t){const e=this.parent,n=e.children.indexOf(this);e.children.splice(n,0,t)}insertAfter(t){const e=this.parent,n=e.children.indexOf(this);e.children.splice(n+1,0,t)}}class ue extends g{constructor(){super(),this.isOperationGroup=!0,this._previousMatrix=new s}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,n=t.elements,r=e.elements;for(let t=0;t<16;t++)if(n[t]!==r[t])return!0;return!1}}class de extends p{get enableGrid(){return Boolean(this._enableGrid)}set enableGrid(t){this._enableGrid!==t&&(this._enableGrid=t,this.needsUpdate=!0)}constructor(...t){super(...t),this.enableGrid=!0}onBeforeCompile(t){!function(t){t.uniforms={...t.uniforms,checkerboardColor:{value:new f(1118481)}},function(t){/varying\s+vec3\s+wPosition/.test(t.vertexShader)||(t.vertexShader=`\n\t\t\tvarying vec3 wPosition;\n\t\t\t${t.vertexShader}\n\t\t`.replace(/#include <displacementmap_vertex>/,t=>`${t}\n\t\t\t\twPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;\n\t\t\t\t`),t.fragmentShader=`\n\t\tvarying vec3 wPosition;\n\t\t${t.fragmentShader}\n\t\t`)}(t),t.defines={CSG_GRID:1},t.fragmentShader=t.fragmentShader.replace(/#include <common>/,t=>`\n\t\t\t${t}\n\n\t\t\tuniform vec3 checkerboardColor;\n\t\t\tfloat getCheckerboard( vec2 p, float scale ) {\n\n\t\t\t\tp /= scale;\n\t\t\t\tp += vec2( 0.5 );\n\n\t\t\t\tvec2 line = mod( p, 2.0 ) - vec2( 1.0 );\n\t\t\t\tline = abs( line );\n\n\t\t\t\tvec2 pWidth = fwidth( line );\n\t\t\t\tvec2 value = smoothstep( 0.5 - pWidth / 2.0, 0.5 + pWidth / 2.0, line );\n\t\t\t\tfloat result = value.x * value.y + ( 1.0 - value.x ) * ( 1.0 - value.y );\n\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\tfloat getGrid( vec2 p, float scale, float thickness ) {\n\n\t\t\t\tp /= 0.5 * scale;\n\n\t\t\t\tvec2 stride = mod( p, 2.0 ) - vec2( 1.0 );\n\t\t\t\tstride = abs( stride );\n\n\t\t\t\tvec2 pWidth = fwidth( p );\n\t\t\t\tvec2 line = smoothstep( 1.0 - pWidth / 2.0, 1.0 + pWidth / 2.0, stride + thickness * pWidth );\n\n\t\t\t\treturn max( line.x, line.y );\n\n\t\t\t}\n\n\t\t\tvec3 getFaceColor( vec2 p, vec3 color ) {\n\n\t\t\t\tfloat checkLarge = getCheckerboard( p, 1.0 );\n\t\t\t\tfloat checkSmall = abs( getCheckerboard( p, 0.1 ) );\n\t\t\t\tfloat lines = getGrid( p, 10.0, 1.0 );\n\n\t\t\t\tvec3 checkColor = mix(\n\t\t\t\t\tvec3( 0.7 ) * color,\n\t\t\t\t\tvec3( 1.0 ) * color,\n\t\t\t\t\tcheckSmall * 0.4 + checkLarge * 0.6\n\t\t\t\t);\n\n\t\t\t\tvec3 gridColor = vec3( 1.0 );\n\n\t\t\t\treturn mix( checkColor, gridColor, lines );\n\n\t\t\t}\n\n\t\t\tfloat angleBetween( vec3 a, vec3 b ) {\n\n\t\t\t\treturn acos( abs( dot( a, b ) ) );\n\n\t\t\t}\n\n\t\t\tvec3 planeProject( vec3 norm, vec3 other ) {\n\n\t\t\t\tfloat d = dot( norm, other );\n\t\t\t\treturn normalize( other - norm * d );\n\n\t\t\t}\n\n\t\t\tvec3 getBlendFactors( vec3 norm ) {\n\n\t\t\t\tvec3 xVec = vec3( 1.0, 0.0, 0.0 );\n\t\t\t\tvec3 yVec = vec3( 0.0, 1.0, 0.0 );\n\t\t\t\tvec3 zVec = vec3( 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 projX = planeProject( xVec, norm );\n\t\t\t\tvec3 projY = planeProject( yVec, norm );\n\t\t\t\tvec3 projZ = planeProject( zVec, norm );\n\n\t\t\t\tfloat xAngle = max(\n\t\t\t\t\tangleBetween( xVec, projY ),\n\t\t\t\t\tangleBetween( xVec, projZ )\n\t\t\t\t);\n\n\t\t\t\tfloat yAngle = max(\n\t\t\t\t\tangleBetween( yVec, projX ),\n\t\t\t\t\tangleBetween( yVec, projZ )\n\t\t\t\t);\n\n\t\t\t\tfloat zAngle = max(\n\t\t\t\t\tangleBetween( zVec, projX ),\n\t\t\t\t\tangleBetween( zVec, projY )\n\t\t\t\t);\n\n\t\t\t\treturn vec3( xAngle, yAngle, zAngle ) / ( 0.5 * PI );\n\n\t\t\t}\n\t\t`).replace(/#include <normal_fragment_maps>/,t=>`${t}\n\t\t\t\t#if CSG_GRID\n\t\t\t\t{\n\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t\t\t\tfloat yCont = abs( dot( vec3( 0.0, 1.0, 0.0 ), worldNormal ) );\n\t\t\t\t\tfloat zCont = abs( dot( vec3( 0.0, 0.0, 1.0 ), worldNormal ) );\n\t\t\t\t\tfloat xCont = abs( dot( vec3( 1.0, 0.0, 0.0 ), worldNormal ) );\n\n\t\t\t\t\tvec3 factors = getBlendFactors( worldNormal );\n\t\t\t\t\tfactors = smoothstep( vec3( 0.475 ), vec3( 0.525 ), vec3( 1.0 ) - factors );\n\n\t\t\t\t\tfloat weight = factors.x + factors.y + factors.z;\n\t\t\t\t\tfactors /= weight;\n\n\t\t\t\t\tvec3 color =\n\t\t\t\t\t\tgetFaceColor( wPosition.yz, diffuseColor.rgb ) * factors.x +\n\t\t\t\t\t\tgetFaceColor( wPosition.xz, diffuseColor.rgb ) * factors.y +\n\t\t\t\t\t\tgetFaceColor( wPosition.xy, diffuseColor.rgb ) * factors.z;\n\n\t\t\t\t\tdiffuseColor.rgb = color;\n\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t`)}(t),t.defines.CSG_GRID=Number(this.enableGrid)}customProgramCacheKey(){return this.enableGrid.toString()}}function he(...t){function e(t){return`new THREE.Vector3( ${t.x}, ${t.y}, ${t.z} )`}return t.map(t=>`\nnew THREE.Triangle(\n\t${e(t.a)},\n\t${e(t.b)},\n\t${e(t.c)},\n)\n\t\t`.trim())}function ge(...t){console.log(he(...t).join(",\n"))}function fe(e){const n=e.attributes.position,r=new Float32Array(3*n.count),s=new f;for(let t=0,e=r.length;t<e;t+=9)s.setHSL(Math.random(),m.lerp(.5,1,Math.random()),m.lerp(.5,.75,Math.random())),r[t+0]=s.r,r[t+1]=s.g,r[t+2]=s.b,r[t+3]=s.r,r[t+4]=s.g,r[t+5]=s.b,r[t+6]=s.r,r[t+7]=s.g,r[t+8]=s.b;e.setAttribute("color",new t(r,3))}class pe extends g{get color(){return this._mesh.material.color}get side(){return this._mesh.material.side}set side(t){this._mesh.material.side=t}constructor(t=[]){super();const e=new h,n=new h;this._mesh=new o(e,new p({flatShading:!0,transparent:!0,opacity:.25,depthWrite:!1})),this._lines=new y(n,new b),this._mesh.material.color=this._lines.material.color,this._lines.frustumCulled=!1,this._mesh.frustumCulled=!1,this.add(this._lines,this._mesh),this.setTriangles(t)}setTriangles(e){const n=new Float32Array(9*e.length),r=new Float32Array(18*e.length);for(let t=0,s=e.length;t<s;t++){const s=9*t,i=18*t,o=e[t];o.a.toArray(n,s+0),o.b.toArray(n,s+3),o.c.toArray(n,s+6),o.a.toArray(r,i+0),o.b.toArray(r,i+3),o.b.toArray(r,i+6),o.c.toArray(r,i+9),o.c.toArray(r,i+12),o.a.toArray(r,i+15)}this._mesh.geometry.dispose(),this._mesh.geometry.setAttribute("position",new t(n,3)),this._lines.geometry.dispose(),this._lines.geometry.setAttribute("position",new t(r,3))}}class me extends y{get color(){return this.material.color}constructor(t=[]){super(),this.frustumCulled=!1,this.setEdges(t)}setEdges(t){const{geometry:e}=this,n=t.flatMap(t=>[t.start,t.end]);e.dispose(),e.setFromPoints(n)}}const ye=new s;class be extends w{get color(){return this.material.color}constructor(t=1e3,e=[]){super(new x(.025),new A,t),this.frustumCulled=!1,this.setPoints(e)}setPoints(t){for(let e=0,n=t.length;e<n;e++){const n=t[e];ye.makeTranslation(n.x,n.y,n.z),this.setMatrixAt(e,ye)}this.count=t.length}}const we=["a","b","c"],xe=new l,Ae=new l,ve=new e,Se=new e,Te=new e,Me=new e,Be=new e,ze=new e,Ee=new e,Ie=new e,Ce=new e,_e=new e,Ge=new e,Ve=new e,Pe=new c,je=new c,ke=new e,Xe=new n,De=new a;function $e(t,e,n){const r=3*e;let s=r+0,i=r+1,o=r+2;const a=t.index,l=t.attributes.position;return a&&(s=a.getX(s),i=a.getX(i),o=a.getX(o)),n.a.fromBufferAttribute(l,s),n.b.fromBufferAttribute(l,i),n.c.fromBufferAttribute(l,o),n}function We(t,e,n,r,s){const i=(e+1)%3,o=t[we[e]],a=t[we[i]],l=(r+1)%3,c=n[we[r]],u=n[we[l]];C(o,a,Xe);let d=Ce.subVectors(o,Xe.origin).dot(Xe.direction),h=Ce.subVectors(a,Xe.origin).dot(Xe.direction);d>h&&([d,h]=[h,d]);let g=Ce.subVectors(c,Xe.origin).dot(Xe.direction),f=Ce.subVectors(u,Xe.origin).dot(Xe.direction);g>f&&([g,f]=[f,g]);const p=Math.max(d,g),m=Math.min(h,f);Xe.at(p,s.start),Xe.at(m,s.end)}class Ne extends me{constructor(t=null,e=null){super(),this.straightEdges=!1,this.displayDisconnectedEdges=!1,t&&e&&this.setHalfEdges(t,e)}setHalfEdges(t,e){const{straightEdges:n,displayDisconnectedEdges:r}=this,s=[],i=t.drawRange.start;let o=P(t);if(t.drawRange.count!==1/0&&(o=~~(t.drawRange.count/3)),r)if(e.unmatchedDisjointEdges)e.unmatchedDisjointEdges.forEach(({forward:t,reverse:e,ray:n})=>{[...t,...e].forEach(({start:t,end:e})=>{const r=new a;n.at(t,r.start),n.at(e,r.end),s.push(r)})});else for(let n=i;n<o;n++){$e(t,n,xe);for(let t=0;t<3;t++)if(-1===e.getSiblingTriangleIndex(n,t)){const e=(t+1)%3,n=xe[we[t]],r=xe[we[e]],i=new a;i.start.copy(n),i.end.copy(r),s.push(i)}}else for(let n=i;n<o;n++){$e(t,n,xe);for(let r=0;r<3;r++){const s=e.getSiblingTriangleIndex(n,r);if(-1===s)continue;$e(t,s,Ae);const i=(r+1)%3,o=xe[we[r]],a=xe[we[i]];ke.lerpVectors(o,a,.5),l(xe,Ae,ke)}if(e.disjointConnections)for(let r=0;r<3;r++){const s=e.getDisjointSiblingTriangleIndices(n,r),i=e.getDisjointSiblingEdgeIndices(n,r);for(let e=0;e<s.length;e++){const n=s[e],o=i[e];$e(t,n,Ae),We(xe,r,Ae,o,De),ke.lerpVectors(De.start,De.end,.5),l(xe,Ae,ke)}}}function l(t,e,r){t.getMidpoint(ve),e.getMidpoint(Se),t.getPlane(Pe),e.getPlane(je);const i=new a;i.start.copy(ve),n?(Pe.projectPoint(Se,Te),je.projectPoint(ve,Me),Be.subVectors(Te,ve),ze.subVectors(Me,Se),Ee.subVectors(r,ve),Ie.subVectors(r,Se),Be.dot(Ee)<0&&Be.multiplyScalar(-1),ze.dot(Ie)<0&&ze.multiplyScalar(-1),Ce.addVectors(ve,Be),_e.addVectors(Se,ze),t.closestPointToPoint(Ce,Ge),e.closestPointToPoint(_e,Ve),i.end.lerpVectors(Ge,Ve,.5)):i.end.copy(r),s.push(i)}super.setEdges(s)}}const Re=new l,Fe=new e,Ue=new e;function Oe(t){let e,n;t.isBufferGeometry?(e=t,n=null):(e=t.geometry,n=Math.abs(t.matrixWorld.determinant()-1)<1e-15?null:t.matrixWorld);const r=e.index,s=e.attributes.position,i=e.drawRange,o=Math.min(P(e),i.count/3);Re.setFromAttributeAndIndices(s,0,1,2),qe(Re,n),Re.getNormal(Fe),Re.getMidpoint(Ue).add(Fe);let a=0;const l=i.start/3;for(let t=l,e=l+o;t<e;t++){let e=3*t+0,i=3*t+1,o=3*t+2;r&&(e=r.getX(e),i=r.getX(i),o=r.getX(o)),Re.setFromAttributeAndIndices(s,e,i,o),qe(Re,n),He(Re,Ue),a+=Le(Re.a,Re.b,Re.c)}return Math.abs(a)}function Le(t,e,n){return 1/6*(-n.x*e.y*t.z+e.x*n.y*t.z+n.x*t.y*e.z-t.x*n.y*e.z-e.x*t.y*n.z+t.x*e.y*n.z)}function He(t,e){t.a.sub(e),t.b.sub(e),t.c.sub(e)}function qe(t,e=null){null!==e&&(t.a.applyMatrix4(e),t.b.applyMatrix4(e),t.c.applyMatrix4(e))}export{mt as ADDITION,K as Brush,xt as DIFFERENCE,me as EdgesHelper,ce as Evaluator,de as GridMaterial,vt as HOLLOW_INTERSECTION,At as HOLLOW_SUBTRACTION,Ne as HalfEdgeHelper,Z as HalfEdgeMap,wt as INTERSECTION,le as Operation,ue as OperationGroup,be as PointsHelper,bt as REVERSE_SUBTRACTION,yt as SUBTRACTION,pe as TriangleSetHelper,ht as TriangleSplitter,Oe as computeMeshVolume,fe as generateRandomTriangleColors,he as getTriangleDefinitions,ge as logTriangleDefinitions};export default null;