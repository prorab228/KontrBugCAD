class BooleanOperations{constructor(o){if(this.editor=o,"undefined"==typeof THREE||"undefined"==typeof THREE_BVH_CSG)return console.error("three-bvh-csg не загружена"),void this.showError("Библиотека three-bvh-csg не загружена");this.OPS=THREE_BVH_CSG,this.evaluator=new THREE_BVH_CSG.Evaluator,console.log("BooleanOperations (three-bvh-csg) инициализирован")}prepareObjectForCSG(o){if(!o||!o.geometry)return console.error("Объект не содержит geometry"),null;const t=o.clone(),e=this.repairGeometry(t.geometry),r=new THREE_BVH_CSG.Brush(e,t.material);return r.position.copy(o.position),r.rotation.copy(o.rotation),r.scale.copy(o.scale),r.updateMatrixWorld(),console.log(`Brush создан для объекта ${o.uuid}:`),console.log(`  Позиция: (${r.position.x}, ${r.position.y}, ${r.position.z})`),console.log(`  Вращение: (${r.rotation.x}, ${r.rotation.y}, ${r.rotation.z})`),r}performOperation(o,t){if(!o||o.length<2)return this.showError("Для операции нужно минимум 2 объекта"),null;console.log(`=== Выполнение операции ${t} ===`),console.log(`Количество объектов: ${o.length}`),o.forEach((o,t)=>{console.log(`  Объект ${t}: ${o.userData?.name||o.uuid}, позиция: (${o.position.x}, ${o.position.y}, ${o.position.z})`)});const e=o.map(o=>this.prepareObjectForCSG(o)).filter(o=>o);if(e.length<2)return this.showError("Не удалось подготовить объекты для операции"),null;try{let r,n=e[0];console.log(`Начальный brush позиция: (${n.position.x}, ${n.position.y}, ${n.position.z})`);for(let o=1;o<e.length;o++)console.log(`Объединение с brush ${o}: позиция (${e[o].position.x}, ${e[o].position.y}, ${e[o].position.z})`),n=this.evaluator.evaluate(n,e[o],t),console.log(`Результат после шага ${o}: позиция brush (${n.position.x}, ${n.position.y}, ${n.position.z})`);o[0]&&o[0].material?(r=o[0].material.clone(),r.emissive=new THREE.Color(0),r.emissiveIntensity=0,r.transparent=!1,r.opacity=1,r.wireframe=!1):r=new THREE.MeshStandardMaterial({color:8421504,side:THREE.FrontSide,transparent:!1,wireframe:!1});const i=new THREE.Mesh(n.geometry,r);i.geometry.computeBoundingBox();const s=i.geometry.boundingBox,a=new THREE.Vector3;s.getCenter(a),console.log(`Центр геометрии resultBrush: (${a.x}, ${a.y}, ${a.z})`),i.geometry.translate(-a.x,-a.y,-a.z),i.position.copy(a),i.rotation.set(0,0,0),i.scale.set(1,1,1),i.updateMatrixWorld(!0),console.log(`Итоговая позиция меша: (${i.position.x}, ${i.position.y}, ${i.position.z})`);const l=(new THREE.Box3).setFromObject(i),u=new THREE.Vector3;return l.getCenter(u),console.log(`Финальный центр меша в мировых координатах: (${u.x}, ${u.y}, ${u.z})`),i.castShadow=!0,i.receiveShadow=!0,i.userData={id:"csg_"+Date.now(),name:this.getOperationName(t),type:"boolean",operation:t,sourceObjects:o.map(o=>o.uuid),createdAt:(new Date).toISOString(),debug:{originalGeometryCenter:a.toArray(),finalPosition:i.position.toArray()}},i}catch(o){return console.error(`Ошибка операции ${t}:`,o),this.showError(`Ошибка ${this.getOperationName(t)}: ${o.message}`),null}}unionMultiple(o){return this.performOperation(o,this.OPS.ADDITION)}subtract(o,t){return this.performOperation([o,t],this.OPS.SUBTRACTION)}intersect(o,t){return this.performOperation([o,t],this.OPS.INTERSECTION)}canPerformOperation(o){return!o||o.length<2?{can:!1,reason:"Нужно минимум 2 объекта"}:{can:!0,reason:""}}repairGeometry(o){const t=o.clone();if(t.attributes.normal&&0!==t.attributes.normal.count||(t.computeVertexNormals(),console.log("Ремонт: атрибут normal вычислен.")),!t.attributes.uv||0===t.attributes.uv.count){const o=t.attributes.position.count,e=new Float32Array(2*o);for(let r=0;r<o;r++){const o=t.attributes.position.getX(r),n=t.attributes.position.getY(r);t.attributes.position.getZ(r);e[2*r]=.5*(o+1),e[2*r+1]=.5*(n+1)}t.setAttribute("uv",new THREE.BufferAttribute(e,2)),console.log("Ремонт: атрибут uv создан.")}if(!t.attributes.position||0===t.attributes.position.count)throw new Error("Геометрия не содержит атрибута position. Ремонт невозможен.");return t.index||console.warn("Ремонт: у геометрии нет индексов. Возможны проблемы."),t}getOperationStats(o){if(!o||!o.geometry)return null;const t=o.geometry;let e=0,r=0;t.attributes.position&&(e=t.attributes.position.count),t.index?r=t.index.count/3:t.attributes.position&&(r=t.attributes.position.count/3),t.computeBoundingBox();const n=t.boundingBox,i=n?(new THREE.Vector3).subVectors(n.max,n.min):new THREE.Vector3,s=i.x*i.y*i.z;return{vertices:e,faces:r,volume:s,volumeMM3:s,bbox:n,size:i}}getOperationName(o){return{union:"Объединение",subtract:"Вычитание",intersect:"Пересечение"}[o]||o}showError(o){this.editor&&this.editor.showStatus?this.editor.showStatus(o,"error"):console.error("BooleanOperations Error:",o)}showWarning(o){this.editor&&this.editor.showStatus?this.editor.showStatus(o,"warning"):console.warn("BooleanOperations Warning:",o)}}