class FontManager{constructor(t){this.editor=t,this.fonts={},this.fontData={},this.loadingPromises={},this.availableFonts=[{name:"Roboto",file:"fonts/Roboto_Regular.json"},{name:"Arial",file:"fonts/helvetiker_regular.typeface.json"},{name:"Bold",file:"fonts/helvetiker_bold.typeface.json"},{name:"Optima",file:"fonts/optimer_regular.typeface.json"}],this.ttfConverter=new TTFConverter,this.init()}init(){this.loadStandardFonts(),this.loadCustomFonts()}async loadStandardFonts(){const t=new THREE.FontLoader;for(const o of this.availableFonts)this.loadingPromises[o.name]=new Promise((n,s)=>{fetch(o.file).then(t=>{if(!t.ok)throw new Error(`HTTP ${t.status}`);return t.json()}).then(s=>{this.fontData[o.name]=s;const e=t.parse(s);this.fonts[o.name]=e,console.log(`Шрифт ${o.name} загружен`),n(e)}).catch(t=>{console.error(`Ошибка загрузки шрифта ${o.name}:`,t),s(t)})})}loadCustomFonts(){const t=this.ttfConverter.loadFontsFromLocalStorage(),o=new THREE.FontLoader;for(const[n,s]of Object.entries(t))try{const t=o.parse(s);this.fonts[n]=t,this.fontData[n]=s,console.log(`Кастомный шрифт ${n} загружен из localStorage`)}catch(t){console.error(`Ошибка загрузки кастомного шрифта ${n}:`,t)}}async waitForFont(t){if(!this.fonts[t]){if(!this.loadingPromises[t])throw new Error(`Шрифт ${t} не найден и не загружается`);await this.loadingPromises[t]}}async waitForFonts(t){const o=[...new Set(t)];await Promise.all(o.map(t=>this.waitForFont(t).catch(t=>console.warn(t))))}addCustomFont(t,o){const n=(new THREE.FontLoader).parse(o);this.fonts[t]=n,this.fontData[t]=o,this.ttfConverter.saveFontToLocalStorage(t,o)}getFontData(t){return this.fontData[t]||null}}