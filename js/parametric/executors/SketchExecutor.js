class SketchExecutor extends ParametricExecutor{execute(e,t){const{planeId:s,elements:a}=e.parameters,n=t.objectMap.get(s);if(!n)throw new Error(`Sketch: плоскость ${s} не найдена`);const r=[];n.children.forEach(e=>{e.userData&&"sketch_element"===e.userData.type&&r.push(e)}),r.forEach(e=>{n.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()});const o=[];for(const e of a){const t=this.createSketchElement(e,n);t&&(n.add(t),o.push(t))}return n.userData.hasSketch=o.length>0,n.userData.sketchElementsCount=o.length,n.userData.sketchElements=a,null}createSketchElement(e,t){const{type:s,points:a,color:n,closed:r,dashed:o,dashSize:c,gapSize:i}=e,l=[];a.forEach(e=>l.push(e[0],e[1],.01));const h=new THREE.BufferGeometry;let E,u;return h.setAttribute("position",new THREE.Float32BufferAttribute(l,3)),E=o?new THREE.LineDashedMaterial({color:n,dashSize:c,gapSize:i,linewidth:2}):new THREE.LineBasicMaterial({color:n,linewidth:2}),u=r?new THREE.LineLoop(h,E):new THREE.Line(h,E),u.userData={type:"sketch_element",elementType:s,points:a.map(e=>new THREE.Vector3(e[0],e[1],0)),closed:r,dashed:o,originalColor:n,sketchPlaneId:t.uuid},o&&u.computeLineDistances(),u}}