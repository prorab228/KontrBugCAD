class ExtrudeExecutor extends ParametricExecutor{execute(e,t){const{figures:o,height:r,direction:n,operationType:u,color:s=5025616,planeId:a}=e.parameters,i=e.inputs||[],p=t.objectMap.get(a)||this.findPlaneById(a,t.editor);if(!p)throw new Error(`Extrude: плоскость ${a} не найдена`);const c=this._createGeometry(o,r,n,"new"!==u);if(!c)throw new Error("Extrude: не удалось создать геометрию");const l=new THREE.Mesh(c,new THREE.MeshStandardMaterial({color:s}));if(l.position.copy(p.position),l.quaternion.copy(p.quaternion),l.castShadow=!0,l.receiveShadow=!0,l.userData={type:"extrude",sourceFigures:o,height:r,direction:n,operationType:u,planeId:a},"new"===u)return e.outputs.length>0?l.uuid=e.outputs[0]:e.outputs=[l.uuid],l;if(!t.editor.booleanOps)throw new Error("Extrude: булевы операции не доступны");const d=i.map(e=>t.objectMap.get(e)).filter(Boolean);if(0===d.length)throw new Error("Extrude: не найдены целевые объекты");let h;if("cut"===u?h=t.editor.booleanOps.subtract(d[0],l):"join"===u&&(h=t.editor.booleanOps.unionMultiple([l,...d])),!h)throw new Error(`Extrude: не удалось выполнить ${u}`);return d.forEach(e=>{t.objectMap.delete(e.uuid),t.sceneGroup.remove(e)}),h.userData={...h.userData,type:"extrude_boolean",operationType:u},e.outputs.length>0?h.uuid=e.outputs[0]:e.outputs=[h.uuid],h}_createGeometry(e,t,o,r){const n=[];for(const t of e){const e=[];for(let o=0;o<t.outer.length;o+=2)e.push(new THREE.Vector2(t.outer[o],t.outer[o+1]));const o=new THREE.Shape(e);if(t.holes)for(const e of t.holes){const t=[];for(let o=0;o<e.length;o+=2)t.push(new THREE.Vector2(e[o],e[o+1]));const r=new THREE.Path(t);o.holes.push(r)}n.push(o)}let u=t;r&&(u+=.01);const s=new THREE.ExtrudeGeometry(n,{depth:u,bevelEnabled:!1,steps:1});return r&&("positive"===o?s.translate(0,0,-.01):"both"===o?s.translate(0,0,-u/2):"negative"===o&&s.translate(0,0,-u)),s}findPlaneById(e,t){let o=null;return t.scene.traverse(t=>{t.uuid===e&&t.userData?.type?.includes("plane")&&(o=t)}),o}}