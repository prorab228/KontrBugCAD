class FilletChamferExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e,this.tolerance=1e-4}execute(e,o){const{targetId:t,type:r,distance:n,angle:a,edges:i}=e.parameters,s=o.objectMap.get(t);if(!s)throw new Error(`FilletChamfer: объект ${t} не найден`);console.log("Выполнение фаски для объекта",s.uuid,s.position,s.rotation,s.scale);const l=s.geometry.clone();l.applyMatrix4(s.matrixWorld);const c=this.findEdges(l,i,s.matrixWorld);if(0===c.length)throw new Error("Не найдены выбранные рёбра в текущей геометрии");const u=[];for(const e of c){const o=this.buildChamferTool(e,n,a);o&&o.geometry.index.count>=3&&u.push(o)}if(0===u.length)throw new Error("Не удалось построить инструменты");let d;if(1===u.length?d=u[0]:(d=this.editor.booleanOps.unionMultiple(u,!1),u.forEach(e=>this.disposeMesh(e))),!d||!d.geometry||d.geometry.index.count<3)throw new Error("Инструмент не содержит треугольников");console.log(`toolMesh имеет ${d.geometry.index.count/3} треугольников`);const f=this.editor.booleanOps.subtract(s,d,!1);if(!f)throw new Error("Булева операция не дала результата");const m=(new THREE.Matrix4).copy(s.matrixWorld).invert(),p=f.geometry,E=p.attributes.position,h=E.array;for(let e=0;e<h.length;e+=3){const o=new THREE.Vector3(h[e],h[e+1],h[e+2]);o.applyMatrix4(m),h[e]=o.x,h[e+1]=o.y,h[e+2]=o.z}return E.needsUpdate=!0,p.computeBoundingBox(),p.computeVertexNormals(),f.position.copy(s.position),f.rotation.copy(s.rotation),f.scale.copy(s.scale),f.updateMatrixWorld(),f.userData={...JSON.parse(JSON.stringify(s.userData||{})),modifiedBy:"filletChamfer",operationParams:{type:r,distance:n,angle:a,edges:i}},o.objectMap.delete(t),o.sceneGroup.remove(s),this.disposeMesh(s),e.outputs.length>0?f.uuid=e.outputs[0]:e.outputs=[f.uuid],f}findEdges(e,o,t){const r=e.attributes.position,n=e.index;if(!n)return[];console.log("Поиск рёбер с допуском 2");const a=[];for(const i of o){const o=new THREE.Vector3(i.v1[0],i.v1[1],i.v1[2]),s=new THREE.Vector3(i.v2[0],i.v2[1],i.v2[2]),l=o.clone().applyMatrix4(t),c=s.clone().applyMatrix4(t);console.log(`Поиск ребра (лок: ${o.toArray().map(e=>e.toFixed(2))} - ${s.toArray().map(e=>e.toFixed(2))}) -> (мир: ${l.toArray().map(e=>e.toFixed(2))} - ${c.toArray().map(e=>e.toFixed(2))})`);let u=-1,d=-1,f=1/0,m=1/0;for(let e=0;e<r.count;e++){const o=(new THREE.Vector3).fromBufferAttribute(r,e),t=o.distanceTo(l);t<f&&(f=t,u=e);const n=o.distanceTo(c);n<m&&(m=n,d=e)}if(console.log(`  Ближайшая к v1: индекс ${u}, расстояние ${f.toFixed(4)}`),console.log(`  Ближайшая к v2: индекс ${d}, расстояние ${m.toFixed(4)}`),-1===u||-1===d||u===d)continue;if(f>2||m>2){console.warn(`  → Превышен допуск (${f.toFixed(4)} / ${m.toFixed(4)})`);continue}let p=!1;for(let e=0;e<n.count;e+=3){const o=n.array[e],t=n.array[e+1],r=n.array[e+2];if(o===u&&(t===d||r===d)||t===u&&(o===d||r===d)||r===u&&(o===d||t===d)){p=!0;break}}if(!p){console.warn("  → Индексы не образуют ребро (не в одном треугольнике)");continue}const E=(new THREE.Vector3).fromBufferAttribute(r,u),h=(new THREE.Vector3).fromBufferAttribute(r,d);console.log(`  → Найдено совпадение: (${E.toArray().map(e=>e.toFixed(2))} - ${h.toArray().map(e=>e.toFixed(2))})`);const y=this.getEdgeNormals(e,E,h);a.push({v1:E,v2:h,normals:y,convex:!0})}return a}getEdgeNormals(e,o,t){const r=e.attributes.position,n=e.index,a=this.tolerance,i=[];for(let e=0;e<n.count;e+=3){const s=n.array[e],l=n.array[e+1],c=n.array[e+2],u=(new THREE.Vector3).fromBufferAttribute(r,s),d=(new THREE.Vector3).fromBufferAttribute(r,l),f=(new THREE.Vector3).fromBufferAttribute(r,c),m=u.distanceTo(o)<a||d.distanceTo(o)<a||f.distanceTo(o)<a,p=u.distanceTo(t)<a||d.distanceTo(t)<a||f.distanceTo(t)<a;if(m&&p){const e=d.clone().sub(u),o=f.clone().sub(u),t=(new THREE.Vector3).crossVectors(e,o).normalize();isNaN(t.x)||i.push(t)}}return i}buildChamferTool(e,o,t){const{v1:r,v2:n,normals:a}=e;if(a.length<2)return console.warn("buildChamferTool: недостаточно нормалей"),null;const i=THREE.MathUtils.degToRad(t),s=o/Math.tan(i);if(Math.abs(s)<1e-6)return console.warn("buildChamferTool: offset слишком мал"),null;const l=a[0].clone().normalize(),c=a[1].clone().normalize(),u=l.dot(c);if(Math.abs(u)>.999)return console.warn("buildChamferTool: нормали почти коллинеарны"),null;const d=r.clone(),f=n.clone(),m=d.clone().addScaledVector(l,1*s),p=d.clone().addScaledVector(c,1*s),E=f.clone().addScaledVector(l,1*s),h=f.clone().addScaledVector(c,1*s),y=new THREE.Triangle(d,m,p).getArea(),x=new THREE.Triangle(f,E,h).getArea();if(y<1e-6||x<1e-6)return console.warn("buildChamferTool: вырожденный треугольник"),null;const g=[d.x,d.y,d.z,m.x,m.y,m.z,p.x,p.y,p.z,f.x,f.y,f.z,E.x,E.y,E.z,h.x,h.y,h.z],T=new THREE.BufferGeometry;return T.setAttribute("position",new THREE.Float32BufferAttribute(g,3)),T.setIndex([0,1,2,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),T.computeVertexNormals(),T.index.count<3?(console.warn("buildChamferTool: нет треугольников"),null):new THREE.Mesh(T,new THREE.MeshBasicMaterial)}disposeMesh(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}