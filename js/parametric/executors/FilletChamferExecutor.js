class FilletChamferExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e,this.tolerance=1e-4}execute(e,t){const{targetId:o,type:r,distance:n,angle:s,edges:a,operationType:i}=e.parameters,l=t.objectMap.get(o);if(!l)throw new Error(`FilletChamfer: объект ${o} не найден`);console.log("Выполнение фаски для объекта",l.uuid,l.position,l.rotation,l.scale),console.log("Тип операции:",i);const c=l.geometry.clone();c.computeBoundingBox();const d=c.boundingBox,u=new THREE.Vector3;d.getCenter(u),console.log("Центр геометрии (лок):",u);const f=this.findEdges(c,a);if(0===f.length)throw new Error("Не найдены выбранные рёбра в текущей геометрии");const p=[],h=[];for(const e of f){const t=this.buildChamferTool(e,n,s,u);t&&t.geometry.index.count>=3?(p.push(t),h.push(e)):console.warn("Не удалось построить инструмент для ребра",e)}if(0===p.length)throw new Error("Не удалось построить инструменты");let E;if(this.snapVerticesByTopology(p,h),1===p.length?E=p[0]:(E=this.editor.booleanOps.unionMultiple(p,!1),p.forEach(e=>this.disposeMesh(e))),!E||!E.geometry||E.geometry.index.count<3)throw new Error("Инструмент не содержит треугольников");const g=new THREE.MeshPhongMaterial({color:16711935,transparent:!0,opacity:.3,side:THREE.DoubleSide}),m=E.clone();let y;if(m.material=g,this.editor.scene.add(m),setTimeout(()=>this.editor.scene.remove(m),5e3),E.position.copy(l.position),E.rotation.copy(l.rotation),E.scale.copy(l.scale),E.updateMatrixWorld(),y=this.editor.booleanOps.subtract(l,E,!1),!y)throw new Error("Булева операция не дала результата");const x=(new THREE.Matrix4).copy(l.matrixWorld).invert(),T=y.geometry,$=T.attributes.position,w=$.array;for(let e=0;e<w.length;e+=3){const t=new THREE.Vector3(w[e],w[e+1],w[e+2]);t.applyMatrix4(x),w[e]=t.x,w[e+1]=t.y,w[e+2]=t.z}if($.needsUpdate=!0,THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeVertices){const e=THREE.BufferGeometryUtils.mergeVertices(T,.01);y.geometry=e}const b=this.keepLargestComponent(y.geometry);if(b!==y.geometry){const e=y.geometry;y.geometry=b,e.dispose()}T.computeBoundingBox(),T.computeVertexNormals(),y.position.copy(l.position),y.rotation.copy(l.rotation),y.scale.copy(l.scale),y.updateMatrixWorld();let V=l.material;return l.userData&&l.userData.originalMaterial&&(V=l.userData.originalMaterial),V&&"function"==typeof V.clone?y.material=V.clone():y.material=new THREE.MeshStandardMaterial({color:8421504,side:THREE.FrontSide,flatShading:!0}),y.material.flatShading=!0,y.userData={...JSON.parse(JSON.stringify(l.userData||{})),modifiedBy:"filletChamfer",originalMaterial:y.material,operationParams:{type:r,distance:n,angle:s,edges:a,operationType:i}},t.objectMap.delete(o),t.sceneGroup.remove(l),this.disposeMesh(l),e.outputs.length>0?y.uuid=e.outputs[0]:e.outputs=[y.uuid],y}snapVerticesByTopology(e,t){if(e.length!==t.length)return void console.warn("snapVerticesByTopology: несовпадение длины массивов");if(e.length<2)return;console.log("=== snapVerticesByTopology ==="),console.log("Инструментов:",e.length);const o=[],r=[];e.forEach((e,n)=>{const s=t[n];if(!s||!s.v1||!s.v2)return void console.warn(`edgeData[${n}] не содержит v1/v2`,s);const a=e.geometry.attributes.position,i=(new THREE.Vector3).fromBufferAttribute(a,0);o.push({toolIdx:n,vertIdx:0,pos:i.clone(),key:`${s.v1.x.toFixed(6)},${s.v1.y.toFixed(6)},${s.v1.z.toFixed(6)}`});const l=(new THREE.Vector3).fromBufferAttribute(a,3);r.push({toolIdx:n,vertIdx:3,pos:l.clone(),key:`${s.v2.x.toFixed(6)},${s.v2.y.toFixed(6)},${s.v2.z.toFixed(6)}`})});const n=(e,t)=>{const o=new Map;return e.forEach(e=>{o.has(e.key)||o.set(e.key,[]),o.get(e.key).push(e)}),console.log(`${t}: уникальных ключей = ${o.size}`),o.forEach((e,t)=>{if(console.log(`  Ключ ${t}: ${e.length} вершин, индексы инструментов: ${e.map(e=>e.toolIdx).join(", ")}`),e.length>1){let t=0,o=1/0,r=0,n=0;for(let s=0;s<e.length;s++)for(let a=s+1;a<e.length;a++){const i=e[s].pos.distanceTo(e[a].pos);t=Math.max(t,i),o=Math.min(o,i),r+=i,n++}const s=n>0?r/n:0;console.log(`    Расстояния: мин=${o.toFixed(6)}, макс=${t.toFixed(6)}, ср=${s.toFixed(6)}`)}}),o},s=n(o,"Группы A"),a=n(r,"Группы B"),i=t=>{if(t.length<2)return;const o=new THREE.Vector3;t.forEach(e=>o.add(e.pos)),o.divideScalar(t.length),t.forEach(t=>{e[t.toolIdx].geometry.attributes.position.setXYZ(t.vertIdx,o.x,o.y,o.z)})};s.forEach(e=>i(e)),a.forEach(e=>i(e));const l=(t,o,r)=>{t.forEach((t,n)=>{o.forEach(o=>{const s=[];if(t.forEach(t=>{const r=e[t.toolIdx].geometry.attributes.position,n=(new THREE.Vector3).fromBufferAttribute(r,o);s.push({toolIdx:t.toolIdx,vertIdx:o,pos:n.clone()})}),s.length<2)return;console.log(`${r} для ключа ${n}, вершина ${o}: ${s.length} вершин`);let a=0,i=1/0,l=0,c=0;for(let e=0;e<s.length;e++)for(let t=e+1;t<s.length;t++){const o=s[e].pos.distanceTo(s[t].pos);a=Math.max(a,o),i=Math.min(i,o),l+=o,c++}if(c>0){const e=l/c;console.log(`    Расстояния: мин=${i.toFixed(6)}, макс=${a.toFixed(6)}, ср=${e.toFixed(6)}`)}const d=new THREE.Vector3;s.forEach(e=>d.add(e.pos)),d.divideScalar(s.length),s.forEach(t=>{e[t.toolIdx].geometry.attributes.position.setXYZ(t.vertIdx,d.x,d.y,d.z)})})})};l(s,[1,2],"A1/A2"),l(a,[4,5],"B1/B2"),e.forEach(e=>{e.geometry.attributes.position.needsUpdate=!0,e.geometry.computeVertexNormals()}),console.log("=== snapVerticesByTopology завершён ===")}keepLargestComponent(e){const t=e.index;if(!t)return e;const o=t.array,r=(e.attributes.position,o.length/3),n=new Map;for(let e=0;e<o.length;e+=3){const t=e/3,r=o[e],s=o[e+1],a=o[e+2];[r<s?`${r}|${s}`:`${s}|${r}`,s<a?`${s}|${a}`:`${a}|${s}`,a<r?`${a}|${r}`:`${r}|${a}`].forEach(e=>{n.has(e)||n.set(e,[]),n.get(e).push(t)})}const s=new Array(r).fill(!1),a=[];for(let e=0;e<r;e++){if(s[e])continue;const t=[e];s[e]=!0;const r=[];for(;t.length;){const e=t.pop();r.push(e);const a=3*e,i=o[a],l=o[a+1],c=o[a+2];[i<l?`${i}|${l}`:`${l}|${i}`,l<c?`${l}|${c}`:`${c}|${l}`,c<i?`${c}|${i}`:`${i}|${c}`].forEach(e=>{(n.get(e)||[]).forEach(e=>{s[e]||(s[e]=!0,t.push(e))})})}a.push(r)}let i=[];if(a.forEach(e=>{e.length>i.length&&(i=e)}),i.length===r)return e;const l=[];i.forEach(e=>{const t=3*e;l.push(o[t],o[t+1],o[t+2])});const c=new THREE.BufferGeometry;for(const t in e.attributes)c.setAttribute(t,e.attributes[t].clone());return c.setIndex(l),c.computeVertexNormals(),c}findEdges(e,t){const o=e.attributes.position;if(!e.index)return[];console.log("Поиск рёбер с допуском 0.1");const r=[];for(const n of t){const t=new THREE.Vector3(n.v1[0],n.v1[1],n.v1[2]),s=new THREE.Vector3(n.v2[0],n.v2[1],n.v2[2]);console.log(`Поиск ребра (лок: ${t.toArray().map(e=>e.toFixed(2))} - ${s.toArray().map(e=>e.toFixed(2))})`);let a=-1,i=-1,l=1/0,c=1/0;for(let e=0;e<o.count;e++){const r=(new THREE.Vector3).fromBufferAttribute(o,e),n=r.distanceTo(t);n<l&&(l=n,a=e);const d=r.distanceTo(s);d<c&&(c=d,i=e)}if(console.log(`  Ближайшая к v1: индекс ${a}, расстояние ${l.toFixed(4)}`),console.log(`  Ближайшая к v2: индекс ${i}, расстояние ${c.toFixed(4)}`),-1===a||-1===i||a===i)continue;if(l>.1||c>.1){console.warn(`  → Превышен допуск (${l.toFixed(4)} / ${c.toFixed(4)})`);continue}const d=(new THREE.Vector3).fromBufferAttribute(o,a),u=(new THREE.Vector3).fromBufferAttribute(o,i);console.log(`  → Найдено совпадение: (${d.toArray().map(e=>e.toFixed(2))} - ${u.toArray().map(e=>e.toFixed(2))})`);const f=this.getEdgeNormalsAndCenters(e,d,u);r.push({v1:d,v2:u,normalsAndCenters:f})}return r}getEdgeNormalsAndCenters(e,t,o){const r=e.attributes.position,n=e.index,s=this.tolerance,a=[];for(let e=0;e<n.count;e+=3){const i=n.array[e],l=n.array[e+1],c=n.array[e+2],d=(new THREE.Vector3).fromBufferAttribute(r,i),u=(new THREE.Vector3).fromBufferAttribute(r,l),f=(new THREE.Vector3).fromBufferAttribute(r,c),p=d.distanceTo(t)<s||u.distanceTo(t)<s||f.distanceTo(t)<s,h=d.distanceTo(o)<s||u.distanceTo(o)<s||f.distanceTo(o)<s;if(p&&h){const e=u.clone().sub(d),t=f.clone().sub(d),o=(new THREE.Vector3).crossVectors(e,t).normalize();if(!isNaN(o.x)){const e=d.clone().add(u).add(f).multiplyScalar(1/3);a.push({normal:o,center:e})}}}return a}buildChamferTool(e,t,o,r){const{v1:n,v2:s,normalsAndCenters:a}=e;if(!a||a.length<2)return console.warn("buildChamferTool: недостаточно данных"),null;const i=THREE.MathUtils.degToRad(o),l=t/Math.tan(i);if(Math.abs(l)<1e-6)return console.warn("buildChamferTool: offset слишком мал"),null;const c=1.2*l,d=a[0].normal.clone().normalize(),u=a[1].normal.clone().normalize(),f=a[0].center,p=a[1].center,h=n.clone().add(s).multiplyScalar(.5),E=f.clone().add(p).multiplyScalar(.5).clone().sub(h).normalize(),g=d.clone().add(u).normalize().dot(E)>0?1:-1,m=n.clone(),y=s.clone(),x=m.clone().addScaledVector(d,g*c),T=m.clone().addScaledVector(u,g*c),$=y.clone().addScaledVector(d,g*c),w=y.clone().addScaledVector(u,g*c),b=new THREE.Triangle(m,x,T).getArea(),V=new THREE.Triangle(y,$,w).getArea();if(b<1e-6||V<1e-6)return console.warn("buildChamferTool: вырожденный треугольник"),null;const R=[m.x,m.y,m.z,x.x,x.y,x.z,T.x,T.y,T.z,y.x,y.y,y.z,$.x,$.y,$.z,w.x,w.y,w.z],H=new THREE.BufferGeometry;H.setAttribute("position",new THREE.Float32BufferAttribute(R,3)),H.setIndex([0,1,2,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),H.computeVertexNormals();const v=new THREE.Vector3;for(let e=0;e<R.length;e+=3)v.x+=R[e],v.y+=R[e+1],v.z+=R[e+2];v.divideScalar(6);const B=H.index.array,A=H.attributes.position,M=[];for(let e=0;e<B.length;e+=3){const t=B[e],o=B[e+1],r=B[e+2],n=(new THREE.Vector3).fromBufferAttribute(A,t),s=(new THREE.Vector3).fromBufferAttribute(A,o),a=(new THREE.Vector3).fromBufferAttribute(A,r),i=(new THREE.Vector3).addVectors(n,s).add(a).multiplyScalar(1/3),l=v.clone().sub(i);(new THREE.Vector3).crossVectors(s.clone().sub(n),a.clone().sub(n)).normalize().dot(l)<0?M.push(t,o,r):M.push(r,o,t)}return H.setIndex(M),H.computeVertexNormals(),H.index.count<3?(console.warn("buildChamferTool: нет треугольников"),null):new THREE.Mesh(H,new THREE.MeshBasicMaterial)}disposeMesh(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}