class RepairExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e}execute(e,t){const{targets:o,fixOpenEdges:r=!0,removeIsolated:a=!0,removeSmallComponents:n=!1,createUVs:s=!0,repairStrategy:i="balanced",fallbackToConvexHull:l=!1}=e.parameters,c=[];for(const e of o){const o=t.objectMap.get(e);if(o&&o.isMesh)try{const p=this.repairObject(o,{fixOpenEdges:r,removeIsolated:a,removeSmallComponents:n,createUVs:s,repairStrategy:i,fallbackToConvexHull:l});p&&(t.objectMap.delete(e),t.sceneGroup.remove(o),this.disposeObject(o),c.push(p))}catch(t){throw console.error(`Repair: ошибка при ремонте объекта ${e}:`,t),t}}return c}repairObject(e,t){if(!window.geometryRepair)throw new Error("GeometryRepair не загружен");const o=e.geometry.clone();o.applyMatrix4(e.matrixWorld);const r={mergeDistance:1e-4,removeDegenerate:!0,removeDuplicates:!0,removeIsolated:t.removeIsolated,removeSmallComponents:t.removeSmallComponents,minComponentSize:10,closeHoles:t.fixOpenEdges&&"fast"!==t.repairStrategy,fixNormals:!0,checkInfinity:!0,verbose:!0,maxIterations:"fast"===t.repairStrategy?1:3};let a=window.geometryRepair.repair(o,r);if("guaranteed"===t.repairStrategy&&t.fallbackToConvexHull&&window.booleanOps&&window.booleanOps.isReady)try{const e=window.booleanOps._threeGeometryToManifold(a);if(0!==e.status()){console.warn("Результат ремонта не манифолден, применяем convex hull");const e=this._createConvexHull(a);e&&(a=e)}e.delete?.()}catch(e){console.warn("Ошибка проверки manifold, применяем convex hull",e);const t=this._createConvexHull(a);t&&(a=t)}t.createUVs&&!a.attributes.uv&&this._createSimpleUVs(a);const n=this._cloneMaterial(e.material),s=new THREE.Mesh(a,n);return s.position.set(0,0,0),s.rotation.set(0,0,0),s.scale.set(1,1,1),s.castShadow=e.castShadow,s.receiveShadow=e.receiveShadow,s.visible=e.visible,s.name=`repaired_${e.name||e.uuid}`,s.userData={...JSON.parse(JSON.stringify(e.userData||{})),repaired:!0,repairedAt:(new Date).toISOString(),originalId:e.uuid},s}_createConvexHull(e){if(!window.booleanOps||!window.booleanOps.manifold)return null;const{manifold:t}=window.booleanOps;try{const o=e.attributes.position.array,r=[];for(let e=0;e<o.length;e+=3)r.push([o[e],o[e+1],o[e+2]]);const a=t.Manifold.hull(r),n=window.booleanOps._manifoldToThreeGeometry(a);return a.delete(),n}catch(e){return console.warn("Convex hull failed:",e),null}}_createSimpleUVs(e){const t=e.attributes.position,o=t.count,r=new Float32Array(2*o);e.computeBoundingBox();const a=e.boundingBox,n=new THREE.Vector3;a.getCenter(n);for(let e=0;e<o;e++){const o=t.getX(e)-n.x,a=t.getY(e)-n.y,s=t.getZ(e)-n.z,i=Math.sqrt(o*o+a*a+s*s);if(i<.001)r[2*e]=.5,r[2*e+1]=.5;else{const t=Math.atan2(s,o),n=Math.acos(a/i);r[2*e]=(t+Math.PI)/(2*Math.PI),r[2*e+1]=n/Math.PI}}e.setAttribute("uv",new THREE.BufferAttribute(r,2))}_cloneMaterial(e){return e?Array.isArray(e)?e.map(e=>this._cloneMaterial(e)):"function"==typeof e.clone?e.clone():new THREE.MeshStandardMaterial({color:8421504}):new THREE.MeshStandardMaterial({color:8421504})}disposeObject(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}