class BooleanOperations{constructor(e){if(this.editor=e,"undefined"==typeof THREE||"undefined"==typeof ThreeCSG)return console.error("three-csg-ts не загружена"),void this.showError("Библиотека three-csg-ts не загружена. Подключите https://unpkg.com/three-csg-ts@1.0.0/dist/three-csg-ts.js");console.log("BooleanOperations (three-csg-ts) инициализирован")}prepareObjectForCSG(e){if(!e||!e.geometry)return console.error("Объект не содержит geometry"),null;const t=e.clone();return t.geometry.attributes.normal&&0!==t.geometry.attributes.normal.count||t.geometry.computeVertexNormals(),t.geometry.index||this.makeGeometryIndexed(t.geometry),t}makeGeometryIndexed(e){e.attributes.position.array;const t=e.attributes.position.count,r=new Uint32Array(t);for(let e=0;e<t;e++)r[e]=e;return e.setIndex(new THREE.BufferAttribute(r,1)),e}performOperation(e,t){if(!e||e.length<2)return this.showError("Для операции нужно минимум 2 объекта"),null;console.log(`=== Выполнение операции ${t} (three-csg-ts) ===`);try{const r=e[0].clone();r.updateMatrixWorld(!0),r.geometry.applyMatrix4(r.matrixWorld),r.position.set(0,0,0),r.rotation.set(0,0,0),r.scale.set(1,1,1),r.updateMatrix();let o=new ThreeCSG(r);for(let r=1;r<e.length;r++){const n=e[r].clone();n.updateMatrixWorld(!0),n.geometry.applyMatrix4(n.matrixWorld),n.position.set(0,0,0),n.rotation.set(0,0,0),n.scale.set(1,1,1),n.updateMatrix();const s=new ThreeCSG(n);switch(t){case"union":o=o.union(s);break;case"subtract":o=o.subtract(s);break;case"intersect":o=o.intersect(s)}}const n=o.toMesh(),s=new THREE.MeshStandardMaterial({color:e[0].material?.color||8421504,side:THREE.DoubleSide,transparent:!1,wireframe:!1,flatShading:!1});n.material=s,n.geometry=this.fixGeometry(n.geometry,t),n.geometry.computeBoundingBox();const a=n.geometry.boundingBox,i=new THREE.Vector3;return a.getCenter(i),n.geometry.translate(-i.x,-i.y,-i.z),n.position.copy(i),n.rotation.set(0,0,0),n.scale.set(1,1,1),n.updateMatrixWorld(!0),n.castShadow=!0,n.receiveShadow=!0,n.userData={id:"csg_"+Date.now(),name:this.getOperationName(t),type:"boolean",operation:t,sourceObjects:e.map(e=>e.uuid),createdAt:(new Date).toISOString(),library:"three-csg-ts"},console.log(`Операция ${t} завершена успешно`),n}catch(e){return console.error(`Ошибка операции ${t}:`,e),this.showError(`Ошибка ${this.getOperationName(t)}: ${e.message}`),null}}fixGeometry(e,t){console.log("Исправление геометрии после операции...");const r=e.clone();return r.attributes.normal&&0!==r.attributes.normal.count||r.computeVertexNormals(),r.index||this.makeGeometryIndexed(r),r.index=this.removeDegenerateTriangles(r),r.computeVertexNormals(),"subtract"===t&&(r=this.fixNormalsForSubtract(r)),r=this.fixTriangleOrientation(r),r.computeVertexNormals(),r}removeDegenerateTriangles(e){if(!e.index)return e.index;const t=e.attributes.position.array,r=e.index.array,o=[];for(let e=0;e<r.length;e+=3){const n=r[e],s=r[e+1],a=r[e+2],i=new THREE.Vector3(t[3*n],t[3*n+1],t[3*n+2]),c=new THREE.Vector3(t[3*s],t[3*s+1],t[3*s+2]),u=new THREE.Vector3(t[3*a],t[3*a+1],t[3*a+2]);c.clone().sub(i).cross(u.clone().sub(i)).length()/2>1e-5&&o.push(n,s,a)}return new THREE.BufferAttribute(new Uint32Array(o),1)}fixNormalsForSubtract(e){const t=e.attributes.normal.array,r=e.index.array,o=e.attributes.position.array;let n=0;for(let e=0;e<r.length;e+=3){const t=r[e],s=r[e+1],a=r[e+2],i=new THREE.Vector3(o[3*t],o[3*t+1],o[3*t+2]),c=new THREE.Vector3(o[3*s],o[3*s+1],o[3*s+2]),u=new THREE.Vector3(o[3*a],o[3*a+1],o[3*a+2]);n+=i.dot(c.cross(u))/6}if(n<0){console.log("Инвертируем нормали для вычитания (объем < 0)");for(let e=0;e<t.length;e+=3)t[e]*=-1,t[e+1]*=-1,t[e+2]*=-1;e.attributes.normal.needsUpdate=!0;for(let e=0;e<r.length;e+=3){const t=r[e+1];r[e+1]=r[e+2],r[e+2]=t}e.index.needsUpdate=!0}return e}fixTriangleOrientation(e){if(!e.index)return e;const t=e.attributes.position.array,r=e.attributes.normal.array,o=e.index.array;for(let e=0;e<o.length;e+=3){const n=o[e],s=o[e+1],a=o[e+2],i=new THREE.Vector3(t[3*n],t[3*n+1],t[3*n+2]),c=new THREE.Vector3(t[3*s],t[3*s+1],t[3*s+2]),u=new THREE.Vector3(t[3*a],t[3*a+1],t[3*a+2]),l=c.clone().sub(i).cross(u.clone().sub(i)).normalize(),m=new THREE.Vector3(r[3*n],r[3*n+1],r[3*n+2]),d=new THREE.Vector3(r[3*s],r[3*s+1],r[3*s+2]),g=new THREE.Vector3(r[3*a],r[3*a+1],r[3*a+2]),p=m.clone().add(d).add(g).multiplyScalar(1/3).normalize();l.dot(p)<-.5&&([o[e+1],o[e+2]]=[o[e+2],o[e+1]])}return e.index.needsUpdate=!0,e}unionMultiple(e){return this.performOperation(e,"union")}subtract(e,t){return this.performOperation([e,t],"subtract")}intersect(e,t){return this.performOperation([e,t],"intersect")}canPerformOperation(e){if(!e||e.length<2)return{can:!1,reason:"Нужно минимум 2 объекта"};for(const t of e)if(!t.geometry)return{can:!1,reason:`Объект ${t.userData?.name||t.uuid} не имеет геометрии`};return{can:!0,reason:""}}getOperationStats(e){if(!e||!e.geometry)return null;const t=e.geometry;let r=0,o=0;t.attributes.position&&(r=t.attributes.position.count),t.index?o=t.index.count/3:t.attributes.position&&(o=t.attributes.position.count/3),t.computeBoundingBox();const n=t.boundingBox,s=n?(new THREE.Vector3).subVectors(n.max,n.min):new THREE.Vector3,a=s.x*s.y*s.z;return{vertices:r,faces:o,volume:a,volumeMM3:a,bbox:n,size:s}}getOperationName(e){return{union:"Объединение",subtract:"Вычитание",intersect:"Пересечение"}[e]||e}showError(e){this.editor&&this.editor.showStatus?this.editor.showStatus(e,"error"):console.error("BooleanOperations Error:",e)}showWarning(e){this.editor&&this.editor.showStatus?this.editor.showStatus(e,"warning"):console.warn("BooleanOperations Warning:",e)}}