class ExtrudeManager{constructor(e){this.editor=e,this.figureManager=e.objectsManager.figureManager,this.extrudePreviewGroup=null,this.previewMaterial=null,this.selectedFigures=new Map,this.basePlane=null,this.extrudeArrow=null,this.isDraggingArrow=!1,this.arrowStartHeight=0,this.startMouseY=0,this.isArrowHovered=!1,this.arrowNormalColor=65280,this.arrowHoverColor=65416,this.hoveredFigure=null,this.hoveredColor=16776960,this.selectedColor=26367,this.isProcessingClick=!1,this.mergeConnectedFigures=!1,this.mergeThreshold=.1,this.clipperScale=1e5,this.clipperAvailable=!1,this.initializeClipper(),console.log("ExtrudeManager: создан (упрощенная версия с Clipper.js)")}initializeClipper(){"undefined"!=typeof ClipperLib?(this.clipperAvailable=!0,console.log("Clipper.js доступен"),ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale):(console.error("Clipper.js не найден! Объединение фигур будет недоступно."),this.clipperAvailable=!1)}initialize(){console.log("ExtrudeManager: инициализация"),this.figureManager?this.figureManager.collectAllFigures():console.error("ExtrudeManager: FigureManager не найден!")}handleFigureClick(e){if(console.log("=== handleFigureClick ==="),this.isProcessingClick)return!1;this.isProcessingClick=!0;try{const t=this.figureManager.getAllFigures();if(0===t.length)return console.log("Нет фигур для выбора"),!1;const r=this.findFigureAtPoint(e,t);return r?(console.log("Найдена фигура:",r.id,"плоскость:",this.getFigurePlane(r)?.uuid),this.toggleSelection(r),this.updateExtrudePreview(),this.updateExtrudeUI(),this.createExtrudeDirectionIndicator(),!0):(console.log("Не найдена фигура под курсором"),!1)}finally{setTimeout(()=>{this.isProcessingClick=!1},50)}}isPlaneVisible(e){if(!e)return!1;if(!e.visible)return!1;if(e.userData&&!1===e.userData.visible)return!1;let t=e.parent;for(;t;){if(!t.visible)return!1;t=t.parent}return!0}findFigureAtPoint(e,t){const r=[...t].sort((e,t)=>e.depth!==t.depth?t.depth-e.depth:e.area-t.area);for(const t of r){if(!t.outer||!t.outer.points)continue;const r=this.getFigurePlane(t);if(!r)continue;if(!this.isPlaneVisible(r))continue;const i=this.getPointOnPlane(e,r);if(!i)continue;const o=r.worldToLocal(i.clone()),s=new THREE.Vector2(o.x,o.y);if(this.isPointInContour(s,t.outer.points))return t}return null}recalculateBasePlane(){if(0===this.selectedFigures.size)return void(this.basePlane=null);const e=this.selectedFigures.values().next().value;this.basePlane=this.getFigurePlane(e),console.log("Пересчитана базовая плоскость:",this.basePlane?.uuid)}toggleSelection(e){const t=e.id;if(this.selectedFigures.has(t))this.selectedFigures.delete(t),this.unhighlightFigure(e),0===this.selectedFigures.size?this.basePlane=null:this.recalculateBasePlane();else{this.selectedFigures.set(t,e);const r=this.getFigurePlane(e);if(this.basePlane){if(!this.arePlanesCompatible(this.basePlane,r))return this.editor.showStatus("Выбраны фигуры на разных плоскостях!","error"),void this.selectedFigures.delete(t)}else this.basePlane=r;this.highlightFigure(e,this.selectedColor)}console.log("Выделено фигур:",this.selectedFigures.size,"Базовая плоскость:",this.basePlane?.uuid)}getFiguresForExtrusion(){if(console.log("=== getFiguresForExtrusion ==="),console.log("Выделено фигур:",this.selectedFigures.size),0===this.selectedFigures.size)return[];if(1===this.selectedFigures.size){const e=this.selectedFigures.values().next().value;return[this.createExtrusionFigure(e)]}if(!this.mergeConnectedFigures||!this.clipperAvailable)return console.log("Объединение отключено или Clipper недоступен"),this.getIndividualFigures(Array.from(this.selectedFigures.values()));const e=Array.from(this.selectedFigures.values());if(!this.areAllFiguresOnSamePlane(e))return console.log("Фигуры на разных плоскостях, не объединяем"),this.getIndividualFigures(e);if(!this.basePlane&&e.length>0){const t=this.getFigurePlane(e[0]);t&&(this.basePlane=t,console.log("Установлена базовая плоскость:",this.basePlane.uuid))}const t=[],r=[];if(e.forEach(e=>{e.isHole?r.push(e):t.push(e)}),console.log("Внешних фигур:",t.length,"Отверстий:",r.length),0===t.length)return console.log("Нет внешних фигур для вытягивания"),[];const i=[];if(1===t.length){const e=this.getFigurePointsForBasePlane(t[0]);i.push({points:e,area:Math.abs(this.calculateSignedPolygonArea(e))})}else try{const e=new ClipperLib.Clipper;t.forEach(t=>{const r=this.getFigurePointsForBasePlane(t);if(r.length>=3){const t=this.pointsToClipperPath(r);e.AddPath(t,ClipperLib.PolyType.ptSubject,!0)}});const r=new ClipperLib.Paths;e.Execute(ClipperLib.ClipType.ctUnion,r,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)&&r.length>0&&r.forEach(e=>{const t=this.clipperPathToPoints(e);if(t.length>=3){const e=this.calculateSignedPolygonArea(t),r=e>0?t.reverse():t;i.push({points:r,area:Math.abs(e)})}})}catch(e){console.error("Ошибка при объединении внешних контуров:",e)}0===i.length&&t.forEach(e=>{const t=this.getFigurePointsForBasePlane(e);t.length>=3&&i.push({points:t,area:Math.abs(this.calculateSignedPolygonArea(t))})});const o=[];t.forEach(e=>{e.holes&&e.holes.length>0&&e.holes.forEach(e=>{const t=this.getContourPointsForBasePlane(e);t.length>=3&&o.push({points:t,area:Math.abs(this.calculateSignedPolygonArea(t))})})}),r.forEach(e=>{const t=this.getFigurePointsForBasePlane(e);t.length>=3&&o.push({points:t,area:Math.abs(this.calculateSignedPolygonArea(t))})});const s=[];return i.forEach((t,r)=>{const i=[];o.forEach(e=>{if(e.points.length>0){const r=e.points[0];if(this.isPointInContour(r,t.points)){const t=this.calculateSignedPolygonArea(e.points)<0?e.points.reverse():e.points;i.push({points:t,center:this.calculateContourCenter(t),area:Math.abs(this.calculateSignedPolygonArea(t))})}}}),console.log(`Внешний контур ${r}: ${t.points.length} точек, ${i.length} отверстий`);const n=this.getFigurePlane(e[0]),a={id:`merged_${Date.now()}_${r}`,outer:{points:t.points,center:this.calculateContourCenter(t.points),area:t.area},holes:i,area:t.area,isHole:!1,parentId:null,childrenIds:[],depth:0,isMerged:!0,geometricMerge:!0,plane:n,planeId:n?n.uuid:null};s.push(a)}),s}convertClipperSolutionToFigures(e,t){const r=[];if(!e||0===e.length)return console.log("Clipper вернул пустой результат"),r;console.log("Clipper вернул",e.length,"полигонов");let i=null,o=-1/0;for(let t=0;t<e.length;t++){const r=Math.abs(ClipperLib.Clipper.Area(e[t]));r>o&&(o=r,i=e[t])}if(!i)return console.log("Не найден внешний полигон"),r;const s=this.clipperPathToPoints(i),n=this.calculateSignedPolygonArea(s)>0?s.reverse():s,a=[];for(let t=0;t<e.length;t++){if(e[t]===i)continue;const r=this.clipperPathToPoints(e[t]),o=this.calculateSignedPolygonArea(r);if(r.length>0){const e=r[0];if(this.isPointInContour(e,n)){const e=o<0?r.reverse():r;a.push({points:e,center:this.calculateContourCenter(e),area:Math.abs(this.calculateSignedPolygonArea(e))})}}}console.log("Найден внешний контур с",a.length,"отверстиями");const l=this.getFigurePlane(t),u={id:`merged_${Date.now()}`,outer:{points:n,center:this.calculateContourCenter(n),area:Math.abs(this.calculateSignedPolygonArea(n))},holes:a,area:Math.abs(this.calculateSignedPolygonArea(n)),isHole:!1,parentId:null,childrenIds:[],depth:0,isMerged:!0,geometricMerge:!0,plane:l,planeId:l?l.uuid:null};return r.push(u),r}getIndividualFigures(e){return e.map(e=>this.createExtrusionFigure(e))}createExtrusionFigure(e){const t=this.getAllImmediateHoles(e),r=this.getFigurePlane(e);return{id:e.id,outer:e.outer,holes:t,area:e.area,isHole:e.isHole,parentId:e.parentId,childrenIds:e.childrenIds,depth:e.depth,plane:r,planeId:r?r.uuid:null,element:e.element}}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=this.getFigurePlane(e[0]);if(!t)return!1;for(let r=1;r<e.length;r++){const i=this.getFigurePlane(e[r]);if(!i||!this.arePlanesCompatible(t,i))return!1}return!0}getAllImmediateHoles(e){const t=[];if(e.childrenIds&&e.childrenIds.length>0)for(const r of e.childrenIds){const i=this.figureManager.getFigureById(r);i&&(!e.isHole&&i.isHole||e.isHole&&!i.isHole)&&(t.push(i.outer),console.log(`    Добавлено отверстие: ${r}, isHole=${i.isHole}`))}return t}highlightFigure(e,t){e&&e.outer&&(e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,t):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,t)}))}unhighlightFigure(e){e&&e.outer&&(this.selectedFigures.has(e.id)||(e.outer.element?this.editor.objectsManager.safeRestoreElementColor(e.outer.element):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)})))}highlightFiguresOnHover(e){if(this.hoveredFigure&&!this.selectedFigures.has(this.hoveredFigure.id)&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),this.isDraggingArrow)return;const t=this.figureManager.getAllFigures(),r=this.findFigureAtPoint(e,t);if(r){if(this.selectedFigures.has(r.id))return this.hoveredFigure&&(this.hoveredFigure=null),void(document.body.style.cursor="default");this.hoveredFigure=r,this.highlightFigure(r,this.hoveredColor),document.body.style.cursor="pointer"}else document.body.style.cursor="default"}clearSelection(){console.log("=== clearSelection ===");for(const e of this.selectedFigures.values())this.unhighlightFigure(e);this.selectedFigures.clear(),this.basePlane=null,this.hoveredFigure&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),document.body.style.cursor="default"}getPointOnPlane(e,t=null){const r=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((e.clientX-r.left)/r.width*2-1,-(e.clientY-r.top)/r.height*2+1);if(this.editor.raycaster.setFromCamera(i,this.editor.camera),t){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(t.quaternion);const r=new THREE.Plane;r.setFromNormalAndCoplanarPoint(e,t.position);const i=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(r,i))return i}if(this.basePlane){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(this.basePlane.quaternion);const t=new THREE.Plane;t.setFromNormalAndCoplanarPoint(e,this.basePlane.position);const r=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(t,r))return r}const o=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];for(const e of o){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const r=new THREE.Plane;r.setFromNormalAndCoplanarPoint(t,e.position);const i=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(r,i))return i}return null}isPointInContour(e,t){if(t.length<3)return!1;let r=0;const i=t.length;for(let o=0;o<i;o++){const s=t[o],n=t[(o+1)%i];s.y<=e.y?n.y>e.y&&this.isLeft(s,n,e)>0&&r++:n.y<=e.y&&this.isLeft(s,n,e)<0&&r--}return 0!==r}isContourInside(e,t){if(0===e.length||0===t.length)return!1;const r=e[0];return this.isPointInContour(r,t)}isLeft(e,t,r){return(t.x-e.x)*(r.y-e.y)-(r.x-e.x)*(t.y-e.y)}getFigurePlane(e){if(e.plane)return e.plane;if(e.planeId){const t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId);if(t)return e.plane=t,t}let t=null;if(e.element?t=e.element:e.outer&&e.outer.element?t=e.outer.element:e.outer&&e.outer.elements&&e.outer.elements.length>0&&(t=e.outer.elements[0]),t){const r=this.findSketchPlaneForElement(t);return r&&(e.plane=r,e.planeId=r.uuid),r}return console.warn(`Не удалось определить плоскость для фигуры ${e.id}`),null}findSketchPlaneForElement(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}return this.editor.sketchPlanes.length>0?this.editor.sketchPlanes[0]:this.editor.workPlanes.length>0?this.editor.workPlanes[0]:null}calculateSignedPolygonArea(e){if(e.length<3)return 0;let t=0;const r=e.length;for(let i=0;i<r;i++){const o=(i+1)%r;t+=e[i].x*e[o].y,t-=e[o].x*e[i].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,r=0;return e.forEach(e=>{t+=e.x,r+=e.y}),new THREE.Vector2(t/e.length,r/e.length)}fixContourOrientation(e,t){if(e.length<3)return e;return this.calculateSignedPolygonArea(e)<0!==t?[...e].reverse():e}createExtrusionGeometryFromFigures(e,t,r){if(0===e.length||!this.basePlane)return null;if(0===e.length||!this.basePlane)return console.error("Нет базовой плоскости для создания геометрии!"),null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;const i=[];if(e.forEach(e=>{console.log(`Создание фигуры: ${e.id}, isHole: ${e.isHole}, отверстий: ${e.holes?e.holes.length:0}`);const t=this.getFigurePointsForBasePlane(e);if(t.length<3)return void console.log(`  Недостаточно точек: ${t.length}`);let r=!1;e.isHole&&(r=!1);const o=this.fixContourOrientation(t,r);try{const t=new THREE.Shape(o.map(e=>new THREE.Vector2(e.x,e.y)));e.holes&&e.holes.length>0&&e.holes.forEach((e,r)=>{const i=this.getContourPointsForBasePlane(e);if(i.length>=3){const e=this.fixContourOrientation(i,!0);try{const i=new THREE.Path(e.map(e=>new THREE.Vector2(e.x,e.y)));t.holes.push(i),console.log(`    Добавлено отверстие ${r}`)}catch(e){console.error(`    Ошибка создания отверстия ${r}:`,e)}}}),i.push(t),console.log("  Форма успешно создана")}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),0===i.length)return console.log("Нет фигур для создания геометрии"),null;console.log(`Создано ${i.length} форм для выдавливания`);const o={depth:t,bevelEnabled:!1,steps:1};try{console.log("Создание ExtrudeGeometry...");const e=new THREE.ExtrudeGeometry(i,o);return"negative"===r?e.translate(0,0,-t):"both"===r&&e.translate(0,0,-t/2),console.log("Геометрия успешно создана, вершин:",e.attributes.position.count),e}catch(e){return console.error("Ошибка создания геометрии выдавливания:",e),null}}getFigurePointsForBasePlane(e){const t=this.getFigurePlane(e);return t?!this.basePlane||this.arePlanesCompatible(t,this.basePlane)?e.outer.points||[]:(e.outer.points||[]).map(e=>{const r=new THREE.Vector3(e.x,e.y,0),i=t.localToWorld(r.clone()),o=this.basePlane.worldToLocal(i.clone());return new THREE.Vector2(o.x,o.y)}):e.outer.points||[]}getContourPointsForBasePlane(e){return e.points||[]}arePlanesCompatible(e,t){if(!e||!t)return console.log("Одна из плоскостей null!"),!1;if(e.uuid===t.uuid)return!0;const r=e.position,i=t.position,o=e.quaternion,s=t.quaternion,n=r.distanceTo(i),a=o.angleTo(s),l=n<.001&&a<.001;return l||(console.log(`Плоскости не совместимы: ${e.uuid} и ${t.uuid}`),console.log(`  Расстояние: ${n}, угол: ${a}`)),l}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let r=0;r<e.length;r++)t[r]=new ClipperLib.IntPoint(Math.round(e[r].x*this.clipperScale),Math.round(e[r].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let r=0;r<e.length;r++)t.push(new THREE.Vector2(e[r].X/this.clipperScale,e[r].Y/this.clipperScale));return t}createExtrudeDirectionIndicator(){this.extrudeArrow&&(this.extrudeArrow.parent&&this.extrudeArrow.parent.remove(this.extrudeArrow),this.extrudeArrow=null);const e=this.getFiguresForExtrusion();if(!e||0===e.length||!this.basePlane)return;if(!this.isPlaneVisible(this.basePlane))return void console.log("Базовая плоскость скрыта, не создаем стрелку");const t=document.getElementById("extrudeDirection")?.value||"positive",r=new THREE.Vector3(0,0,1);r.applyQuaternion(this.basePlane.quaternion),r.normalize(),"negative"===t&&r.negate(),this.extrudeArrow=new THREE.Group,this.extrudeArrow.userData.isExtrudeArrow=!0,this.extrudeArrow.userData.isDraggable=!0,this.extrudeArrow.raycast=()=>{};const i=new THREE.CylinderGeometry(.5,.5,15,8),o=new THREE.MeshBasicMaterial({color:this.arrowNormalColor,transparent:!0,opacity:.7}),s=new THREE.Mesh(i,o);s.position.y=7.5,s.userData.isArrowPart=!0,s.userData.isDraggable=!0,s.userData.isArrowHandle=!0,this.extrudeArrow.add(s);const n=new THREE.ConeGeometry(3,6,8),a=new THREE.MeshBasicMaterial({color:this.arrowNormalColor,transparent:!0,opacity:.9}),l=new THREE.Mesh(n,a);l.position.y=18,l.userData.isArrowPart=!0,l.userData.isArrowHandle=!0,l.userData.isDraggable=!0,this.extrudeArrow.add(l);const u=new THREE.MeshBasicMaterial({color:this.arrowHoverColor,transparent:!0,opacity:.9});s.userData.originalMaterial=o,l.userData.originalMaterial=a,s.userData.highlightMaterial=u.clone(),l.userData.highlightMaterial=u.clone(),this.setupArrowHoverEvents(s),this.setupArrowHoverEvents(l);const c=new THREE.Vector3(0,1,0),h=(new THREE.Quaternion).setFromUnitVectors(c,r.clone().normalize());this.extrudeArrow.quaternion.copy(h),this.updateArrowPosition(),this.editor.scene.add(this.extrudeArrow)}setupArrowHoverEvents(e){e.userData.isHovered=!1,e.onPointerEnter=()=>{e.userData.isHovered||this.isDraggingArrow||(e.userData.isHovered=!0,this.highlightArrow(!0),document.body.style.cursor="grab")},e.onPointerLeave=()=>{e.userData.isHovered&&!this.isDraggingArrow&&(e.userData.isHovered=!1,this.highlightArrow(!1),document.body.style.cursor="default")}}highlightArrow(e){this.extrudeArrow&&(this.extrudeArrow.traverse(t=>{t.userData&&t.userData.isArrowPart&&(t.material=e?t.userData.highlightMaterial:t.userData.originalMaterial)}),this.isArrowHovered=e)}updateArrowPosition(){if(!this.extrudeArrow||!this.basePlane)return;const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10,t=document.getElementById("extrudeDirection")?.value||"positive",r=this.getFiguresForExtrusion();if(0===r.length)return;const i=new THREE.Vector3(0,0,1);i.applyQuaternion(this.basePlane.quaternion),i.normalize();let o=i.clone();"negative"===t&&o.negate();const s=new THREE.Vector3(0,1,0),n=(new THREE.Quaternion).setFromUnitVectors(s,o.clone().normalize());this.extrudeArrow.quaternion.copy(n);const a=new THREE.Vector3(0,0,0);let l=0;r.forEach(e=>{if(e.outer&&e.outer.center){const t=e.outer.area||1;a.x+=e.outer.center.x*t,a.y+=e.outer.center.y*t,l+=t}}),l>0&&(a.x/=l,a.y/=l);const u=this.basePlane.localToWorld(a.clone()),c=new THREE.Vector3;this.basePlane.getWorldPosition(c);const h=(new THREE.Vector3).subVectors(u,c);let d=e;"both"===t&&(d=e/2);const g=c.clone().add(h).clone().clone().add(o.clone().multiplyScalar(d));this.extrudeArrow.position.copy(g),this.extrudeArrow.updateMatrixWorld(!0)}handleArrowDragStart(e){if(!this.extrudeArrow)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.extrudeArrow&&this.extrudeArrow.traverse(e=>{e.userData&&(e.userData.isDraggable||e.userData.isArrowHandle)&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingArrow=!0,this.startMouseY=e.clientY,this.arrowStartHeight=parseFloat(document.getElementById("extrudeHeight")?.value)||10,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleArrowDrag(e){if(!this.isDraggingArrow||!this.extrudeArrow||!this.basePlane)return;const t=e.clientY-this.startMouseY,r=document.getElementById("extrudeDirection")?.value||"positive",i=new THREE.Vector3(0,0,1);i.applyQuaternion(this.basePlane.quaternion),i.normalize();const o=this.extrudeArrow.position.clone(),s=o.clone().project(this.editor.camera);let n=.4*-t;o.clone().add(i.clone().multiplyScalar(10)).clone().project(this.editor.camera).y-s.y<0&&(n=-n),"negative"===r&&(n=-n);let a=this.arrowStartHeight+n;a=Math.max(.1,a),a=Math.round(10*a)/10;const l=document.getElementById("extrudeHeight");if(l){l.value=a;const e=new Event("input",{bubbles:!0});l.dispatchEvent(e),this.updateExtrudePreview(),this.updateArrowPosition()}e.preventDefault()}handleArrowDragEnd(){this.isDraggingArrow=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor=this.isArrowHovered?"grab":"default",this.updateExtrudePreview(),this.updateArrowPosition();const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10;this.editor.showStatus(`Высота установлена: ${e.toFixed(1)} мм`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingArrow&&this.handleArrowDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingArrow&&0===e.button&&this.handleArrowDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}updateExtrudePreview(){const e=this.getFiguresForExtrusion();if(0===e.length)return void this.removeExtrudePreview();const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive";if(this.extrudePreviewGroup&&this.extrudePreviewGroup.children.length>0){const i=this.extrudePreviewGroup.children[0],o=this.createExtrusionGeometryFromFigures(e,t,r);o&&(i.geometry.dispose(),i.geometry=o,this.updatePreviewPosition(i,t,r))}else this.createNewExtrudePreview(e,t,r)}createNewExtrudePreview(e,t,r){this.removeExtrudePreview();const i=this.createExtrusionGeometryFromFigures(e,t,r);if(!i)return;this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.3,side:THREE.DoubleSide}));const o=new THREE.Mesh(i,this.previewMaterial);this.updatePreviewPosition(o,t,r),this.extrudePreviewGroup=new THREE.Group,this.extrudePreviewGroup.add(o),this.editor.objectsGroup.add(this.extrudePreviewGroup)}updatePreviewPosition(e,t,r){if(!e||!this.basePlane)return;const i=new THREE.Vector3;this.basePlane.getWorldPosition(i),e.position.copy(i),e.quaternion.copy(this.basePlane.quaternion);const o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();e.position.add(o.clone().multiplyScalar(.1))}removeExtrudePreview(){this.extrudePreviewGroup&&(this.editor.objectsGroup.remove(this.extrudePreviewGroup),this.extrudePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.extrudePreviewGroup=null)}showExtrudeUI(){const e=document.getElementById("extrudeUI");e&&e.remove();const t=this.selectedFigures.size,r=document.createElement("div");r.id="extrudeUI",r.className="extrude-ui",r.innerHTML=`\n\n            <div class="extrude-header">\n\n                <h3><i class="fas fa-arrows-alt-v"></i> Вытягивание фигур</h3>\n\n                <button id="cancelExtrude" class="btn-secondary">\n\n                    <i class="fas fa-times"></i> Отмена\n\n                </button>\n\n            </div>\n\n            <div class="extrude-controls">\n\n                <div class="control-group">\n\n                    <label>Высота (мм):</label>\n\n                    <input type="number" id="extrudeHeight" value="10" step="0.1" min="0.1" style="width: 100px;">\n\n                </div>\n\n                <div class="control-group">\n\n                    <label>Направление:</label>\n\n                    <select id="extrudeDirection">\n\n                        <option value="positive">Наружу</option>\n\n                        <option value="negative">Внутрь</option>\n\n                        <option value="both">В обе стороны</option>\n\n                    </select>\n\n                </div>\n\n                <div class="control-group">\n\n                    <label>Операция:</label>\n\n                    <select id="extrudeOperation">\n\n                        <option value="new">Новый объект</option>\n\n                        <option value="cut">Вырезать</option>\n\n                        <option value="join">Объединить</option>\n\n                    </select>\n\n                </div>\n\n                <div class="control-group">\n\n                    <label>\n\n                        Автоматически объединять соединённые фигуры\n\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n\n                        ${this.clipperAvailable?"":" (Clipper.js не найден)"}\n\n                    </label>\n\n                </div>\n\n                <div class="extrude-info">\n\n                    <div id="selectedContourInfo">\n\n                        ${t>0?`Выбрано фигур: ${t}`:"Кликните по фигуре для выбора"}\n\n                    </div>\n\n                    <div id="mergeStatus" style="font-size: 12px; color: #888; margin-top: 5px;"></div>\n\n                    <div id="clipperStatus" style="font-size: 12px; color: #888; margin-top: 2px;"></div>\n\n                </div>\n\n                <button id="performExtrude" class="btn-primary" ${t>0?"":"disabled"}>\n\n                    <i class="fas fa-check"></i> Выполнить вытягивание\n\n                </button>\n\n            </div>\n\n            <div class="extrude-hint">\n\n                <i class="fas fa-info-circle"></i>\n\n                <div>• Клик по фигуре: выделить/снять выделение</div>\n\n                <div>• Соединённые фигуры будут объединены при вытягивании (только если включена галка)</div>\n\n                <div>• Перетаскивайте стрелку для изменения высоты</div>\n\n                <div>• Escape для отмены, Enter для подтверждения</div>\n\n                ${this.clipperAvailable?"<div>• Используется Clipper.js для точного объединения</div>":'<div style="color: #f44336;">• Clipper.js не найден. Объединение фигур будет недоступно.</div>'}\n\n            </div>\n\n        `,document.querySelector(".viewport-container").appendChild(r),r.querySelector("#cancelExtrude").addEventListener("click",()=>{this.exitExtrudeMode()}),r.querySelector("#performExtrude").addEventListener("click",()=>{this.performExtrude()});r.querySelector("#extrudeHeight").addEventListener("input",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});r.querySelector("#extrudeDirection").addEventListener("change",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});const i=r.querySelector("#extrudeOperation");i.addEventListener("change",()=>{this.currentOperation=i.value,this.updateExtrudeUI()});const o=r.querySelector("#mergeFigures");o.addEventListener("change",e=>{this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(o.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","error")),this.updateExtrudePreview(),this.updateExtrudeUI()}),this.updateExtrudeUI()}updateExtrudeUI(){const e=document.getElementById("selectedContourInfo"),t=document.getElementById("mergeStatus"),r=document.getElementById("clipperStatus"),i=document.getElementById("performExtrude"),o=document.getElementById("mergeFigures");if(o&&(o.disabled=!this.clipperAvailable),e){const i=this.selectedFigures.size;if(i>0){if(e.textContent=`Выбрано фигур: ${i}`,e.style.color="#4CAF50",t)if(i>1&&this.mergeConnectedFigures&&this.clipperAvailable){const e=Array.from(this.selectedFigures.values());this.areAllFiguresOnSamePlane(e)?(t.textContent="✓ Фигуры будут объединены",t.style.color="#4CAF50"):(t.textContent="✗ Фигуры на разных плоскостях",t.style.color="#f44336")}else!this.clipperAvailable&&i>1?(t.textContent="⚠ Clipper.js не найден, объединение недоступно",t.style.color="#FF9800"):t.textContent="";r&&(this.clipperAvailable?(r.textContent="✓ Clipper.js доступен",r.style.color="#4CAF50"):(r.textContent="✗ Clipper.js не найден",r.style.color="#f44336"))}else e.textContent="Кликните по фигуре для выбора",e.style.color="#888",t&&(t.textContent=""),r&&(r.textContent="")}i&&(i.disabled=0===this.selectedFigures.size)}performExtrude(){const e=this.getFiguresForExtrusion();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вытягивания","error");const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive",i=document.getElementById("extrudeOperation")?.value||"new";if(isNaN(t))return void this.editor.showStatus("Введите корректную высоту","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const o=this.createExtrusionGeometryFromFigures(e,t,r);if(!o)return void this.editor.showStatus("Не удалось создать геометрию выдавливания","error");const s=this.createExtrusionMesh(o,t,r,e);if(!s)return void this.editor.showStatus("Не удалось создать объект выдавливания","error");const n=new THREE.Vector3;this.basePlane.getWorldPosition(n),s.position.copy(n),s.quaternion.copy(this.basePlane.quaternion);const a={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),height:t,direction:r,operation:i,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures};switch(i){case"new":this.handleNewOperation(s,a);break;case"cut":this.handleCutOperation(s,a);break;case"join":this.handleJoinOperation(s,a)}this.exitExtrudeMode();const l=e.filter(e=>e.isMerged).length,u=e.length;l>0&&u>l?this.editor.showStatus(`Выполнено выдавливание (${t} мм): ${l} объединенных + ${u-l} отдельных фигур`,"success"):l>0?this.editor.showStatus(`Выполнено выдавливание (${t} мм) с объединением ${l} фигур`,"success"):this.editor.showStatus(`Выполнено выдавливание (${t} мм) ${u} фигур`,"success")}createExtrusionMesh(e,t,r,i){if(!e)return null;const o=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.9,side:THREE.DoubleSide}),s=new THREE.Mesh(e,o);s.castShadow=!0,s.receiveShadow=!0;const n=i.some(e=>e.isMerged),a=i.filter(e=>e.isMerged),l=a.length;return s.userData={type:"extrusion",sourceFigureIds:i.flatMap(e=>e.sourceFigures||[e.id]),height:t,direction:r,operation:this.currentOperation,name:`Вытягивание (${t} мм)${n?` [${l} объединенных]`:""}`,figureCount:i.length,holeCount:i.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:n,mergedFrom:n?a.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures},s}handleNewOperation(e,t){const r=e.position.clone(),i=e.scale.clone();this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectObject(e);const o=this.editor.projectManager.serializeObjectForHistory(e);o.userData.finalPosition=r.toArray(),o.userData.finalScale=i.toArray(),this.editor.history.addAction({type:"create",subtype:"extrude",object:e.uuid,data:{...t,objectData:o,finalPosition:r.toArray(),finalScale:i.toArray()}})}handleCutOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const i=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let o=!1,s=null;r.forEach(r=>{try{const n=this.editor.booleanOps.subtract(r,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(s=n,this.replaceObjectWithResult(r,n,"cut",{sourceExtrude:t,targetObjectData:i}),o=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),o||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const i=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),o=this.editor.projectManager.serializeObjectForHistory(e);try{const s=[...r,e],n=this.editor.booleanOps.unionMultiple(s);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(s,n,"join",{sourceObjectsData:i,extrudeData:o,sourceExtrude:t})}catch(r){console.error("Ошибка соединения:",r),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],r=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(i=>{if(i===e||"sketch_plane"===i.userData.type||"work_plane"===i.userData.type||"sketch_element"===i.userData.type)return;const o=(new THREE.Box3).setFromObject(i);r.intersectsBox(o)&&t.push(i)}),t}replaceObjectWithResult(e,t,r,i){const o=(new THREE.Box3).setFromObject(e),s=new THREE.Vector3;o.getSize(s);const n=this.editor.objects.indexOf(e);n>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(n,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()),t.userData={...t.userData,type:"boolean_result",operation:r,originalObjects:[e.uuid],createdAt:(new Date).toISOString(),originalSize:s.toArray(),originalPosition:e.position.toArray()},this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectObject(t),this.editor.history.addAction({type:"boolean",operation:"subtract",result:t.uuid,sourceObjects:[e.uuid],originalObjects:i?[{uuid:e.uuid,data:i.targetObjectData[0]}]:[],resultData:this.editor.projectManager.serializeObjectForHistory(t),context:i?.sourceExtrude})}replaceObjectsWithResult(e,t,r,i){const o=e.map(e=>{const t=(new THREE.Box3).setFromObject(e),r=new THREE.Vector3;return t.getSize(r),{uuid:e.uuid,position:e.position.toArray(),size:r.toArray(),data:this.editor.projectManager.serializeObjectForHistory(e)}});e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),t.userData={...t.userData,type:"boolean_result",operation:r,originalObjects:e.map(e=>e.uuid),createdAt:(new Date).toISOString(),originalSizes:o.map(e=>e.size),originalPositions:o.map(e=>e.position)},this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectObject(t),this.editor.history.addAction({type:"boolean",operation:"union",result:t.uuid,sourceObjects:e.map(e=>e.uuid),originalObjects:o.map(e=>({uuid:e.uuid,data:e.data})),resultData:this.editor.projectManager.serializeObjectForHistory(t),context:i?.sourceExtrude})}exitExtrudeMode(){this.editor.toolManager.setCurrentTool("select")}cancelExtrudeMode(){this.clearSelection(),this.extrudeArrow&&(this.editor.scene.remove(this.extrudeArrow),this.extrudeArrow=null),this.removeExtrudePreview();const e=document.getElementById("extrudeUI");e&&e.remove();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.editor.showStatus("Режим вытягивания завершен","info"),document.body.style.cursor="default"}highlightExtrudableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,2201331):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,2201331)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вытягивания","warning")}}