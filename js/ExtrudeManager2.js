class ExtrudeManager{constructor(e){this.editor=e,this.figureManager=new FigureManager(e),this.extrudePreview=null,this.extrudePreviewGroup=null,this.dragging=!1,this.startHeight=0,this.startMouseY=0,this.currentOperation="new",this.currentDirection="positive",this.previewMaterial=null,this.arrowHandle=null,this.lastIntersectPoint=null,this.basePlane=null,this.selectedFigureIds=new Set,this.excludedHoles=new Map,this.extrudeArrow=null,this.isDraggingArrow=!1,this.arrowStartPosition=null,this.arrowStartHeight=0,this.hoveredFigure=null,this.isProcessingClick=!1,console.log("ExtrudeManager: создан")}initialize(){console.log("ExtrudeManager: инициализация"),this.figureManager.collectAllFigures()}handleFigureClick(e){if(console.log("=== НАЧАЛО handleFigureClick ==="),this.isProcessingClick)return console.log("Предотвращаем двойной клик"),!1;this.isProcessingClick=!0;try{this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera),this.editor.raycaster.params.Line={threshold:5};const t=this.editor.objectsManager.getAllSketchElements(),o=this.editor.raycaster.intersectObjects(t,!1);if(o.length>0){const e=o[0].object;console.log("Кликнули элемент:",e.uuid,"тип:",e.userData.elementType);const t=this.figureManager.getFiguresByElement(e);if(console.log("Найдено фигур, содержащих элемент:",t.length),0===t.length)return console.log("Фигуры не найдены"),!1;let r=t[0];if(t.length>1)for(const e of t)if(e.isHole){r=e,console.log("Выбрана внутренняя фигура (отверстие):",e.id);break}return console.log("Выбрана фигура:",r.id,"isHole:",r.isHole,"площадь:",r.area),this.toggleFigureSelection(r),this.updateExtrudePreview(),this.updateExtrudeUI(),this.createExtrudeDirectionIndicator(),!0}console.log("Нет пересечений с элементами")}finally{setTimeout(()=>{this.isProcessingClick=!1},50)}return console.log("=== КОНЕЦ handleFigureClick ==="),!1}toggleFigureSelection(e){console.log("=== toggleFigureSelection ==="),console.log("Фигура:",e.id,"isHole:",e.isHole,"площадь:",e.area),console.log("Текущее состояние выделения:",this.selectedFigureIds.has(e.id)?"выделена":"не выделена");const t=e.id;if(this.selectedFigureIds.has(t)){if(console.log("Удаляем фигуру из выделения"),e.isHole){const o=this.findParentIdForSelected(e);o&&this.excludedHoles.get(o)?.has(t)&&(console.log("Возвращаем отверстие в родительскую фигуру"),this.toggleHoleExclusion(o,t))}this.removeFigureFromSelection(e)}else console.log("Добавляем фигуру в выделение"),this.addFigureToSelection(e)}addFigureToSelection(e){console.log("=== addFigureToSelection ===");const t=e.id,o=this.isChildOfAnySelected(e);if(o&&e.isHole){console.log("Добавляем отверстие как отдельную фигуру для вытягивания"),this.selectedFigureIds.add(t),this.highlightFigure(e,5025616);const o=this.findParentIdForSelected(e);o&&(console.log("И отмечаем как исключенное из родительской фигуры"),this.toggleHoleExclusion(o,t))}else o&&!e.isHole?(console.log("Добавляем внешний дочерний контур как отдельную фигуру"),this.selectedFigureIds.add(t),this.highlightFigure(e,26367)):(console.log("Добавляем фигуру в selectedFigureIds"),this.selectedFigureIds.add(t),this.basePlane||(this.basePlane=this.getFigurePlane(e),console.log("Установлена базовая плоскость:",this.basePlane?.uuid)),console.log("Подсвечиваем фигуру"),e.isHole?this.highlightFigure(e,5025616):this.highlightFigure(e,26367));console.log("selectedFigureIds после добавления:",Array.from(this.selectedFigureIds))}isChildOfAnySelected(e){for(const t of this.selectedFigureIds){const o=this.figureManager.getFigureById(t);if(o&&o.childrenIds.includes(e.id))return!0}return!1}findParentIdForSelected(e){for(const t of this.selectedFigureIds){const o=this.figureManager.getFigureById(t);if(o&&o.childrenIds.includes(e.id))return t}return null}removeFigureFromSelection(e){console.log("=== removeFigureFromSelection ===");const t=e.id;console.log("Удаляем фигуру из selectedFigureIds"),this.selectedFigureIds.delete(t),this.excludedHoles.delete(t),console.log("Восстанавливаем цвет фигуры"),this.unhighlightFigure(e),e.childrenIds&&e.childrenIds.length>0&&(console.log("У фигуры есть отверстия, проверяем их"),e.childrenIds.forEach(e=>{const t=this.figureManager.getFigureById(e);t&&this.selectedFigureIds.has(e)&&(console.log("Снимаем выделение с дочерней фигуры:",e),this.removeFigureFromSelection(t))})),0===this.selectedFigureIds.size&&(console.log("Нет выделенных фигур, сбрасываем базовую плоскость"),this.basePlane=null),console.log("selectedFigureIds после удаления:",Array.from(this.selectedFigureIds))}toggleHoleExclusion(e,t){console.log("=== toggleHoleExclusion ==="),console.log("Родитель:",e,"Отверстие:",t),this.excludedHoles.has(e)||(console.log("Создаем новый Set для исключенных отверстий"),this.excludedHoles.set(e,new Set));const o=this.excludedHoles.get(e),r=this.figureManager.getFigureById(t);r?(o.has(t)?(console.log("Включаем отверстие обратно"),o.delete(t),this.highlightHole(r,!0)):(console.log("Исключаем отверстие"),o.add(t),this.highlightHole(r,!1)),console.log("Исключенные отверстия для родителя",e,":",Array.from(o)),this.updateExtrudePreview()):console.log("Отверстие не найдено!")}getFiguresForExtrusion(){const e=[],t=new Set,o=[];console.log("=== getFiguresForExtrusion (улучшенная версия) ==="),console.log("Выделенные фигуры:",Array.from(this.selectedFigureIds));for(const e of this.selectedFigureIds){const t=this.figureManager.getNodeById(e);t&&(o.push(t),console.log(`  Выбран узел: ${t.id.substring(0,8)} - isHole: ${t.isHole}, depth: ${t.depth}`))}o.sort((e,t)=>e.depth-t.depth);for(const r of o)if(!t.has(r)){if(console.log(`\nОбработка узла ${r.id.substring(0,8)}: isHole=${r.isHole}, depth=${r.depth}`),r.isHole){console.log("  Вытягиваем отверстие отдельно как выступ");const t=this.excludedHoles.get(r.id)||new Set,o=this.collectHolesForHoleNode(r).filter(e=>{const o=this.figureManager.findNodeByContour(e);return o&&!t.has(o.id)});e.push({id:r.id,outer:r.contour,holes:o,area:r.area,isHole:!0,isOuter:!1,depth:r.depth,elementIds:r.elementIds,element:r.element,node:r}),console.log(`  Добавлено отверстие с ${o.length} отверстиями внутри`)}else{console.log("  Вытягиваем внешний контур");const i=this.collectAllHolesForSelectedOuter(r,o,t),s=this.excludedHoles.get(r.id)||new Set,n=i.filter(e=>{const t=this.figureManager.findNodeByContour(e);return t&&!s.has(t.id)});e.push({id:r.id,outer:r.contour,holes:n,area:r.area,isHole:!1,isOuter:!0,depth:r.depth,elementIds:r.elementIds,element:r.element,node:r}),console.log(`  Добавлен внешний контур с ${n.length} отверстиями`),this.markSelectedDescendantsAsProcessed(r,o,t)}t.add(r)}return console.log("\nИтого фигур для вытягивания:",e.length),e}collectAllHolesForSelectedOuter(e,t,o){console.log(`  collectAllHolesForSelectedOuter для ${e.id.substring(0,8)}`);const r=new Set;return e.children.forEach(e=>{e.isHole&&!t.includes(e)&&(console.log(`    Добавляем непосредственное отверстие: ${e.id.substring(0,8)}`),r.add(e.contour))}),e.children.forEach(e=>{e.isHole&&t.includes(e)&&(console.log(`    Обработка выбранного отверстия: ${e.id.substring(0,8)}`),e.children.forEach(e=>{e.isHole||t.includes(e)||(console.log(`      Внешний ребенок выбранного отверстия -> отверстие: ${e.id.substring(0,8)}`),r.add(e.contour))}))}),console.log(`    Всего отверстий собрано: ${r.size}`),Array.from(r)}collectHolesForHoleNode(e){const t=[];return e.children.forEach(e=>{e.isHole||t.push(e.contour)}),t}markSelectedDescendantsAsProcessed(e,t,o){e.children.forEach(e=>{t.includes(e)&&!o.has(e)&&(o.add(e),this.markSelectedDescendantsAsProcessed(e,t,o))})}getExtrusionFigureForNode(e){let t=[];return e.isHole?(e.children.forEach(e=>{e.isHole||t.push(e.contour)}),console.log(`  Узел-отверстие ${e.id.substring(0,8)}: ${e.children.length} детей, ${t.length} будут отверстиями в выступе`)):(e.children.forEach(e=>{e.isHole&&t.push(e.contour)}),console.log(`  Внешний узел ${e.id.substring(0,8)}: ${e.children.length} детей, ${t.length} отверстий`)),{id:e.id,outer:e.contour,holes:t,area:e.area,isHole:e.isHole,isOuter:!e.isHole,depth:e.depth,elementIds:e.elementIds,element:e.element,node:e}}highlightFigure(e,t){console.log(`highlightFigure: фигура ${e.id}, цвет ${t.toString(16)}`),e.outer&&e.outer.element?(console.log(`  Подсвечиваем элемент ${e.outer.element.uuid}`),this.editor.objectsManager.safeSetElementColor(e.outer.element,t)):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{console.log(`  Подсвечиваем элемент ${e.uuid} (из группы)`),this.editor.objectsManager.safeSetElementColor(e,t)}),e.holes&&e.holes.length>0&&(console.log(`  Подсвечиваем ${e.holes.length} отверстий`),e.holes.forEach((t,o)=>{const r=this.figureManager.findNodeByContour(t);if(!r)return void console.warn(`  Не найден узел для отверстия ${o}`);const i=(this.excludedHoles.get(e.id)||new Set).has(r.id),s=i?8947848:16750592;console.log(`  Отверстие ${o}: holeId=${r.id}, исключено=${i}, цвет=${s.toString(16)}`),t.element?this.editor.objectsManager.safeSetElementColor(t.element,s):t.elements&&t.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,s)})}))}highlightHole(e,t){const o=t?16750592:8947848;console.log(`highlightHole: отверстие ${e.id}, включено=${t}, цвет=${o.toString(16)}`),e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,o):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,o)})}unhighlightFigure(e){console.log(`unhighlightFigure: фигура ${e.id}`),e.outer&&e.outer.element?this.editor.objectsManager.safeRestoreElementColor(e.outer.element):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),e.holes&&e.holes.length>0&&e.holes.forEach(e=>{e.element?this.editor.objectsManager.safeRestoreElementColor(e.element):e.elements&&e.elements.forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)})})}clearSelection(){console.log("=== clearSelection ===");for(const e of this.selectedFigureIds){const t=this.figureManager.getFigureById(e);t&&this.unhighlightFigure(t)}this.selectedFigureIds.clear(),this.excludedHoles.clear(),this.basePlane=null,this.hoveredFigure=null}getFigurePlane(e){let t=null;return e.element?t=e.element:e.outer&&e.outer.element?t=e.outer.element:e.outer&&e.outer.elements&&e.outer.elements.length>0&&(t=e.outer.elements[0]),t?this.findSketchPlaneForElement(t):null}findSketchPlaneForElement(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}return this.editor.sketchPlanes.length>0?this.editor.sketchPlanes[0]:this.editor.workPlanes.length>0?this.editor.workPlanes[0]:null}highlightFiguresOnHover(e){if(this.dragging||this.isDraggingArrow)return;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.objectsManager.getAllSketchElements().filter(e=>this.figureManager.isSketchElementClosed(e)||"line"===e.userData.elementType||"polyline"===e.userData.elementType);this.hoveredFigure&&(this.selectedFigureIds.has(this.hoveredFigure.id)||this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null);const o=this.editor.raycaster.intersectObjects(t,!1);if(o.length>0){const e=o[0].object,t=this.figureManager.getFiguresByElement(e);if(t.length>0){const e=t[0];this.selectedFigureIds.has(e.id)?document.body.style.cursor="default":(this.hoveredFigure=e,this.highlightFigure(e,16776960),document.body.style.cursor="pointer")}else document.body.style.cursor="default"}else document.body.style.cursor="default"}fixContourOrientation(e,t){if(e.length<3)return e;let o=0;const r=e.length;for(let t=0;t<r;t++){const i=(t+1)%r;o+=e[t].x*e[i].y,o-=e[i].x*e[t].y}o/=2;const i=o<0;return i!==t?(console.log(`Исправляем направление обхода: было ${i?"по часовой":"против часовой"}, нужно ${t?"по часовой":"против часовой"}, площадь=${o}`),[...e].reverse()):e}createExtrusionGeometryFromFigures(e,t,o){if(0===e.length||!this.basePlane)return null;const r=[];if(e.forEach(e=>{console.log(`Создание фигуры: ${e.id}, isHole: ${e.isHole}, глубина: ${e.depth}, отверстий: ${e.holes?e.holes.length:0}`);const t=this.getFigurePointsForBasePlane(e);if(t.length<3)return void console.log(`  Недостаточно точек: ${t.length}`);let o=e.isHole;e.isHole&&(o=!1,console.log("  Отверстие вытягивается отдельно - инвертируем ориентацию для создания выступа"));const i=this.fixContourOrientation(t,o),s=new THREE.Shape(i.map(e=>new THREE.Vector2(e.x,e.y)));e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{const o=this.getContourPointsForBasePlane(e);if(o.length>=3){const e=this.fixContourOrientation(o,!0),r=new THREE.Path(e.map(e=>new THREE.Vector2(e.x,e.y)));s.holes.push(r),console.log(`    Добавлено отверстие ${t}`)}}),r.push(s)}),0===r.length)return console.log("Нет фигур для создания геометрии"),null;console.log(`Создано ${r.length} форм для выдавливания`);const i={depth:t,bevelEnabled:!1,steps:1};try{console.log("Создание ExtrudeGeometry...");const e=new THREE.ExtrudeGeometry(r,i);return"negative"===o?e.translate(0,0,-t):"both"===o&&e.translate(0,0,-t/2),console.log("Геометрия успешно создана"),e}catch(e){return console.error("Ошибка создания геометрии выдавливания:",e),null}}getFigurePointsForBasePlane(e){const t=this.getFigurePlane(e);return t?this.arePlanesCompatible(t,this.basePlane)?e.outer.points||[]:(e.outer.points||[]).map(e=>{const o=new THREE.Vector3(e.x,e.y,0),r=t.localToWorld(o.clone()),i=this.basePlane.worldToLocal(r.clone());return new THREE.Vector2(i.x,i.y)}):e.outer.points||[]}getContourPointsForBasePlane(e){const t=this.figureManager.findNodeByHoleContour(e);if(!t)return e.points||[];const o=this.getFigurePlane(t);return o?this.arePlanesCompatible(o,this.basePlane)?e.points||[]:(e.points||[]).map(e=>{const t=new THREE.Vector3(e.x,e.y,0),r=o.localToWorld(t.clone()),i=this.basePlane.worldToLocal(r.clone());return new THREE.Vector2(i.x,i.y)}):e.points||[]}arePlanesCompatible(e,t){if(!e||!t)return!1;const o=e.position,r=t.position,i=e.quaternion,s=t.quaternion,n=o.distanceTo(r),l=i.angleTo(s);return n<.001&&l<.001}createExtrudeDirectionIndicator(){this.extrudeArrow&&(this.extrudeArrow.parent&&this.extrudeArrow.parent.remove(this.extrudeArrow),this.extrudeArrow=null);const e=this.getFiguresForExtrusion();if(!e||0===e.length||!this.basePlane)return;e[0];const t=new THREE.Vector3(0,0,1);t.applyQuaternion(this.basePlane.quaternion),t.normalize(),this.extrudeArrow=new THREE.Group,this.extrudeArrow.userData.isExtrudeArrow=!0,this.extrudeArrow.userData.isDraggable=!0,this.extrudeArrow.raycast=()=>{};const o=new THREE.CylinderGeometry(.8,.8,25,8),r=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.9}),i=new THREE.Mesh(o,r);i.position.y=12.5,i.userData.isArrowPart=!0,i.userData.isDraggable=!1,i.raycast=()=>{},this.extrudeArrow.add(i);const s=new THREE.ConeGeometry(4,8,8),n=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.9}),l=new THREE.Mesh(s,n);l.position.y=29,l.userData.isArrowPart=!0,l.userData.isArrowHandle=!0,l.userData.isDraggable=!0,this.extrudeArrow.add(l);const a=new THREE.SphereGeometry(6,8,8),d=new THREE.MeshBasicMaterial({color:16711680,transparent:!0,opacity:.2,visible:!0,depthTest:!0,depthWrite:!1});this.arrowHandle=new THREE.Mesh(a,d),this.arrowHandle.position.y=33,this.arrowHandle.userData.isArrowHandle=!0,this.arrowHandle.userData.isDraggable=!0,this.extrudeArrow.add(this.arrowHandle);const u=new THREE.Vector3(0,1,0),c=(new THREE.Quaternion).setFromUnitVectors(u,t.clone().normalize());this.extrudeArrow.quaternion.copy(c),this.updateArrowPosition(),this.editor.scene.add(this.extrudeArrow)}updateArrowPosition(){if(!this.extrudeArrow||!this.basePlane)return;const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10,t=document.getElementById("extrudeDirection")?.value||"positive",o=this.getFiguresForExtrusion();if(0===o.length)return;const r=new THREE.Vector3(0,0,1);r.applyQuaternion(this.basePlane.quaternion),r.normalize();const i=this.getFiguresCenter(o),s=this.basePlane.localToWorld(i.clone()),n=new THREE.Vector3;this.basePlane.getWorldPosition(n);const l=(new THREE.Vector3).subVectors(s,n);let a=0;"positive"===t?a=e/2:"negative"===t?a=-e/2:"both"===t&&(a=0);const d=n.clone().add(l).clone().add(r.clone().multiplyScalar(a+2));this.extrudeArrow.position.copy(d),this.extrudeArrow.updateMatrixWorld(!0)}getFiguresCenter(e){const t=new THREE.Vector3(0,0,0);let o=0;return e.forEach(e=>{const r=e.outer.center,i=e.outer.area||1;t.x+=r.x*i,t.y+=r.y*i,o+=i}),o>0&&(t.x/=o,t.y/=o),t}handleArrowDragStart(e){if(!this.extrudeArrow)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.extrudeArrow&&this.extrudeArrow.traverse(e=>{e.userData&&e.userData.isDraggable&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingArrow=!0,this.startMouseY=e.clientY,this.arrowStartHeight=parseFloat(document.getElementById("extrudeHeight")?.value)||10,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleArrowDrag(e){if(!this.isDraggingArrow||!this.extrudeArrow||!this.basePlane)return;if(0===this.getFiguresForExtrusion().length)return;let t=.1*(e.clientY-this.startMouseY);const o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();const r=this.editor.camera.position,i=new THREE.Vector3;this.basePlane.getWorldPosition(i);(new THREE.Vector3).subVectors(r,i).normalize().dot(o)<0&&(t=-t);let s=this.arrowStartHeight+t;s=Math.max(.1,s),s=Math.round(10*s)/10;const n=document.getElementById("extrudeHeight");if(n){n.value=s;const e=new Event("input",{bubbles:!0});n.dispatchEvent(e),this.updateExtrudePreview(),this.updateArrowPosition()}e.preventDefault()}handleArrowDragEnd(){this.isDraggingArrow=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor="default",this.updateExtrudePreview(),this.updateArrowPosition();const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10;this.editor.showStatus(`Высота установлена: ${e.toFixed(1)} мм`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingArrow&&this.handleArrowDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingArrow&&0===e.button&&this.handleArrowDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}updateExtrudePreview(){const e=this.getFiguresForExtrusion();if(0===e.length)return void this.removeExtrudePreview();const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,o=document.getElementById("extrudeDirection")?.value||"positive";if(this.extrudePreviewGroup&&this.extrudePreviewGroup.children.length>0){const r=this.extrudePreviewGroup.children[0],i=this.createExtrusionGeometryFromFigures(e,t,o);i&&(r.geometry.dispose(),r.geometry=i,this.updatePreviewPosition(r,t,o))}else this.createNewExtrudePreview(e,t,o)}createNewExtrudePreview(e,t,o){this.removeExtrudePreview();const r=this.createExtrusionGeometryFromFigures(e,t,o);if(!r)return;this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.3,side:THREE.DoubleSide}));const i=new THREE.Mesh(r,this.previewMaterial);this.updatePreviewPosition(i,t,o),this.extrudePreviewGroup=new THREE.Group,this.extrudePreviewGroup.add(i),this.editor.objectsGroup.add(this.extrudePreviewGroup)}updatePreviewPosition(e,t,o){if(!e||!this.basePlane)return;const r=new THREE.Vector3;this.basePlane.getWorldPosition(r),e.position.copy(r),e.quaternion.copy(this.basePlane.quaternion);const i=new THREE.Vector3(0,0,1);i.applyQuaternion(this.basePlane.quaternion),i.normalize();e.position.add(i.clone().multiplyScalar(.1))}removeExtrudePreview(){this.extrudePreviewGroup&&(this.editor.objectsGroup.remove(this.extrudePreviewGroup),this.extrudePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.extrudePreviewGroup=null)}showExtrudeUI(){const e=document.getElementById("extrudeUI");e&&e.remove();this.getFiguresForExtrusion();const t=this.selectedFigureIds.size,o=document.createElement("div");o.id="extrudeUI",o.className="extrude-ui",o.innerHTML=`\n            <div class="extrude-header">\n                <h3><i class="fas fa-arrows-alt-v"></i> Вытягивание фигур</h3>\n                <button id="cancelExtrude" class="btn-secondary">\n                    <i class="fas fa-times"></i> Отмена\n                </button>\n            </div>\n            <div class="extrude-controls">\n                <div class="control-group">\n                    <label>Высота (мм):</label>\n                    <input type="number" id="extrudeHeight" value="10" step="0.1" min="0.1" style="width: 100px;">\n                </div>\n                <div class="control-group">\n                    <label>Направление:</label>\n                    <select id="extrudeDirection">\n                        <option value="positive">Наружу (по нормали)</option>\n                        <option value="negative">Внутрь (против нормали)</option>\n                        <option value="both">В обе стороны</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>Операция:</label>\n                    <select id="extrudeOperation">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать из существующих</option>\n                        <option value="join">Объединить с существующими</option>\n                    </select>\n                </div>\n                <div class="extrude-info">\n                    <div id="selectedContourInfo" style="font-size: 12px; margin: 10px 0;">\n                        ${t>0?this.getFigureInfoText():"Выберите фигуру(ы) для вытягивания"}\n                    </div>\n                    <div id="operationHint" style="font-size: 11px; color: #888; margin: 5px 0;">\n                        ${t>0?this.getOperationHint():""}\n                    </div>\n                </div>\n                <button id="performExtrude" class="btn-primary" ${t>0?"":"disabled"}>\n                    <i class="fas fa-check"></i> ${this.getOperationButtonText()}\n                </button>\n            </div>\n            <div class="extrude-hint">\n                <i class="fas fa-info-circle"></i>\n                <div>• Клик по фигуре: добавляет/удаляет фигуру из выбранных</div>\n                <div>• Клик по отверстию выделенной фигуры: исключает/возвращает отверстие</div>\n                <div>• Перетаскивайте стрелку для изменения высоты</div>\n                <div>• Escape для отмены, Enter для подтверждения</div>\n            </div>\n        `,document.querySelector(".viewport-container").appendChild(o),o.querySelector("#cancelExtrude").addEventListener("click",()=>{this.cancelExtrudeMode()}),o.querySelector("#performExtrude").addEventListener("click",()=>{this.performExtrude()});o.querySelector("#extrudeHeight").addEventListener("input",e=>{this.updateExtrudePreview(),this.updateArrowPosition();const t=document.querySelector("#performExtrude");if(t&&!t.disabled){const o=parseFloat(e.target.value)||10;t.innerHTML=`<i class="fas fa-check"></i> ${this.getOperationButtonText(o)}`}});o.querySelector("#extrudeDirection").addEventListener("change",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});const r=o.querySelector("#extrudeOperation");r.addEventListener("change",()=>{this.currentOperation=r.value,this.updateOperationHint(),this.updateExtrudeUI()})}getFigureInfoText(){let e=`✓ Выбрано фигур: ${this.selectedFigureIds.size}`,t=0;for(const[e,o]of this.excludedHoles)t+=o.size;if(t>0&&(e+=` (исключено отверстий: ${t})`),this.basePlane){e+=` на ${this.basePlane.userData?.name||"основной плоскости"}`}return e}getOperationHint(){return{new:"Создаст новый объект на базовой плоскости",cut:"Вырежет из пересекающихся объектов на базовой плоскости",join:"Объединит с пересекающихся объектов на базовой плоскости"}[document.getElementById("extrudeOperation")?.value||"new"]||""}getOperationButtonText(e=null){const t=document.getElementById("extrudeOperation")?.value||"new",o=this.selectedFigureIds.size,r=e?`${e.toFixed(1)} мм`:"";return{new:`Создать ${o>1?`(${o} фигур)`:""} ${r}`,cut:`Вырезать ${o>1?`(${o} фигур)`:""} ${r}`,join:`Объединить ${o>1?`(${o} фигур)`:""} ${r}`}[t]||"Выполнить"}updateOperationHint(){const e=document.getElementById("operationHint");e&&(e.textContent=this.getOperationHint())}updateExtrudeUI(){const e=document.getElementById("selectedContourInfo"),t=document.getElementById("performExtrude"),o=document.getElementById("operationHint");if(e){this.selectedFigureIds.size>0?(e.textContent=this.getFigureInfoText(),e.style.color="#4CAF50"):(e.textContent="Выберите фигуру(ы) для вытягивания",e.style.color="#888")}if(o&&(o.textContent=this.getOperationHint()),t){const e=this.selectedFigureIds.size;if(t.disabled=0===e,e>0){const e=document.getElementById("extrudeHeight")?.value||10;t.innerHTML=`<i class="fas fa-check"></i> ${this.getOperationButtonText(parseFloat(e))}`}}}performExtrude(){const e=this.getFiguresForExtrusion();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вытягивания","error");const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,o=document.getElementById("extrudeDirection")?.value||"positive",r=document.getElementById("extrudeOperation")?.value||"new";if(isNaN(t))return void this.editor.showStatus("Введите корректную высоту","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const i=this.createExtrusionGeometryFromFigures(e,t,o);if(!i)return void this.editor.showStatus("Не удалось создать геометрию выдавливания","error");const s=this.createExtrusionMesh(i,t,o,e);if(!s)return void this.editor.showStatus("Не удалось создать объект выдавливания","error");const n=new THREE.Vector3;this.basePlane.getWorldPosition(n),s.position.copy(n),s.quaternion.copy(this.basePlane.quaternion);const l={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),height:t,direction:o,operation:r};switch(r){case"new":this.handleNewOperation(s,l);break;case"cut":this.handleCutOperation(s,l);break;case"join":this.handleJoinOperation(s,l)}this.cancelExtrudeMode(),this.editor.showStatus(`Выполнено выдавливание (${t} мм)`,"success")}createExtrusionMesh(e,t,o,r){if(!e)return null;const i=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.9,side:THREE.DoubleSide}),s=new THREE.Mesh(e,i);return s.castShadow=!0,s.receiveShadow=!0,s.userData={type:"extrusion",sourceFigureIds:r.map(e=>e.id),height:t,direction:o,operation:this.currentOperation,name:`Вытягивание (${t} мм)`,figureCount:r.length,holeCount:r.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString()},s}handleNewOperation(e,t){const o=e.position.clone(),r=e.scale.clone();this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectObject(e);const i=this.editor.projectManager.serializeObjectForHistory(e);i.userData.finalPosition=o.toArray(),i.userData.finalScale=r.toArray(),this.editor.history.addAction({type:"create",subtype:"extrude",object:e.uuid,data:{...t,objectData:i,finalPosition:o.toArray(),finalScale:r.toArray()}})}handleCutOperation(e,t){const o=this.findIntersectingObjects(e);if(0===o.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const r=o.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let i=!1,s=null;o.forEach(o=>{try{const n=this.editor.booleanOps.subtract(o,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(s=n,this.replaceObjectWithResult(o,n,"cut",{sourceExtrude:t,targetObjectData:r}),i=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),i||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){const o=this.findIntersectingObjects(e);if(0===o.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const r=o.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),i=this.editor.projectManager.serializeObjectForHistory(e);try{const s=[...o,e],n=this.editor.booleanOps.unionMultiple(s);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(s,n,"join",{sourceObjectsData:r,extrudeData:i,sourceExtrude:t})}catch(o){console.error("Ошибка соединения:",o),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],o=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(r=>{if(r===e||"sketch_plane"===r.userData.type||"work_plane"===r.userData.type||"sketch_element"===r.userData.type)return;const i=(new THREE.Box3).setFromObject(r);o.intersectsBox(i)&&t.push(r)}),t}replaceObjectWithResult(e,t,o,r){const i=(new THREE.Box3).setFromObject(e),s=new THREE.Vector3;i.getSize(s);const n=this.editor.objects.indexOf(e);n>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(n,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()),t.userData={...t.userData,type:"boolean_result",operation:o,originalObjects:[e.uuid],createdAt:(new Date).toISOString(),originalSize:s.toArray(),originalPosition:e.position.toArray()},this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectObject(t),this.editor.history.addAction({type:"boolean",operation:"subtract",result:t.uuid,sourceObjects:[e.uuid],originalObjects:r?[{uuid:e.uuid,data:r.targetObjectData[0]}]:[],resultData:this.editor.projectManager.serializeObjectForHistory(t),context:r?.sourceExtrude})}replaceObjectsWithResult(e,t,o,r){const i=e.map(e=>{const t=(new THREE.Box3).setFromObject(e),o=new THREE.Vector3;return t.getSize(o),{uuid:e.uuid,position:e.position.toArray(),size:o.toArray(),data:this.editor.projectManager.serializeObjectForHistory(e)}});e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),t.userData={...t.userData,type:"boolean_result",operation:o,originalObjects:e.map(e=>e.uuid),createdAt:(new Date).toISOString(),originalSizes:i.map(e=>e.size),originalPositions:i.map(e=>e.position)},this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectObject(t),this.editor.history.addAction({type:"boolean",operation:"union",result:t.uuid,sourceObjects:e.map(e=>e.uuid),originalObjects:i.map(e=>({uuid:e.uuid,data:e.data})),resultData:this.editor.projectManager.serializeObjectForHistory(t),context:r?.sourceExtrude})}cancelExtrudeMode(){this.clearSelection(),this.excludedHoles.clear(),this.hoveredFigure=null,this.extrudeArrow&&(this.extrudeArrow.parent&&this.extrudeArrow.parent.remove(this.extrudeArrow),this.extrudeArrow=null,this.arrowHandle=null),this.removeExtrudePreview();const e=document.getElementById("extrudeUI");e&&e.remove();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.dragging=!1,this.isDraggingArrow=!1,this.basePlane=null,this.editor.showStatus("Режим выдавливания завершен","info")}highlightExtrudableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,2201331):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,2201331)}),e.holes.forEach(e=>{e.element?this.editor.objectsManager.safeSetElementColor(e.element,16750592):e.elements&&e.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,16750592)})})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вытягивания","warning")}}