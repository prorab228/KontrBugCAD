class FigureManager{constructor(e){this.editor=e,this.figureTree=new Map,this.rootNodes=[],this.elementToNodes=new Map,this.figureCacheTimestamp=0,this.autoContours=[],this.brokenElements=new Set,this.clipperScale=1e5,this.clipperAvailable=!1,this.useClipperForContourSeparation=!0,this.initializeClipper(),console.log("FigureManager: создан (исправленная версия)")}initializeClipper(){"undefined"!=typeof ClipperLib?(this.clipperAvailable=!0,console.log("Clipper.js доступен в FigureManager"),ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale):(console.warn("Clipper.js не найден! Разделение контуров будет недоступно."),this.clipperAvailable=!1,this.useClipperForContourSeparation=!1)}clearAutoContours(){this.autoContours=[]}collectAllFigures(){console.log("=== FigureManager: начинаем сбор фигур ===");const e=Date.now();if(this.figureTree.size>0&&e-this.figureCacheTimestamp<200)return console.log("FigureManager: используем кэш, узлов:",this.figureTree.size),this.getAllFiguresFlat();const t=this.getAllSketchElements();console.log("FigureManager: найдено элементов:",t.length);const n=this.collectSimpleContours(t);console.log("FigureManager: простых контуров:",n.length);const r=this.collectLineContours(t,n);console.log("FigureManager: контуров из линий:",r.length);const o=this.getAutoContours();console.log("FigureManager: автоматических контуров:",o.length),this.updateBrokenElements(o);const i=this.filterBrokenContours(n);console.log("FigureManager: после фильтрации контуров:",i.length);const l=[...i,...r,...o];console.log("FigureManager: всего контуров до Clipper:",l.length);let s=l;this.useClipperForContourSeparation&&this.clipperAvailable&&l.length>0&&(s=this.advancedSeparateContours(l),console.log("FigureManager: после разделения Clipper:",s.length,"контуров"));const a=s.map(e=>new FigureNode(e));return console.log("FigureManager: создано узлов:",a.length),a.length>0?this.buildEnhancedNestingTree(a):this.rootNodes=[],this.rootNodes.length>0&&this.determineContourTypes(),this.updateDataStructures(a),this.figureCacheTimestamp=e,this.getAllFiguresFlat()}advancedSeparateContours(e){if(console.log("=== FigureManager: улучшенное разделение контуров ==="),!this.clipperAvailable||0===e.length)return e;try{const t=this.groupContoursByPlane(e);let n=[];for(const[e,r]of Object.entries(t)){if(console.log(`Обрабатываем плоскость ${e}: ${r.length} контуров`),0===r.length)continue;const t=this.getPlaneById(e);if(!t){n=n.concat(r);continue}const{holes:o,solids:i}=this.separateHolesAndSolids(r),l=this.separateSolidContours(i,t);n=n.concat(l,o)}return console.log(`Всего получено ${n.length} контуров`),n}catch(t){return console.error("Ошибка при улучшенном разделении контуров:",t),e}}separateHolesAndSolids(e){const t=[],n=[],r=[...e.map(e=>new FigureNode(e))].sort((e,t)=>t.area-e.area);for(let e=0;e<r.length;e++){const t=r[e];for(let n=0;n<e;n++){const e=r[n];if(this.isContourInside(t.contour,e.contour)){e.addChild(t);break}}}const o=r.filter(e=>null===e.parent),i=(e,r)=>{e.depth=r,e.isHole=r%2==1,e.isHole?t.push(e.contour):n.push(e.contour),e.children.forEach(e=>i(e,r+1))};return o.forEach(e=>i(e,0)),console.log(`Найдено: ${n.length} твердых тел, ${t.length} отверстий`),{holes:t,solids:n}}separateSolidContours(e,t){if(0===e.length)return[];try{return 1===e.length?[e[0]]:2===e.length?this.separateTwoSolids(e[0],e[1],t):this.separateMultipleSolids(e,t)}catch(t){return console.error("Ошибка при разделении твердых контуров:",t),e}}separateTwoSolids(e,t,n){try{const r=e.points||[],o=t.points||[];if(r.length<3||o.length<3)return[e,t];const i=[];this.clipperDifference(r,o,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid1_minus_2",n))});this.clipperDifference(o,r,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid2_minus_1",n))});return this.clipperIntersection(r,o,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"intersection",n))}),console.log(`Разделение двух тел: было 2, стало ${i.length}`),i.length>0?i:[e,t]}catch(n){return console.error("Ошибка при разделении двух тел:",n),[e,t]}}separateMultipleSolids(e,t){try{console.log(`Разделение ${e.length} твердых тел`);let n=[];for(let r=1;r<1<<e.length;r++){const o=[];for(let t=0;t<e.length;t++)r&1<<t&&o.push(e[t]);if(0===o.length)continue;let i=o[0].points||[];for(let e=1;e<o.length&&0!==i.length;e++)i=this.clipperIntersection(i,o[e].points||[],t)[0]||[];if(i.length<3)continue;let l=i;for(let n=0;n<e.length;n++)if(!(r&1<<n)){if(l=this.clipperDifference(l,e[n].points||[],t)[0]||[],0===l.length)break}if(l.length>=3){const e=this.calculatePolygonArea(l);Math.abs(e)>.01&&n.push({points:l,mask:r,area:Math.abs(e)})}}const r=n.map((e,n)=>this.createSeparatedContour(e.points,`area_${n}`,t));return console.log(`Разделение ${e.length} тел: было ${e.length}, стало ${r.length}`),r.length>0?r:e}catch(t){return console.error("Ошибка при разделении нескольких тел:",t),e}}clipperDifference(e,t,n){try{const n=new ClipperLib.Clipper,r=this.pointsToClipperPath(e);n.AddPath(r,ClipperLib.PolyType.ptSubject,!0);const o=this.pointsToClipperPath(t);n.AddPath(o,ClipperLib.PolyType.ptClip,!0);const i=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctDifference,i,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?i.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Difference:",e),[]}}clipperIntersection(e,t,n){try{const n=new ClipperLib.Clipper,r=this.pointsToClipperPath(e);n.AddPath(r,ClipperLib.PolyType.ptSubject,!0);const o=this.pointsToClipperPath(t);n.AddPath(o,ClipperLib.PolyType.ptClip,!0);const i=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctIntersection,i,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?i.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Intersection:",e),[]}}createSeparatedContour(e,t,n){const r=this.calculatePolygonArea(e),o=Math.abs(r),i=r<0,l=i?e:e.reverse();return{points:l,area:o,center:this.calculateContourCenter(l),boundingBox:this.calculateBoundingBox(l),type:t,isClosed:!0,isClockwise:i,planeId:n.uuid,plane:n,isSeparated:!0}}groupContoursByPlane(e){const t={};return e.forEach(e=>{const n=e.planeId||this.getContourPlaneId(e);n&&(t[n]||(t[n]=[]),t[n].push(e))}),t}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let n=0;n<e.length;n++)t[n]=new ClipperLib.IntPoint(Math.round(e[n].x*this.clipperScale),Math.round(e[n].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let n=0;n<e.length;n++)t.push(new THREE.Vector2(e[n].X/this.clipperScale,e[n].Y/this.clipperScale));return t}getContourPlaneId(e){if(e.planeId)return e.planeId;if(e.plane)return e.plane.uuid;if(e.element){const t=this.getElementPlane(e.element);return t?t.uuid:null}return null}getPlaneById(e){return[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e)||null}updateBrokenElements(e){this.brokenElements.clear(),e.forEach(e=>{e.elements&&e.elements.forEach(e=>{this.isSketchElementClosed(e)&&this.brokenElements.add(e)})}),console.log("Разбитых элементов:",this.brokenElements.size)}filterBrokenContours(e){if(0===this.brokenElements.size)return e;return e.filter(e=>{if(e.element&&this.brokenElements.has(e.element))return!1;if(e.elements&&e.elements.length>0){if(e.elements.every(e=>this.brokenElements.has(e)))return!1}return!0})}getAllSketchElements(){const e=[],t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];return 0===t.length?this.editor.scene.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)}):t.forEach(t=>{t.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)})}),e}collectSimpleContours(e){const t=[];return e.forEach(e=>{if(!e.userData)return;const n=e.userData.elementType,r=this.getElementPoints(e);if("line"===n||"polyline"===n){if(r.length<2)return;const o=this.isSketchElementClosed(e);if(this.brokenElements.has(e))return;if(!o)return;const i=this.calculatePolygonArea(r);if(Math.abs(i)<.001)return;const l=this.calculateContourCenter(r),s=this.calculateBoundingBox(r),a=i<0,u=this.getElementPlane(e);if(!u)return;return void t.push({element:e,points:r,area:Math.abs(i),center:l,boundingBox:s,type:n,isClosed:!0,isClockwise:a,originalArea:i,planeId:u.uuid,plane:u})}if(r.length<3)return;if(!this.isSketchElementClosed(e))return;if(this.brokenElements.has(e))return;const o=this.calculatePolygonArea(r);if(Math.abs(o)<.001)return;const i=this.calculateContourCenter(r),l=this.calculateBoundingBox(r),s=o<0,a=this.getElementPlane(e);a&&t.push({element:e,points:r,area:Math.abs(o),center:i,boundingBox:l,type:n,isClosed:!0,isClockwise:s,originalArea:o,planeId:a.uuid,plane:a})}),t}collectLineContours(e,t){const n=new Set;t.forEach(e=>{e.element&&n.add(e.element.uuid)});const r=e.filter(e=>{const t=e.userData?.elementType;return"line"===t&&!n.has(e.uuid)});if(r.length<3)return[];const o=r.map(e=>{const t=this.getElementPoints(e);return{element:e,start:t[0],end:t[1],points:t}});return this.findClosedContoursFromLines(o)}findClosedContoursFromLines(e){if(e.length<3)return[];const t=[],n=new Set;for(let r=0;r<e.length;r++){if(n.has(r))continue;const o=this.buildContourFromLine(r,e,n);if(o&&o.points.length>=3){const e=this.calculatePolygonArea(o.points);if(Math.abs(e)>.01){const n=this.calculateContourCenter(o.points),r=this.calculateBoundingBox(o.points),i=o.elements[0],l=this.getElementPlane(i);t.push({elements:o.elements,points:o.points,area:Math.abs(e),center:n,boundingBox:r,type:"line_contour",isClosed:!0,isClockwise:e<0,planeId:l?l.uuid:null,plane:l})}}}return t}buildContourFromLine(e,t,n){const r=t[e],o=[r.element],i=[];let l=r.start,s=r.end;i.push(l.clone()),i.push(s.clone()),n.add(e);let a=!0,u=0;for(;a&&u<100;){a=!1,u++;for(let e=0;e<t.length;e++){if(n.has(e))continue;const r=t[e],l=this.getDistance(s,r.start),u=this.getDistance(s,r.end);if(l<.5){s=r.end,i.push(s.clone()),o.push(r.element),n.add(e),a=!0;break}if(u<.5){s=r.start,i.push(s.clone()),o.push(r.element),n.add(e),a=!0;break}}if(this.getDistance(s,r.start)<.5)return{elements:o,points:i}}return null}getDistance(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}getAutoContours(){return this.autoContours||[]}updateWithAutoContours(e,t=null){t&&e.forEach(e=>{e.planeId=t}),this.autoContours=e.filter(e=>e&&e.points&&e.points.length>=3&&e.area>.01),this.figureCacheTimestamp=0,this.collectAllFigures()}getElementPoints(e){if(!e.userData)return[];if(e.userData.localPoints&&e.userData.localPoints.length>0)return e.userData.localPoints.map(e=>e instanceof THREE.Vector3||void 0!==e.x&&void 0!==e.y?new THREE.Vector2(e.x,e.y):new THREE.Vector2(0,0));if(e.geometry&&e.geometry.attributes.position){const t=e.geometry.attributes.position.array,n=[];for(let e=0;e<t.length;e+=3)n.push(new THREE.Vector2(t[e],t[e+1]));return n}return e.userData.elementType,[]}isSketchElementClosed(e){if(!e.userData)return!1;const t=e.userData.elementType;return!!["rectangle","circle","polygon","oval","stadium","arc","polyline"].includes(t)}calculatePolygonArea(e){if(e.length<3)return 0;let t=0;const n=e.length;for(let r=0;r<n;r++){const o=(r+1)%n;t+=e[r].x*e[o].y,t-=e[o].x*e[r].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);const t=new THREE.Vector2(0,0);return e.forEach(e=>{t.x+=e.x,t.y+=e.y}),t.x/=e.length,t.y/=e.length,t}calculateBoundingBox(e){if(0===e.length)return{min:new THREE.Vector2(0,0),max:new THREE.Vector2(0,0)};const t=new THREE.Vector2(1/0,1/0),n=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),n.x=Math.max(n.x,e.x),n.y=Math.max(n.y,e.y)}),{min:t,max:n}}buildEnhancedNestingTree(e){e.forEach(e=>{e.parent=null,e.children=[],e.depth=0});const t=[...e].sort((e,t)=>t.area-e.area);for(let e=0;e<t.length;e++){const n=t[e];let r=null,o=1/0;for(let i=0;i<e;i++){const e=t[i];this.isContourInside(n.contour,e.contour)&&e.area<o&&(r=e,o=e.area)}r&&r.addChild(n)}this.rootNodes=t.filter(e=>null===e.parent),this.updateDepthsRecursively()}getContourPlane(e){if(e.planeId){return[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId)||null}return e.element?this.getElementPlane(e.element):null}getElementPlane(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}const n=this.editor.sketchPlanes||[],r=this.editor.workPlanes||[];return n.length>0?n[0]:r.length>0?r[0]:null}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=e[0],n=this.getFigurePlane(t);if(!n)return!1;for(let t=1;t<e.length;t++){const r=e[t],o=this.getFigurePlane(r);if(!o)return!1;if(o.uuid!==n.uuid)return!1}return!0}isContourInside(e,t){const n=e.points||[],r=t.points||[];if(0===n.length||0===r.length)return!1;const o=this.getContourPlane(e),i=this.getContourPlane(t);if(!o||!i||o.uuid!==i.uuid)return!1;for(const e of n)if(!this.isPointInsidePolygon(e,r))return!1;return!0}isPointInsidePolygon(e,t){if(t.length<3)return!1;let n=!1;const r=e.x,o=e.y;for(let e=0,i=t.length-1;e<t.length;i=e++){const l=t[e].x,s=t[e].y,a=t[i].x,u=t[i].y;s>o!=u>o&&r<(a-l)*(o-s)/(u-s)+l&&(n=!n)}return n}updateDepthsRecursively(){const e=(t,n)=>{t.depth=n,t.children.forEach(t=>e(t,n+1))};this.rootNodes.forEach(t=>e(t,0))}determineContourTypes(){const e=t=>{t.isHole=t.depth%2==1,t.isOuter=!t.isHole,t.children.forEach(e)};this.rootNodes.forEach(e)}updateDataStructures(e){this.figureTree.clear(),this.elementToNodes.clear(),e.forEach(e=>{this.figureTree.set(e.id,e),e.elementIds.forEach(t=>{this.elementToNodes.has(t)||this.elementToNodes.set(t,[]),this.elementToNodes.get(t).push(e)})})}getFigurePlane(e){if(e.plane)return e.plane;if(e.planeId){const t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId);if(t)return e.plane=t,t}if(e.element){const t=this.getElementPlane(e.element);return t&&(e.plane=t,e.planeId=t.uuid),t}return null}getImmediateHolesForFigure(e){const t=this.getNodeById(e);return t?t.getImmediateHoles().map(e=>e.contour):[]}getAllFiguresFlat(){const e=[],t=n=>{n.getImmediateHoles().map(e=>e.contour);const r={id:n.id,outer:n.contour,holes:n.getImmediateHoles().map(e=>e.contour),area:n.area,selected:!1,parentId:n.parent?n.parent.id:null,childrenIds:n.children.map(e=>e.id),isStandalone:null===n.parent,canBeSelected:!0,isHole:n.isHole,isOuter:n.isOuter,depth:n.depth,elementIds:n.elementIds,element:n.element,boundingBox:n.boundingBox,center:n.center,type:n.type,holeDepth:n.isHole?n.depth:null,hasDeepHoles:n.getHoleDescendants().length>0,plane:n.contour.plane,planeId:n.contour.planeId,isSeparated:n.contour.isSeparated||!1};e.push(r),n.children.forEach(e=>t(e))};return this.rootNodes.forEach(e=>t(e)),e.sort((e,t)=>e.depth-t.depth),e}getNodeById(e){return this.figureTree.get(e)}getFigureById(e){const t=this.getNodeById(e);return t?this.nodeToFigure(t):null}getFiguresByElement(e){const t=e.uuid,n=(this.elementToNodes.get(t)||[]).filter(e=>{if(e.element&&this.brokenElements.has(e.element))return!1;if(e.elementIds&&e.elementIds.size>0){const t=Array.from(e.elementIds).every(e=>{const t=this.findElementById(e);return t&&this.brokenElements.has(t)});if(t)return!1}return!0});return n.map(e=>this.nodeToFigure(e))}findElementById(e){let t=null;const n=r=>{if(r.uuid===e)return t=r,!0;if(r.children&&r.children.length>0)for(const e of r.children)if(n(e))return!0;return!1};return n(this.editor.scene),t}findNodeByContour(e){for(const t of this.figureTree.values())if(t.contour===e)return t;return null}nodeToFigure(e){const t=e.getImmediateHoles().map(e=>e.contour);return{id:e.id,outer:e.contour,holes:t,area:e.area,isHole:e.isHole,isOuter:e.isOuter,depth:e.depth,parentId:e.parent?e.parent.id:null,childrenIds:e.children.map(e=>e.id),elementIds:e.elementIds,element:e.element,boundingBox:e.boundingBox,center:e.center,type:e.type,plane:e.contour.plane,planeId:e.contour.planeId,isSeparated:e.contour.isSeparated||!1}}setUseClipperForContourSeparation(e){this.useClipperForContourSeparation=e&&this.clipperAvailable,e&&!this.clipperAvailable&&console.warn("Clipper.js недоступен, разделение контуров отключено"),this.figureCacheTimestamp=0}isClipperAvailable(){return this.clipperAvailable}findFigureByHoleContour(e){const t=this.findNodeByContour(e);return t?this.nodeToFigure(t):null}getAllFigures(){return this.getAllFiguresFlat()}findNodeByHoleContour(e){return this.findNodeByContour(e)}debugPrintTree(){if(console.log("\n=== ДЕРЕВО ФИГУР ==="),0===this.rootNodes.length)return void console.log("  Дерево пустое");const e=(t,n="")=>{const r=t.isHole?"○ ОТВЕРСТИЕ":"● ВНЕШНИЙ",o=t.area.toFixed(2),i=t.elementIds.size,l=t.children.length,s=t.depth,a=t.contour.isSeparated?" [РАЗДЕЛЕН]":"";console.log(`${n}${r}${a} [ID: ${t.id.substring(0,8)}...]`),console.log(`${n}  Глубина: ${s}, Площадь: ${o}, Элементов: ${i}, Детей: ${l}`),t.children.forEach(t=>e(t,n+"  "))};this.rootNodes.forEach((t,n)=>{console.log(`\nКорень ${n+1}:`),e(t)})}}