class FigureManager{constructor(e){this.editor=e,this.figureTree=new Map,this.rootNodes=[],this.elementToNodes=new Map,this.figureCacheTimestamp=0,this.autoContours=[],this.brokenElements=new Set,console.log("FigureManager: создан")}collectAllFigures(){console.log("=== FigureManager: начинаем сбор фигур ===");const e=Date.now();if(this.figureTree.size>0&&e-this.figureCacheTimestamp<200)return console.log("FigureManager: используем кэш, узлов:",this.figureTree.size),this.getAllFiguresFlat();const t=this.getAllSketchElements();console.log("FigureManager: найдено элементов:",t.length);const n=this.collectSimpleContours(t);console.log("FigureManager: простых контуров:",n.length);const o=this.collectLineContours(t,n);console.log("FigureManager: контуров из линий:",o.length);const r=this.getAutoContours();console.log("FigureManager: автоматических контуров:",r.length),this.updateBrokenElements(r);const s=this.filterBrokenContours(n);console.log("FigureManager: после фильтрации контуров:",s.length);const l=[...s,...o,...r];console.log("FigureManager: всего контуров:",l.length);const i=l.map(e=>new FigureNode(e));return console.log("FigureManager: создано узлов:",i.length),i.length>0?this.buildEnhancedNestingTree(i):this.rootNodes=[],this.rootNodes.length>0&&this.determineContourTypes(),this.updateDataStructures(i),this.figureCacheTimestamp=e,this.getAllFiguresFlat()}updateBrokenElements(e){this.brokenElements.clear(),e.forEach(e=>{e.elements&&e.elements.forEach(e=>{this.isSketchElementClosed(e)&&this.brokenElements.add(e)})}),console.log("Разбитых элементов:",this.brokenElements.size)}filterBrokenContours(e){if(0===this.brokenElements.size)return e;return e.filter(e=>{if(e.element&&this.brokenElements.has(e.element))return console.log("Исключаем разбитый контур:",e.type,"площадь:",e.area),!1;if(e.elements&&e.elements.length>0){if(e.elements.every(e=>this.brokenElements.has(e)))return console.log("Исключаем разбитый составной контур:",e.type,"площадь:",e.area),!1}return!0})}getAllSketchElements(){const e=[],t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];return 0===t.length?this.editor.scene.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)}):t.forEach(t=>{t.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)})}),e}collectSimpleContours(e){const t=[];return e.forEach(e=>{if(!e.userData)return;const n=e.userData.elementType,o=this.getElementPoints(e);if("line"===n||"polyline"===n){if(o.length<2)return;const r=this.isSketchElementClosed(e);if(this.brokenElements.has(e))return void console.log("Пропускаем разбитый элемент при создании простого контура:",n);if(!r)return;const s=this.calculatePolygonArea(o);if(Math.abs(s)<.001)return;const l=this.calculateContourCenter(o),i=this.calculateBoundingBox(o),a=s<0;return void t.push({element:e,points:o,area:Math.abs(s),center:l,boundingBox:i,type:n,isClosed:!0,isClockwise:a,originalArea:s,isPolyline:!0})}if(o.length<3)return;if(!this.isSketchElementClosed(e))return;if(this.brokenElements.has(e))return void console.log("Пропускаем разбитый элемент при создании простого контура:",n);const r=this.calculatePolygonArea(o);if(Math.abs(r)<.001)return;const s=this.calculateContourCenter(o),l=this.calculateBoundingBox(o),i=r<0;t.push({element:e,points:o,area:Math.abs(r),center:s,boundingBox:l,type:n,isClosed:!0,isClockwise:i,originalArea:r})}),t}collectLineContours(e,t){console.log("=== FigureManager: поиск контуров из линий (группировка) ===");const n=new Set;t.forEach(e=>{e.element&&n.add(e.element.uuid)});const o=e.filter(e=>{const t=e.userData?.elementType;return"line"===t&&!n.has(e.uuid)});if(console.log(`Найдено отдельных линий: ${o.length}`),o.length<3)return[];const r=o.map(e=>{const t=this.getElementPoints(e);return{element:e,start:t[0],end:t[1],points:t}}),s=this.findClosedContoursFromLines(r);return console.log(`Найдено контуров из линий: ${s.length}`),s}findClosedContoursFromLines(e){if(e.length<3)return[];const t=[],n=new Set;for(let o=0;o<e.length;o++){if(n.has(o))continue;const r=this.buildContourFromLine(o,e,n);if(r&&r.points.length>=3){const e=this.calculatePolygonArea(r.points);if(Math.abs(e)>.01){const n=this.calculateContourCenter(r.points),o=this.calculateBoundingBox(r.points);t.push({elements:r.elements,points:r.points,area:Math.abs(e),center:n,boundingBox:o,type:"line_contour",isClosed:!0,isClockwise:e<0})}}}return t}buildContourFromLine(e,t,n){const o=t[e],r=[o.element],s=[];let l=o.start,i=o.end;s.push(l.clone()),s.push(i.clone()),n.add(e);let a=!0,u=0;for(;a&&u<100;){a=!1,u++;for(let e=0;e<t.length;e++){if(n.has(e))continue;const o=t[e],l=this.getDistance(i,o.start),u=this.getDistance(i,o.end);if(l<.5){i=o.end,s.push(i.clone()),r.push(o.element),n.add(e),a=!0;break}if(u<.5){i=o.start,s.push(i.clone()),r.push(o.element),n.add(e),a=!0;break}}if(this.getDistance(i,o.start)<.5)return{elements:r,points:s}}return null}getDistance(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}getAutoContours(){return this.autoContours||[]}updateWithAutoContours(e,t=null){console.log("=== FigureManager: обновление автоматическими контурами ==="),console.log("Получено контуров:",e.length),t&&e.forEach(e=>{e.planeId=t}),this.autoContours=e.filter(e=>e&&e.points&&e.points.length>=3&&e.area>.01),console.log("Валидных контуров:",this.autoContours.length),this.figureCacheTimestamp=0,this.collectAllFigures()}getElementPoints(e){if(!e.userData)return console.warn("Элемент не имеет userData"),[];if(e.userData.localPoints&&e.userData.localPoints.length>0)return console.log("Получаем точки из userData.localPoints для",e.userData.elementType,"количество точек:",e.userData.localPoints.length),e.userData.localPoints.map(e=>e instanceof THREE.Vector3||void 0!==e.x&&void 0!==e.y?new THREE.Vector2(e.x,e.y):new THREE.Vector2(0,0));if(e.geometry&&e.geometry.attributes.position){const t=e.geometry.attributes.position.array,n=[];for(let e=0;e<t.length;e+=3)n.push(new THREE.Vector2(t[e],t[e+1]));return console.log("Получаем точки из geometry для",e.userData.elementType,"количество точек:",n.length),n}return"text"===e.userData.elementType||console.warn("Не удалось получить точки для элемента:",e.userData.elementType),[]}isSketchElementClosed(e){if(!e.userData)return!1;const t=e.userData.elementType;return!!["rectangle","circle","polygon","oval","stadium","arc","polyline"].includes(t)}calculatePolygonArea(e){if(e.length<3)return 0;let t=0;const n=e.length;for(let o=0;o<n;o++){const r=(o+1)%n;t+=e[o].x*e[r].y,t-=e[r].x*e[o].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);const t=new THREE.Vector2(0,0);return e.forEach(e=>{t.x+=e.x,t.y+=e.y}),t.x/=e.length,t.y/=e.length,t}calculateBoundingBox(e){if(0===e.length)return{min:new THREE.Vector2(0,0),max:new THREE.Vector2(0,0)};const t=new THREE.Vector2(1/0,1/0),n=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),n.x=Math.max(n.x,e.x),n.y=Math.max(n.y,e.y)}),{min:t,max:n}}buildEnhancedNestingTree(e){console.log("=== FigureManager: строим дерево вложенности ==="),e.forEach(e=>{e.parent=null,e.children=[],e.depth=0});const t=[...e].sort((e,t)=>t.area-e.area);console.log(`Сортировка: ${t.length} узлов`);for(let e=0;e<t.length;e++){const n=t[e];let o=null,r=1/0;for(let s=0;s<e;s++){const e=t[s];this.isContourInside(n.contour,e.contour)&&e.area<r&&(o=e,r=e.area)}o&&o.addChild(n)}this.rootNodes=t.filter(e=>null===e.parent),this.updateDepthsRecursively(),console.log(`Построено дерево: ${this.rootNodes.length} корневых узлов`)}isContourInside(e,t){const n=e.points||[],o=t.points||[];if(0===n.length||0===o.length)return!1;for(const e of n)if(!this.isPointInsidePolygon(e,o))return!1;return!0}isPointInsidePolygon(e,t){if(t.length<3)return!1;let n=!1;const o=e.x,r=e.y;for(let e=0,s=t.length-1;e<t.length;s=e++){const l=t[e].x,i=t[e].y,a=t[s].x,u=t[s].y;i>r!=u>r&&o<(a-l)*(r-i)/(u-i)+l&&(n=!n)}return n}updateDepthsRecursively(){const e=(t,n)=>{t.depth=n,t.children.forEach(t=>e(t,n+1))};this.rootNodes.forEach(t=>e(t,0))}determineContourTypes(){console.log("=== FigureManager: определяем типы контуров ===");const e=t=>{t.isHole=t.depth%2==1,t.isOuter=!t.isHole,t.children.forEach(e)};this.rootNodes.forEach(e)}updateDataStructures(e){this.figureTree.clear(),this.elementToNodes.clear(),e.forEach(e=>{this.figureTree.set(e.id,e),e.elementIds.forEach(t=>{this.elementToNodes.has(t)||this.elementToNodes.set(t,[]),this.elementToNodes.get(t).push(e)})})}getAllFiguresFlat(){const e=[],t=n=>{const o=n.getImmediateHoles().map(e=>e.contour),r={id:n.id,outer:n.contour,holes:o,area:n.area,selected:!1,parentId:n.parent?n.parent.id:null,childrenIds:n.children.map(e=>e.id),isStandalone:null===n.parent,canBeSelected:!0,isHole:n.isHole,isOuter:n.isOuter,depth:n.depth,elementIds:n.elementIds,element:n.element,boundingBox:n.boundingBox,center:n.center,type:n.type};e.push(r),n.children.forEach(e=>t(e))};return this.rootNodes.forEach(e=>t(e)),e.sort((e,t)=>e.depth-t.depth),e}getNodeById(e){return this.figureTree.get(e)}getFigureById(e){const t=this.getNodeById(e);return t?this.nodeToFigure(t):null}getFiguresByElement(e){const t=e.uuid,n=(this.elementToNodes.get(t)||[]).filter(e=>{if(e.element&&this.brokenElements.has(e.element))return!1;if(e.elementIds&&e.elementIds.size>0){const t=Array.from(e.elementIds).every(e=>{const t=this.findElementById(e);return t&&this.brokenElements.has(t)});if(t)return!1}return!0});return n.map(e=>this.nodeToFigure(e))}findElementById(e){let t=null;const n=o=>{if(o.uuid===e)return t=o,!0;if(o.children&&o.children.length>0)for(const e of o.children)if(n(e))return!0;return!1};return n(this.editor.scene),t}findNodeByContour(e){for(const t of this.figureTree.values())if(t.contour===e)return t;return null}nodeToFigure(e){const t=e.getImmediateHoles().map(e=>e.contour);return{id:e.id,outer:e.contour,holes:t,area:e.area,isHole:e.isHole,isOuter:e.isOuter,depth:e.depth,parentId:e.parent?e.parent.id:null,childrenIds:e.children.map(e=>e.id),elementIds:e.elementIds,element:e.element,boundingBox:e.boundingBox,center:e.center,type:e.type}}debugPrintTree(){if(console.log("\n=== ДЕРЕВО ФИГУР ==="),0===this.rootNodes.length)return void console.log("  Дерево пустое");const e=(t,n="")=>{const o=t.isHole?"○ ОТВЕРСТИЕ":"● ВНЕШНИЙ",r=t.area.toFixed(2),s=t.elementIds.size,l=t.children.length,i=t.depth;console.log(`${n}${o} [ID: ${t.id.substring(0,8)}...]`),console.log(`${n}  Глубина: ${i}, Площадь: ${r}, Элементов: ${s}, Детей: ${l}`),t.children.forEach(t=>e(t,n+"  "))};this.rootNodes.forEach((t,n)=>{console.log(`\nКорень ${n+1}:`),e(t)})}findFigureByHoleContour(e){const t=this.findNodeByContour(e);return t?this.nodeToFigure(t):null}getAllFigures(){return this.getAllFiguresFlat()}findNodeByHoleContour(e){return this.findNodeByContour(e)}}