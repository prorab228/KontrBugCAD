class EdgeToolBase extends Tool{constructor(e,t,s){super(e,t,s),this.requiresSelection=!0,this.selectedEdges=new Set,this.tempVisuals=[],this.highlightColor=65280,this.highlightedEdges=new Map,this.edgeSelectionMode="single",this.tempHighlight=null,this.tempHighlightMaterial=new THREE.LineBasicMaterial({color:16776960,linewidth:2,depthTest:!1,transparent:!0,opacity:.8}),this.edgeMaterial=new THREE.LineBasicMaterial({color:this.highlightColor,linewidth:3,depthTest:!1,depthWrite:!1}),this.currentIntersection=null,this.vertexSnapThreshold=2,this.edgeSnapThreshold=1}onActivate(){if(this.canActivate()){if(1!==this.editor.selectedObjects.length)return this.editor.showStatus("Выберите один объект для работы с рёбрами","error"),void this.editor.toolManager.restorePreviousTool();this.selectedEdges.clear(),this.clearTempHighlight(),document.body.style.cursor="crosshair"}else this.editor.toolManager.restorePreviousTool()}onDeactivate(){this.cleanupVisualization(),this.clearTempHighlight(),document.body.style.cursor="default"}onMouseDown(e){if(0!==e.button)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.selectedObjects[0],s=this.editor.raycaster.intersectObject(t,!0);if(s.length>0){const e=s[0],i=this.findClosestEdge(t,e);if(i)return"single"===this.edgeSelectionMode?this.toggleEdgeSelection(t,i):"chain"===this.edgeSelectionMode?this.selectEdgeChain(t,i):"loop"===this.edgeSelectionMode&&this.selectEdgeLoop(t,i),!0}return!1}onMouseMove(e){this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.selectedObjects[0];if(!t)return;const s=this.editor.raycaster.intersectObject(t,!0);if(s.length>0){this.currentIntersection=s[0],document.body.style.cursor="pointer";const e=this.findClosestEdge(t,s[0]);e?this.showTempHighlight(e):this.clearTempHighlight()}else this.currentIntersection=null,document.body.style.cursor="default",this.clearTempHighlight();return!0}onKeyDown(e){return"Escape"===e.key&&(this.cleanup(),this.editor.toolManager.setCurrentTool("select"),!0)}findClosestEdge(e,t){if(!e.geometry||!t.face)return null;const s=e.geometry,i=t.face,o=t.point,r=this.getFaceVertices(s,i,e.matrixWorld);if(3!==r.length)return null;const n=[{start:r[0],end:r[1],key:this.getEdgeKey(r[0],r[1])},{start:r[1],end:r[2],key:this.getEdgeKey(r[1],r[2])},{start:r[2],end:r[0],key:this.getEdgeKey(r[2],r[0])}];let h=null,d=1/0;for(const e of n){const t=this.getClosestPointOnSegment(o,e.start,e.end),s=o.distanceTo(t);s<d&&(d=s,h=e)}return h}getFaceVertices(e,t,s){const i=[];if(e.index){const o=e.attributes.position.array,r=e.index.array,n=[r[3*t.a],r[3*t.b],r[3*t.c]];for(const e of n){const t=new THREE.Vector3(o[3*e],o[3*e+1],o[3*e+2]).applyMatrix4(s);i.push(t)}}else if(void 0!==t.a){const o=e.vertices||e.attributes.position.array,r=[t.a,t.b,t.c];for(const e of r){let t;t=o[e]instanceof THREE.Vector3?o[e].clone():new THREE.Vector3(o[3*e],o[3*e+1],o[3*e+2]),t.applyMatrix4(s),i.push(t)}}else{const o=e.attributes.position.array,r=9*t;for(let e=0;e<3;e++){const t=new THREE.Vector3(o[r+3*e],o[r+3*e+1],o[r+3*e+2]).applyMatrix4(s);i.push(t)}}return i}getEdgeKey(e,t){const s=e=>e.clone().multiplyScalar(1e3).round().divideScalar(1e3),i=s(e),o=s(t);let r,n;return i.x<o.x||i.x===o.x&&i.y<o.y||i.x===o.x&&i.y===o.y&&i.z<o.z?(r=i,n=o):(r=o,n=i),`${r.x.toFixed(3)},${r.y.toFixed(3)},${r.z.toFixed(3)}-${n.x.toFixed(3)},${n.y.toFixed(3)},${n.z.toFixed(3)}`}getClosestPointOnSegment(e,t,s){const i=s.clone().sub(t),o=e.clone().sub(t),r=i.lengthSq();if(0===r)return t.clone();const n=Math.max(0,Math.min(1,o.dot(i)/r));return t.clone().add(i.multiplyScalar(n))}toggleEdgeSelection(e,t){const s=t.key;this.selectedEdges.has(s)?(this.selectedEdges.delete(s),this.removeEdgeHighlight(s)):(this.selectedEdges.add(s),this.highlightEdge(e,t))}highlightEdge(e,t){this.removeEdgeHighlight(t.key);const s=[t.start,t.end],i=(new THREE.BufferGeometry).setFromPoints(s),o=new THREE.Line(i,this.edgeMaterial);o.userData.isEdgeHighlight=!0,o.userData.edgeKey=t.key,o.renderOrder=999,this.editor.scene.add(o),this.highlightedEdges.set(t.key,o),this.tempVisuals.push(o)}removeEdgeHighlight(e){const t=this.highlightedEdges.get(e);if(t){this.editor.scene.remove(t),t.geometry&&t.geometry.dispose(),this.highlightedEdges.delete(e);const s=this.tempVisuals.indexOf(t);s>-1&&this.tempVisuals.splice(s,1)}}selectEdgeChain(e,t){this.selectedEdges.add(t.key),this.highlightEdge(e,t);const s=this.extractAllEdges(e),i=new Set([t.key]),o=[t];for(;o.length>0;){const t=o.shift();for(const r of s){const s=r.key;i.has(s)||this.areEdgesConnected(t,r)&&this.areEdgesCoLinear(t,r)&&(this.selectedEdges.add(s),this.highlightEdge(e,r),i.add(s),o.push(r))}}}selectEdgeLoop(e,t){this.selectedEdges.add(t.key),this.highlightEdge(e,t);const s=this.extractAllEdges(e),i=new Set([t.key]);this.traverseLoopInDirection(e,s,t,i,!0),this.traverseLoopInDirection(e,s,t,i,!1)}traverseLoopInDirection(e,t,s,i,o){let r=s,n=0;for(;n<100;){const o=this.findConnectedEdges(t,r,i);if(0===o.length)break;let h=null,d=Math.PI;for(const e of o){const t=this.getAngleBetweenEdges(r,e);t<d&&(d=t,h=e)}if(!h)break;if(this.areEdgesConnected(h,s)&&i.size>2)break;this.selectedEdges.add(h.key),this.highlightEdge(e,h),i.add(h.key),r=h,n++}}extractAllEdges(e){const t=new Map,s=e.geometry;if(!s)return[];const i=(s.index?s.clone().toNonIndexed():s.clone()).attributes.position.array,o=e.matrixWorld;for(let e=0;e<i.length;e+=9){const s=new THREE.Vector3(i[e],i[e+1],i[e+2]).applyMatrix4(o),r=new THREE.Vector3(i[e+3],i[e+4],i[e+5]).applyMatrix4(o),n=new THREE.Vector3(i[e+6],i[e+7],i[e+8]).applyMatrix4(o);this.addEdgeToMap(t,s,r),this.addEdgeToMap(t,r,n),this.addEdgeToMap(t,n,s)}return Array.from(t.values())}addEdgeToMap(e,t,s){const i=this.getEdgeKey(t,s);e.has(i)||e.set(i,{start:t,end:s,key:i})}areEdgesConnected(e,t){return e.start.equals(t.start)||e.start.equals(t.end)||e.end.equals(t.start)||e.end.equals(t.end)}areEdgesCoLinear(e,t,s=.01){const i=e.end.clone().sub(e.start).normalize(),o=t.end.clone().sub(t.start).normalize(),r=Math.abs(i.dot(o));return Math.abs(r-1)<s}getAngleBetweenEdges(e,t){const s=e.end.clone().sub(e.start).normalize(),i=t.end.clone().sub(t.start).normalize();return Math.acos(Math.abs(s.dot(i)))}findConnectedEdges(e,t,s){const i=[];for(const o of e){const e=o.key;s.has(e)||this.areEdgesConnected(t,o)&&i.push(o)}return i}showTempHighlight(e){this.clearTempHighlight();const t=[e.start,e.end],s=(new THREE.BufferGeometry).setFromPoints(t);this.tempHighlight=new THREE.Line(s,this.tempHighlightMaterial),this.tempHighlight.renderOrder=1e3,this.tempHighlight.userData.isTempHighlight=!0,this.editor.scene.add(this.tempHighlight),this.tempVisuals.push(this.tempHighlight)}clearTempHighlight(){if(this.tempHighlight){this.editor.scene.remove(this.tempHighlight),this.tempHighlight.geometry&&this.tempHighlight.geometry.dispose();const e=this.tempVisuals.indexOf(this.tempHighlight);e>-1&&this.tempVisuals.splice(e,1),this.tempHighlight=null}}cleanupVisualization(){this.highlightedEdges.forEach((e,t)=>{this.editor.scene.remove(e),e.geometry&&e.geometry.dispose()}),this.highlightedEdges.clear(),this.tempVisuals.forEach(e=>{e.parent&&e.parent.remove(e),e.geometry&&e.geometry.dispose()}),this.tempVisuals=[],this.clearTempHighlight()}cleanup(){this.cleanupVisualization(),this.selectedEdges.clear(),this.currentIntersection=null}debugLog(e,t=null){this.debugMode&&console.log(`[EdgeToolBase] ${e}`,t||"")}getSelectedEdgesCount(){return this.selectedEdges.size}getEdgeSelectionMode(){return this.edgeSelectionMode}setEdgeSelectionMode(e){return!!["single","chain","loop"].includes(e)&&(this.edgeSelectionMode=e,!0)}}