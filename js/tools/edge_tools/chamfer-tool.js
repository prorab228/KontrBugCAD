class ChamferTool extends EdgeToolBase{constructor(e){super("chamfer","fa-angle-double-right",e),this.chamferSize=5,this.chamferAngle=45,this.mode="select",this.previewGeometry=null,this.edgeMap=new Map,this.debugMode=!1,this.autoPreview=!0,this.chamferType="distance-angle",this.secondDistance=5,this.originalObject=null,this.originalGeometry=null,this.originalVertices=null,this.csgAvailable="undefined"!=typeof THREE_BVH_CSG,this.csgAvailable&&(this.evaluator=new THREE_BVH_CSG.Evaluator,this.operations=THREE_BVH_CSG)}onActivate(){if(this.canActivate()){if(1!==this.editor.selectedObjects.length)return this.editor.showStatus("Для создания фаски выберите один объект","error"),void this.editor.toolManager.restorePreviousTool();if(this.originalObject=this.editor.selectedObjects[0],"work_plane"===this.originalObject.userData.type||"sketch_plane"===this.originalObject.userData.type)return this.editor.showStatus("Нельзя создать фаску на плоскости","error"),void this.editor.toolManager.restorePreviousTool();if(!this.originalObject.geometry)return this.editor.showStatus("Объект не имеет геометрии","error"),void this.editor.toolManager.restorePreviousTool();if(!this.csgAvailable)return this.editor.showStatus("Библиотека three-bvh-csg не загружена. Фаска через булевы операции недоступна.","error"),void this.editor.toolManager.restorePreviousTool();this.originalGeometry=this.originalObject.geometry.clone(),this.originalVertices=this.extractVertices(this.originalGeometry),this.mode="select",this.selectedEdges.clear(),this.edgeMap.clear(),this.extractAndMapEdges(this.originalObject),this.setupSelectionUI(),this.createPropertiesSection(),this.editor.showStatus("Выберите рёбра для фаски. Используется метод булевых операций.","info")}else this.editor.toolManager.restorePreviousTool()}onDeactivate(){this.cleanup(),this.removePropertiesSection(),document.body.style.cursor="default"}extractVertices(e){const t=e.attributes.position.array,r=[];for(let e=0;e<t.length;e+=3)r.push(new THREE.Vector3(t[e],t[e+1],t[e+2]));return r}setupSelectionUI(){if(!document.getElementById("propertiesContent"))return;const e=document.querySelector('.property-group[data-tool="chamfer"]');if(!e)return;const t=document.createElement("div");t.className="edge-selection-toolbar",t.innerHTML=`\n            <div class="property-row">\n                <label style="font-weight: bold;">Режим выбора рёбер:</label>\n            </div>\n            <div class="property-row">\n                <div class="btn-group" style="width: 100%;">\n                    <button class="btn btn-sm btn-outline-secondary edge-mode-btn ${"single"===this.edgeSelectionMode?"active":""}"\n                            data-mode="single" title="Одиночный выбор">\n                        <i class="fas fa-mouse-pointer"></i> Один\n                    </button>\n                    <button class="btn btn-sm btn-outline-secondary edge-mode-btn ${"chain"===this.edgeSelectionMode?"active":""}"\n                            data-mode="chain" title="Выбор цепочки">\n                        <i class="fas fa-link"></i> Цепочка\n                    </button>\n                    <button class="btn btn-sm btn-outline-secondary edge-mode-btn ${"loop"===this.edgeSelectionMode?"active":""}"\n                            data-mode="loop" title="Выбор петли">\n                        <i class="fas fa-sync-alt"></i> Петля\n                    </button>\n                </div>\n            </div>\n            <div class="property-row">\n                <button class="btn btn-sm btn-danger" id="clearSelectedEdges" style="width: 100%;" title="Очистить выбор">\n                    <i class="fas fa-times"></i> Очистить выбранные рёбра\n                </button>\n            </div>\n            <div class="property-row">\n                <div class="selection-info">\n                    <i class="fas fa-info-circle"></i>\n                    <span>Выбрано рёбер: <span id="edgeCount">0</span></span>\n                </div>\n            </div>\n        `;const r=e.querySelector("h4");r&&r.parentNode.insertBefore(t,r.nextSibling),t.querySelectorAll(".edge-mode-btn").forEach(e=>{e.addEventListener("click",e=>{const r=e.currentTarget.dataset.mode;this.edgeSelectionMode=r,t.querySelectorAll(".edge-mode-btn").forEach(e=>{e.classList.remove("active")}),e.currentTarget.classList.add("active"),this.updateSelectionStatus()})}),document.getElementById("clearSelectedEdges").addEventListener("click",()=>{this.selectedEdges.clear(),this.cleanupVisualization(),this.updateSelectionStatus(),this.editor.showStatus("Выбор рёбер очищен","info")}),this.updateSelectionStatus()}updateSelectionStatus(){const e=document.getElementById("edgeCount");e&&(e.textContent=this.selectedEdges.size);const t={single:"Одиночный выбор рёбер. Кликните по рёбрам для выбора",chain:"Выбор цепочки. Кликните по ребру для выбора смежных рёбер",loop:"Выбор петли. Кликните по ребру для выбора замкнутого контура"};"select"===this.mode&&this.editor.showStatus(`${t[this.edgeSelectionMode]}. Выбрано рёбер: ${this.selectedEdges.size}`,"info")}extractAndMapEdges(e){this.extractAllEdges(e).forEach(e=>{this.edgeMap.set(e.key,e)})}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","chamfer"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="chamfer"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){const e="distance-angle"===this.chamferType;return`\n            <h4><i class="fas fa-angle-double-right"></i> ФАСКА НА РЁБРАХ (three-bvh-csg)</h4>\n            <div class="property-row" style="margin-bottom: 15px;">\n                <div class="alert alert-info" style="margin: 0; padding: 8px; font-size: 0.9em;">\n                    <i class="fas fa-info-circle"></i> Используется метод булевых операций для точного создания фаски\n                </div>\n            </div>\n\n            <div class="property-row">\n                <label>Тип фаски:</label>\n                <select id="chamferType" class="property-select">\n                    <option value="distance-angle" ${e?"selected":""}>Расстояние-Угол</option>\n                    <option value="distance-distance" ${e?"":"selected"}>Расстояние-Расстояние</option>\n                </select>\n            </div>\n\n            <div class="property-row">\n                <label>${e?"Расстояние:":"Первое расстояние:"}</label>\n                <div class="input-with-unit">\n                    <input type="number" id="chamferSize" value="${this.chamferSize}" min="0.1" max="100" step="0.1" class="property-input">\n                    <span class="unit">мм</span>\n                </div>\n            </div>\n\n            ${e?`\n                <div class="property-row">\n                    <label>Угол фаски:</label>\n                    <div class="input-with-unit">\n                        <input type="number" id="chamferAngle" value="${this.chamferAngle}" min="1" max="89" step="1" class="property-input">\n                        <span class="unit">°</span>\n                    </div>\n                </div>\n            `:`\n                <div class="property-row">\n                    <label>Второе расстояние:</label>\n                    <div class="input-with-unit">\n                        <input type="number" id="secondDistance" value="${this.secondDistance}" min="0.1" max="100" step="0.1" class="property-input">\n                        <span class="unit">мм</span>\n                    </div>\n                </div>\n            `}\n\n            <div class="property-row">\n                <div class="btn-group-vertical" style="width: 100%;">\n                    <button class="btn btn-success" id="previewChamfer">\n                        <i class="fas fa-eye"></i> Показать предпросмотр\n                    </button>\n                    <button class="btn btn-primary" id="applyChamfer">\n                        <i class="fas fa-check"></i> Применить фаску\n                    </button>\n                    <button class="btn btn-danger" id="cancelChamfer">\n                        <i class="fas fa-times"></i> Отменить операцию\n                    </button>\n                </div>\n            </div>\n\n            <div class="property-row" style="margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd;">\n                <label>Дополнительные настройки:</label>\n            </div>\n\n            <div class="property-row">\n                <label>Автопредпросмотр:</label>\n                <input type="checkbox" id="autoPreview" ${this.autoPreview?"checked":""}>\n            </div>\n\n            <div class="property-row">\n                <label>Режим отладки:</label>\n                <input type="checkbox" id="debugMode" ${this.debugMode?"checked":""}>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#chamferType");e&&e.addEventListener("change",e=>{this.chamferType=e.target.value,this.updatePropertiesUI(),this.editor.showStatus("Тип фаски: "+("distance-angle"===this.chamferType?"Расстояние-Угол":"Расстояние-Расстояние"),"info")});const t=this.propertiesElement.querySelector("#chamferSize");t&&t.addEventListener("input",e=>{this.chamferSize=parseFloat(e.target.value),this.autoPreview&&this.selectedEdges.size>0&&this.updatePreview(),this.editor.showStatus(`Размер фаски: ${this.chamferSize} мм`,"info")});const r=this.propertiesElement.querySelector("#chamferAngle");r&&r.addEventListener("input",e=>{this.chamferAngle=parseFloat(e.target.value),this.autoPreview&&this.selectedEdges.size>0&&this.updatePreview(),this.editor.showStatus(`Угол фаски: ${this.chamferAngle}°`,"info")});const i=this.propertiesElement.querySelector("#secondDistance");i&&i.addEventListener("input",e=>{this.secondDistance=parseFloat(e.target.value),this.autoPreview&&this.selectedEdges.size>0&&this.updatePreview(),this.editor.showStatus(`Второе расстояние: ${this.secondDistance} мм`,"info")}),document.getElementById("previewChamfer").addEventListener("click",()=>{this.showPreview()}),document.getElementById("applyChamfer").addEventListener("click",()=>{this.applyChamfer()}),document.getElementById("cancelChamfer").addEventListener("click",()=>{this.cleanup(),this.editor.toolManager.setCurrentTool("select")});const s=this.propertiesElement.querySelector("#autoPreview");s&&s.addEventListener("change",e=>{this.autoPreview=e.target.checked,this.editor.showStatus("Автопредпросмотр: "+(this.autoPreview?"ВКЛ":"ВЫКЛ"),"info")});const o=this.propertiesElement.querySelector("#debugMode");o&&o.addEventListener("change",e=>{this.debugMode=e.target.checked,this.editor.showStatus("Режим отладки: "+(this.debugMode?"ВКЛ":"ВЫКЛ"),"info")})}updatePropertiesUI(){if(!this.propertiesElement)return;const e=this.getPropertiesHTML();this.propertiesElement.innerHTML=e,this.bindPropertiesEvents()}onMouseDown(e){if(0!==e.button)return!1;return!!super.onMouseDown(e)&&(this.updateSelectionStatus(),this.autoPreview&&this.selectedEdges.size>0&&setTimeout(()=>this.showPreview(),50),!0)}onMouseMove(e){if(super.onMouseMove(e),this.currentIntersection){const e=this.currentIntersection.point;document.getElementById("coords").textContent=`X: ${e.x.toFixed(2)}, Y: ${e.y.toFixed(2)}, Z: ${e.z.toFixed(2)}`}return!0}onKeyDown(e){return"Escape"===e.key&&(this.cleanup(),this.editor.toolManager.setCurrentTool("select"),!0)}showPreview(){if(0===this.selectedEdges.size)return void this.editor.showStatus("Сначала выберите рёбра для фаски","warning");this.mode="preview",this.previewGeometry&&(this.previewGeometry.parent&&this.previewGeometry.parent.remove(this.previewGeometry),this.previewGeometry.geometry&&this.previewGeometry.geometry.dispose(),this.previewGeometry.material&&this.previewGeometry.material.dispose());const e=this.createChamferPreview();e?(this.previewGeometry=e,this.editor.scene.add(e),this.editor.showStatus('Предпросмотр фаски. Нажмите "Применить" для создания',"info")):this.editor.showStatus("Не удалось создать предпросмотр фаски","error")}createChamferPreview(){if(!this.originalObject)return null;const e=Array.from(this.selectedEdges).map(e=>this.edgeMap.get(e));if(0===e.length)return null;const t=new THREE.Group;return t.userData.isPreview=!0,t.userData.tool="chamfer",e.forEach(e=>{const r=this.createChamferVisualization(e);r&&t.add(r)}),t}createChamferVisualization(e){const t=e.start.clone(),r=e.end.clone(),i=t.distanceTo(r);if(i<.001)return null;const s=this.findAdjacentFaceNormals(e,this.originalObject);if(s.length<2)return null;let o,n;if("distance-angle"===this.chamferType){const e=THREE.MathUtils.degToRad(this.chamferAngle),t=Math.abs(this.chamferSize/Math.tan(e));t>100||!isFinite(t)?(o=s[0].clone().multiplyScalar(this.chamferSize),n=s[1].clone().multiplyScalar(this.chamferSize)):(o=s[0].clone().multiplyScalar(t),n=s[1].clone().multiplyScalar(t))}else o=s[0].clone().multiplyScalar(this.chamferSize),n=s[1].clone().multiplyScalar(this.secondDistance);const a=(new THREE.BufferGeometry).setFromPoints([t.clone(),t.clone().add(o)]),l=(new THREE.BufferGeometry).setFromPoints([t.clone(),t.clone().add(n)]),c=(new THREE.BufferGeometry).setFromPoints([t.clone(),t.clone().add(o).add(n).multiplyScalar(.5)]),h=new THREE.LineBasicMaterial({color:16746496,linewidth:2,transparent:!0,opacity:.8}),d=new THREE.Line(a,h),u=new THREE.Line(l,h),p=new THREE.Line(c,h.clone());p.material.color.set(65280);const m=[],g=Math.max(3,Math.min(10,Math.floor(i/5)));for(let e=0;e<=g;e++){const i=e/g,s=t.clone().lerp(r,i);m.push(s)}const f=(new THREE.BufferGeometry).setFromPoints(m),y=new THREE.LineDashedMaterial({color:16746496,linewidth:1,dashSize:2,gapSize:1,transparent:!0,opacity:.5}),b=new THREE.Line(f,y);b.computeLineDistances();const E=new THREE.Group;return E.add(d),E.add(u),E.add(p),E.add(b),E}findAdjacentFaceNormals(e,t){const r=[],i=t.geometry;if(!i||!i.attributes.position)return r;const s=i.attributes.position.array,o=t.matrixWorld;if(i.index){const t=i.index.array;for(let i=0;i<t.length;i+=3){const n=t[i],a=t[i+1],l=t[i+2],c=new THREE.Vector3(s[3*n],s[3*n+1],s[3*n+2]).applyMatrix4(o),h=new THREE.Vector3(s[3*a],s[3*a+1],s[3*a+2]).applyMatrix4(o),d=new THREE.Vector3(s[3*l],s[3*l+1],s[3*l+2]).applyMatrix4(o);if(this.faceContainsEdge(c,h,d,e.start,e.end,.01)){const e=(new THREE.Vector3).crossVectors(h.clone().sub(c),d.clone().sub(c)).normalize();if(!this.isVectorValid(e))continue;if(r.some(t=>t.angleTo(e)<.01)||r.push(e),r.length>=2)break}}}else for(let t=0;t<s.length;t+=9){const i=new THREE.Vector3(s[t],s[t+1],s[t+2]).applyMatrix4(o),n=new THREE.Vector3(s[t+3],s[t+4],s[t+5]).applyMatrix4(o),a=new THREE.Vector3(s[t+6],s[t+7],s[t+8]).applyMatrix4(o);if(this.faceContainsEdge(i,n,a,e.start,e.end,.01)){const e=(new THREE.Vector3).crossVectors(n.clone().sub(i),a.clone().sub(i)).normalize();if(!this.isVectorValid(e))continue;if(r.some(t=>t.angleTo(e)<.01)||r.push(e),r.length>=2)break}}return r}isVectorValid(e){return!isNaN(e.x)&&!isNaN(e.y)&&!isNaN(e.z)&&isFinite(e.x)&&isFinite(e.y)&&isFinite(e.z)}faceContainsEdge(e,t,r,i,s,o=.01){const n=[[e,t],[t,r],[r,e]];for(const[e,t]of n)if(e.distanceTo(i)<o&&t.distanceTo(s)<o||e.distanceTo(s)<o&&t.distanceTo(i)<o)return!0;return!1}updatePreview(){this.previewGeometry&&(this.previewGeometry.parent&&this.previewGeometry.parent.remove(this.previewGeometry),this.previewGeometry.geometry&&this.previewGeometry.geometry.dispose(),this.previewGeometry.material&&this.previewGeometry.material.dispose(),this.previewGeometry=null),this.selectedEdges.size>0&&this.showPreview()}applyChamfer(){if(0!==this.selectedEdges.size)if(this.originalObject)if(this.csgAvailable){this.editor.showStatus("Создание фаски с помощью булевых операций...","info");try{const e=this.createChamferWithCSG();e?(this.saveToHistory(this.originalObject,e),this.replaceObjectInScene(this.originalObject,e),this.editor.showStatus(`Фаска создана на ${this.selectedEdges.size} рёбрах с помощью three-bvh-csg`,"success")):this.editor.showStatus("Не удалось создать фаску","error")}catch(e){console.error("Chamfer error:",e),this.editor.showStatus(`Ошибка создания фаски: ${e.message}`,"error")}finally{this.cleanup(),this.editor.toolManager.setCurrentTool("select")}}else this.editor.showStatus("Библиотека three-bvh-csg не загружена","error");else this.editor.showStatus("Не удалось найти исходный объект","error");else this.editor.showStatus("Не выбраны рёбра для фаски","error")}createChamferWithCSG(){if(!this.originalObject||!this.originalGeometry)return null;const e=this.createChamferWedge();if(!e)return this.editor.showStatus("Не удалось создать геометрию фаски","error"),null;try{const t=this.prepareObjectForCSG(this.originalObject),r=this.prepareObjectForCSG(e);if(!t||!r)return this.editor.showStatus("Ошибка подготовки объектов для CSG операции","error"),null;console.log("Выполнение CSG операции вычитания для создания фаски...");const i=this.evaluator.evaluate(t,r,this.operations.SUBTRACTION),s=new THREE.Mesh(i.geometry);this.originalObject.material&&(Array.isArray(this.originalObject.material)?s.material=this.originalObject.material.map(e=>e.clone()):s.material=this.originalObject.material.clone()),s.userData={...this.originalObject.userData},s.userData.hasChamfer=!0,s.userData.chamferSize=this.chamferSize,s.userData.chamferAngle=this.chamferAngle,s.userData.chamferEdges=Array.from(this.selectedEdges),s.userData.chamferType=this.chamferType,s.userData.createdWith="three-bvh-csg";try{s.geometry.computeVertexNormals(),s.geometry.computeBoundingBox(),s.geometry.computeBoundingSphere()}catch(e){console.warn("Ошибка при вычислении свойств геометрии:",e),s.geometry=(new THREE.BufferGeometry).fromGeometry((new THREE.Geometry).fromBufferGeometry(s.geometry))}return s}catch(e){return console.error("Ошибка CSG операции:",e),null}}prepareObjectForCSG(e){if(!e||!e.geometry)return console.error("Объект не содержит geometry"),null;try{const t=e.geometry.clone();if(!t.attributes.position)return console.error("Геометрия не имеет атрибута position"),null;const r=t.attributes.position.array;for(let e=0;e<r.length;e++)if(isNaN(r[e]))return console.error(`Найден NaN в позиции вершины [${e}]:`,r[e]),null;if(t.attributes.normal&&0!==t.attributes.normal.count||t.computeVertexNormals(),!t.attributes.uv||0===t.attributes.uv.count){const e=t.attributes.position.count,r=new Float32Array(2*e);for(let t=0;t<e;t++)r[2*t]=t%10/10,r[2*t+1]=Math.floor(t/10)/10;t.setAttribute("uv",new THREE.BufferAttribute(r,2))}const i=e.material?e.material.clone():new THREE.MeshStandardMaterial,s=new this.operations.Brush(t,i);return s.position.copy(e.position),s.rotation.copy(e.rotation),s.scale.copy(e.scale),s.updateMatrixWorld(),s}catch(e){return console.error("Ошибка подготовки объекта для CSG:",e),null}}createChamferWedge(){const e=Array.from(this.selectedEdges).map(e=>this.edgeMap.get(e));if(0===e.length)return null;const t=new THREE.Group;if(e.forEach(e=>{const r=this.createSingleEdgeWedge(e);r&&t.add(r)}),0===t.children.length)return null;if(1===t.children.length)return t.children[0];try{const e=new THREE.BufferGeometry,r=[],i=[],s=[],o=[];let n=0;t.children.forEach(e=>{const t=e.geometry,a=t.attributes.position.array;for(let e=0;e<a.length;e+=3)r.push(a[e],a[e+1],a[e+2]);if(t.attributes.normal){const e=t.attributes.normal.array;for(let t=0;t<e.length;t+=3)s.push(e[t],e[t+1],e[t+2])}if(t.attributes.uv){const e=t.attributes.uv.array;for(let t=0;t<e.length;t+=2)o.push(e[t],e[t+1])}if(t.index){const e=t.index.array;for(let t=0;t<e.length;t++)i.push(e[t]+n)}n+=a.length/3}),e.setAttribute("position",new THREE.BufferAttribute(new Float32Array(r),3)),s.length===r.length&&e.setAttribute("normal",new THREE.BufferAttribute(new Float32Array(s),3)),o.length===2*r.length/3&&e.setAttribute("uv",new THREE.BufferAttribute(new Float32Array(o),2)),i.length>0&&e.setIndex(new THREE.BufferAttribute(new Uint32Array(i),1));const a=new THREE.MeshStandardMaterial({color:16711680,transparent:!0,opacity:.7,side:THREE.DoubleSide}),l=new THREE.Mesh(e,a);try{l.geometry.computeBoundingBox(),l.geometry.computeBoundingSphere()}catch(e){console.warn("Ошибка при вычислении bounding volume:",e)}return l}catch(e){return console.error("Ошибка объединения геометрий клиньев:",e),t.children[0]}}createSingleEdgeWedge(e){const t=e.start.clone(),r=e.end.clone(),i=r.clone().sub(t),s=i.length();i.clone().normalize();if(s<.001)return null;const o=this.findAdjacentFaceNormals(e,this.originalObject);if(o.length<2)return null;let n,a;if("distance-angle"===this.chamferType){const e=THREE.MathUtils.degToRad(this.chamferAngle),t=Math.tan(e);Math.abs(t)<.001?(n=this.chamferSize,a=this.chamferSize):(n=Math.abs(this.chamferSize/t),a=n);const r=100;n=Math.min(n,r),a=Math.min(a,r)}else n=this.chamferSize,a=this.secondDistance;const l=[],c=[t,t.clone().add(o[0].clone().multiplyScalar(n)),t.clone().add(o[1].clone().multiplyScalar(a)),r,r.clone().add(o[0].clone().multiplyScalar(n)),r.clone().add(o[1].clone().multiplyScalar(a))];for(const e of c){if(!this.isVectorValid(e))return console.error("Некорректная вершина в клине:",e),null;l.push(e.x,e.y,e.z)}const h=new THREE.BufferGeometry;h.setAttribute("position",new THREE.BufferAttribute(new Float32Array(l),3));h.setIndex(new THREE.BufferAttribute(new Uint32Array([0,2,1,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),1));try{h.computeVertexNormals()}catch(e){console.error("Ошибка вычисления нормалей:",e);const t=new Float32Array(l.length);for(let e=0;e<t.length;e+=3)t[e]=0,t[e+1]=1,t[e+2]=0;h.setAttribute("normal",new THREE.BufferAttribute(t,3))}const d=l.length/3,u=new Float32Array(2*d);for(let e=0;e<d;e++)u[2*e]=e%3/3,u[2*e+1]=Math.floor(e/3)/2;h.setAttribute("uv",new THREE.BufferAttribute(u,2));try{h.computeBoundingBox(),h.computeBoundingSphere()}catch(e){console.error("Ошибка при вычислении bounding volume:",e),h.boundingBox=(new THREE.Box3).setFromArray(l),h.boundingSphere=new THREE.Sphere,h.boundingBox.getCenter(h.boundingSphere.center),h.boundingSphere.radius=h.boundingBox.getSize(new THREE.Vector3).length()/2}const p=new THREE.MeshStandardMaterial({color:16711680,transparent:!0,opacity:.7,side:THREE.DoubleSide});return new THREE.Mesh(h,p)}replaceObjectInScene(e,t){if(e&&t)try{this.editor.objectsManager.unhighlightObject(e),this.editor.objectsGroup.remove(e);const r=this.editor.objects.indexOf(e);r>-1&&this.editor.objects.splice(r,1),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectedObjects=[t],this.editor.objectsManager.highlightObject(t),this.editor.objectsManager.updateSceneStats(),this.editor.objectsManager.updateSceneList()}catch(e){console.error("Ошибка при замене объекта:",e),this.editor.showStatus("Ошибка при создании фаски","error")}}saveToHistory(e,t){if(!e||!t)return;const r=this.editor.projectManager.serializeObjectForHistory(e),i=this.editor.projectManager.serializeObjectForHistory(t);this.editor.history.addAction({type:"modify_chamfer_csg",objects:[{uuid:e.uuid,data:r},{uuid:t.uuid,data:i}],parameters:{size:this.chamferSize,angle:this.chamferAngle,secondDistance:this.secondDistance,type:this.chamferType,edges:Array.from(this.selectedEdges),method:"three-bvh-csg"}})}cleanup(){super.cleanup(),this.removePropertiesSection(),this.previewGeometry&&(this.previewGeometry.parent&&this.previewGeometry.parent.remove(this.previewGeometry),this.previewGeometry.geometry&&this.previewGeometry.geometry.dispose(),this.previewGeometry.material&&this.previewGeometry.material.dispose(),this.previewGeometry=null),this.edgeMap.clear(),this.mode="select",this.originalObject=null,this.originalGeometry=null,this.originalVertices=null}}