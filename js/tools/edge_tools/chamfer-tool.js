class ChamferTool extends EdgeToolBase{constructor(e){super("chamfer","fa-angle-double-right",e),this.chamferSize=5,this.chamferAngle=45,this.mode="select",this.previewGeometry=null,this.edgeMap=new Map,this.debugMode=!1,this.autoPreview=!0,this.chamferType="distance-angle",this.secondDistance=5,this.originalObject=null,this.originalGeometry=null,this.originalVertices=null,this.csgAvailable="undefined"!=typeof THREE_BVH_CSG,this.csgAvailable&&(this.evaluator=new THREE_BVH_CSG.Evaluator,this.operations=THREE_BVH_CSG),this.wedgePreview=null,this.wireframePreview=null}onActivate(){if(this.canActivate()){if(1!==this.editor.selectedObjects.length)return this.editor.showStatus("Для создания фаски выберите один объект","error"),void this.editor.toolManager.restorePreviousTool();if(this.originalObject=this.editor.selectedObjects[0],"work_plane"===this.originalObject.userData.type||"sketch_plane"===this.originalObject.userData.type)return this.editor.showStatus("Нельзя создать фаску на плоскости","error"),void this.editor.toolManager.restorePreviousTool();if(!this.originalObject.geometry)return this.editor.showStatus("Объект не имеет геометрии","error"),void this.editor.toolManager.restorePreviousTool();if(!this.csgAvailable)return this.editor.showStatus("Библиотека three-bvh-csg не загружена. Фаска через булевы операции недоступна.","error"),void this.editor.toolManager.restorePreviousTool();this.originalGeometry=this.originalObject.geometry.clone(),this.originalVertices=this.extractVertices(this.originalGeometry),this.mode="select",this.selectedEdges.clear(),this.edgeMap.clear(),this.extractAndMapEdges(this.originalObject),this.setupSelectionUI(),this.createPropertiesSection(),this.editor.showStatus("Выберите рёбра для фаски. Используется метод булевых операций.","info")}else this.editor.toolManager.restorePreviousTool()}onDeactivate(){this.cleanup(),this.removePropertiesSection(),document.body.style.cursor="default"}extractVertices(e){const t=e.attributes.position.array,i=[];for(let e=0;e<t.length;e+=3)i.push(new THREE.Vector3(t[e],t[e+1],t[e+2]));return i}setupSelectionUI(){if(!document.getElementById("propertiesContent"))return;const e=document.querySelector('.property-group[data-tool="chamfer"]');if(!e)return;const t=document.createElement("div");t.className="edge-selection-toolbar",t.innerHTML=`\n            <div class="property-row">\n                <label style="font-weight: bold;">Режим выбора рёбер:</label>\n            </div>\n            <div class="property-row">\n                <div class="btn-group" style="width: 100%;">\n                    <button class="btn btn-sm btn-outline-secondary edge-mode-btn ${"single"===this.edgeSelectionMode?"active":""}"\n                            data-mode="single" title="Одиночный выбор">\n                        <i class="fas fa-mouse-pointer"></i> Один\n                    </button>\n                    <button class="btn btn-sm btn-outline-secondary edge-mode-btn ${"chain"===this.edgeSelectionMode?"active":""}"\n                            data-mode="chain" title="Выбор цепочки">\n                        <i class="fas fa-link"></i> Цепочка\n                    </button>\n                    <button class="btn btn-sm btn-outline-secondary edge-mode-btn ${"loop"===this.edgeSelectionMode?"active":""}"\n                            data-mode="loop" title="Выбор петли">\n                        <i class="fas fa-sync-alt"></i> Петля\n                    </button>\n                </div>\n            </div>\n            <div class="property-row">\n                <button class="btn btn-sm btn-danger" id="clearSelectedEdges" style="width: 100%;" title="Очистить выбор">\n                    <i class="fas fa-times"></i> Очистить выбранные рёбра\n                </button>\n            </div>\n            <div class="property-row">\n                <div class="selection-info">\n                    <i class="fas fa-info-circle"></i>\n                    <span>Выбрано рёбер: <span id="edgeCount">0</span></span>\n                </div>\n            </div>\n        `;const i=e.querySelector("h4");i&&i.parentNode.insertBefore(t,i.nextSibling),t.querySelectorAll(".edge-mode-btn").forEach(e=>{e.addEventListener("click",e=>{const i=e.currentTarget.dataset.mode;this.edgeSelectionMode=i,t.querySelectorAll(".edge-mode-btn").forEach(e=>{e.classList.remove("active")}),e.currentTarget.classList.add("active"),this.updateSelectionStatus()})}),document.getElementById("clearSelectedEdges").addEventListener("click",()=>{this.selectedEdges.clear(),this.cleanupVisualization(),this.updateSelectionStatus(),this.editor.showStatus("Выбор рёбер очищен","info")}),this.updateSelectionStatus()}updateSelectionStatus(){const e=document.getElementById("edgeCount");e&&(e.textContent=this.selectedEdges.size);const t={single:"Одиночный выбор рёбер. Кликните по рёбрам для выбора",chain:"Выбор цепочки. Кликните по ребру для выбора смежных рёбер",loop:"Выбор петли. Кликните по ребру для выбора замкнутого контура"};"select"===this.mode&&this.editor.showStatus(`${t[this.edgeSelectionMode]}. Выбрано рёбер: ${this.selectedEdges.size}`,"info")}extractAndMapEdges(e){this.extractAllEdges(e).forEach(e=>{this.edgeMap.set(e.key,e)})}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","chamfer"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="chamfer"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){const e="distance-angle"===this.chamferType;return`\n            <h4><i class="fas fa-angle-double-right"></i> ФАСКА НА РЁБРАХ (three-bvh-csg)</h4>\n            <div class="property-row" style="margin-bottom: 15px;">\n                <div class="alert alert-info" style="margin: 0; padding: 8px; font-size: 0.9em;">\n                    <i class="fas fa-info-circle"></i> Используется метод булевых операций для точного создания фаски\n                </div>\n            </div>\n\n            <div class="property-row">\n                <label>Тип фаски:</label>\n                <select id="chamferType" class="property-select">\n                    <option value="distance-angle" ${e?"selected":""}>Расстояние-Угол</option>\n                    <option value="distance-distance" ${e?"":"selected"}>Расстояние-Расстояние</option>\n                </select>\n            </div>\n\n            <div class="property-row">\n                <label>${e?"Расстояние:":"Первое расстояние:"}</label>\n                <div class="input-with-unit">\n                    <input type="number" id="chamferSize" value="${this.chamferSize}" min="0.1" max="100" step="0.1" class="property-input">\n                    <span class="unit">мм</span>\n                </div>\n            </div>\n\n            ${e?`\n                <div class="property-row">\n                    <label>Угол фаски:</label>\n                    <div class="input-with-unit">\n                        <input type="number" id="chamferAngle" value="${this.chamferAngle}" min="1" max="89" step="1" class="property-input">\n                        <span class="unit">°</span>\n                    </div>\n                </div>\n            `:`\n                <div class="property-row">\n                    <label>Второе расстояние:</label>\n                    <div class="input-with-unit">\n                        <input type="number" id="secondDistance" value="${this.secondDistance}" min="0.1" max="100" step="0.1" class="property-input">\n                        <span class="unit">мм</span>\n                    </div>\n                </div>\n            `}\n\n            <div class="property-row">\n                <div class="btn-group-vertical" style="width: 100%;">\n                    <button class="btn btn-success" id="previewChamfer">\n                        <i class="fas fa-eye"></i> Показать предпросмотр\n                    </button>\n                    <button class="btn btn-primary" id="applyChamfer">\n                        <i class="fas fa-check"></i> Применить фаску\n                    </button>\n                    <button class="btn btn-danger" id="cancelChamfer">\n                        <i class="fas fa-times"></i> Отменить операцию\n                    </button>\n                </div>\n            </div>\n\n            <div class="property-row" style="margin-top: 20px; padding-top: 10px; border-top: 1px solid #ddd;">\n                <label>Дополнительные настройки:</label>\n            </div>\n\n            <div class="property-row">\n                <label>Автопредпросмотр:</label>\n                <input type="checkbox" id="autoPreview" ${this.autoPreview?"checked":""}>\n            </div>\n\n            <div class="property-row">\n                <label>Режим отладки:</label>\n                <input type="checkbox" id="debugMode" ${this.debugMode?"checked":""}>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#chamferType");e&&e.addEventListener("change",e=>{this.chamferType=e.target.value,this.updatePropertiesUI(),this.editor.showStatus("Тип фаски: "+("distance-angle"===this.chamferType?"Расстояние-Угол":"Расстояние-Расстояние"),"info")});const t=this.propertiesElement.querySelector("#chamferSize");t&&t.addEventListener("input",e=>{this.chamferSize=parseFloat(e.target.value),this.autoPreview&&this.selectedEdges.size>0&&this.updatePreview(),this.editor.showStatus(`Размер фаски: ${this.chamferSize} мм`,"info")});const i=this.propertiesElement.querySelector("#chamferAngle");i&&i.addEventListener("input",e=>{this.chamferAngle=parseFloat(e.target.value),this.autoPreview&&this.selectedEdges.size>0&&this.updatePreview(),this.editor.showStatus(`Угол фаски: ${this.chamferAngle}°`,"info")});const r=this.propertiesElement.querySelector("#secondDistance");r&&r.addEventListener("input",e=>{this.secondDistance=parseFloat(e.target.value),this.autoPreview&&this.selectedEdges.size>0&&this.updatePreview(),this.editor.showStatus(`Второе расстояние: ${this.secondDistance} мм`,"info")}),document.getElementById("previewChamfer").addEventListener("click",()=>{this.showPreview()}),document.getElementById("applyChamfer").addEventListener("click",()=>{this.applyChamfer()}),document.getElementById("cancelChamfer").addEventListener("click",()=>{this.cleanup(),this.editor.toolManager.setCurrentTool("select")});const s=this.propertiesElement.querySelector("#autoPreview");s&&s.addEventListener("change",e=>{this.autoPreview=e.target.checked,this.editor.showStatus("Автопредпросмотр: "+(this.autoPreview?"ВКЛ":"ВЫКЛ"),"info")});const o=this.propertiesElement.querySelector("#debugMode");o&&o.addEventListener("change",e=>{this.debugMode=e.target.checked,this.editor.showStatus("Режим отладки: "+(this.debugMode?"ВКЛ":"ВЫКЛ"),"info")})}updatePropertiesUI(){if(!this.propertiesElement)return;const e=this.getPropertiesHTML();this.propertiesElement.innerHTML=e,this.bindPropertiesEvents()}onMouseDown(e){if(0!==e.button)return!1;return!!super.onMouseDown(e)&&(this.updateSelectionStatus(),this.autoPreview&&this.selectedEdges.size>0&&setTimeout(()=>this.showPreview(),50),!0)}onMouseMove(e){if(super.onMouseMove(e),this.currentIntersection){const e=this.currentIntersection.point;document.getElementById("coords").textContent=`X: ${e.x.toFixed(2)}, Y: ${e.y.toFixed(2)}, Z: ${e.z.toFixed(2)}`}return!0}onKeyDown(e){return"Escape"===e.key&&(this.cleanup(),this.editor.toolManager.setCurrentTool("select"),!0)}showPreview(){if(0===this.selectedEdges.size)return void this.editor.showStatus("Сначала выберите рёбра для фаски","warning");this.mode="preview",this.previewGeometry&&(this.previewGeometry.parent&&this.previewGeometry.parent.remove(this.previewGeometry),this.previewGeometry.geometry&&this.previewGeometry.geometry.dispose(),this.previewGeometry.material&&this.previewGeometry.material.dispose());const e=this.createChamferPreview();e?(this.previewGeometry=e,this.editor.scene.add(e),this.editor.showStatus('Предпросмотр фаски. Нажмите "Применить" для создания',"info")):this.editor.showStatus("Не удалось создать предпросмотр фаски","error")}createChamferPreview(){if(!this.originalObject)return null;const e=Array.from(this.selectedEdges).map(e=>this.edgeMap.get(e));if(0===e.length)return null;const t=new THREE.Group;return t.userData.isPreview=!0,t.userData.tool="chamfer",e.forEach(e=>{const i=this.createChamferVisualization(e);i&&t.add(i)}),t}createChamferVisualization(e){const t=e.start.clone(),i=e.end.clone(),r=t.distanceTo(i);if(r<.001)return null;const s=this.findAdjacentFaceNormals(e,this.originalObject);if(s.length<2)return null;const o=this.isConvexAngle(s[0],s[1],e);let n,a;if("distance-angle"===this.chamferType){const e=THREE.MathUtils.degToRad(this.chamferAngle),t=Math.abs(this.chamferSize/Math.tan(e));t>100||!isFinite(t)?(n=s[0].clone().multiplyScalar(this.chamferSize),a=s[1].clone().multiplyScalar(this.chamferSize)):(n=s[0].clone().multiplyScalar(t),a=s[1].clone().multiplyScalar(t))}else n=s[0].clone().multiplyScalar(this.chamferSize),a=s[1].clone().multiplyScalar(this.secondDistance);o&&(n.negate(),a.negate());const l=(new THREE.BufferGeometry).setFromPoints([t.clone(),t.clone().add(n)]),c=(new THREE.BufferGeometry).setFromPoints([t.clone(),t.clone().add(a)]),h=(new THREE.BufferGeometry).setFromPoints([t.clone(),t.clone().add(n).add(a).multiplyScalar(.5)]),d=o?16746496:35071,u=new THREE.LineBasicMaterial({color:d,linewidth:2,transparent:!0,opacity:.8}),p=new THREE.Line(l,u),m=new THREE.Line(c,u),g=new THREE.Line(h,u.clone());g.material.color.set(65280);const w=[],f=Math.max(3,Math.min(10,Math.floor(r/5)));for(let e=0;e<=f;e++){const r=e/f,s=t.clone().lerp(i,r);w.push(s)}const v=(new THREE.BufferGeometry).setFromPoints(w),y=new THREE.LineDashedMaterial({color:d,linewidth:1,dashSize:2,gapSize:1,transparent:!0,opacity:.5}),b=new THREE.Line(v,y);b.computeLineDistances();const E=new THREE.Group;if(E.add(p),E.add(m),E.add(g),E.add(b),this.debugMode){const e=s[0].dot(s[1]),t=180*Math.acos(Math.min(1,Math.max(-1,e)))/Math.PI;E.userData.edgeType=o?"выпуклый":"вогнутый",E.userData.angle=t.toFixed(1)}return E}findAdjacentFaceNormals(e,t){const i=[],r=t.geometry;if(!r||!r.attributes.position)return i;const s=r.attributes.position.array,o=t.matrixWorld;if(r.index){const t=r.index.array;for(let r=0;r<t.length;r+=3){const n=t[r],a=t[r+1],l=t[r+2],c=new THREE.Vector3(s[3*n],s[3*n+1],s[3*n+2]).applyMatrix4(o),h=new THREE.Vector3(s[3*a],s[3*a+1],s[3*a+2]).applyMatrix4(o),d=new THREE.Vector3(s[3*l],s[3*l+1],s[3*l+2]).applyMatrix4(o);if(this.faceContainsEdge(c,h,d,e.start,e.end,.01)){const e=(new THREE.Vector3).crossVectors(h.clone().sub(c),d.clone().sub(c)).normalize();if(!this.isVectorValid(e))continue;if(i.some(t=>t.angleTo(e)<.01)||i.push(e),i.length>=2)break}}}else for(let t=0;t<s.length;t+=9){const r=new THREE.Vector3(s[t],s[t+1],s[t+2]).applyMatrix4(o),n=new THREE.Vector3(s[t+3],s[t+4],s[t+5]).applyMatrix4(o),a=new THREE.Vector3(s[t+6],s[t+7],s[t+8]).applyMatrix4(o);if(this.faceContainsEdge(r,n,a,e.start,e.end,.01)){const e=(new THREE.Vector3).crossVectors(n.clone().sub(r),a.clone().sub(r)).normalize();if(!this.isVectorValid(e))continue;if(i.some(t=>t.angleTo(e)<.01)||i.push(e),i.length>=2)break}}return i}isConvexAngle(e,t,i){i.end.clone().sub(i.start).normalize();const r=e.clone().add(t).normalize(),s=new THREE.Vector3;this.originalObject.getWorldPosition(s);const o=i.start.clone().sub(s).normalize();return r.dot(o)>0}isVectorValid(e){return!isNaN(e.x)&&!isNaN(e.y)&&!isNaN(e.z)&&isFinite(e.x)&&isFinite(e.y)&&isFinite(e.z)}faceContainsEdge(e,t,i,r,s,o=.01){const n=[[e,t],[t,i],[i,e]];for(const[e,t]of n)if(e.distanceTo(r)<o&&t.distanceTo(s)<o||e.distanceTo(s)<o&&t.distanceTo(r)<o)return!0;return!1}updatePreview(){this.previewGeometry&&(this.previewGeometry.parent&&this.previewGeometry.parent.remove(this.previewGeometry),this.previewGeometry.geometry&&this.previewGeometry.geometry.dispose(),this.previewGeometry.material&&this.previewGeometry.material.dispose(),this.previewGeometry=null),this.selectedEdges.size>0&&this.showPreview()}applyChamfer(){if(0!==this.selectedEdges.size)if(this.originalObject)if(this.csgAvailable){this.editor.showStatus("Создание фаски с помощью булевых операций...","info");try{const e=this.createChamferWithCSG();e?(this.saveToHistory(this.originalObject,e),this.replaceObjectInScene(this.originalObject,e),this.editor.showStatus(`Фаска создана на ${this.selectedEdges.size} рёбрах с помощью three-bvh-csg`,"success")):this.editor.showStatus("Не удалось создать фаску","error")}catch(e){console.error("Chamfer error:",e),this.editor.showStatus(`Ошибка создания фаски: ${e.message}`,"error")}finally{this.cleanup(),this.editor.toolManager.setCurrentTool("select")}}else this.editor.showStatus("Библиотека three-bvh-csg не загружена","error");else this.editor.showStatus("Не удалось найти исходный объект","error");else this.editor.showStatus("Не выбраны рёбра для фаски","error")}createChamferWithCSG(){if(!this.originalObject||!this.originalGeometry)return null;const e=this.createChamferWedge();if(!e)return this.editor.showStatus("Не удалось создать геометрию фаски","error"),null;this.debugMode&&(this.showWedgePreview(e),this.showWireframePreview(this.originalObject));try{const t=this.prepareObjectForCSG(this.originalObject,!1),i=this.prepareObjectForCSG(e,!0);if(!t||!i)return this.editor.showStatus("Ошибка подготовки объектов для CSG операции","error"),null;console.log("Выполнение CSG операции вычитания для создания фаски...");const r=this.evaluator.evaluate(t,i,this.operations.SUBTRACTION),s=new THREE.Mesh(r.geometry);this.originalObject.material&&(Array.isArray(this.originalObject.material)?s.material=this.originalObject.material.map(e=>e.clone()):s.material=this.originalObject.material.clone()),s.position.copy(this.originalObject.position),s.rotation.copy(this.originalObject.rotation),s.scale.copy(this.originalObject.scale),s.updateMatrixWorld(),s.userData={...this.originalObject.userData},s.userData.hasChamfer=!0,s.userData.chamferSize=this.chamferSize,s.userData.chamferAngle=this.chamferAngle,s.userData.chamferEdges=Array.from(this.selectedEdges),s.userData.chamferType=this.chamferType,s.userData.createdWith="three-bvh-csg";try{s.geometry.computeVertexNormals(),s.geometry.computeBoundingBox(),s.geometry.computeBoundingSphere()}catch(e){console.warn("Ошибка при вычислении свойств геометрии:",e)}return s}catch(e){return console.error("Ошибка CSG операции:",e),null}}prepareObjectForCSG(e,t=!1){if(!e||!e.geometry)return console.error("Объект не содержит geometry"),null;try{const i=e.geometry.clone();if(t||i.applyMatrix4(e.matrixWorld),!i.attributes.position)return console.error("Геометрия не имеет атрибута position"),null;const r=i.attributes.position.array;for(let e=0;e<r.length;e++)if(isNaN(r[e]))return console.error(`Найден NaN в позиции вершины [${e}]:`,r[e]),null;if(i.attributes.normal&&0!==i.attributes.normal.count||i.computeVertexNormals(),!i.attributes.uv||0===i.attributes.uv.count){const e=i.attributes.position.count,t=new Float32Array(2*e);for(let i=0;i<e;i++)t[2*i]=0,t[2*i+1]=0;i.setAttribute("uv",new THREE.BufferAttribute(t,2))}const s=e.material?e.material.clone():new THREE.MeshStandardMaterial,o=new this.operations.Brush(i,s);return o.position.set(0,0,0),o.rotation.set(0,0,0),o.scale.set(1,1,1),o.updateMatrixWorld(),o}catch(e){return console.error("Ошибка подготовки объекта для CSG:",e),null}}createChamferWedge(){const e=Array.from(this.selectedEdges).map(e=>this.edgeMap.get(e));if(0===e.length)return null;const t=[];if(e.forEach(e=>{const i=this.createSingleEdgeWedge(e);i&&t.push(i)}),0===t.length)return null;if(1===t.length)return t[0];try{const e=new THREE.BufferGeometry,i=[],r=[],s=[],o=[];let n=0;t.forEach(e=>{const t=e.geometry,a=t.attributes.position.array;for(let e=0;e<a.length;e+=3)i.push(a[e],a[e+1],a[e+2]);if(t.attributes.normal){const e=t.attributes.normal.array;for(let t=0;t<e.length;t+=3)s.push(e[t],e[t+1],e[t+2])}if(t.attributes.uv){const e=t.attributes.uv.array;for(let t=0;t<e.length;t+=2)o.push(e[t],e[t+1])}if(t.index){const e=t.index.array;for(let t=0;t<e.length;t++)r.push(e[t]+n)}n+=a.length/3}),e.setAttribute("position",new THREE.BufferAttribute(new Float32Array(i),3)),s.length===i.length&&e.setAttribute("normal",new THREE.BufferAttribute(new Float32Array(s),3)),o.length===2*i.length/3&&e.setAttribute("uv",new THREE.BufferAttribute(new Float32Array(o),2)),r.length>0&&e.setIndex(new THREE.BufferAttribute(new Uint32Array(r),1));const a=new THREE.MeshStandardMaterial({color:16711680,transparent:!0,opacity:.7,side:THREE.DoubleSide}),l=new THREE.Mesh(e,a);try{l.geometry.computeBoundingBox(),l.geometry.computeBoundingSphere()}catch(e){console.warn("Ошибка при вычислении bounding volume:",e)}return l}catch(e){return console.error("Ошибка объединения геометрий клиньев:",e),t[0]}}createSingleEdgeWedge(e){const t=e.start.clone(),i=e.end.clone(),r=i.clone().sub(t),s=r.length();r.clone().normalize();if(s<.001)return null;const o=this.findAdjacentFaceNormals(e,this.originalObject);if(o.length<2)return null;const n=this.isConvexAngle(o[0],o[1],e);let a,l;if("distance-angle"===this.chamferType){const e=THREE.MathUtils.degToRad(this.chamferAngle),t=Math.tan(e);Math.abs(t)<.001?(a=this.chamferSize,l=this.chamferSize):(a=Math.abs(this.chamferSize/t),l=a);const i=100;a=Math.min(a,i),l=Math.min(l,i)}else a=this.chamferSize,l=this.secondDistance;n||(a=-a,l=-l);const c=[],h=[t,t.clone().add(o[0].clone().multiplyScalar(a)),t.clone().add(o[1].clone().multiplyScalar(l)),i,i.clone().add(o[0].clone().multiplyScalar(a)),i.clone().add(o[1].clone().multiplyScalar(l))];for(const e of h){if(!this.isVectorValid(e))return console.error("Некорректная вершина в клине:",e),null;c.push(e.x,e.y,e.z)}const d=new THREE.BufferGeometry;d.setAttribute("position",new THREE.BufferAttribute(new Float32Array(c),3));d.setIndex(new THREE.BufferAttribute(new Uint32Array([0,1,2,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),1));try{d.computeVertexNormals()}catch(e){console.error("Ошибка вычисления нормалей:",e);const t=new Float32Array(c.length);for(let e=0;e<t.length;e+=3)t[e]=0,t[e+1]=1,t[e+2]=0;d.setAttribute("normal",new THREE.BufferAttribute(t,3))}const u=c.length/3,p=new Float32Array(2*u);for(let e=0;e<u;e++)p[2*e]=e%3/3,p[2*e+1]=Math.floor(e/3)/2;d.setAttribute("uv",new THREE.BufferAttribute(p,2));try{d.computeBoundingBox(),d.computeBoundingSphere()}catch(e){console.error("Ошибка при вычислении bounding volume:",e),d.boundingBox=(new THREE.Box3).setFromArray(c),d.boundingSphere=new THREE.Sphere,d.boundingBox.getCenter(d.boundingSphere.center),d.boundingSphere.radius=d.boundingBox.getSize(new THREE.Vector3).length()/2}const m=new THREE.MeshStandardMaterial({color:n?16746496:35071,transparent:!0,opacity:.7,side:THREE.DoubleSide}),g=new THREE.Mesh(d,m);return g.userData.isChamferWedge=!0,g.userData.edgeKey=e.key,g.userData.isConvex=n,g}showWedgePreview(e){this.wedgePreview&&(this.wedgePreview.parent&&this.wedgePreview.parent.remove(this.wedgePreview),this.wedgePreview.geometry&&this.wedgePreview.geometry.dispose(),this.wedgePreview.material&&this.wedgePreview.material.dispose());const t=e.clone();t.material=t.material.clone(),t.material.opacity=.5,t.material.wireframe=!0,t.renderOrder=999,this.editor.scene.add(t),this.wedgePreview=t,this.editor.showStatus("Предпросмотр клина для фаски","info")}showWireframePreview(e){this.wireframePreview&&(this.wireframePreview.parent&&this.wireframePreview.parent.remove(this.wireframePreview),this.wireframePreview.geometry&&this.wireframePreview.geometry.dispose(),this.wireframePreview.material&&this.wireframePreview.material.dispose());const t=e.clone();t.material=new THREE.MeshBasicMaterial({color:65280,wireframe:!0,transparent:!0,opacity:.3}),t.renderOrder=998,this.editor.scene.add(t),this.wireframePreview=t}replaceObjectInScene(e,t){if(e&&t)try{this.editor.objectsManager.unhighlightObject(e),this.editor.objectsGroup.remove(e);const i=this.editor.objects.indexOf(e);i>-1&&this.editor.objects.splice(i,1),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectedObjects=[t],this.editor.objectsManager.highlightObject(t),this.editor.objectsManager.updateSceneStats(),this.editor.objectsManager.updateSceneList()}catch(e){console.error("Ошибка при замене объекта:",e),this.editor.showStatus("Ошибка при создании фаски","error")}}saveToHistory(e,t){if(!e||!t)return;const i=this.editor.projectManager.serializeObjectForHistory(e),r=this.editor.projectManager.serializeObjectForHistory(t);this.editor.history.addAction({type:"modify_chamfer_csg",objects:[{uuid:e.uuid,data:i},{uuid:t.uuid,data:r}],parameters:{size:this.chamferSize,angle:this.chamferAngle,secondDistance:this.secondDistance,type:this.chamferType,edges:Array.from(this.selectedEdges),method:"three-bvh-csg"}})}cleanup(){super.cleanup(),this.removePropertiesSection(),this.previewGeometry&&(this.previewGeometry.parent&&this.previewGeometry.parent.remove(this.previewGeometry),this.previewGeometry.geometry&&this.previewGeometry.geometry.dispose(),this.previewGeometry.material&&this.previewGeometry.material.dispose(),this.previewGeometry=null),this.wedgePreview&&(this.wedgePreview.parent&&this.wedgePreview.parent.remove(this.wedgePreview),this.wedgePreview.geometry&&this.wedgePreview.geometry.dispose(),this.wedgePreview.material&&this.wedgePreview.material.dispose(),this.wedgePreview=null),this.wireframePreview&&(this.wireframePreview.parent&&this.wireframePreview.parent.remove(this.wireframePreview),this.wireframePreview.geometry&&this.wireframePreview.geometry.dispose(),this.wireframePreview.material&&this.wireframePreview.material.dispose(),this.wireframePreview=null),this.edgeMap.clear(),this.mode="select",this.originalObject=null,this.originalGeometry=null,this.originalVertices=null}}