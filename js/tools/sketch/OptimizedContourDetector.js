class OptimizedContourDetector{constructor(){this.segments=[],this.points=[],this.edges=[],this.contours=[],this.cacheValid=!1,this.cachedContours=null,this.elementHash="",this.minContourArea=.1,this.intersectionEpsilon=.001,this.snapPrecision=4}updateElements(e){const t=this.calculateElementsHash(e);if(t===this.elementHash&&this.cacheValid)console.log("ContourDetector: используем кэш элементов");else if(this.elementHash=t,this.cacheValid=!1,this.cachedContours=null,this.segments=[],this.points=[],this.edges=[],this.contours=[],e&&0!==e.length){for(const t of e){if(!t||!t.userData)continue;const e=this.getElementPoints(t);if(e.length<2)continue;const s=[];for(let n=0;n<e.length-1;n++){const o=e[n],i=e[n+1];o.distanceTo(i)<this.intersectionEpsilon||s.push({element:t,start:o.clone(),end:i.clone(),index:-1,isClosed:n===e.length-2&&t.userData.isClosed,elementType:t.userData.elementType})}if(t.userData.isClosed&&e.length>2){const n=e[e.length-1],o=e[0];n.distanceTo(o)>this.intersectionEpsilon&&s.push({element:t,start:n.clone(),end:o.clone(),index:-1,isClosed:!0,elementType:t.userData.elementType})}s.forEach(e=>{e.index=this.segments.length,this.segments.push(e)})}console.log(`ContourDetector: создано ${this.segments.length} сегментов`)}else console.log("ContourDetector: нет элементов для анализа")}findClosedContours(){return console.log("ContourDetector: поиск замкнутых контуров..."),this.cacheValid&&this.cachedContours?(console.log("ContourDetector: возвращаем кэшированные контуры"),this.cachedContours):this.segments.length<3?(console.log("Недостаточно сегментов для поиска контуров"),[]):(this.findIntersections(),this.buildGraph(),this.findAllContours(),this.processFoundContours(),this.cachedContours=this.contours,this.cacheValid=!0,console.log(`ContourDetector: найдено ${this.contours.length} контуров`),this.contours)}findIntersections(){console.log("Поиск пересечений...");const e=new Map;for(let t=0;t<this.segments.length;t++)e.set(t,[]);for(let t=0;t<this.segments.length;t++)for(let s=t+1;s<this.segments.length;s++){const n=this.getLineIntersection(this.segments[t].start,this.segments[t].end,this.segments[s].start,this.segments[s].end);n&&(e.get(t).push({point:n,distance:this.getDistanceAlongSegment(n,this.segments[t])}),e.get(s).push({point:n,distance:this.getDistanceAlongSegment(n,this.segments[s])}))}this.splitSegmentsAtIntersections(e)}getLineIntersection(e,t,s,n){if(e.equals(s)||e.equals(n)||t.equals(s)||t.equals(n))return null;const o=(n.y-s.y)*(t.x-e.x)-(n.x-s.x)*(t.y-e.y);if(Math.abs(o)<1e-4)return null;const i=((n.x-s.x)*(e.y-s.y)-(n.y-s.y)*(e.x-s.x))/o,r=((t.x-e.x)*(e.y-s.y)-(t.y-e.y)*(e.x-s.x))/o;if(i>=-1e-4&&i<=1.0001&&r>=-1e-4&&r<=1.0001){const s=Math.max(0,Math.min(1,i));return new THREE.Vector2(e.x+s*(t.x-e.x),e.y+s*(t.y-e.y))}return null}getDistanceAlongSegment(e,t){const s=t.end.x-t.start.x,n=t.end.y-t.start.y;return Math.abs(s)>Math.abs(n)?(e.x-t.start.x)/s:(e.y-t.start.y)/n}splitSegmentsAtIntersections(e){const t=[];this.segments.forEach((s,n)=>{const o=e.get(n);if(!o||0===o.length)return void t.push(s);o.sort((e,t)=>e.distance-t.distance);let i=s.start.clone();const r=[i.clone()];o.forEach(e=>{i.distanceTo(e.point)>.001&&(r.push(e.point.clone()),i=e.point.clone())}),i.distanceTo(s.end)>.001&&r.push(s.end.clone());for(let e=0;e<r.length-1;e++)t.push({element:s.element,start:r[e],end:r[e+1],index:t.length,originalIndex:n,elementType:s.elementType,isClosed:s.isClosed})}),this.segments=t,console.log(`После разбиения: ${this.segments.length} сегментов`)}buildGraph(){console.log("Построение графа...");const e=new Map,t=e=>`${e.x.toFixed(4)},${e.y.toFixed(4)}`;this.segments.forEach(s=>{const n=t(s.start),o=t(s.end);e.has(n)||e.set(n,{point:s.start.clone(),edges:[]}),e.has(o)||e.set(o,{point:s.end.clone(),edges:[]});const i=e.get(n),r=e.get(o);i.edges.push({to:o,segmentIndex:s.index,segment:s}),r.edges.push({to:n,segmentIndex:s.index,segment:s})}),this.points=Array.from(e.values()),console.log(`Граф построен: ${this.points.length} вершин`)}findAllContours(){if(console.log("Поиск всех контуров..."),!this.points||0===this.points.length)return void console.log("Нет вершин для поиска контуров");const e=new Map;for(const t of this.points){const s=this.getVertexKey(t.point);e.set(s,t)}const t=[],s=new Set;for(const n of this.points){this.getVertexKey(n.point);this.findContoursDFS(n,e,s).forEach(e=>{e.points&&e.points.length>0&&t.push(e)})}console.log(`Найдено циклов: ${t.length}`),this.contours=t}findContoursDFS(e,t,s){const n=[];if(e.edges.length<2)return n;const o=this.getVertexKey(e.point),i=[];for(const n of e.edges){const r=this.getEdgeKey(e.point,n.to);if(s.has(r))continue;const l=t.get(n.to);l&&i.push({vertex:l,path:[e,l],edgePath:[n.segmentIndex],visitedEdges:new Set([r]),startKey:o})}for(;i.length>0;){const e=i.pop(),o=e.vertex,r=e.path,l=e.edgePath,h=e.visitedEdges;if(this.getVertexKey(o.point)===e.startKey&&r.length>=3){const e=this.createContourFromPath(r,l);if(e&&e.area>this.minContourArea){n.push(e);for(const e of h)s.add(e)}continue}for(const n of o.edges){const c=this.getEdgeKey(o.point,n.to);if(h.has(c))continue;if(s.has(c))continue;const a=t.get(n.to);if(!a)continue;const g=this.getVertexKey(a.point);if(g!==e.startKey){if(r.some(e=>this.getVertexKey(e.point)===g))continue}const u=new Set(h);u.add(c),i.push({vertex:a,path:[...r,a],edgePath:[...l,n.segmentIndex],visitedEdges:u,startKey:e.startKey})}}return n}processFoundContours(){const e=this.contours;if(!e||0===e.length)return void(this.contours=[]);const t=e.filter(e=>e.isValid&&e.points&&e.points.length>=3&&e.area>this.minContourArea);if(0===t.length)return void(this.contours=[]);const s=new Map;for(const e of t){const t=this.getContourHash(e);s.has(t)||s.set(t,e)}const n=Array.from(s.values()),o=n.filter(e=>{const t=new Set(e.elements.map(e=>e.userData.elementType));return 1===t.size&&t.has("circle")}),i=n.filter(e=>{const t=new Set(e.elements.map(e=>e.userData.elementType));return t.has("circle")&&t.has("line")});console.log(`Контуров только из круга: ${o.length}`),console.log(`Контуров из круга и линии: ${i.length}`);const r=[];i.length>0?(console.log("Есть разрезанные контуры, удаляем целый круг"),n.forEach(e=>{new Set(e.elements.map(e=>e.userData.elementType)).has("line")&&r.push(e)})):r.push(...n);const l=[];for(let e=0;e<r.length;e++){const t=r[e];let s=!1;for(let n=0;n<r.length;n++){if(e===n)continue;const o=r[n],i=new Set(t.elements.map(e=>e.uuid)),l=new Set(o.elements.map(e=>e.uuid));let h=!0;for(const e of i)if(!l.has(e)){h=!1;break}if(h&&l.size>i.size&&o.area>t.area){console.log(`Удаляем контур ${e} (площадь ${t.area}), так как он входит в контур ${n} (площадь ${o.area})`),s=!0;break}}s||l.push(t)}this.contours=l,console.log(`Обработано контуров: ${this.contours.length}`)}createContourFromPath(e,t){if(e.length<3)return null;const s=e.map(e=>e.point.clone());s.push(s[0].clone());const n=this.calculatePolygonArea(s);if(Math.abs(n)<this.minContourArea)return null;const o=n<0;o&&s.reverse();const i=new Set;return t.forEach(e=>{this.segments[e]&&i.add(this.segments[e].element)}),{elements:Array.from(i),points:s.slice(0,-1),area:Math.abs(n),isClockwise:o,isValid:!0}}calculatePolygonArea(e){let t=0;const s=e.length;for(let n=0;n<s;n++){const o=(n+1)%s;t+=e[n].x*e[o].y,t-=e[o].x*e[n].y}return t/2}getElementPoints(e){const t=[];if(e.userData.localPoints&&e.userData.localPoints.length>0)for(const s of e.userData.localPoints)t.push(new THREE.Vector2(s.x,s.y));else if(e.geometry&&e.geometry.attributes.position){const s=e.geometry.attributes.position.array;for(let e=0;e<s.length;e+=3)t.push(new THREE.Vector2(s[e],s[e+1]))}return t}getVertexKey(e){return`${e.x.toFixed(this.snapPrecision)},${e.y.toFixed(this.snapPrecision)}`}getEdgeKey(e,t){const s=this.getVertexKey(e);return s<t?`${s}-${t}`:`${t}-${s}`}getContourHash(e){if(!e.points||0===e.points.length)return"";return`${Math.round(100*e.area)/100}|${e.elements?e.elements.map(e=>e.uuid).sort().join(","):""}`}calculateElementsHash(e){if(!e||0===e.length)return"";return e.map(e=>e.uuid).sort().join("|")}clear(){this.segments=[],this.points=[],this.edges=[],this.contours=[],this.cacheValid=!1,this.cachedContours=null,this.elementHash=""}}