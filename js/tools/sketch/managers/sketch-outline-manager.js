class SketchOutlineManager{constructor(e){this.sketchManager=e,this.editor=e.editor,this.outlineEnabled=!0,this.maxCenterDistance=200,this.normalThreshold=.95,this.distanceThreshold=.2,this.loadSettings()}loadSettings(){const e=localStorage.getItem("cad-sketch-outline");if(e){const t=JSON.parse(e);this.outlineEnabled=void 0===t.enabled||t.enabled}}saveSettings(){const e={enabled:this.outlineEnabled,lastUpdated:(new Date).toISOString()};localStorage.setItem("cad-sketch-outline",JSON.stringify(e))}setOutlineEnabled(e){return this.outlineEnabled=void 0!==e?e:!this.outlineEnabled,this.saveSettings(),this.outlineEnabled}checkPlaneIntersectionWithObjects(){if(!this.sketchManager.currentPlane||!this.outlineEnabled)return null;console.log("Поиск объектов рядом с плоскостью скетча...");const e=this.editor.objectsGroup.children.filter(e=>e!==this.sketchManager.currentPlane&&e.userData&&"sketch_plane"!==e.userData.type&&"work_plane"!==e.userData.type&&e.isMesh);console.log("Количество объектов для проверки:",e.length);let t=null,o=1/0;for(const n of e){if(!n.geometry){console.log("Пропускаем объект без геометрии:",n.name);continue}const e=(new THREE.Box3).setFromObject(n).getCenter(new THREE.Vector3).distanceTo(this.sketchManager.currentPlane.position);if(console.log(`Объект ${n.name||n.uuid}: расстояние до плоскости ${e.toFixed(2)}`),e<50&&e<o){const r=this.findClosestFaceToPlane(n,this.sketchManager.currentPlane);r&&(t=r,o=e,console.log(`Найдена ближайшая грань: объект ${n.name||n.uuid}, грань ${r.faceIndex}`))}}return t}findClosestFaceToPlane(e,t){if(!e||!e.geometry)return console.log("У объекта нет геометрии"),null;console.log("Тип геометрии объекта:",e.geometry.type,"имеет faces:",!!e.geometry.faces,"имеет index:",!!e.geometry.index);const o=new THREE.Vector3(0,0,1);o.applyQuaternion(t.quaternion);const n=t.position;return e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?this.findClosestFaceInBufferGeometry(e,o,n):e.geometry.faces&&e.geometry.vertices?this.findClosestFaceInStandardGeometry(e,o,n):(console.log("Неизвестный тип геометрии, пробуем BufferGeometry подход"),this.findClosestFaceInBufferGeometry(e,o,n))}findClosestFaceInBufferGeometry(e,t,o){const n=e.geometry,r=n.attributes.position;if(!r)return console.log("У объекта нет позиций"),null;console.log("BufferGeometry: количество вершин =",r.count,"имеет index:",!!n.index);let l=-1,s=1/0;const a=null!==n.index,c=r.count;if(a){const a=n.index,c=a.count/3;console.log("Количество граней (по индексам):",c);for(let n=0;n<c;n++){const c=[a.array[3*n],a.array[3*n+1],a.array[3*n+2]],i=[];for(const t of c){const o=new THREE.Vector3;o.fromBufferAttribute(r,t),o.applyMatrix4(e.matrixWorld),i.push(o)}const u=new THREE.Vector3;for(const e of i)u.add(e);u.divideScalar(3);const h=Math.abs(u.distanceTo(o)),g=(new THREE.Vector3).subVectors(i[1],i[0]),f=(new THREE.Vector3).subVectors(i[2],i[0]),d=(new THREE.Vector3).crossVectors(g,f).normalize(),p=Math.abs(d.dot(t));p>.85&&h<s&&h<20&&(s=h,l=n,console.log(`Найдена подходящая грань: индекс=${n}, расстояние=${h.toFixed(2)}, угол=${p.toFixed(3)}`))}}else{const n=Math.floor(c/3);console.log("Количество граней (без индексов):",n);for(let a=0;a<n;a++){const n=[];for(let t=0;t<3;t++){const o=new THREE.Vector3;o.fromBufferAttribute(r,3*a+t),o.applyMatrix4(e.matrixWorld),n.push(o)}const c=new THREE.Vector3;for(const e of n)c.add(e);c.divideScalar(3);const i=Math.abs(c.distanceTo(o)),u=(new THREE.Vector3).subVectors(n[1],n[0]),h=(new THREE.Vector3).subVectors(n[2],n[0]),g=(new THREE.Vector3).crossVectors(u,h).normalize(),f=Math.abs(g.dot(t));f>.85&&i<s&&i<20&&(s=i,l=a,console.log(`Найдена подходящая грань: индекс=${a}, расстояние=${i.toFixed(2)}, угол=${f.toFixed(3)}`))}}return-1!==l?(console.log("Найдена ближайшая грань:",l,"с расстоянием",s.toFixed(2)),{object:e,faceIndex:l,point:o}):(console.log("Не найдено подходящих граней для BufferGeometry"),null)}findClosestFaceInStandardGeometry(e,t,o){const n=e.geometry;if(!n.faces||!n.vertices)return console.log("У объекта нет граней или вершин"),null;console.log("Standard Geometry: количество граней =",n.faces.length);let r=-1,l=1/0;const s=n.faces,a=n.vertices;for(let n=0;n<s.length;n++){const c=s[n],i=[a[c.a].clone().applyMatrix4(e.matrixWorld),a[c.b].clone().applyMatrix4(e.matrixWorld),a[c.c].clone().applyMatrix4(e.matrixWorld)],u=new THREE.Vector3;for(const e of i)u.add(e);u.divideScalar(3);const h=Math.abs(u.distanceTo(o)),g=(new THREE.Vector3).subVectors(i[1],i[0]),f=(new THREE.Vector3).subVectors(i[2],i[0]),d=(new THREE.Vector3).crossVectors(g,f).normalize(),p=Math.abs(d.dot(t));p>.85&&h<l&&h<20&&(l=h,r=n,console.log(`Найдена подходящая грань: индекс=${n}, расстояние=${h.toFixed(2)}, угол=${p.toFixed(3)}`))}return-1!==r?{object:e,faceIndex:r,point:o}:(console.log("Не найдено подходящих граней для Standard Geometry"),null)}getAllPolygonsOfFace(e,t){console.log("Поиск всех полигонов грани для треугольника",t);const o=e.geometry,n=o.attributes.position,r=null!==o.index,l=this.getPolygonData(e,t);if(!l)return console.log("Не удалось получить данные полигона",t),[t];const{normal:s,center:a}=l;console.log("Основной полигон: нормаль",s.toArray(),"центр",a.toArray());const c=r?o.index.count/3:n.count/3;console.log("Всего треугольников в объекте:",c);const i=[t];for(let o=0;o<c;o++){if(o===t)continue;const n=this.getPolygonData(e,o);if(!n)continue;const{normal:r,center:l}=n,c=Math.abs(s.dot(r));if(c<this.normalThreshold)continue;const u=Math.abs(s.dot(l.clone().sub(a)));if(u>this.distanceThreshold)continue;l.distanceTo(a)>this.maxCenterDistance||(console.log(`Найден смежный треугольник ${o}: расстояние=${u.toFixed(2)}, нормаль=${c.toFixed(3)}`),i.push(o))}return console.log("Всего полигонов в грани:",i.length),i}getPolygonData(e,t){const o=e.geometry,n=o.attributes.position;let r;if(null!==o.index){const e=o.index,n=3*t;if(n+2>=e.count)return null;r=[e.array[n],e.array[n+1],e.array[n+2]]}else{const e=3*t;if(e+2>=n.count)return null;r=[e,e+1,e+2]}const l=r.map(t=>{const o=new THREE.Vector3;return o.fromBufferAttribute(n,t),o.applyMatrix4(e.matrixWorld),o}),s=(new THREE.Vector3).subVectors(l[1],l[0]),a=(new THREE.Vector3).subVectors(l[2],l[0]),c=(new THREE.Vector3).crossVectors(s,a).normalize(),i=new THREE.Vector3;return l.forEach(e=>i.add(e)),i.divideScalar(3),{normal:c,center:i,vertices:l}}getFaceByIndex(e,t){return e.geometry?e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?this.getFaceFromBufferGeometry(e,t):e.geometry.faces&&e.geometry.vertices?this.getFaceFromStandardGeometry(e,t):(console.log("Неизвестный тип геометрии для получения грани"),null):null}getFaceFromBufferGeometry(e,t){const o=e.geometry,n=o.attributes.position;if(null!==o.index){const e=o.index,n=3*t;return n+2>=e.count?null:{a:e.array[n],b:e.array[n+1],c:e.array[n+2],normal:o.attributes.normal?(new THREE.Vector3).fromBufferAttribute(o.attributes.normal,e.array[n]):new THREE.Vector3(0,0,1)}}{const e=3*t;return e+2>=n.count?null:{a:e,b:e+1,c:e+2,normal:o.attributes.normal?(new THREE.Vector3).fromBufferAttribute(o.attributes.normal,e):new THREE.Vector3(0,0,1)}}}getFaceFromStandardGeometry(e,t){const o=e.geometry;if(!o.faces||t>=o.faces.length)return null;const n=o.faces[t];return{a:n.a,b:n.b,c:n.c,normal:n.normal?n.normal.clone():new THREE.Vector3(0,0,1)}}getFaceOutline(e,t){if(!e||!e.geometry||void 0===t)return console.log("Неверные параметры для получения контура грани"),null;let o;return console.log("Получение контура грани:",t,"тип геометрии:",e.geometry.type),e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?(o=this.getAllPolygonsOfFace(e,t),console.log("Найдены полигоны грани:",o)):o=this.editor.planesManager&&this.editor.planesManager.getFacePolygons?this.editor.planesManager.getFacePolygons(e,t):[t],o&&0!==o.length?(console.log("Полигоны грани:",o),e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?this.getFaceOutlineFromBufferGeometry(e,o):e.geometry.faces&&e.geometry.vertices?this.getFaceOutlineFromStandardGeometry(e,o):(console.log("Неизвестный тип геометрии для получения контура"),null)):(console.log("Не найдены полигоны для грани",t),null)}getFaceOutlineFromBufferGeometry(e,t){const o=e.geometry,n=o.attributes.position,r=null!==o.index;console.log("Получение контура из BufferGeometry, полигонов:",t.length);const l=new Map;for(const s of t){let t;if(r){const e=o.index,n=3*s;if(n+2>=e.count)continue;t=[e.array[n],e.array[n+1],e.array[n+2]]}else{const e=3*s;if(e+2>=n.count)continue;t=[e,e+1,e+2]}if(t)for(let o=0;o<3;o++){const r=t[o],s=t[(o+1)%3],a=new THREE.Vector3;a.fromBufferAttribute(n,r),a.applyMatrix4(e.matrixWorld);const c=this.getProjectedPointOnPlane(a),i=new THREE.Vector3;i.fromBufferAttribute(n,s),i.applyMatrix4(e.matrixWorld);const u=this.getProjectedPointOnPlane(i);if(!c||!u)continue;const h=this.pointToKey(c),g=this.pointToKey(u),f=[h,g].sort().join("|");l.has(f)||l.set(f,{p1:c,p2:u,key1:h,key2:g,count:0}),l.get(f).count++}}const s=[];for(const e of l.values())1===e.count&&s.push(e);if(console.log("Внешние ребра грани:",s.length),0===s.length){console.log("Не найдены внешние ребра грани");const o=this.getOutlineFromAllPolygons(e,t);return o?[o]:[]}const a=this.findAllContours(s);if(a.length>0)return console.log("Найдено контуров:",a.length,"с точками:",a.map(e=>e.length)),a;console.log("Не удалось построить контуры из ребер, используем альтернативный метод");const c=this.getOutlineFromAllPolygons(e,t);return c?[c]:[]}findAllContours(e){if(0===e.length)return[];console.log("Поиск всех контуров из",e.length,"ребер");const t=[],o=new Set;for(let n=0;n<e.length;n++){if(o.has(n))continue;const r=this.buildSingleContour(e,n,o);r&&r.length>=3&&(t.push(r),console.log("Найден контур с",r.length,"точками"))}return t}buildSingleContour(e,t,o){const n=e[t],r=[];r.push(n.p1),r.push(n.p2),o.add(t);let l=n.p2,s=!0;for(;s&&r.length<2*e.length;){s=!1;for(let t=0;t<e.length;t++){if(o.has(t))continue;const n=e[t];if(this.pointsEqual(n.p1,l)){r.push(n.p2),l=n.p2,o.add(t),s=!0;break}if(this.pointsEqual(n.p2,l)){r.push(n.p1),l=n.p1,o.add(t),s=!0;break}}if(r.length>=3){const e=r[0],t=r[r.length-1];if(this.pointsEqual(e,t))return console.log("Контур замкнулся после",r.length,"точек"),r}}if(r.length>=3){const e=r[0],t=r[r.length-1];return this.pointsEqual(e,t)||r.push(e.clone()),console.log("Построен незамкнутый контур с",r.length,"точками"),r}return console.log("Не удалось построить контур"),null}pointToKey(e,t=6){const o=Math.pow(10,t);return`${Math.round(e.x*o)/o},${Math.round(e.y*o)/o},${Math.round(e.z*o)/o}`}buildContourFromEdges(e){if(0===e.length)return null;if(e.length<=2)return this.buildSimpleContour(e);const t=new Map;for(const o of e)t.has(o.key1)||t.set(o.key1,[]),t.has(o.key2)||t.set(o.key2,[]),t.get(o.key1).push({point:o.p2,key:o.key2}),t.get(o.key2).push({point:o.p1,key:o.key1});let o=null;for(const[e,n]of t)if(n.length%2==1||null===o){o=e;break}if(!o)return console.log("Не удалось найти начальную точку"),null;const n=[o],r=[],l=new Set;for(;n.length>0;){const o=n[n.length-1],s=t.get(o);if(s&&s.length>0){for(let e=0;e<s.length;e++){const t=s[e],r=[o,t.key].sort().join("|");if(!l.has(r)){l.add(r),n.push(t.key);break}}if(n[n.length-1]===o){n.pop();for(const t of e){if(t.key1===o){r.push(t.p1);break}if(t.key2===o){r.push(t.p2);break}}}}else n.pop()}if(r.length>2)for(const t of e){if(t.key1===o){r.push(t.p1);break}if(t.key2===o){r.push(t.p2);break}}const s=[];for(let e=0;e<r.length;e++)0!==e&&this.pointsEqual(r[e],r[e-1])||s.push(r[e]);return console.log("Построен контур из",s.length,"точек"),s.length>=2?s:null}buildSimpleContour(e){if(0===e.length)return null;if(1===e.length)return[e[0].p1,e[0].p2];if(2===e.length){const t=e[0],o=e[1];return this.pointsEqual(t.p2,o.p1)?[t.p1,t.p2,o.p2]:this.pointsEqual(t.p1,o.p2)?[o.p1,o.p2,t.p2]:this.pointsEqual(t.p1,o.p1)?[t.p2,t.p1,o.p2]:this.pointsEqual(t.p2,o.p2)?[t.p1,t.p2,o.p1]:[t.p1,t.p2,o.p1,o.p2]}return null}pointsEqual(e,t,o=.001){return Math.abs(e.x-t.x)<o&&Math.abs(e.y-t.y)<o&&Math.abs(e.z-t.z)<o}getOutlineFromAllPolygons(e,t){console.log("Используем альтернативный метод получения контура");const o=e.geometry,n=o.attributes.position,r=null!==o.index,l=[];for(const s of t){let t;if(r){const e=o.index,n=3*s;if(n+2>=e.count)continue;t=[e.array[n],e.array[n+1],e.array[n+2]]}else{const e=3*s;if(e+2>=n.count)continue;t=[e,e+1,e+2]}if(t){const o=[];for(const r of t){const t=new THREE.Vector3;t.fromBufferAttribute(n,r),t.applyMatrix4(e.matrixWorld),o.push(t)}const r=o.map(e=>this.getProjectedPointOnPlane(e));l.push(...r)}}if(0===l.length)return console.log("Не найдено точек для контура"),null;const s=this.findBoundaryPoints(l);if(s.length<2)return console.log("Недостаточно граничных точек для контура"),null;const a=this.buildMainContour(s);return console.log("Альтернативный метод: найдено",a.length,"точек контура"),a}buildMainContour(e){if(e.length<=3)return e;const t=new THREE.Vector3;e.forEach(e=>t.add(e)),t.divideScalar(e.length);const o=[...e];o.sort((e,o)=>Math.atan2(e.y-t.y,e.x-t.x)-Math.atan2(o.y-t.y,o.x-t.x));const n=[];for(let e=0;e<o.length;e++){const r=o[e],l=Math.atan2(r.y-t.y,r.x-t.x);let s=!1;for(let e=0;e<n.length;e++){const o=n[e],r=Math.atan2(o.y-t.y,o.x-t.x);if(Math.abs(l-r)<.05){s=!0;break}}s||n.push(r)}return n.length>2&&n.push(n[0].clone()),n}findBoundaryPoints(e){if(e.length<=3)return e;const t=new THREE.Vector3;e.forEach(e=>t.add(e)),t.divideScalar(e.length);const o=e.map(e=>({point:e,distance:e.distanceTo(t)}));o.sort((e,t)=>t.distance-e.distance);const n=Math.max(3,Math.floor(.1*e.length));return o.slice(0,n).map(e=>e.point)}getFaceOutlineFromStandardGeometry(e,t){const o=e.geometry;if(!o.faces||!o.vertices)return console.log("У объекта нет граней или вершин"),null;const n=new Map;for(const e of t){if(e>=o.faces.length)continue;const t=o.faces[e],r=[t.a,t.b,t.c];for(let e=0;e<3;e++){const t=r[e],o=r[(e+1)%3],l=Math.min(t,o),s=Math.max(t,o),a=`${l}-${s}`;n.has(a)||n.set(a,{v1:l,v2:s,count:0}),n.get(a).count++}}const r=[];for(const e of n.values())1===e.count&&r.push(e);if(0===r.length)return console.log("Не найдены внешние ребра грани"),null;const l=[],s=new Set;let a=r[0],c=a.v1;for(;l.length<r.length&&s.size<2*r.length;){const t=o.vertices[c].clone().applyMatrix4(e.matrixWorld),n=this.getProjectedPointOnPlane(t);n&&l.push(n),s.add(c);const i=r.find(e=>e.v1===c&&!s.has(e.v2)||e.v2===c&&!s.has(e.v1));if(!i)break;c=i.v1===c?i.v2:i.v1,a=i}return l.length>2&&l.push(l[0]),l.length>=2?l:null}getProjectedPointOnPlane(e){if(!this.sketchManager.currentPlane)return null;const t=this.sketchManager.currentPlane.worldToLocal(e.clone());return t.z=0,this.sketchManager.currentPlane.localToWorld(t)}addFaceOutlineToSketch(){if(!this.sketchManager.currentPlane||!this.outlineEnabled)return void console.log("Обводка отключена или нет текущей плоскости");console.log("Добавление контура грани к скетчу...");const e=this.sketchManager.currentPlane.userData.parentObject,t=this.sketchManager.currentPlane.userData.faceIndex;let o=null,n=null;if(e&&void 0!==t?(n=this.editor.findObjectByUuid(e),n&&(o={object:n,faceIndex:t,face:this.getFaceByIndex(n,t),point:this.sketchManager.currentPlane.position},console.log("Используем сохраненные данные о грани"))):(o=this.checkPlaneIntersectionWithObjects(),o&&(this.sketchManager.currentPlane.userData.parentObject=o.object.uuid,this.sketchManager.currentPlane.userData.faceIndex=o.faceIndex,this.sketchManager.currentPlane.userData.intersectionPoint=o.point.clone(),o.face&&o.face.normal&&(this.sketchManager.currentPlane.userData.faceNormal=o.face.normal.clone()),console.log("Найдено новое пересечение, сохранено в userData"))),!o||!o.object||void 0===o.faceIndex)return void console.log("Не найдено пересечение плоскости с объектами для создания контура");console.log("Получение контура грани...");const r=this.getFaceOutline(o.object,o.faceIndex);if(!r||0===r.length)return void console.log("Не удалось получить контур грани");console.log("Получено контуров грани:",r.length);let l=0;for(let e=0;e<r.length;e++){const t=r[e];if(!t||t.length<2)continue;console.log(`Контур ${e+1}: ${t.length} точек`);const o={type:"polyline",points:t,color:39423,isFaceOutline:!0,contourIndex:e};this.sketchManager.elementManager.addElement(o),l++}console.log(`Добавлено ${l} контуров грани к скетчу`)}clear(){this.outlineEnabled=!0}}