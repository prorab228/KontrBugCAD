class SketchOutlineManager{constructor(e){this.sketchManager=e,this.editor=e.editor,this.outlineEnabled=!0,this.maxCenterDistance=200,this.maxFaceArea=1e4,this.normalThreshold=.995,this.distanceThreshold=.1,this.planeDistanceThreshold=.05,this.debug=!0,this.loadSettings()}loadSettings(){const e=localStorage.getItem("cad-sketch-outline");if(e){const t=JSON.parse(e);this.outlineEnabled=void 0===t.enabled||t.enabled,void 0!==t.debug&&(this.debug=t.debug)}}saveSettings(){const e={enabled:this.outlineEnabled,debug:this.debug,lastUpdated:(new Date).toISOString()};localStorage.setItem("cad-sketch-outline",JSON.stringify(e))}setOutlineEnabled(e){return this.debug&&console.log("setOutlineEnabled",e),this.outlineEnabled=e,this.saveSettings(),this.outlineEnabled}checkPlaneIntersectionWithObjects(){if(!this.sketchManager.currentPlane||!this.outlineEnabled)return null;this.debug&&console.log("Поиск объектов рядом с плоскостью скетча...");const e=this.editor.objectsGroup.children.filter(e=>e!==this.sketchManager.currentPlane&&e.userData&&"sketch_plane"!==e.userData.type&&"work_plane"!==e.userData.type&&e.isMesh);this.debug&&console.log("Количество объектов для проверки:",e.length);let t=null,o=1/0;for(const n of e){if(!n.geometry){this.debug&&console.log("Пропускаем объект без геометрии:",n.name);continue}const e=(new THREE.Box3).setFromObject(n).getCenter(new THREE.Vector3).distanceTo(this.sketchManager.currentPlane.position);if(this.debug&&console.log(`Объект ${n.name||n.uuid}: расстояние до плоскости ${e.toFixed(2)}`),e<50&&e<o){const s=this.findClosestFaceToPlane(n,this.sketchManager.currentPlane);s&&(t=s,o=e,this.debug&&console.log(`Найдена ближайшая грань: объект ${n.name||n.uuid}, грань ${s.faceIndex}`))}}return t}findClosestFaceToPlane(e,t){if(!e||!e.geometry)return this.debug&&console.log("У объекта нет геометрии"),null;this.debug&&console.log("Тип геометрии объекта:",e.geometry.type,"имеет faces:",!!e.geometry.faces,"имеет index:",!!e.geometry.index);const o=new THREE.Vector3(0,0,1);o.applyQuaternion(t.quaternion);const n=t.position;return e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?this.findClosestFaceInBufferGeometry(e,o,n):e.geometry.faces&&e.geometry.vertices?this.findClosestFaceInStandardGeometry(e,o,n):(this.debug&&console.log("Неизвестный тип геометрии, пробуем BufferGeometry подход"),this.findClosestFaceInBufferGeometry(e,o,n))}findClosestFaceInBufferGeometry(e,t,o){const n=e.geometry,s=n.attributes.position;if(!s)return this.debug&&console.log("У объекта нет позиций"),null;this.debug&&console.log("BufferGeometry: количество вершин =",s.count,"имеет index:",!!n.index);let r=-1,c=1/0;const l=null!==n.index,a=s.count;if(l){const l=n.index,a=l.count/3;this.debug&&console.log("Количество граней (по индексам):",a);for(let n=0;n<a;n++){const a=[l.array[3*n],l.array[3*n+1],l.array[3*n+2]],i=[];for(const t of a){const o=new THREE.Vector3;o.fromBufferAttribute(s,t),o.applyMatrix4(e.matrixWorld),i.push(o)}const u=new THREE.Vector3;for(const e of i)u.add(e);u.divideScalar(3);const g=Math.abs(u.distanceTo(o)),h=(new THREE.Vector3).subVectors(i[1],i[0]),d=(new THREE.Vector3).subVectors(i[2],i[0]),f=(new THREE.Vector3).crossVectors(h,d).normalize(),b=Math.abs(f.dot(t));b>.9&&g<c&&g<10&&(c=g,r=n,this.debug&&console.log(`Найдена подходящая грань: индекс=${n}, расстояние=${g.toFixed(2)}, угол=${b.toFixed(3)}`))}}else{const n=Math.floor(a/3);this.debug&&console.log("Количество граней (без индексов):",n);for(let l=0;l<n;l++){const n=[];for(let t=0;t<3;t++){const o=new THREE.Vector3;o.fromBufferAttribute(s,3*l+t),o.applyMatrix4(e.matrixWorld),n.push(o)}const a=new THREE.Vector3;for(const e of n)a.add(e);a.divideScalar(3);const i=Math.abs(a.distanceTo(o)),u=(new THREE.Vector3).subVectors(n[1],n[0]),g=(new THREE.Vector3).subVectors(n[2],n[0]),h=(new THREE.Vector3).crossVectors(u,g).normalize(),d=Math.abs(h.dot(t));d>.9&&i<c&&i<10&&(c=i,r=l,this.debug&&console.log(`Найдена подходящая грань: индекс=${l}, расстояние=${i.toFixed(2)}, угол=${d.toFixed(3)}`))}}return-1!==r?(this.debug&&console.log("Найдена ближайшая грань:",r,"с расстоянием",c.toFixed(2)),{object:e,faceIndex:r,point:o}):(this.debug&&console.log("Не найдено подходящих граней для BufferGeometry"),null)}findClosestFaceInStandardGeometry(e,t,o){const n=e.geometry;if(!n.faces||!n.vertices)return this.debug&&console.log("У объекта нет граней или вершин"),null;this.debug&&console.log("Standard Geometry: количество граней =",n.faces.length);let s=-1,r=1/0;const c=n.faces,l=n.vertices;for(let n=0;n<c.length;n++){const a=c[n],i=[l[a.a].clone().applyMatrix4(e.matrixWorld),l[a.b].clone().applyMatrix4(e.matrixWorld),l[a.c].clone().applyMatrix4(e.matrixWorld)],u=new THREE.Vector3;for(const e of i)u.add(e);u.divideScalar(3);const g=Math.abs(u.distanceTo(o)),h=(new THREE.Vector3).subVectors(i[1],i[0]),d=(new THREE.Vector3).subVectors(i[2],i[0]),f=(new THREE.Vector3).crossVectors(h,d).normalize(),b=Math.abs(f.dot(t));b>.9&&g<r&&g<10&&(r=g,s=n,this.debug&&console.log(`Найдена подходящая грань: индекс=${n}, расстояние=${g.toFixed(2)}, угол=${b.toFixed(3)}`))}return-1!==s?{object:e,faceIndex:s,point:o}:(this.debug&&console.log("Не найдено подходящих граней для Standard Geometry"),null)}getAllPolygonsOfFace(e,t){this.debug&&console.log("Поиск всех полигонов грани для треугольника",t);const o=e.geometry,n=o.attributes.position,s=null!==o.index,r=this.getPolygonData(e,t);if(!r)return this.debug&&console.log("Не удалось получить данные полигона",t),[t];const{normal:c,center:l}=r;this.debug&&console.log("Основной полигон: нормаль",c.toArray(),"центр",l.toArray());const a=s?o.index.count/3:n.count/3;this.debug&&console.log("Всего треугольников в объекте:",a);const i=new Set([t]),u=new Map;u.set(t,r);for(let o=0;o<a;o++){if(o===t)continue;const n=this.getPolygonData(e,o);if(!n)continue;const{normal:s,center:r}=n;if(Math.abs(c.dot(s))<this.normalThreshold)continue;if(Math.abs(c.dot(r.clone().sub(l)))>this.planeDistanceThreshold)continue;r.distanceTo(l)>this.maxCenterDistance||(i.add(o),u.set(o,n))}this.debug&&console.log("Кандидатов на принадлежность грани:",i.size);const g=this.findConnectedPolygons(e,t,i,u);if(this.debug&&console.log("Связных полигонов в грани:",g.size),g.size>1){const o=this.calculateFaceArea(e,g,u);if(o>this.maxFaceArea)return this.debug&&console.log(`Площадь грани ${o.toFixed(2)} мм² превышает лимит ${this.maxFaceArea}, используем только исходный треугольник`),[t]}return Array.from(g)}findConnectedPolygons(e,t,o,n){const s=new Set([t]),r=[t],c=e.geometry;c.attributes.position,c.index;for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const e of o){if(s.has(e))continue;const o=n.get(e);this.trianglesShareEdge(t,o)&&(s.add(e),r.push(e))}}return s}trianglesShareEdge(e,t){const o=e.vertices,n=t.vertices,s=[[o[0],o[1]],[o[1],o[2]],[o[2],o[0]]],r=[[n[0],n[1]],[n[1],n[2]],[n[2],n[0]]];for(const e of s)for(const t of r)if(this.pointsEqual(e[0],t[0])&&this.pointsEqual(e[1],t[1])||this.pointsEqual(e[0],t[1])&&this.pointsEqual(e[1],t[0]))return!0;return!1}calculateFaceArea(e,t,o){const n=[],s=new Map;for(const e of t){const t=o.get(e);if(t)for(const e of t.vertices){const t=this.pointToKey(e);s.has(t)||(s.set(t,e),n.push(e))}}if(n.length<3)return 0;const r=this.computeConvexHull(n);let c=0;for(let e=0;e<r.length;e++){const t=(e+1)%r.length;c+=r[e].x*r[t].y,c-=r[t].x*r[e].y}return Math.abs(c)/2}getPolygonData(e,t){const o=e.geometry,n=o.attributes.position;let s;if(null!==o.index){const e=o.index,n=3*t;if(n+2>=e.count)return null;s=[e.array[n],e.array[n+1],e.array[n+2]]}else{const e=3*t;if(e+2>=n.count)return null;s=[e,e+1,e+2]}const r=s.map(t=>{const o=new THREE.Vector3;return o.fromBufferAttribute(n,t),o.applyMatrix4(e.matrixWorld),o}),c=(new THREE.Vector3).subVectors(r[1],r[0]),l=(new THREE.Vector3).subVectors(r[2],r[0]),a=(new THREE.Vector3).crossVectors(c,l).normalize(),i=new THREE.Vector3;return r.forEach(e=>i.add(e)),i.divideScalar(3),{normal:a,center:i,vertices:r,index:t}}getFaceByIndex(e,t){return e.geometry?e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?this.getFaceFromBufferGeometry(e,t):e.geometry.faces&&e.geometry.vertices?this.getFaceFromStandardGeometry(e,t):(this.debug&&console.log("Неизвестный тип геометрии для получения грани"),null):null}getFaceFromBufferGeometry(e,t){const o=e.geometry,n=o.attributes.position;if(null!==o.index){const e=o.index,n=3*t;return n+2>=e.count?null:{a:e.array[n],b:e.array[n+1],c:e.array[n+2],normal:o.attributes.normal?(new THREE.Vector3).fromBufferAttribute(o.attributes.normal,e.array[n]):new THREE.Vector3(0,0,1)}}{const e=3*t;return e+2>=n.count?null:{a:e,b:e+1,c:e+2,normal:o.attributes.normal?(new THREE.Vector3).fromBufferAttribute(o.attributes.normal,e):new THREE.Vector3(0,0,1)}}}getFaceFromStandardGeometry(e,t){const o=e.geometry;if(!o.faces||t>=o.faces.length)return null;const n=o.faces[t];return{a:n.a,b:n.b,c:n.c,normal:n.normal?n.normal.clone():new THREE.Vector3(0,0,1)}}getFaceOutline(e,t){if(!e||!e.geometry||void 0===t)return this.debug&&console.log("Неверные параметры для получения контура грани"),null;let o;return this.debug&&console.log("Получение контура грани:",t,"тип геометрии:",e.geometry.type),e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?(o=this.getAllPolygonsOfFace(e,t),this.debug&&console.log("Найдены полигоны грани:",o)):o=this.editor.planesManager&&this.editor.planesManager.getFacePolygons?this.editor.planesManager.getFacePolygons(e,t):[t],o&&0!==o.length?(this.debug&&console.log("Полигоны грани:",o),e.geometry.isBufferGeometry||"BufferGeometry"===e.geometry.type?this.getFaceOutlineFromBufferGeometry(e,o):e.geometry.faces&&e.geometry.vertices?this.getFaceOutlineFromStandardGeometry(e,o):(this.debug&&console.log("Неизвестный тип геометрии для получения контура"),null)):(this.debug&&console.log("Не найдены полигоны для грани",t),null)}getFaceOutlineFromBufferGeometry(e,t){const o=e.geometry,n=o.attributes.position,s=null!==o.index;this.debug&&console.log("Получение контура из BufferGeometry, полигонов:",t.length);const r=new Map;for(const c of t){let t;if(s){const e=o.index,n=3*c;if(n+2>=e.count)continue;t=[e.array[n],e.array[n+1],e.array[n+2]]}else{const e=3*c;if(e+2>=n.count)continue;t=[e,e+1,e+2]}if(t)for(let o=0;o<3;o++){const s=t[o],c=t[(o+1)%3],l=new THREE.Vector3;l.fromBufferAttribute(n,s),l.applyMatrix4(e.matrixWorld);const a=new THREE.Vector3;a.fromBufferAttribute(n,c),a.applyMatrix4(e.matrixWorld);const i=this.getProjectedPointOnPlane(l),u=this.getProjectedPointOnPlane(a);if(!i||!u)continue;const g=this.sketchManager.currentPlane.worldToLocal(i.clone()),h=this.sketchManager.currentPlane.worldToLocal(u.clone()),d=this.pointToKey(g),f=this.pointToKey(h),b=[d,f].sort().join("|");r.has(b)||r.set(b,{p1:g,p2:h,key1:d,key2:f,count:0}),r.get(b).count++}}this.debug&&console.log("Всего уникальных ребер:",r.size);const c=[];for(const e of r.values())1===e.count&&c.push(e);if(this.debug&&console.log("Внешние ребра грани:",c.length),0===c.length){this.debug&&console.log("Не найдены внешние ребра, используем все ребра грани");for(const e of r.values())c.push(e)}const l=this.buildContoursFromEdges(c);return 0===l.length?(this.debug&&console.log("Не удалось построить контуры, используем альтернативный метод"),this.getAlternativeOutline(e,t)):(this.debug&&console.log("Построено контуров:",l.length),l)}buildContoursFromEdges(e){if(0===e.length)return this.debug&&console.log("Нет ребер для построения контура"),[];this.debug&&console.log("Построение контуров из",e.length,"ребер");const t=new Map;for(const o of e){const e=o.key1,n=o.key2;t.has(e)||t.set(e,{point:o.p1,connected:new Set}),t.has(n)||t.set(n,{point:o.p2,connected:new Set}),t.get(e).connected.add(n),t.get(n).connected.add(e)}this.debug&&console.log("Точек в графе:",t.size);const o=[],n=new Set,s=e=>{const o=[];let s=e,r=null;do{const e=t.get(s);if(!e)break;o.push(e.point);let c=null;for(const t of e.connected){const e=[s,t].sort().join("|");if(!n.has(e)){c=t,n.add(e);break}}if(!c&&r)for(const t of e.connected)if(t===r){c=t;break}r=s,s=c}while(s&&s!==e&&o.length<2*t.size);if(o.length>=3){if(s===e)o.push(o[0].clone());else if(o.length>3){const e=o[0],t=o[o.length-1];this.pointsEqual(e,t,.01)||e.distanceTo(t)<.1&&o.push(e.clone())}return o}return null};for(const[e,r]of t){let t=!1;for(const o of r.connected){const s=[e,o].sort().join("|");if(!n.has(s)){t=!0;break}}if(t){const t=s(e);t&&t.length>=3&&(o.push(t),this.debug&&console.log("Найден контур с",t.length,"точками"))}}if(0===o.length&&e.length>0){this.debug&&console.log("Создаем простые контуры из отдельных ребер");for(const t of e)o.push([t.p1,t.p2])}return o}getAlternativeOutline(e,t){this.debug&&console.log("Используем альтернативный метод получения контура");const o=e.geometry,n=o.attributes.position,s=null!==o.index,r=[];for(const c of t){let t;if(s){const e=o.index,n=3*c;if(n+2>=e.count)continue;t=[e.array[n],e.array[n+1],e.array[n+2]]}else{const e=3*c;if(e+2>=n.count)continue;t=[e,e+1,e+2]}if(t)for(const o of t){const t=new THREE.Vector3;t.fromBufferAttribute(n,o),t.applyMatrix4(e.matrixWorld);const s=this.getProjectedPointOnPlane(t),c=this.sketchManager.currentPlane.worldToLocal(s.clone());let l=!1;for(const e of r)if(this.pointsEqual(c,e,.01)){l=!0;break}l||r.push(c)}}if(r.length<3)return this.debug&&console.log("Недостаточно точек для контура"),[];this.debug&&console.log("Всего уникальных точек:",r.length);const c=this.computeConvexHull(r);return c.length>=3?(c.push(c[0].clone()),this.debug&&console.log("Создан контур из",c.length,"точек (выпуклая оболочка)"),[c]):this.createBoundingBoxContour(r)}computeConvexHull(e){if(e.length<=3)return e;let t=e[0];for(const o of e)(o.x<t.x||Math.abs(o.x-t.x)<.001&&o.y<t.y)&&(t=o);const o=e.filter(e=>e!==t);o.sort((e,o)=>{const n=Math.atan2(e.y-t.y,e.x-t.x),s=Math.atan2(o.y-t.y,o.x-t.x);if(Math.abs(n-s)<.001){return e.distanceTo(t)-o.distanceTo(t)}return n-s});const n=[t];for(const e of o){for(;n.length>=2;){const t=n[n.length-2],o=n[n.length-1];if(!((o.x-t.x)*(e.y-o.y)-(o.y-t.y)*(e.x-o.x)<=.001))break;n.pop()}n.push(e)}return n}createBoundingBoxContour(e){if(0===e.length)return[];let t=1/0,o=-1/0,n=1/0,s=-1/0;for(const r of e)t=Math.min(t,r.x),o=Math.max(o,r.x),n=Math.min(n,r.y),s=Math.max(s,r.y);const r=[new THREE.Vector3(t,n,0),new THREE.Vector3(o,n,0),new THREE.Vector3(o,s,0),new THREE.Vector3(t,s,0),new THREE.Vector3(t,n,0)];return this.debug&&console.log("Создан bounding box контур"),[r]}pointToKey(e,t=6){const o=Math.pow(10,t);return`${Math.round(e.x*o)/o},${Math.round(e.y*o)/o},${Math.round(e.z*o)/o}`}pointsEqual(e,t,o=.001){return Math.abs(e.x-t.x)<o&&Math.abs(e.y-t.y)<o&&Math.abs(e.z-t.z)<o}getFaceOutlineFromStandardGeometry(e,t){const o=e.geometry;if(!o.faces||!o.vertices)return this.debug&&console.log("У объекта нет граней или вершин"),null;const n=new Map;for(const e of t){if(e>=o.faces.length)continue;const t=o.faces[e],s=[t.a,t.b,t.c];for(let e=0;e<3;e++){const t=s[e],o=s[(e+1)%3],r=Math.min(t,o),c=Math.max(t,o),l=`${r}-${c}`;n.has(l)||n.set(l,{v1:r,v2:c,count:0}),n.get(l).count++}}const s=[];for(const e of n.values())1===e.count&&s.push(e);if(0===s.length)return this.debug&&console.log("Не найдены внешние ребра грани"),null;const r=[],c=new Set;let l=s[0],a=l.v1;for(;r.length<s.length&&c.size<2*s.length;){const t=o.vertices[a].clone().applyMatrix4(e.matrixWorld),n=this.getProjectedPointOnPlane(t);if(n){const e=this.sketchManager.currentPlane.worldToLocal(n.clone());r.push(e)}c.add(a);const i=s.find(e=>e.v1===a&&!c.has(e.v2)||e.v2===a&&!c.has(e.v1));if(!i)break;a=i.v1===a?i.v2:i.v1,l=i}return r.length>2&&r.push(r[0].clone()),r.length>=2?[r]:null}getProjectedPointOnPlane(e){if(!this.sketchManager.currentPlane)return null;const t=this.sketchManager.currentPlane.worldToLocal(e.clone());return t.z=0,this.sketchManager.currentPlane.localToWorld(t)}addFaceOutlineToSketch(){if(!this.sketchManager.currentPlane||!this.outlineEnabled)return void(this.debug&&console.log("Обводка отключена или нет текущей плоскости"));console.log("Добавление контура грани к скетчу...");const e=this.sketchManager.currentPlane.userData.parentObject,t=this.sketchManager.currentPlane.userData.faceIndex;let o=null,n=null;if(e&&void 0!==t?(n=this.editor.findObjectByUuid(e),n&&(o={object:n,faceIndex:t,face:this.getFaceByIndex(n,t),point:this.sketchManager.currentPlane.position},this.debug&&console.log("Используем сохраненные данные о грани"))):(o=this.checkPlaneIntersectionWithObjects(),o&&(this.sketchManager.currentPlane.userData.parentObject=o.object.uuid,this.sketchManager.currentPlane.userData.faceIndex=o.faceIndex,this.sketchManager.currentPlane.userData.intersectionPoint=o.point.clone(),o.face&&o.face.normal&&(this.sketchManager.currentPlane.userData.faceNormal=o.face.normal.clone()),this.debug&&console.log("Найдено новое пересечение, сохранено в userData"))),!o||!o.object||void 0===o.faceIndex)return void(this.debug&&console.log("Не найдено пересечение плоскости с объектами для создания контура"));this.debug&&console.log("Получение контура грани...");const s=this.getFaceOutline(o.object,o.faceIndex);if(!s||0===s.length)return void(this.debug&&console.log("Не удалось получить контур грани"));console.log("Получено контуров грани:",s.length);let r=0;for(let e=0;e<s.length;e++){const t=s[e];if(!t||t.length<2)continue;this.debug&&console.log(`Контур ${e+1}: ${t.length} точек`);const o={type:"polyline",points:t,color:39423,isFaceOutline:!0,contourIndex:e};this.sketchManager.elementManager.addElement(o),r++}console.log(`Добавлено ${r} контуров грани к скетчу`)}clear(){}}