class SketchExportManager{constructor(e){this.sketchManager=e}exportToSVG(){if(!this.sketchManager.currentPlane)return void this.sketchManager.editor.showStatus("Нет активного скетча для экспорта","warning");this.sketchManager.elementManager.collectSketchElements(this.sketchManager.currentPlane);const e=this.sketchManager.elementManager.elements;if(e&&0!==e.length){console.log("Элементы для экспорта:",e),console.log("Количество элементов:",e.length);try{const n=this.calculateBoundingBox(e);if(!n)return void this.sketchManager.editor.showStatus("Не удалось вычислить границы чертежа","error");const t=50,r={x:n.minX-t,y:n.minY-t,width:n.width+2*t,height:n.height+2*t},s=this.generateSVGContent(r,e,n),o=`${this.sketchManager.currentSketch.name||"sketch"}.svg`;this.downloadFile(s,o,"image/svg+xml"),this.sketchManager.editor.showStatus(`Чертеж экспортирован в SVG (${e.length} элементов)`,"success")}catch(e){console.error("Ошибка экспорта:",e),this.sketchManager.editor.showStatus(`Ошибка экспорта: ${e.message}`,"error")}}else this.sketchManager.editor.showStatus("Нет элементов для экспорта","warning")}calculateBoundingBox(e){if(!e||0===e.length)return null;let n=1/0,t=1/0,r=-1/0,s=-1/0;return e.forEach(e=>{this.getElementPoints(e).forEach(e=>{n=Math.min(n,e.x),t=Math.min(t,e.y),r=Math.max(r,e.x),s=Math.max(s,e.y)})}),n===1/0||t===1/0?null:{minX:n,minY:t,maxX:r,maxY:s,width:r-n,height:s-t,centerX:(n+r)/2,centerY:(t+s)/2}}getElementPoints(e){const n=[];return e.localPoints&&Array.isArray(e.localPoints)&&e.localPoints.length>0&&n.push(...e.localPoints),e.center&&(n.push(e.center),void 0!==e.radius&&n.push(new THREE.Vector3(e.center.x-e.radius,e.center.y,0),new THREE.Vector3(e.center.x+e.radius,e.center.y,0),new THREE.Vector3(e.center.x,e.center.y-e.radius,0),new THREE.Vector3(e.center.x,e.center.y+e.radius,0)),void 0!==e.radiusX&&void 0!==e.radiusY&&n.push(new THREE.Vector3(e.center.x-e.radiusX,e.center.y,0),new THREE.Vector3(e.center.x+e.radiusX,e.center.y,0),new THREE.Vector3(e.center.x,e.center.y-e.radiusY,0),new THREE.Vector3(e.center.x,e.center.y+e.radiusY,0))),n}generateSVGContent(e,n,t){const r=this.generateSVGElements(n,t);if(!r.trim())throw new Error("Нет элементов для экспорта");return`<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg width="${e.width}mm" height="${e.height}mm" viewBox="${e.x} ${-e.y-e.height} ${e.width} ${e.height}"\n     xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">\n\n    <title>Чертеж ${this.sketchManager.currentSketch.name||"sketch"}</title>\n    <desc>Экспортировано из CAD Editor</desc>\n\n    \x3c!-- Стили --\x3e\n    <style type="text/css">\n        .sketch-element {\n            stroke: #000000;\n            stroke-width: 0.2;\n            fill: none;\n            stroke-linecap: round;\n            stroke-linejoin: round;\n        }\n        .dashed-element {\n            stroke-dasharray: 2,2;\n        }\n        .dimension-element {\n            stroke: #00c853;\n            stroke-width: 0.15;\n            font-size: 3px;\n            font-family: Arial, sans-serif;\n        }\n    </style>\n\n    \x3c!-- Трансформация для инверсии Y --\x3e\n    <g transform="scale(1, -1) translate(0, ${-t.minY-t.maxY})" data-y-inversion="true">\n        ${r}\n    </g>\n\n</svg>`}generateSVGElements(e,n){let t="",r=0;if(e.forEach((e,n)=>{try{const s=`element-${n}`;let o="";if(!e.localPoints||!Array.isArray(e.localPoints)||0===e.localPoints.length)return void console.warn(`Элемент ${n} (${e.type}) не имеет точек для экспорта`);switch(e.type){case"line":o=this.generateSVGLine(e,s);break;case"dashedline":o=this.generateSVGDashedLine(e,s);break;case"rectangle":o=this.generateSVGRectangle(e,s);break;case"circle":o=this.generateSVGCircle(e,s);break;case"polygon":o=this.generateSVGPolygon(e,s);break;case"polyline":o=this.generateSVGPolyline(e,s);break;case"oval":o=this.generateSVGOval(e,s);break;case"arc":o=this.generateSVGArc(e,s);break;case"dimension":o=this.generateSVGDimension(e,s);break;default:console.warn(`Неизвестный тип элемента для экспорта: ${e.type}`),o=this.generateSVGPolyline(e,s)}o?(t+=o+"\n",r++,console.log(`Элемент ${n} (${e.type}) успешно сгенерирован, точек: ${e.localPoints.length}`)):console.warn(`Не удалось сгенерировать SVG для элемента ${n} типа ${e.type}`)}catch(t){console.error(`Ошибка генерации SVG для элемента ${n} (тип: ${e.type}):`,t)}}),console.log(`Сгенерировано ${r} из ${e.length} элементов`),0===r)throw new Error("Не удалось сгенерировать ни одного элемента для экспорта");return t}generateSVGLine(e,n){if(!e.localPoints||e.localPoints.length<2)return"";const t=e.localPoints[0],r=e.localPoints[e.localPoints.length-1];return`    <line id="${n}" class="sketch-element"\n            x1="${t.x}" y1="${t.y}"\n            x2="${r.x}" y2="${r.y}" />`}generateSVGDashedLine(e,n){if(!e.localPoints||e.localPoints.length<2)return"";return`    <polyline id="${n}" class="sketch-element dashed-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}generateSVGRectangle(e,n){if(!e.localPoints||e.localPoints.length<3)return"";return`    <polygon id="${n}" class="sketch-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}generateSVGCircle(e,n){if(e.center&&void 0!==e.radius)return`    <circle id="${n}" class="sketch-element"\n                cx="${e.center.x}" cy="${e.center.y}" r="${e.radius}" />`;if(e.localPoints&&e.localPoints.length>0){return`    <polygon id="${n}" class="sketch-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}return""}generateSVGPolygon(e,n){if(!e.localPoints||e.localPoints.length<3)return"";return`    <polygon id="${n}" class="sketch-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}generateSVGPolyline(e,n){if(!e.localPoints||e.localPoints.length<2)return"";return`    <polyline id="${n}" class="sketch-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}generateSVGOval(e,n){if(e.center&&void 0!==e.radiusX&&void 0!==e.radiusY)return`    <ellipse id="${n}" class="sketch-element"\n                cx="${e.center.x}" cy="${e.center.y}"\n                rx="${e.radiusX}" ry="${e.radiusY}" />`;if(e.localPoints&&e.localPoints.length>0){return`    <polygon id="${n}" class="sketch-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}return""}generateSVGArc(e,n){if(!e.localPoints||e.localPoints.length<2)return"";return`    <polyline id="${n}" class="sketch-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}generateSVGDimension(e,n){if(!e.localPoints||e.localPoints.length<2)return"";return`    <polyline id="${n}" class="dimension-element" points="${e.localPoints.map(e=>`${e.x},${e.y}`).join(" ")}" />`}downloadFile(e,n,t){const r=new Blob([e],{type:t}),s=URL.createObjectURL(r),o=document.createElement("a");o.href=s,o.download=n,o.style.display="none",document.body.appendChild(o),o.click(),document.body.removeChild(o),URL.revokeObjectURL(s)}}