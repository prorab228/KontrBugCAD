class SketchImportManager{constructor(t){this.sketchManager=t,this.fileInput=null}init(){this.fileInput=document.createElement("input"),this.fileInput.type="file",this.fileInput.accept=".svg",this.fileInput.style.display="none",this.fileInput.addEventListener("change",t=>this.handleFileSelect(t)),document.body.appendChild(this.fileInput)}openImportDialog(){this.sketchManager.currentPlane?this.fileInput&&this.fileInput.click():this.sketchManager.editor.showStatus("Сначала откройте скетч","warning")}handleFileSelect(t){const e=t.target.files[0];if(!e)return;if(!e.name.toLowerCase().endsWith(".svg"))return void this.sketchManager.editor.showStatus("Поддерживается только формат SVG","error");const r=new FileReader;r.onload=t=>{this.importSVG(t.target.result,e.name)},r.onerror=()=>{this.sketchManager.editor.showStatus("Ошибка чтения файла","error")},r.readAsText(e)}importSVG(t,e){try{const e=(new DOMParser).parseFromString(t,"image/svg+xml");if(e.querySelector("parsererror"))throw new Error("Некорректный SVG файл");const r=this.checkForYInversion(e),n=e.querySelectorAll("line, rect, circle, ellipse, polygon, polyline, path");if(0===n.length)return void this.sketchManager.editor.showStatus("SVG файл не содержит векторных элементов","warning");let o=0;const s=0,i=0;n.forEach((t,e)=>{const n=this.convertSVGToSketchElement(t,s,i,r);n&&(this.sketchManager.elementManager.addElement(n),o++)}),this.sketchManager.editor.showStatus(`Импортировано ${o} элементов из SVG`,"success")}catch(t){console.error("Ошибка парсинга SVG:",t),this.sketchManager.editor.showStatus(`Ошибка импорта SVG: ${t.message}`,"error")}}checkForYInversion(t){const e=t.querySelectorAll("g");for(const t of e){const e="true"===t.getAttribute("data-y-inversion"),r=t.getAttribute("transform"),n=r&&r.includes("scale(1, -1)");if(e||n)return!0}return!1}convertSVGToSketchElement(t,e,r,n){const o=t.tagName.toLowerCase();try{switch(o){case"line":return this.convertSVGLine(t,e,r,n);case"rect":return this.convertSVGRect(t,e,r,n);case"circle":return this.convertSVGCircle(t,e,r,n);case"ellipse":return this.convertSVGEllipse(t,e,r,n);case"polygon":case"polyline":return this.convertSVGPoly(t,e,r,o,n);case"path":return this.convertSVGPath(t,e,r,n);default:return null}}catch(t){return console.warn(`Не удалось конвертировать элемент ${o}:`,t),null}}convertSVGLine(t,e,r,n){let o=parseFloat(t.getAttribute("x1")||0)+e,s=parseFloat(t.getAttribute("y1")||0)+r,i=parseFloat(t.getAttribute("x2")||0)+e,c=parseFloat(t.getAttribute("y2")||0)+r;n||(s=-s,c=-c);const a=new THREE.Vector3(o,s,0),l=new THREE.Vector3(i,c,0);return{type:"line",start:a,end:l,points:[a,l],color:this.sketchManager.sketchColor}}convertSVGRect(t,e,r,n){let o=parseFloat(t.getAttribute("x")||0)+e,s=parseFloat(t.getAttribute("y")||0)+r;const i=parseFloat(t.getAttribute("width")||0),c=parseFloat(t.getAttribute("height")||0);n||(s=-s);const a=[new THREE.Vector3(o,s,0),new THREE.Vector3(o+i,s,0),new THREE.Vector3(o+i,s-c,0),new THREE.Vector3(o,s-c,0),new THREE.Vector3(o,s,0)];return{type:"rectangle",start:a[0].clone(),end:a[2].clone(),width:i,height:c,points:a,color:this.sketchManager.sketchColor}}convertSVGCircle(t,e,r,n){let o=parseFloat(t.getAttribute("cx")||0)+e,s=parseFloat(t.getAttribute("cy")||0)+r;const i=parseFloat(t.getAttribute("r")||0);n||(s=-s);return{type:"circle",center:new THREE.Vector3(o,s,0),radius:i,diameter:2*i,segments:32,points:this.calculateCirclePoints(o,s,i,32),color:this.sketchManager.sketchColor}}convertSVGEllipse(t,e,r,n){let o=parseFloat(t.getAttribute("cx")||0)+e,s=parseFloat(t.getAttribute("cy")||0)+r;const i=parseFloat(t.getAttribute("rx")||0),c=parseFloat(t.getAttribute("ry")||0);n||(s=-s);return{type:"oval",center:new THREE.Vector3(o,s,0),radiusX:i,radiusY:c,segments:32,points:this.calculateOvalPoints(o,s,i,c,32),color:this.sketchManager.sketchColor}}convertSVGPoly(t,e,r,n,o){const s=t.getAttribute("points");if(!s)return null;const i=s.trim().split(/[\s,]+/),c=[];for(let t=0;t<i.length;t+=2){let n=parseFloat(i[t])+e,s=parseFloat(i[t+1])+r;o||(s=-s),c.push(new THREE.Vector3(n,s,0))}return{type:"polygon"===n?"polygon":"polyline",points:c,color:this.sketchManager.sketchColor}}convertSVGPath(t,e,r,n){const o=t.getAttribute("d");if(!o)return null;const s=o.match(/[MLCQ][^MLCQ]*/gi);if(!s)return null;const i=[];return s.forEach(t=>{const o=t[0],s=t.substring(1).trim().split(/[\s,]+/).map(Number);switch(o.toUpperCase()){case"M":case"L":if(s.length>=2){let t=s[0]+e,o=s[1]+r;n||(o=-o),i.push(new THREE.Vector3(t,o,0))}break;case"C":if(s.length>=6){const t=i[i.length-1]||new THREE.Vector3(0,0,0);let o=s[0]+e,c=s[1]+r,a=s[2]+e,l=s[3]+r,h=s[4]+e,u=s[5]+r;n||(c=-c,l=-l,u=-u);const p=new THREE.Vector3(o,c,0),g=new THREE.Vector3(a,l,0),E=new THREE.Vector3(h,u,0),w=this.approximateBezier(t,p,g,E,10);i.push(...w.slice(1))}}}),i.length<2?null:{type:"polyline",points:i,color:this.sketchManager.sketchColor}}calculateCirclePoints(t,e,r,n){const o=[];for(let s=0;s<=n;s++){const i=s/n*Math.PI*2,c=t+Math.cos(i)*r,a=e+Math.sin(i)*r;o.push(new THREE.Vector3(c,a,0))}return o}calculateOvalPoints(t,e,r,n,o){const s=[];for(let i=0;i<=o;i++){const c=i/o*Math.PI*2,a=t+Math.cos(c)*r,l=e+Math.sin(c)*n;s.push(new THREE.Vector3(a,l,0))}return s}approximateBezier(t,e,r,n,o){const s=[];for(let i=0;i<=o;i++){const c=i/o,a=Math.pow(1-c,3)*t.x+3*Math.pow(1-c,2)*c*e.x+3*(1-c)*Math.pow(c,2)*r.x+Math.pow(c,3)*n.x,l=Math.pow(1-c,3)*t.y+3*Math.pow(1-c,2)*c*e.y+3*(1-c)*Math.pow(c,2)*r.y+Math.pow(c,3)*n.y;s.push(new THREE.Vector3(a,l,0))}return s}dispose(){this.fileInput&&this.fileInput.parentNode&&(this.fileInput.parentNode.removeChild(this.fileInput),this.fileInput=null)}}