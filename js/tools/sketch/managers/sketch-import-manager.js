import*as THREE from"three";export class SketchImportManager{constructor(t){this.sketchManager=t,this.fileInput=null}init(){this.fileInput=document.createElement("input"),this.fileInput.type="file",this.fileInput.accept=".svg",this.fileInput.style.display="none",this.fileInput.addEventListener("change",t=>this.handleFileSelect(t)),document.body.appendChild(this.fileInput)}openImportDialog(){this.sketchManager.currentPlane?this.fileInput&&this.fileInput.click():this.sketchManager.editor.showStatus("Сначала откройте скетч","warning")}handleFileSelect(t){const e=t.target.files[0];if(!e)return;if(!e.name.toLowerCase().endsWith(".svg"))return void this.sketchManager.editor.showStatus("Поддерживается только формат SVG","error");const r=new FileReader;r.onload=t=>{this.importSVG(t.target.result,e.name)},r.onerror=()=>{this.sketchManager.editor.showStatus("Ошибка чтения файла","error")},r.readAsText(e)}importSVG(t,e){try{const e=(new DOMParser).parseFromString(t,"image/svg+xml");if(e.querySelector("parsererror"))throw new Error("Некорректный SVG файл");const r=this.checkForYInversion(e),o=e.querySelectorAll("line, rect, circle, ellipse, polygon, polyline, path");if(0===o.length)return void this.sketchManager.editor.showStatus("SVG файл не содержит векторных элементов","warning");let n=0;const s=0,i=0;o.forEach((t,e)=>{const o=this.convertSVGToSketchElement(t,s,i,r);o&&(this.sketchManager.elementManager.addElement(o),n++)}),this.sketchManager.editor.showStatus(`Импортировано ${n} элементов из SVG`,"success")}catch(t){console.error("Ошибка парсинга SVG:",t),this.sketchManager.editor.showStatus(`Ошибка импорта SVG: ${t.message}`,"error")}}checkForYInversion(t){const e=t.querySelectorAll("g");for(const t of e){const e="true"===t.getAttribute("data-y-inversion"),r=t.getAttribute("transform"),o=r&&r.includes("scale(1, -1)");if(e||o)return!0}return!1}convertSVGToSketchElement(t,e,r,o){const n=t.tagName.toLowerCase();try{switch(n){case"line":return this.convertSVGLine(t,e,r,o);case"rect":return this.convertSVGRect(t,e,r,o);case"circle":return this.convertSVGCircle(t,e,r,o);case"ellipse":return this.convertSVGEllipse(t,e,r,o);case"polygon":case"polyline":return this.convertSVGPoly(t,e,r,n,o);case"path":return this.convertSVGPath(t,e,r,o);default:return null}}catch(t){return console.warn(`Не удалось конвертировать элемент ${n}:`,t),null}}convertSVGLine(t,e,r,o){let n=parseFloat(t.getAttribute("x1")||0)+e,s=parseFloat(t.getAttribute("y1")||0)+r,i=parseFloat(t.getAttribute("x2")||0)+e,a=parseFloat(t.getAttribute("y2")||0)+r;o||(s=-s,a=-a);const c=new THREE.Vector3(n,s,0),l=new THREE.Vector3(i,a,0);return{type:"line",start:c,end:l,points:[c,l],color:this.sketchManager.sketchColor}}convertSVGRect(t,e,r,o){let n=parseFloat(t.getAttribute("x")||0)+e,s=parseFloat(t.getAttribute("y")||0)+r;const i=parseFloat(t.getAttribute("width")||0),a=parseFloat(t.getAttribute("height")||0);o||(s=-s);const c=[new THREE.Vector3(n,s,0),new THREE.Vector3(n+i,s,0),new THREE.Vector3(n+i,s-a,0),new THREE.Vector3(n,s-a,0),new THREE.Vector3(n,s,0)];return{type:"rectangle",start:c[0].clone(),end:c[2].clone(),width:i,height:a,points:c,color:this.sketchManager.sketchColor}}convertSVGCircle(t,e,r,o){let n=parseFloat(t.getAttribute("cx")||0)+e,s=parseFloat(t.getAttribute("cy")||0)+r;const i=parseFloat(t.getAttribute("r")||0);o||(s=-s);return{type:"circle",center:new THREE.Vector3(n,s,0),radius:i,diameter:2*i,segments:32,points:this.calculateCirclePoints(n,s,i,32),color:this.sketchManager.sketchColor}}convertSVGEllipse(t,e,r,o){let n=parseFloat(t.getAttribute("cx")||0)+e,s=parseFloat(t.getAttribute("cy")||0)+r;const i=parseFloat(t.getAttribute("rx")||0),a=parseFloat(t.getAttribute("ry")||0);o||(s=-s);return{type:"oval",center:new THREE.Vector3(n,s,0),radiusX:i,radiusY:a,segments:32,points:this.calculateOvalPoints(n,s,i,a,32),color:this.sketchManager.sketchColor}}convertSVGPoly(t,e,r,o,n){const s=t.getAttribute("points");if(!s)return null;const i=s.trim().split(/[\s,]+/),a=[];for(let t=0;t<i.length;t+=2){let o=parseFloat(i[t])+e,s=parseFloat(i[t+1])+r;n||(s=-s),a.push(new THREE.Vector3(o,s,0))}return{type:"polygon"===o?"polygon":"polyline",points:a,color:this.sketchManager.sketchColor}}convertSVGPath(t,e,r,o){const n=t.getAttribute("d");if(!n)return null;const s=n.match(/[MLCQ][^MLCQ]*/gi);if(!s)return null;const i=[];return s.forEach(t=>{const n=t[0],s=t.substring(1).trim().split(/[\s,]+/).map(Number);switch(n.toUpperCase()){case"M":case"L":if(s.length>=2){let t=s[0]+e,n=s[1]+r;o||(n=-n),i.push(new THREE.Vector3(t,n,0))}break;case"C":if(s.length>=6){const t=i[i.length-1]||new THREE.Vector3(0,0,0);let n=s[0]+e,a=s[1]+r,c=s[2]+e,l=s[3]+r,h=s[4]+e,u=s[5]+r;o||(a=-a,l=-l,u=-u);const p=new THREE.Vector3(n,a,0),g=new THREE.Vector3(c,l,0),E=new THREE.Vector3(h,u,0),w=this.approximateBezier(t,p,g,E,10);i.push(...w.slice(1))}}}),i.length<2?null:{type:"polyline",points:i,color:this.sketchManager.sketchColor}}calculateCirclePoints(t,e,r,o){const n=[];for(let s=0;s<=o;s++){const i=s/o*Math.PI*2,a=t+Math.cos(i)*r,c=e+Math.sin(i)*r;n.push(new THREE.Vector3(a,c,0))}return n}calculateOvalPoints(t,e,r,o,n){const s=[];for(let i=0;i<=n;i++){const a=i/n*Math.PI*2,c=t+Math.cos(a)*r,l=e+Math.sin(a)*o;s.push(new THREE.Vector3(c,l,0))}return s}approximateBezier(t,e,r,o,n){const s=[];for(let i=0;i<=n;i++){const a=i/n,c=Math.pow(1-a,3)*t.x+3*Math.pow(1-a,2)*a*e.x+3*(1-a)*Math.pow(a,2)*r.x+Math.pow(a,3)*o.x,l=Math.pow(1-a,3)*t.y+3*Math.pow(1-a,2)*a*e.y+3*(1-a)*Math.pow(a,2)*r.y+Math.pow(a,3)*o.y;s.push(new THREE.Vector3(c,l,0))}return s}dispose(){this.fileInput&&this.fileInput.parentNode&&(this.fileInput.parentNode.removeChild(this.fileInput),this.fileInput=null)}}