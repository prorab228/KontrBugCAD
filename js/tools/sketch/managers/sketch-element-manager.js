class SketchElementManager{constructor(e,t){this.sketchManager=e,this.elements=[],this.clipboard=[],this.selectedElements=[],this.snapHelper=t}copySelectedElements(){0!==this.selectedElements.length?(this.clipboard=this.selectedElements.map(e=>this.serializeSketchElement(e.mesh)),this.sketchManager.editor.showStatus(`Скопировано элементов: ${this.selectedElements.length}`,"success")):this.sketchManager.editor.showStatus("Нет выделенных элементов для копирования","warning")}cutSelectedElements(){0!==this.selectedElements.length?(this.copySelectedElements(),this.deleteSelectedElements()):this.sketchManager.editor.showStatus("Нет выделенных элементов для вырезания","warning")}pasteElements(){if(0===this.clipboard.length)return void this.sketchManager.editor.showStatus("Буфер обмена пуст","warning");if(!this.sketchManager.currentPlane)return void this.sketchManager.editor.showStatus("Нет активного скетча для вставки","error");const e=this.getCurrentSketchState(),t=[];this.clipboard.forEach(e=>{try{const s=JSON.parse(JSON.stringify(e));if(s.uuid=THREE.MathUtils.generateUUID(),!s.geometry&&!s.userData?.localPoints)return void console.warn("Элемент не содержит геометрии для вставки:",s);const i=this.createElementFromClipboardData(s);if(i){this.addElement(i,!1);const e=this.elements[this.elements.length-1];e&&t.push(e)}}catch(e){console.error("Ошибка при вставке элемента:",e)}}),t.length>0&&this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_add",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:e,elements:t.map(e=>({uuid:e.mesh.uuid,data:this.serializeSketchElement(e.mesh)}))}),this.clearSelection(),t.forEach(e=>{this.selectedElements.push(e),this.highlightElement(e)}),this.sketchManager.toolManager.setCurrentTool("move"),this.sketchManager.editor.showStatus(`Вставлено элементов: ${t.length}`,"success")}createElementFromClipboardData(e){if(!e||!e.userData)return null;const t=e.userData,s=[];if(t.localPoints&&Array.isArray(t.localPoints))t.localPoints.forEach(e=>{Array.isArray(e)?s.push(new THREE.Vector3(e[0]||0,e[1]||0,e[2]||0)):e&&void 0!==e.x&&s.push(new THREE.Vector3(e.x||0,e.y||0,e.z||0))});else if(e.geometry?.attributes?.position){const t=e.geometry.attributes.position;if(Array.isArray(t))for(let e=0;e<t.length;e+=3)s.push(new THREE.Vector3(t[e]||0,t[e+1]||0,t[e+2]||0))}if(0===s.length)return console.warn("Не удалось создать точки из данных элемента"),null;const i={type:t.elementType||"line",points:s,color:t.originalColor||this.sketchManager.sketchColor};return["radius","diameter","width","height","radiusX","radiusY","sides","dashSize","gapSize","startAngle","endAngle","length"].forEach(e=>{void 0!==t[e]&&(i[e]=t[e])}),t.center&&(Array.isArray(t.center)?i.center=(new THREE.Vector3).fromArray(t.center):void 0!==t.center.x&&(i.center=new THREE.Vector3(t.center.x||0,t.center.y||0,t.center.z||0))),i}addElement(e,t=!0){if(!e||!e.type)return;const s=this.getCurrentSketchState(),i=["rectangle","circle","polygon","oval","stadium","arc"].includes(e.type),r=this.createElementGeometry(e,i);if(!r)return;const a=this.createElementMesh(e,r,i);a.userData=this.createElementUserData(e,a,i),this.sketchManager.currentPlane.add(a),e.mesh=a,this.elements.push(e),t&&this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_add",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:s,elements:[{uuid:a.uuid,data:this.serializeSketchElement(a)}]}),this.snapHelper&&this.snapHelper.updateSnapPoints(),this.showSuccessMessage(e.type)}createElementGeometry(e,t){const s=e.points||[];if(0===s.length)return null;const i=[];s.forEach(e=>{i.push(e.x,e.y,.01)});const r=new THREE.BufferGeometry;return r.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),r}createElementMesh(e,t,s){let i;if("dashedline"===e.type){const s=new THREE.LineDashedMaterial({color:new THREE.Color(e.color||this.sketchManager.sketchColor),linewidth:2,dashSize:e.dashSize||1,gapSize:e.gapSize||1,scale:1});i=new THREE.Line(t,s),i.computeLineDistances()}else i=s?new THREE.LineLoop(t,new THREE.LineBasicMaterial({color:new THREE.Color(e.color||this.sketchManager.sketchColor),linewidth:2})):new THREE.Line(t,new THREE.LineBasicMaterial({color:new THREE.Color(e.color||this.sketchManager.sketchColor),linewidth:2}));return i.frustumCulled=!1,i}createElementUserData(e,t,s){const i={type:"sketch_element",elementType:e.type,isClosed:s,originalColor:new THREE.Color(e.color||this.sketchManager.sketchColor),sketchPlaneId:this.sketchManager.currentPlane.uuid,localPoints:e.points?e.points.map(e=>e.clone()):[],createdAt:(new Date).toISOString()};return["center","radius","diameter","width","height","radiusX","radiusY","sides","dashSize","gapSize","startAngle","endAngle","start","end","length"].forEach(t=>{void 0!==e[t]&&(i[t]=e[t])}),i}showSuccessMessage(e){this.sketchManager.editor.showStatus(`Добавлен элемент: ${{line:"Линия",rectangle:"Прямоугольник",circle:"Окружность",polygon:"Многоугольник",polyline:"Полилиния",arc:"Дуга",oval:"Овал",stadium:"Стадион",mirror:"Симметрия","dashed-line":"Пунктирная линия",dimension:"Размер"}[e]||e}`,"success")}serializeSketchElement(e){return e?this.sketchManager.editor.projectManager?this.sketchManager.editor.projectManager.serializeObject(e):{uuid:e.uuid,type:e.type,userData:{...e.userData},geometry:e.geometry?{type:e.geometry.type,parameters:e.geometry.parameters||{},attributes:e.geometry.attributes?{position:Array.from(e.geometry.attributes.position.array)}:{}}:null,material:e.material?{type:e.material.type,color:e.material.color?e.material.color.getHex():0,linewidth:e.material.linewidth||2}:null}:null}getCurrentSketchState(){if(!this.sketchManager.currentPlane)return null;const e={planeId:this.sketchManager.currentPlane.uuid,elements:[]};return this.sketchManager.currentPlane.children.forEach(t=>{if(t.userData&&"sketch_element"===t.userData.type){const s=this.serializeSketchElement(t);s&&e.elements.push({uuid:t.uuid,data:s})}}),e}updateElementsFromPlane(){this.sketchManager.currentPlane&&(this.elements=[],this.selectedElements=[],this.sketchManager.currentPlane.children.forEach(e=>{if(e.userData&&"sketch_element"===e.userData.type){const t={type:e.userData.elementType,mesh:e,originalColor:e.userData.originalColor||new THREE.Color(this.sketchManager.sketchColor),color:e.userData.originalColor||this.sketchManager.sketchColor,localPoints:e.userData.localPoints,localPosition:e.userData.localPosition,isClosed:e.userData.isClosed,sketchPlaneId:e.userData.sketchPlaneId,userData:e.userData};this.elements.push(t)}}))}removeElementFromArrays(e){const t=e.mesh||e,s=this.elements.findIndex(e=>e.mesh===t);s>-1&&this.elements.splice(s,1);const i=this.selectedElements.findIndex(e=>e.mesh===t);i>-1&&this.selectedElements.splice(i,1)}getElementAtPoint(e){if(!this.sketchManager.currentPlane)return null;for(let t=this.elements.length-1;t>=0;t--){const s=this.elements[t];if(!s.mesh)continue;const i=s.mesh.userData?.localPoints||[];for(let t=0;t<i.length-1;t++){const r=i[t],a=i[t+1];if(!r||!a)continue;if(this.pointToLineDistance(e,r,a)<=.1)return s}if(i.length>=3&&s.mesh.userData?.isClosed){const t=i[i.length-1],r=i[0];if(t&&r){if(this.pointToLineDistance(e,t,r)<=.1)return s}}}return null}pointToLineDistance(e,t,s){const i=e.x-t.x,r=e.y-t.y,a=s.x-t.x,n=s.y-t.y,l=a*a+n*n;let o,h,c=-1;0!==l&&(c=(i*a+r*n)/l),c<0?(o=t.x,h=t.y):c>1?(o=s.x,h=s.y):(o=t.x+c*a,h=t.y+c*n);const m=e.x-o,d=e.y-h;return Math.sqrt(m*m+d*d)}selectElement(e){this.clearSelection(),this.selectedElements=[e],this.highlightElement(e),this.sketchManager.editor.showStatus(`Выбран элемент: ${this.getToolName(e.type)}`,"info")}toggleElementSelection(e){const t=this.selectedElements.indexOf(e);t>-1?(this.unhighlightElement(e),this.selectedElements.splice(t,1)):(this.selectedElements.push(e),this.highlightElement(e)),this.sketchManager.editor.showStatus(`Выбрано элементов: ${this.selectedElements.length}`,"info")}selectAllElements(){this.clearSelection(),this.selectedElements=[...this.elements],this.selectedElements.forEach(e=>this.highlightElement(e)),console.log("выделено",this.selectedElements),this.sketchManager.editor.showStatus(`Выбрано всех элементов: ${this.selectedElements.length}`,"info")}clearSelection(){this.selectedElements.forEach(e=>this.unhighlightElement(e)),this.selectedElements=[]}highlightElement(e){if(e.mesh&&e.mesh.material){if(!e.originalColor){if(e.mesh.material.color instanceof THREE.Color)e.originalColor=e.mesh.material.color.clone();else if(e.mesh.userData?.originalColor instanceof THREE.Color)e.originalColor=e.mesh.userData.originalColor.clone();else{let t=1118481;if(void 0!==e.mesh.material.color)if("number"==typeof e.mesh.material.color)t=e.mesh.material.color;else if("string"==typeof e.mesh.material.color)try{t=new THREE.Color(e.mesh.material.color).getHex()}catch(e){console.warn("Error parsing color string:",e)}e.originalColor=new THREE.Color(t)}void 0!==e.mesh.material.linewidth&&(e.originalLinewidth=e.mesh.material.linewidth)}e.mesh.material.color.set(this.sketchManager.highlightColor),e.mesh.material.needsUpdate=!0,void 0!==e.mesh.material.linewidth&&(e.mesh.material.linewidth=4,e.mesh.material.needsUpdate=!0)}}unhighlightElement(e){e.mesh&&e.mesh.material&&e.originalColor&&(e.originalColor instanceof THREE.Color?e.mesh.material.color.copy(e.originalColor):e.mesh.material.color.set(e.originalColor),e.mesh.material.needsUpdate=!0,void 0!==e.mesh.material.linewidth&&void 0!==e.originalLinewidth&&(e.mesh.material.linewidth=e.originalLinewidth,e.mesh.material.needsUpdate=!0,delete e.originalLinewidth),delete e.originalColor)}deleteSelectedElements(){if(0===this.selectedElements.length)return void this.sketchManager.editor.showStatus("Нет выделенных элементов для удаления","warning");const e=this.getCurrentSketchState(),t=[...this.selectedElements];this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_delete",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:e,elements:t.map(e=>({uuid:e.mesh.uuid,data:this.serializeSketchElement(e.mesh)}))}),t.forEach(e=>{e.mesh&&e.mesh.parent&&(e.mesh.parent.remove(e.mesh),e.mesh.geometry&&e.mesh.geometry.dispose(),e.mesh.material&&e.mesh.material.dispose());const t=this.elements.indexOf(e);t>-1&&this.elements.splice(t,1)}),this.selectedElements=[],this.snapHelper&&this.snapHelper.updateSnapPoints(),this.sketchManager.editor.showStatus(`Удалено элементов: ${t.length}`,"success")}updateElementGeometry(e){if(!e||!e.geometry||!e.userData.localPoints)return;const t=[];e.userData.localPoints.forEach(e=>{t.push(e.x,e.y,0)}),e.geometry.setAttribute("position",new THREE.Float32BufferAttribute(t,3)),e.geometry.attributes.position.needsUpdate=!0,e.computeLineDistances&&e.computeLineDistances()}deleteAllElements(){if(0===this.elements.length)return;if(!confirm("Очистить весь чертеж?"))return;const e=this.getCurrentSketchState();this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_delete",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:e,elements:this.elements.map(e=>({uuid:e.mesh.uuid,data:this.serializeSketchElement(e.mesh)}))}),this.elements.forEach(e=>{e.mesh&&e.mesh.parent&&(e.mesh.parent.remove(e.mesh),e.mesh.geometry&&e.mesh.geometry.dispose(),e.mesh.material&&e.mesh.material.dispose())}),this.elements=[],this.selectedElements=[],this.sketchManager.editor.showStatus("Чертеж очищен","success")}getToolName(e){return{line:"Линия",rectangle:"Прямоугольник",circle:"Окружность",polygon:"Многоугольник",polyline:"Полилиния",arc:"Дуга",oval:"Овал",stadium:"Стадион",mirror:"Симметрия","dashed-line":"Пунктирная линия",dimension:"Размер"}[e]||e}collectSketchElements(e){return this.elements=[],this.selectedElements=[],e.children.forEach(e=>{if(e.userData&&"sketch_element"===e.userData.type){e.frustumCulled=!1;const t={type:e.userData.elementType,mesh:e,originalColor:e.userData.originalColor||new THREE.Color(this.sketchManager.sketchColor),color:e.userData.originalColor||this.sketchManager.sketchColor,localPoints:e.userData.localPoints,localPosition:e.userData.localPosition,isClosed:e.userData.isClosed,sketchPlaneId:e.userData.sketchPlaneId,userData:e.userData};void 0!==e.userData.radius&&(t.radius=e.userData.radius),void 0!==e.userData.width&&(t.width=e.userData.width),void 0!==e.userData.height&&(t.height=e.userData.height),this.elements.push(t)}}),this.elements.length}clear(){this.elements.forEach(e=>this.unhighlightElement(e)),this.elements=[],this.selectedElements=[]}}