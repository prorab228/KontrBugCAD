import*as THREE from"three";import{FigureNode}from"./FigureNode.js";export class SketchRegionManager{constructor(e,t){this.editor=e,this.plane=t,this.regions=[],this.regionMap=new Map,this.rootNodes=[],this.nodes=[],this.fillGroup=new THREE.Group,this.fillGroup.userData.isRegionFill=!0,this.plane.add(this.fillGroup),this.hoverFillMesh=null,this.selectedFills=new Map,this.clipperScale=1e5,this.clipperAvailable="undefined"!=typeof ClipperLib,this.clipperAvailable&&(ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale),console.log(`SketchRegionManager создан для плоскости ${t.uuid}`)}getElements(){const e=[];return this.plane.traverse(t=>{"sketch_element"===t.userData?.type&&e.push(t)}),e}debugPrintRegions(){if(console.log(`=== REGION TREE for plane ${this.plane.uuid} ===`),0===this.rootNodes.length)return void console.log("  No root nodes");const e=(t,o="")=>{const n=t.isHole?"HOLE":"OUTER";console.log(`${o}${n} [${t.id.substring(0,8)}] area=${t.area.toFixed(2)} points=${t.contour.points.length} children=${t.children.length}`),t.children.forEach(t=>e(t,o+"  "))};this.rootNodes.forEach((t,o)=>{console.log(`Root ${o}:`),e(t,"  ")}),console.log(`Total regions: ${this.regions.length}`)}updateRegions(){const e=this.getElements();if(0===e.length)return void this.clear();const t=this.collectSimpleContours(e),o=this.collectLineContours(e,t);let n=[...t,...o];const i=this.getCuttingLines(e,n);i.length>0&&(n=this.cutContoursWithLines(n,i)),this.clipperAvailable&&n.length>0&&(n=this.advancedSeparateContours(n)),this.buildNestingTree(n),this.determineContourTypes(),this.regions=this.buildRegionsFromTree(),this.updateRegionMap(),this.updateRegionFills(),this.debugPrintRegions(),console.log(`SketchRegionManager: обновлено регионов – ${this.regions.length}`)}collectSimpleContours(e){const t=[];return e.forEach(e=>{if(!this.isElementClosed(e))return;const o=this.getElementPoints(e);if(o.length<3)return;const n=this.calculatePolygonArea(o);Math.abs(n)<.001||t.push({element:e,points:o,area:Math.abs(n),center:this.calculateContourCenter(o),boundingBox:this.calculateBoundingBox(o),type:e.userData?.elementType||"unknown",isClosed:!0,isClockwise:n<0,elementIds:new Set([e.uuid]),plane:this.plane,planeId:this.plane.uuid})}),console.log(`collectSimpleContours: найдено ${t.length} простых контуров`),t}collectLineContours(e,t){const o=new Set;t.forEach(e=>{e.element&&o.add(e.element.uuid)});const n=e.filter(e=>{const t=e.userData?.elementType;return("line"===t||"polyline"===t)&&!o.has(e.uuid)});if(n.length<3)return[];const i=n.map(e=>{const t=this.getElementPoints(e);return{element:e,start:t[0],end:t[1],points:t}});return this.findClosedContoursFromLines(i)}findClosedContoursFromLines(e){const t=[],o=new Set;for(let n=0;n<e.length;n++){if(o.has(n))continue;const i=this.buildContourFromLine(n,e,o);if(i&&i.points.length>=3){const e=this.calculatePolygonArea(i.points);Math.abs(e)>.01&&t.push({elements:i.elements,points:i.points,area:Math.abs(e),center:this.calculateContourCenter(i.points),boundingBox:this.calculateBoundingBox(i.points),type:"line_contour",isClosed:!0,isClockwise:e<0,elementIds:new Set(i.elements.map(e=>e.uuid)),plane:this.plane,planeId:this.plane.uuid})}}return t}buildContourFromLine(e,t,o){const n=t[e],i=[n.element],s=[n.start.clone(),n.end.clone()];o.add(e);let r=n.end,l=0;for(;l<100;){let e=!1;for(let n=0;n<t.length;n++){if(o.has(n))continue;const l=t[n];if(r.distanceTo(l.start)<.5){r=l.end.clone(),s.push(r.clone()),i.push(l.element),o.add(n),e=!0;break}if(r.distanceTo(l.end)<.5){r=l.start.clone(),s.push(r.clone()),i.push(l.element),o.add(n),e=!0;break}}if(!e)break;if(r.distanceTo(n.start)<.5)return{elements:i,points:s};l++}return null}getCuttingLines(e,t){const o=new Set;return t.forEach(e=>e.elementIds.forEach(e=>o.add(e))),e.filter(e=>{const t=e.userData?.elementType;return("line"===t||"polyline"===t)&&!o.has(e.uuid)})}cutContoursWithLines(e,t){if(console.log("=== cutContoursWithLines ==="),0===t.length||0===e.length)return e;try{let o=[...e];for(const e of t){const t=this.getElementPoints(e);if(t.length<2)continue;const n=[];for(const e of o){const o=e.points||[];if(o.length<3){n.push(e);continue}if(this.findContourLineIntersections(o,t).length>=2){const o=this.splitContourByLine(e,t);n.push(...o)}else n.push(e)}o=n}return console.log(`После разрезания: было ${e.length}, стало ${o.length} контуров`),o}catch(t){return console.error("Ошибка при разрезании контуров линиями:",t),e}}findContourLineIntersections(e,t){const o=[],n=t[0],i=t[1];for(let t=0;t<e.length;t++){const s=(t+1)%e.length,r=e[t],l=e[s],h=this.getLineIntersection(r,l,n,i);h&&o.push({point:h,segmentIndex:t,t:this.getIntersectionParameter(r,l,h)})}return o}splitContourByLine(e,t){const o=e.points||[];if(o.length<4)return[e];const n=[];for(let e=0;e<o.length;e++){const i=(e+1)%o.length,s=this.getLineIntersection(o[e],o[i],t[0],t[1]);s&&n.push({point:s,segmentIndex:e,t:this.getIntersectionParameter(o[e],o[i],s)})}if(2!==n.length)return[e];n.sort((e,t)=>e.segmentIndex!==t.segmentIndex?e.segmentIndex-t.segmentIndex:e.t-t.t);const[i,s]=n,r=this.buildNewContour(o,i,s,!0),l=this.buildNewContour(o,s,i,!0),h=[];if(r.length>=4){const t=this.createCutContour(e,r);t&&h.push(t)}if(l.length>=4){const t=this.createCutContour(e,l);t&&h.push(t)}return h.length>0?h:[e]}buildNewContour(e,t,o,n){const i=[];i.push(t.point.clone());let s=t.segmentIndex;const r=e.length;let l=0;for(;l<2*r;){let h;if(l++,h=n?(s+1)%r:(s-1+r)%r,h===o.segmentIndex){e[h].equals(t.point)||i.push(e[h].clone());break}e[h].equals(t.point)||i.push(e[h].clone()),s=h}return i.push(o.point.clone()),i.length>0&&!i[0].equals(i[i.length-1])&&i.push(i[0].clone()),i}createCutContour(e,t){const o=this.calculatePolygonArea(t),n=Math.abs(o);if(n<.01)return null;const i=o<0,s=i?t:t.reverse();return{...e,points:s,area:n,center:this.calculateContourCenter(s),boundingBox:this.calculateBoundingBox(s),isClockwise:i,isCut:!0,cutFrom:e.id||e.type,originalContourId:e.id||e.uuid}}advancedSeparateContours(e){if(console.log("=== advancedSeparateContours (Clipper) ==="),!this.clipperAvailable||0===e.length)return e;try{const{holes:t,solids:o}=this.separateHolesAndSolids(e),n=[...this.separateSolidContours(o),...t];return console.log(`Всего получено ${n.length} контуров`),n}catch(t){return console.error("Ошибка при разделении контуров через Clipper:",t),e}}separateHolesAndSolids(e){const t=[],o=[],n=[...e.map(e=>new FigureNode(e))].sort((e,t)=>t.area-e.area);for(let e=0;e<n.length;e++){const t=n[e];for(let o=0;o<e;o++){const e=n[o];if(this.isContourInside(t.contour,e.contour)){e.addChild(t);break}}}const i=n.filter(e=>null===e.parent),s=(e,n)=>{e.depth=n,e.isHole=n%2==1,e.isHole?t.push(e.contour):o.push(e.contour),e.children.forEach(e=>s(e,n+1))};return i.forEach(e=>s(e,0)),console.log(`Найдено: ${o.length} твердых тел, ${t.length} отверстий`),{holes:t,solids:o}}separateSolidContours(e){return 0===e.length?[]:1===e.length?[e[0]]:2===e.length?this.separateTwoSolids(e[0],e[1]):this.separateMultipleSolids(e)}separateTwoSolids(e,t){try{const o=e.points||[],n=t.points||[];if(o.length<3||n.length<3)return[e,t];const i=[];this.clipperDifference(o,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid1_minus_2"))});this.clipperDifference(n,o).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid2_minus_1"))});return this.clipperIntersection(o,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"intersection"))}),i.length>0?i:[e,t]}catch(o){return console.error("Ошибка при разделении двух тел:",o),[e,t]}}separateMultipleSolids(e){try{console.log(`Разделение ${e.length} твердых тел`);let t=[];for(let o=1;o<1<<e.length;o++){const n=[];for(let t=0;t<e.length;t++)o&1<<t&&n.push(e[t]);if(0===n.length)continue;let i=n[0].points||[];for(let e=1;e<n.length&&0!==i.length;e++)i=this.clipperIntersection(i,n[e].points||[])[0]||[];if(i.length<3)continue;let s=i;for(let t=0;t<e.length;t++)if(!(o&1<<t)){if(s=this.clipperDifference(s,e[t].points||[])[0]||[],0===s.length)break}if(s.length>=3){const e=this.calculatePolygonArea(s);Math.abs(e)>.01&&t.push({points:s,mask:o,area:Math.abs(e)})}}const o=t.map((e,t)=>this.createSeparatedContour(e.points,`area_${t}`));return o.length>0?o:e}catch(t){return console.error("Ошибка при разделении нескольких тел:",t),e}}clipperDifference(e,t){try{const o=new ClipperLib.Clipper,n=this.pointsToClipperPath(e),i=this.pointsToClipperPath(t);o.AddPath(n,ClipperLib.PolyType.ptSubject,!0),o.AddPath(i,ClipperLib.PolyType.ptClip,!0);const s=new ClipperLib.Paths;return o.Execute(ClipperLib.ClipType.ctDifference,s,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?s.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Difference:",e),[]}}clipperIntersection(e,t){try{const o=new ClipperLib.Clipper,n=this.pointsToClipperPath(e),i=this.pointsToClipperPath(t);o.AddPath(n,ClipperLib.PolyType.ptSubject,!0),o.AddPath(i,ClipperLib.PolyType.ptClip,!0);const s=new ClipperLib.Paths;return o.Execute(ClipperLib.ClipType.ctIntersection,s,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?s.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Intersection:",e),[]}}createSeparatedContour(e,t){const o=this.calculatePolygonArea(e),n=Math.abs(o),i=o<0,s=i?e:e.reverse();return{points:s,area:n,center:this.calculateContourCenter(s),boundingBox:this.calculateBoundingBox(s),type:t,isClosed:!0,isClockwise:i,planeId:this.plane.uuid,plane:this.plane,isSeparated:!0}}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let o=0;o<e.length;o++)t[o]=new ClipperLib.IntPoint(Math.round(e[o].x*this.clipperScale),Math.round(e[o].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let o=0;o<e.length;o++)t.push(new THREE.Vector2(e[o].X/this.clipperScale,e[o].Y/this.clipperScale));return t}buildNestingTree(e){const t=e.map(e=>new FigureNode(e)),o=[...t].sort((e,t)=>t.area-e.area);for(let e=0;e<o.length;e++){const t=o[e];let n=null,i=1/0;for(let s=0;s<e;s++){const e=o[s];this.isContourInside(t.contour,e.contour)&&e.area<i&&(n=e,i=e.area)}n&&n.addChild(t)}this.rootNodes=t.filter(e=>null===e.parent),this.updateDepths(this.rootNodes,0),this.nodes=t}updateDepths(e,t){e.forEach(e=>{e.depth=t,this.updateDepths(e.children,t+1)})}determineContourTypes(){const e=t=>{t.isHole=t.depth%2==1,t.isOuter=!t.isHole,t.children.forEach(e)};this.rootNodes.forEach(e)}isPointOnPolygonBoundary(e,t,o=.001){for(let n=0;n<t.length;n++){const i=(n+1)%t.length,s=t[n],r=t[i];if(this.distancePointToSegment(e,s,r)<o)return!0}return!1}distancePointToSegment(e,t,o){const n=(new THREE.Vector2).subVectors(o,t),i=(new THREE.Vector2).subVectors(e,t),s=i.dot(n)/n.lengthSq();if(s<0)return i.length();if(s>1)return(new THREE.Vector2).subVectors(e,o).length();const r=(new THREE.Vector2).copy(t).add(n.multiplyScalar(s));return(new THREE.Vector2).subVectors(e,r).length()}isContourInside(e,t){const o=e?.points,n=t?.points;if(!o||!n||0===o.length||0===n.length)return!1;for(const e of o){if(!this.pointInPolygon(e,n))return!1;if(this.isPointOnPolygonBoundary(e,n))return!1}return!0}buildRegionsFromTree(){const e=[],t=o=>{const n=!o.isHole,i=o.children.filter(e=>e.isHole===n).map(e=>({points:e.contour.points,center:e.contour.center,area:e.contour.area,elementIds:e.elementIds,isClockwise:e.contour.isClockwise}));e.push({id:o.id,outer:{points:o.contour.points,center:o.contour.center,area:o.contour.area,elementIds:o.elementIds,isClockwise:o.contour.isClockwise},holes:i,area:o.area,isHole:o.isHole,isOuter:o.isOuter,depth:o.depth,plane:this.plane,planeId:this.plane.uuid,elementIds:o.elementIds}),o.children.forEach(e=>t(e))};return this.rootNodes.forEach(t),e}updateRegionMap(){this.regionMap.clear(),this.regions.forEach(e=>this.regionMap.set(e.id,e))}getAllRegions(){return this.regions}getRegionAtPoint(e){const t=new THREE.Vector2(e.x,e.y),o=[...this.regions].sort((e,t)=>t.depth-e.depth);for(const e of o)if(e.outer&&e.outer.points&&this.pointInPolygon(t,e.outer.points)){let o=!1;for(const n of e.holes)if(n.points&&this.pointInPolygon(t,n.points)){o=!0;break}if(!o)return e}return null}_createRegionFillMesh(e,t,o=.5){const n=new THREE.Shape(e.outer.points.map(e=>new THREE.Vector2(e.x,e.y)));for(const t of e.holes){const e=new THREE.Path(t.points.map(e=>new THREE.Vector2(e.x,e.y)));n.holes.push(e)}const i=new THREE.ShapeGeometry(n),s=new THREE.MeshBasicMaterial({color:t,transparent:!0,opacity:o,side:THREE.DoubleSide,depthWrite:!1}),r=new THREE.Mesh(i,s);return r.position.z=.1,r.userData.isRegionFill=!0,r.userData.regionId=e.id,r}highlightRegionHover(e,t){this.unhighlightRegionHover(),e&&(this.hoverFillMesh=this._createRegionFillMesh(e,t,.3),this.fillGroup.add(this.hoverFillMesh))}unhighlightRegionHover(){this.hoverFillMesh&&(this.fillGroup.remove(this.hoverFillMesh),this.hoverFillMesh.geometry&&this.hoverFillMesh.geometry.dispose(),this.hoverFillMesh.material&&this.hoverFillMesh.material.dispose(),this.hoverFillMesh=null)}highlightRegionSelected(e,t){this.unhighlightRegionSelected(e);const o=this._createRegionFillMesh(e,t,.5);this.selectedFills.set(e.id,o),this.fillGroup.add(o)}unhighlightRegionSelected(e){const t=this.selectedFills.get(e.id);t&&(this.fillGroup.remove(t),t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose(),this.selectedFills.delete(e.id))}clearSelectedFills(){for(const e of this.selectedFills.values())this.fillGroup.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose();this.selectedFills.clear()}highlightRegion(e,t){this.highlightRegionSelected(e,t)}unhighlightRegion(e){this.unhighlightRegionSelected(e)}getRegionColor(e){const t=Math.floor(1e3*e.area)%360/360;return(new THREE.Color).setHSL(t,.7,.5)}createRegionFill(e){const t=new THREE.Shape(e.outer.points.map(e=>new THREE.Vector2(e.x,e.y)));for(const o of e.holes){const e=new THREE.Path(o.points.map(e=>new THREE.Vector2(e.x,e.y)));t.holes.push(e)}const o=new THREE.ShapeGeometry(t),n=this.getRegionColor(e),i=new THREE.MeshBasicMaterial({color:n,transparent:!0,opacity:.3,side:THREE.DoubleSide,depthWrite:!1}),s=new THREE.Mesh(o,i);return s.position.z=.05,s.userData.isRegionFill=!0,s.userData.regionId=e.id,s}updateRegionFills(){for(;this.fillGroup.children.length;){const e=this.fillGroup.children[0];e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose(),this.fillGroup.remove(e)}this.regions.forEach(e=>{const t=this.createRegionFill(e);this.fillGroup.add(t)})}findMeshById(e){let t=null;return this.editor.scene.traverse(o=>{o.uuid===e&&(t=o)}),t}clearHighlight(){this.regions.forEach(e=>this.unhighlightRegion(e))}clear(){for(this.clearHighlight(),this.clearSelectedFills(),this.unhighlightRegionHover(),this.regions=[],this.regionMap.clear(),this.nodes=[],this.rootNodes=[];this.fillGroup.children.length;){const e=this.fillGroup.children[0];e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose(),this.fillGroup.remove(e)}}getElementPoints(e){if(e.userData?.points)return e.userData.points.map(e=>new THREE.Vector2(e.x,e.y));if(e.geometry?.attributes.position){const t=e.geometry.attributes.position.array,o=[];for(let e=0;e<t.length;e+=3)o.push(new THREE.Vector2(t[e],t[e+1]));return o}return[]}isElementClosed(e){const t=e.userData?.elementType;return["rectangle","circle","polygon","oval","stadium","arc","polyline"].includes(t)||!0===e.userData?.closed}calculatePolygonArea(e){if(e.length<3)return 0;let t=0;const o=e.length;for(let n=0;n<o;n++){const i=(n+1)%o;t+=e[n].x*e[i].y,t-=e[i].x*e[n].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,o=0;return e.forEach(e=>{t+=e.x,o+=e.y}),new THREE.Vector2(t/e.length,o/e.length)}calculateBoundingBox(e){const t=new THREE.Vector2(1/0,1/0),o=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),o.x=Math.max(o.x,e.x),o.y=Math.max(o.y,e.y)}),{min:t,max:o}}pointInPolygon(e,t){if(!t||t.length<3)return!1;let o=!1;for(let n=0,i=t.length-1;n<t.length;i=n++){const s=t[n].x,r=t[n].y,l=t[i].x,h=t[i].y;r>e.y!=h>e.y&&e.x<(l-s)*(e.y-r)/(h-r)+s&&(o=!o)}return o}getLineIntersection(e,t,o,n,i=1e-6){const s=(n.y-o.y)*(t.x-e.x)-(n.x-o.x)*(t.y-e.y);if(Math.abs(s)<1e-12)return null;const r=((n.x-o.x)*(e.y-o.y)-(n.y-o.y)*(e.x-o.x))/s,l=((t.x-e.x)*(e.y-o.y)-(t.y-e.y)*(e.x-o.x))/s;return r>=-i&&r<=1+i&&l>=-i&&l<=1+i?new THREE.Vector2(e.x+r*(t.x-e.x),e.y+r*(t.y-e.y)):null}getIntersectionParameter(e,t,o){const n=t.x-e.x,i=t.y-e.y;return Math.abs(n)>Math.abs(i)?(o.x-e.x)/n:(o.y-e.y)/i}getDistance(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}}