class SketchRegionManager{constructor(e,t){this.editor=e,this.plane=t,this.regions=[],this.regionMap=new Map,this.rootNodes=[],this.nodes=[],this.fillGroup=new THREE.Group,this.fillGroup.userData.isRegionFill=!0,this.plane.add(this.fillGroup),this.hoverFillMesh=null,this.selectedFills=new Map,this.clipperScale=1e5,this.clipperAvailable="undefined"!=typeof ClipperLib,this.clipperAvailable&&(ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale),console.log(`SketchRegionManager создан для плоскости ${t.uuid}`)}getElements(){const e=[];return this.plane.traverse(t=>{"sketch_element"===t.userData?.type&&e.push(t)}),e}debugPrintRegions(){if(console.log(`=== REGION TREE for plane ${this.plane.uuid} ===`),0===this.rootNodes.length)return void console.log("  No root nodes");const e=(t,n="")=>{const o=t.isHole?"HOLE":"OUTER";console.log(`${n}${o} [${t.id.substring(0,8)}] area=${t.area.toFixed(2)} points=${t.contour.points.length} children=${t.children.length}`),t.children.forEach(t=>e(t,n+"  "))};this.rootNodes.forEach((t,n)=>{console.log(`Root ${n}:`),e(t,"  ")}),console.log(`Total regions: ${this.regions.length}`)}updateRegions(){const e=this.getElements();if(0===e.length)return void this.clear();const t=this.collectSimpleContours(e),n=this.collectLineContours(e,t);let o=[...t,...n];const i=this.getCuttingLines(e,o);i.length>0&&(o=this.cutContoursWithLines(o,i)),this.clipperAvailable&&o.length>0&&(o=this.advancedSeparateContours(o)),this.buildNestingTree(o),this.determineContourTypes(),this.regions=this.buildRegionsFromTree(),this.updateRegionMap(),this.updateRegionFills(),this.debugPrintRegions(),console.log(`SketchRegionManager: обновлено регионов – ${this.regions.length}`)}collectSimpleContours(e){const t=[];return e.forEach(e=>{if(!this.isElementClosed(e))return;const n=this.getElementPoints(e);if(n.length<3)return;const o=this.calculatePolygonArea(n);Math.abs(o)<.001||t.push({element:e,points:n,area:Math.abs(o),center:this.calculateContourCenter(n),boundingBox:this.calculateBoundingBox(n),type:e.userData?.elementType||"unknown",isClosed:!0,isClockwise:o<0,elementIds:new Set([e.uuid]),plane:this.plane,planeId:this.plane.uuid})}),console.log(`collectSimpleContours: найдено ${t.length} простых контуров`),t}collectLineContours(e,t){const n=new Set;t.forEach(e=>{e.element&&n.add(e.element.uuid)});const o=e.filter(e=>{const t=e.userData?.elementType;return("line"===t||"polyline"===t)&&!n.has(e.uuid)});if(o.length<3)return[];const i=o.map(e=>{const t=this.getElementPoints(e);return{element:e,start:t[0],end:t[1],points:t}});return this.findClosedContoursFromLines(i)}findClosedContoursFromLines(e){const t=[],n=new Set;for(let o=0;o<e.length;o++){if(n.has(o))continue;const i=this.buildContourFromLine(o,e,n);if(i&&i.points.length>=3){const e=this.calculatePolygonArea(i.points);Math.abs(e)>.01&&t.push({elements:i.elements,points:i.points,area:Math.abs(e),center:this.calculateContourCenter(i.points),boundingBox:this.calculateBoundingBox(i.points),type:"line_contour",isClosed:!0,isClockwise:e<0,elementIds:new Set(i.elements.map(e=>e.uuid)),plane:this.plane,planeId:this.plane.uuid})}}return t}buildContourFromLine(e,t,n){const o=t[e],i=[o.element],s=[o.start.clone(),o.end.clone()];n.add(e);let r=o.end,l=0;for(;l<100;){let e=!1;for(let o=0;o<t.length;o++){if(n.has(o))continue;const l=t[o];if(r.distanceTo(l.start)<.5){r=l.end.clone(),s.push(r.clone()),i.push(l.element),n.add(o),e=!0;break}if(r.distanceTo(l.end)<.5){r=l.start.clone(),s.push(r.clone()),i.push(l.element),n.add(o),e=!0;break}}if(!e)break;if(r.distanceTo(o.start)<.5)return{elements:i,points:s};l++}return null}getCuttingLines(e,t){const n=new Set;return t.forEach(e=>e.elementIds.forEach(e=>n.add(e))),e.filter(e=>{const t=e.userData?.elementType;return("line"===t||"polyline"===t)&&!n.has(e.uuid)})}cutContoursWithLines(e,t){if(console.log("=== cutContoursWithLines ==="),0===t.length||0===e.length)return e;try{let n=[...e];for(const e of t){const t=this.getElementPoints(e);if(t.length<2)continue;const o=[];for(const e of n){const n=e.points||[];if(n.length<3){o.push(e);continue}if(this.findContourLineIntersections(n,t).length>=2){const n=this.splitContourByLine(e,t);o.push(...n)}else o.push(e)}n=o}return console.log(`После разрезания: было ${e.length}, стало ${n.length} контуров`),n}catch(t){return console.error("Ошибка при разрезании контуров линиями:",t),e}}findContourLineIntersections(e,t){const n=[],o=t[0],i=t[1];for(let t=0;t<e.length;t++){const s=(t+1)%e.length,r=e[t],l=e[s],h=this.getLineIntersection(r,l,o,i);h&&n.push({point:h,segmentIndex:t,t:this.getIntersectionParameter(r,l,h)})}return n}splitContourByLine(e,t){const n=e.points||[];if(n.length<4)return[e];const o=[];for(let e=0;e<n.length;e++){const i=(e+1)%n.length,s=this.getLineIntersection(n[e],n[i],t[0],t[1]);s&&o.push({point:s,segmentIndex:e,t:this.getIntersectionParameter(n[e],n[i],s)})}if(2!==o.length)return[e];o.sort((e,t)=>e.segmentIndex!==t.segmentIndex?e.segmentIndex-t.segmentIndex:e.t-t.t);const[i,s]=o,r=this.buildNewContour(n,i,s,!0),l=this.buildNewContour(n,s,i,!0),h=[];if(r.length>=4){const t=this.createCutContour(e,r);t&&h.push(t)}if(l.length>=4){const t=this.createCutContour(e,l);t&&h.push(t)}return h.length>0?h:[e]}buildNewContour(e,t,n,o){const i=[];i.push(t.point.clone());let s=t.segmentIndex;const r=e.length;let l=0;for(;l<2*r;){let h;if(l++,h=o?(s+1)%r:(s-1+r)%r,h===n.segmentIndex){e[h].equals(t.point)||i.push(e[h].clone());break}e[h].equals(t.point)||i.push(e[h].clone()),s=h}return i.push(n.point.clone()),i.length>0&&!i[0].equals(i[i.length-1])&&i.push(i[0].clone()),i}createCutContour(e,t){const n=this.calculatePolygonArea(t),o=Math.abs(n);if(o<.01)return null;const i=n<0,s=i?t:t.reverse();return{...e,points:s,area:o,center:this.calculateContourCenter(s),boundingBox:this.calculateBoundingBox(s),isClockwise:i,isCut:!0,cutFrom:e.id||e.type,originalContourId:e.id||e.uuid}}advancedSeparateContours(e){if(console.log("=== advancedSeparateContours (Clipper) ==="),!this.clipperAvailable||0===e.length)return e;try{const{holes:t,solids:n}=this.separateHolesAndSolids(e),o=[...this.separateSolidContours(n),...t];return console.log(`Всего получено ${o.length} контуров`),o}catch(t){return console.error("Ошибка при разделении контуров через Clipper:",t),e}}separateHolesAndSolids(e){const t=[],n=[],o=[...e.map(e=>new FigureNode(e))].sort((e,t)=>t.area-e.area);for(let e=0;e<o.length;e++){const t=o[e];for(let n=0;n<e;n++){const e=o[n];if(this.isContourInside(t.contour,e.contour)){e.addChild(t);break}}}const i=o.filter(e=>null===e.parent),s=(e,o)=>{e.depth=o,e.isHole=o%2==1,e.isHole?t.push(e.contour):n.push(e.contour),e.children.forEach(e=>s(e,o+1))};return i.forEach(e=>s(e,0)),console.log(`Найдено: ${n.length} твердых тел, ${t.length} отверстий`),{holes:t,solids:n}}separateSolidContours(e){return 0===e.length?[]:1===e.length?[e[0]]:2===e.length?this.separateTwoSolids(e[0],e[1]):this.separateMultipleSolids(e)}separateTwoSolids(e,t){try{const n=e.points||[],o=t.points||[];if(n.length<3||o.length<3)return[e,t];const i=[];this.clipperDifference(n,o).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid1_minus_2"))});this.clipperDifference(o,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid2_minus_1"))});return this.clipperIntersection(n,o).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"intersection"))}),i.length>0?i:[e,t]}catch(n){return console.error("Ошибка при разделении двух тел:",n),[e,t]}}separateMultipleSolids(e){try{console.log(`Разделение ${e.length} твердых тел`);let t=[];for(let n=1;n<1<<e.length;n++){const o=[];for(let t=0;t<e.length;t++)n&1<<t&&o.push(e[t]);if(0===o.length)continue;let i=o[0].points||[];for(let e=1;e<o.length&&0!==i.length;e++)i=this.clipperIntersection(i,o[e].points||[])[0]||[];if(i.length<3)continue;let s=i;for(let t=0;t<e.length;t++)if(!(n&1<<t)){if(s=this.clipperDifference(s,e[t].points||[])[0]||[],0===s.length)break}if(s.length>=3){const e=this.calculatePolygonArea(s);Math.abs(e)>.01&&t.push({points:s,mask:n,area:Math.abs(e)})}}const n=t.map((e,t)=>this.createSeparatedContour(e.points,`area_${t}`));return n.length>0?n:e}catch(t){return console.error("Ошибка при разделении нескольких тел:",t),e}}clipperDifference(e,t){try{const n=new ClipperLib.Clipper,o=this.pointsToClipperPath(e),i=this.pointsToClipperPath(t);n.AddPath(o,ClipperLib.PolyType.ptSubject,!0),n.AddPath(i,ClipperLib.PolyType.ptClip,!0);const s=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctDifference,s,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?s.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Difference:",e),[]}}clipperIntersection(e,t){try{const n=new ClipperLib.Clipper,o=this.pointsToClipperPath(e),i=this.pointsToClipperPath(t);n.AddPath(o,ClipperLib.PolyType.ptSubject,!0),n.AddPath(i,ClipperLib.PolyType.ptClip,!0);const s=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctIntersection,s,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?s.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Intersection:",e),[]}}createSeparatedContour(e,t){const n=this.calculatePolygonArea(e),o=Math.abs(n),i=n<0,s=i?e:e.reverse();return{points:s,area:o,center:this.calculateContourCenter(s),boundingBox:this.calculateBoundingBox(s),type:t,isClosed:!0,isClockwise:i,planeId:this.plane.uuid,plane:this.plane,isSeparated:!0}}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let n=0;n<e.length;n++)t[n]=new ClipperLib.IntPoint(Math.round(e[n].x*this.clipperScale),Math.round(e[n].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let n=0;n<e.length;n++)t.push(new THREE.Vector2(e[n].X/this.clipperScale,e[n].Y/this.clipperScale));return t}buildNestingTree(e){const t=e.map(e=>new FigureNode(e)),n=[...t].sort((e,t)=>t.area-e.area);for(let e=0;e<n.length;e++){const t=n[e];let o=null,i=1/0;for(let s=0;s<e;s++){const e=n[s];this.isContourInside(t.contour,e.contour)&&e.area<i&&(o=e,i=e.area)}o&&o.addChild(t)}this.rootNodes=t.filter(e=>null===e.parent),this.updateDepths(this.rootNodes,0),this.nodes=t}updateDepths(e,t){e.forEach(e=>{e.depth=t,this.updateDepths(e.children,t+1)})}determineContourTypes(){const e=t=>{t.isHole=t.depth%2==1,t.isOuter=!t.isHole,t.children.forEach(e)};this.rootNodes.forEach(e)}isPointOnPolygonBoundary(e,t,n=.001){for(let o=0;o<t.length;o++){const i=(o+1)%t.length,s=t[o],r=t[i];if(this.distancePointToSegment(e,s,r)<n)return!0}return!1}distancePointToSegment(e,t,n){const o=(new THREE.Vector2).subVectors(n,t),i=(new THREE.Vector2).subVectors(e,t),s=i.dot(o)/o.lengthSq();if(s<0)return i.length();if(s>1)return(new THREE.Vector2).subVectors(e,n).length();const r=(new THREE.Vector2).copy(t).add(o.multiplyScalar(s));return(new THREE.Vector2).subVectors(e,r).length()}isContourInside(e,t){const n=e?.points,o=t?.points;if(!n||!o||0===n.length||0===o.length)return!1;for(const e of n){if(!this.pointInPolygon(e,o))return!1;if(this.isPointOnPolygonBoundary(e,o))return!1}return!0}buildRegionsFromTree(){const e=[],t=n=>{const o=!n.isHole,i=n.children.filter(e=>e.isHole===o).map(e=>({points:e.contour.points,center:e.contour.center,area:e.contour.area,elementIds:e.elementIds,isClockwise:e.contour.isClockwise}));e.push({id:n.id,outer:{points:n.contour.points,center:n.contour.center,area:n.contour.area,elementIds:n.elementIds,isClockwise:n.contour.isClockwise},holes:i,area:n.area,isHole:n.isHole,isOuter:n.isOuter,depth:n.depth,plane:this.plane,planeId:this.plane.uuid,elementIds:n.elementIds}),n.children.forEach(e=>t(e))};return this.rootNodes.forEach(t),e}updateRegionMap(){this.regionMap.clear(),this.regions.forEach(e=>this.regionMap.set(e.id,e))}getAllRegions(){return this.regions}getRegionAtPoint(e){const t=new THREE.Vector2(e.x,e.y),n=[...this.regions].sort((e,t)=>t.depth-e.depth);for(const e of n)if(e.outer&&e.outer.points&&this.pointInPolygon(t,e.outer.points)){let n=!1;for(const o of e.holes)if(o.points&&this.pointInPolygon(t,o.points)){n=!0;break}if(!n)return e}return null}_createRegionFillMesh(e,t,n=.5){const o=new THREE.Shape(e.outer.points.map(e=>new THREE.Vector2(e.x,e.y)));for(const t of e.holes){const e=new THREE.Path(t.points.map(e=>new THREE.Vector2(e.x,e.y)));o.holes.push(e)}const i=new THREE.ShapeGeometry(o),s=new THREE.MeshBasicMaterial({color:t,transparent:!0,opacity:n,side:THREE.DoubleSide,depthWrite:!1}),r=new THREE.Mesh(i,s);return r.position.z=.1,r.userData.isRegionFill=!0,r.userData.regionId=e.id,r}highlightRegionHover(e,t){this.unhighlightRegionHover(),e&&(this.hoverFillMesh=this._createRegionFillMesh(e,t,.3),this.fillGroup.add(this.hoverFillMesh))}unhighlightRegionHover(){this.hoverFillMesh&&(this.fillGroup.remove(this.hoverFillMesh),this.hoverFillMesh.geometry&&this.hoverFillMesh.geometry.dispose(),this.hoverFillMesh.material&&this.hoverFillMesh.material.dispose(),this.hoverFillMesh=null)}highlightRegionSelected(e,t){this.unhighlightRegionSelected(e);const n=this._createRegionFillMesh(e,t,.5);this.selectedFills.set(e.id,n),this.fillGroup.add(n)}unhighlightRegionSelected(e){const t=this.selectedFills.get(e.id);t&&(this.fillGroup.remove(t),t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose(),this.selectedFills.delete(e.id))}clearSelectedFills(){for(const e of this.selectedFills.values())this.fillGroup.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose();this.selectedFills.clear()}highlightRegion(e,t){this.highlightRegionSelected(e,t)}unhighlightRegion(e){this.unhighlightRegionSelected(e)}getRegionColor(e){const t=Math.floor(1e3*e.area)%360/360;return(new THREE.Color).setHSL(t,.7,.5)}createRegionFill(e){const t=new THREE.Shape(e.outer.points.map(e=>new THREE.Vector2(e.x,e.y)));for(const n of e.holes){const e=new THREE.Path(n.points.map(e=>new THREE.Vector2(e.x,e.y)));t.holes.push(e)}const n=new THREE.ShapeGeometry(t),o=this.getRegionColor(e),i=new THREE.MeshBasicMaterial({color:o,transparent:!0,opacity:.3,side:THREE.DoubleSide,depthWrite:!1}),s=new THREE.Mesh(n,i);return s.position.z=.05,s.userData.isRegionFill=!0,s.userData.regionId=e.id,s}updateRegionFills(){for(;this.fillGroup.children.length;){const e=this.fillGroup.children[0];e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose(),this.fillGroup.remove(e)}this.regions.forEach(e=>{const t=this.createRegionFill(e);this.fillGroup.add(t)})}findMeshById(e){let t=null;return this.editor.scene.traverse(n=>{n.uuid===e&&(t=n)}),t}clearHighlight(){this.regions.forEach(e=>this.unhighlightRegion(e))}clear(){for(this.clearHighlight(),this.clearSelectedFills(),this.unhighlightRegionHover(),this.regions=[],this.regionMap.clear(),this.nodes=[],this.rootNodes=[];this.fillGroup.children.length;){const e=this.fillGroup.children[0];e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose(),this.fillGroup.remove(e)}}getElementPoints(e){if(e.userData?.points)return e.userData.points.map(e=>new THREE.Vector2(e.x,e.y));if(e.geometry?.attributes.position){const t=e.geometry.attributes.position.array,n=[];for(let e=0;e<t.length;e+=3)n.push(new THREE.Vector2(t[e],t[e+1]));return n}return[]}isElementClosed(e){const t=e.userData?.elementType;return["rectangle","circle","polygon","oval","stadium","arc","polyline"].includes(t)||!0===e.userData?.closed}calculatePolygonArea(e){if(e.length<3)return 0;let t=0;const n=e.length;for(let o=0;o<n;o++){const i=(o+1)%n;t+=e[o].x*e[i].y,t-=e[i].x*e[o].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,n=0;return e.forEach(e=>{t+=e.x,n+=e.y}),new THREE.Vector2(t/e.length,n/e.length)}calculateBoundingBox(e){const t=new THREE.Vector2(1/0,1/0),n=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),n.x=Math.max(n.x,e.x),n.y=Math.max(n.y,e.y)}),{min:t,max:n}}pointInPolygon(e,t){if(!t||t.length<3)return!1;let n=!1;for(let o=0,i=t.length-1;o<t.length;i=o++){const s=t[o].x,r=t[o].y,l=t[i].x,h=t[i].y;r>e.y!=h>e.y&&e.x<(l-s)*(e.y-r)/(h-r)+s&&(n=!n)}return n}getLineIntersection(e,t,n,o,i=1e-6){const s=(o.y-n.y)*(t.x-e.x)-(o.x-n.x)*(t.y-e.y);if(Math.abs(s)<1e-12)return null;const r=((o.x-n.x)*(e.y-n.y)-(o.y-n.y)*(e.x-n.x))/s,l=((t.x-e.x)*(e.y-n.y)-(t.y-e.y)*(e.x-n.x))/s;return r>=-i&&r<=1+i&&l>=-i&&l<=1+i?new THREE.Vector2(e.x+r*(t.x-e.x),e.y+r*(t.y-e.y)):null}getIntersectionParameter(e,t,n){const o=t.x-e.x,i=t.y-e.y;return Math.abs(o)>Math.abs(i)?(n.x-e.x)/o:(n.y-e.y)/i}getDistance(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}}