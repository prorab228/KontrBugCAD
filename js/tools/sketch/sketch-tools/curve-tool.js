import*as THREE from"three";import{SketchToolBase}from"./sketch-tool-base.js";export class CurveSketchTool extends SketchToolBase{constructor(t){super(t,"curve","fa-wave-square"),this.controlPoints=[],this.segments=32,this.isDrawing=!1,this.controlPointMarkers=[],this.dimensionFields=[{label:"Тип кривой",type:"select",options:["Квадратичная","Кубическая"],value:"Кубическая"},{label:"Сегменты",type:"number",value:this.segments,unit:"шт",min:8,max:100,step:4}]}onMouseDown(t){const e=this.getPointOnPlane(t);return!!e&&(this.controlPoints.push(e.clone()),1===this.controlPoints.length?(this.isDrawing=!0,this.tempElement={type:"curve",controlPoints:[e.clone()],curvePoints:[],segments:this.segments,curveType:"cubic",color:this.sketchManager.sketchColor},this.sketchManager.editor.showStatus("Добавлена первая точка. Добавьте контрольные точки (всего 4 для кубической кривой).","info"),this.createTempGeometry()):2===this.controlPoints.length?(this.tempElement.controlPoints.push(e.clone()),this.updateCurve(),this.sketchManager.editor.showStatus("Добавлена вторая точка. Добавьте еще точки для кривой.","info")):3===this.controlPoints.length?(this.tempElement.controlPoints.push(e.clone()),this.updateCurve(),this.sketchManager.editor.showStatus("Добавлена третья точка. Добавьте последнюю точку для кубической кривой.","info")):4===this.controlPoints.length&&(this.tempElement.controlPoints.push(e.clone()),this.updateCurve(),this.finishDrawing()),!0)}updateCurve(){if(!this.tempElement||this.tempElement.controlPoints.length<2)return;const t=this.tempElement.controlPoints;let e;const n=t.length;2===n?e=new THREE.LineCurve(t[0],t[1]):3===n?(e=new THREE.QuadraticBezierCurve(t[0],t[1],t[2]),this.tempElement.curveType="quadratic"):n>=4&&(e=new THREE.CubicBezierCurve(t[0],t[1],t[2],t[3]),this.tempElement.curveType="cubic"),e&&(this.tempElement.curvePoints=e.getPoints(this.segments),this.updateTempGeometry(),this.updateControlPointMarkers())}onMouseMove(t){if(!this.isDrawing||!this.tempElement)return;const e=this.getPointOnPlane(t);if(!e)return;const n=[...this.tempElement.controlPoints];if(1===n.length)this.tempElement.controlPoints=[n[0],e.clone()];else if(2===n.length)this.tempElement.controlPoints=[n[0],n[1],e.clone()];else if(3===n.length)this.tempElement.controlPoints=[n[0],n[1],n[2],e.clone()];else if(n.length>=4)return;this.updateCurve()}onKeyDown(t){return"Escape"===t.key&&this.isDrawing?(this.onCancel(),!0):"Enter"===t.key&&this.isDrawing&&this.controlPoints.length>=2?(this.finishDrawing(),!0):!!("Backspace"===t.key&&this.isDrawing&&this.controlPoints.length>1)&&(this.removeLastPoint(),!0)}onCancel(){this.controlPoints=[],this.isDrawing=!1,this.clearTempGeometry(),this.clearControlPointMarkers(),this.tempElement=null,this.sketchManager.editor.showStatus("Создание кривой отменено","info")}finishDrawing(){this.tempElement&&this.tempElement.curvePoints.length>=2?(this.sketchManager.elementManager.addElement(this.tempElement),this.sketchManager.editor.showStatus("Кривая создана","success")):this.sketchManager.editor.showStatus("Недостаточно точек для создания кривой","warning"),this.onCancel()}removeLastPoint(){!this.tempElement||this.controlPoints.length<=1?this.onCancel():(this.controlPoints.pop(),this.tempElement.controlPoints.pop(),0===this.controlPoints.length?this.onCancel():(this.updateCurve(),this.sketchManager.editor.showStatus("Последняя точка удалена","info")))}updateControlPointMarkers(){this.tempElement&&this.sketchManager.currentPlane&&(this.clearControlPointMarkers(),this.tempElement.controlPoints.forEach((t,e)=>{const n=new THREE.BufferGeometry,s=new Float32Array([t.x-3,t.y,.1,t.x+3,t.y,.1,t.x,t.y-3,.1,t.x,t.y+3,.1]);n.setAttribute("position",new THREE.BufferAttribute(s,3));const o=new THREE.LineBasicMaterial({color:0===e||e===this.tempElement.controlPoints.length-1?16711680:65280,linewidth:2}),i=new THREE.LineSegments(n,o);i.userData={isControlPoint:!0,index:e},this.sketchManager.currentPlane.add(i),this.controlPointMarkers.push(i)}))}clearControlPointMarkers(){this.controlPointMarkers.forEach(t=>{t.parent&&t.parent.remove(t),t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose()}),this.controlPointMarkers=[]}createGeometry(t){if(!t.curvePoints||t.curvePoints.length<2)return null;const e=[];t.curvePoints.forEach(t=>{e.push(t.x,t.y,0)});const n=new THREE.BufferGeometry;return n.setAttribute("position",new THREE.Float32BufferAttribute(e,3)),new THREE.Line(n,new THREE.LineBasicMaterial({color:t.color,linewidth:2}))}updateGeometry(t,e){if(!e.curvePoints||e.curvePoints.length<2)return;const n=[];e.curvePoints.forEach(t=>{n.push(t.x,t.y,0)}),t.geometry.setAttribute("position",new THREE.Float32BufferAttribute(n,3)),t.geometry.attributes.position.needsUpdate=!0}clearTempGeometry(){super.clearTempGeometry(),this.clearControlPointMarkers()}}