class MoveSketchTool extends TransformSketchToolBase{constructor(t){super(t,"move","fa-arrows-alt"),this.mode="free",this.dragAxis=null,this.dragDirection=1,this.isDragging=!1,this.startPoint=null,this.originalPositions=[],this.previousSketchState=null,this.arrows=[],this.arrowSize=6,this.arrowHitboxSize=8,this.arrowOffset=1,this.hoveredArrow=null,this.constrainAxis=!1,this.inputStartDistance=0,this.initMoveTool()}initMoveTool(){this.inputElement.addEventListener("input",t=>{this.isInputFocused&&this.dragAxis&&this.applyInputValueRealTime()}),this.inputElement.addEventListener("focus",()=>{const t=parseFloat(this.inputElement.value)||0;this.inputStartDistance=t})}onActivate(){super.onActivate(),this.setMoveCursor(),this.createArrows(),this.sketchManager.editor.showStatus("Перемещение: используйте стрелки для точного перемещения по осям","info")}setMoveCursor(){this.sketchManager.editor.renderer.domElement.style.cursor="move"}restoreCursor(){this.sketchManager.editor.renderer.domElement.style.cursor=""}createArrows(){this.removeArrows();const t=this.sketchManager.elementManager.selectedElements;if(0===t.length)return;const e=this.calculateSelectionCenter(t);if(!e)return;[{axis:"x",direction:1,offset:new THREE.Vector3(this.arrowOffset,0,0)},{axis:"x",direction:-1,offset:new THREE.Vector3(-this.arrowOffset,0,0)},{axis:"y",direction:1,offset:new THREE.Vector3(0,this.arrowOffset,0)},{axis:"y",direction:-1,offset:new THREE.Vector3(0,-this.arrowOffset,0)}].forEach(t=>{const s=new SketchArrow2D(this.sketchManager,t.axis,t.direction,this.arrowSize),i=e.clone().add(t.offset);s.updatePosition(i),this.sketchManager.currentPlane.add(s.group),this.arrows.push(s)})}calculateSelectionCenter(t){if(0===t.length)return null;let e=0,s=0,i=0;return t.forEach(t=>{if(!t.mesh)return;(t.mesh.userData?.localPoints||[]).forEach(t=>{t&&(e+=t.x,s+=t.y,i++)})}),0===i?null:new THREE.Vector3(e/i,s/i,0)}removeArrows(){this.arrows.forEach(t=>t.dispose()),this.arrows=[],this.hoveredArrow=null}updateArrowsPosition(){const t=this.sketchManager.elementManager.selectedElements;if(0===t.length)return void this.removeArrows();const e=this.calculateSelectionCenter(t);if(!e)return;[{index:0,offset:new THREE.Vector3(this.arrowOffset,0,0)},{index:1,offset:new THREE.Vector3(-this.arrowOffset,0,0)},{index:2,offset:new THREE.Vector3(0,this.arrowOffset,0)},{index:3,offset:new THREE.Vector3(0,-this.arrowOffset,0)}].forEach(t=>{if(this.arrows[t.index]){const s=e.clone().add(t.offset);this.arrows[t.index].updatePosition(s)}})}checkArrowHit(t){const e=this.getPointOnPlane(t);if(!e)return null;for(const t of this.arrows){const s=t.group.position;let i;if("x"===t.axis){const t=Math.abs(e.x-s.x),r=Math.abs(e.y-s.y);i=t<this.arrowHitboxSize&&r<this.arrowHitboxSize/2}else{const t=Math.abs(e.x-s.x);i=Math.abs(e.y-s.y)<this.arrowHitboxSize&&t<this.arrowHitboxSize/2}if(i)return t}return null}onMouseDown(t){if(this.sketchManager.dimensionManager.isInputActive)return this.sketchManager.dimensionManager.applyDimensionInput(),!0;this.isDrawing=!0;const e=this.getPointOnPlane(t);if(!e)return!1;const s=this.checkArrowHit(t);if(s)return this.startAxisDragging(e,s.axis,s.direction),!0;const i=this.sketchManager.elementManager.getElementAtPoint(e);return i?(this.sketchManager.elementManager.selectedElements.includes(i)||(this.sketchManager.elementManager.selectElement(i),this.createArrows()),this.startFreeDragging(e,t.shiftKey),!0):this.sketchManager.elementManager.selectedElements.length>0&&(this.startFreeDragging(e,t.shiftKey),!0)}startAxisDragging(t,e,s){0!==this.sketchManager.elementManager.selectedElements.length&&(this.previousSketchState=this.sketchManager.elementManager.getCurrentSketchState(),this.mode="axis",this.dragAxis=e,this.dragDirection=s,this.isDragging=!0,this.startPoint=t.clone(),this.inputStartDistance=0,this.saveOriginalPositions(),this.showInput("0.0",t.clone(),!1),this.updateInputBorderColor(),this.sketchManager.editor.showStatus(`Перемещение по оси ${e.toUpperCase()}${s>0?"+":"-"}. Введите точное расстояние.`,"info"))}saveOriginalPositions(){const t=this.sketchManager.elementManager.selectedElements;this.originalPositions=[],t.forEach(t=>{t.mesh&&t.mesh.userData?.localPoints&&this.originalPositions.push({mesh:t.mesh,points:t.mesh.userData.localPoints.map(t=>t.clone())})})}updateInputBorderColor(){if(!this.inputContainer||!this.dragAxis)return;const t="x"===this.dragAxis?this.dragDirection>0?"#ff4444":"#ff8888":this.dragDirection>0?"#44ff44":"#88ff88";this.inputContainer.style.borderColor=t}startFreeDragging(t,e=!1){0!==this.sketchManager.elementManager.selectedElements.length&&(this.previousSketchState=this.sketchManager.elementManager.getCurrentSketchState(),this.mode="free",this.constrainAxis=e,this.isDragging=!0,this.startPoint=t.clone(),this.saveOriginalPositions(),this.hideInput(),this.sketchManager.editor.showStatus("Свободное перемещение. Зажмите Shift для перемещения по одной оси.","info"))}onMouseMove(t){if(super.onMouseMove(t),this.updateArrowHover(t),!this.isDragging||!this.startPoint)return;const e=this.getPointOnPlane(t);e&&("axis"===this.mode?this.handleAxisDrag(e):this.handleFreeDrag(e))}updateArrowHover(t){if(this.isDragging)return;const e=this.checkArrowHit(t),s=this.sketchManager.editor.renderer.domElement;e!==this.hoveredArrow&&(this.hoveredArrow&&this.hoveredArrow.setHighlight(!1),e?(e.setHighlight(!0),s.style.cursor="x"===e.axis?"ew-resize":"ns-resize"):s.style.cursor="move",this.hoveredArrow=e)}handleAxisDrag(t){let e=0;e="x"===this.dragAxis?(t.x-this.startPoint.x)*this.dragDirection:(t.y-this.startPoint.y)*this.dragDirection,this.applyMoveFromOriginals(e);const s=e.toFixed(1);this.updateInputValue(s,t);const i=new THREE.Vector3("x"===this.dragAxis?e*this.dragDirection:0,"y"===this.dragAxis?e*this.dragDirection:0,0);this.updateMoveInfo(i)}applyMoveFromOriginals(t){const e=this.sketchManager.elementManager.selectedElements;if(0===e.length||0===this.originalPositions.length)return;let s;s="x"===this.dragAxis?new THREE.Vector3(t*this.dragDirection,0,0):new THREE.Vector3(0,t*this.dragDirection,0),e.forEach((t,e)=>{if(t.mesh&&this.originalPositions[e]){const i=this.originalPositions[e];t.mesh.userData.localPoints&&i.points&&(t.mesh.userData.localPoints=i.points.map(t=>t.clone().add(s))),this.updateElementGeometry(t.mesh)}}),this.updateArrowsPosition()}handleFreeDrag(t){let e=(new THREE.Vector3).subVectors(t,this.startPoint);this.constrainAxis&&(Math.abs(e.x)>Math.abs(e.y)?e.y=0:e.x=0),this.applyMoveToElements(e),this.updateMoveInfo(e)}applyMoveToElements(t){this.sketchManager.elementManager.selectedElements.forEach((e,s)=>{if(e.mesh&&this.originalPositions[s]){const i=this.originalPositions[s];e.mesh.userData.localPoints&&i.points&&(e.mesh.userData.localPoints=i.points.map(e=>e.clone().add(t))),this.updateElementGeometry(e.mesh)}}),this.updateArrowsPosition()}updateElementGeometry(t){if(!t||!t.geometry||!t.userData.localPoints)return;const e=[];t.userData.localPoints.forEach(t=>{e.push(t.x,t.y,0)}),t.geometry.setAttribute("position",new THREE.Float32BufferAttribute(e,3)),t.geometry.attributes.position.needsUpdate=!0,t.computeLineDistances&&t.computeLineDistances()}updateMoveInfo(t){const e=document.getElementById("coords");if(e){const s=e.textContent.split("|")[0];e.textContent=`${s} | ΔX: ${t.x.toFixed(1)}, ΔY: ${t.y.toFixed(1)}`}}onMouseUp(t){if(!this.isDragging||!this.startPoint)return;this.isDrawing=!1;const e=this.getPointOnPlane(t);e&&("axis"===this.mode?this.finishAxisDrag(e):this.finishFreeDrag(e)),this.isDragging=!1,this.startPoint=null,this.constrainAxis=!1}finishAxisDrag(t){if(!this.sketchManager.currentPlane)return;const e=this.sketchManager.elementManager.selectedElements;if(0===e.length)return void this.hideInput();let s,i=0;if(i="x"===this.dragAxis?(t.x-this.startPoint.x)*this.dragDirection:(t.y-this.startPoint.y)*this.dragDirection,Math.abs(i)<.1)return this.sketchManager.editor.showStatus("Перемещение отменено (слишком малое смещение)","info"),this.restoreOriginalPositions(),this.hideInput(),void this.updateArrowsPosition();s="x"===this.dragAxis?new THREE.Vector3(i*this.dragDirection,0,0):new THREE.Vector3(0,i*this.dragDirection,0);const r=this.sketchManager.elementManager.getCurrentSketchState(),n=e.map(t=>t.mesh.uuid);this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_move",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:this.previousSketchState,newSketchState:r,delta:{x:s.x,y:s.y,z:s.z},axis:this.dragAxis,direction:this.dragDirection,elementUUIDs:n}),this.sketchManager.snapHelper&&this.sketchManager.snapHelper.updateSnapPoints(),this.sketchManager.editor.showStatus(`Перемещено по оси ${this.dragAxis.toUpperCase()}${this.dragDirection>0?"+":"-"} на ${Math.abs(i).toFixed(1)} мм`,"success"),this.inputElement.value=i.toFixed(1),this.inputStartDistance=i,this.lastInputValue=i;(new THREE.Vector3).addVectors(this.startPoint,t).multiplyScalar(.5);this.updateInputPosition(t),this.saveOriginalPositions()}finishFreeDrag(t){if(!this.sketchManager.currentPlane)return;const e=this.sketchManager.elementManager.selectedElements;if(0===e.length)return;const s=(new THREE.Vector3).subVectors(t,this.startPoint);if(s.length()<.1)return this.sketchManager.editor.showStatus("Перемещение отменено (слишком малое смещение)","info"),this.restoreOriginalPositions(),void this.updateArrowsPosition();const i=this.sketchManager.elementManager.getCurrentSketchState(),r=e.map(t=>t.mesh.uuid);this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_move",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:this.previousSketchState,newSketchState:i,delta:{x:s.x,y:s.y,z:s.z},elementUUIDs:r}),this.sketchManager.snapHelper&&this.sketchManager.snapHelper.updateSnapPoints(),this.sketchManager.editor.showStatus(`Перемещено на ΔX: ${s.x.toFixed(1)} мм, ΔY: ${s.y.toFixed(1)} мм`,"success"),this.saveOriginalPositions()}applyInputValueRealTime(){const t=this.inputElement.value;if(!t||!this.dragAxis)return;const e=(parseFloat(t)||0)-this.inputStartDistance;let s;s="x"===this.dragAxis?new THREE.Vector3(e*this.dragDirection,0,0):new THREE.Vector3(0,e*this.dragDirection,0);const i=this.sketchManager.elementManager.selectedElements;0!==i.length&&(i.forEach((t,e)=>{if(t.mesh&&this.originalPositions[e]){const i=this.originalPositions[e];t.mesh.userData.localPoints&&i.points&&(t.mesh.userData.localPoints=i.points.map(t=>t.clone().add(s))),this.updateElementGeometry(t.mesh)}}),this.updateArrowsPosition(),this.updateMoveInfo(s))}applyInputValue(){const t=this.inputElement.value;if(!t||!this.dragAxis)return;const e=parseFloat(t)||0;if(Math.abs(e)<.1)return void this.sketchManager.editor.showStatus("Слишком малое расстояние","warning");const s=this.sketchManager.elementManager.selectedElements;if(0===s.length)return;const i=e-this.inputStartDistance;let r;r="x"===this.dragAxis?new THREE.Vector3(i*this.dragDirection,0,0):new THREE.Vector3(0,i*this.dragDirection,0);const n=this.sketchManager.elementManager.getCurrentSketchState(),a=s.map(t=>t.mesh.uuid);s.forEach((t,e)=>{if(t.mesh&&this.originalPositions[e]){const s=this.originalPositions[e];t.mesh.userData.localPoints&&s.points&&(t.mesh.userData.localPoints=s.points.map(t=>t.clone().add(r))),this.updateElementGeometry(t.mesh)}});const o=this.sketchManager.elementManager.getCurrentSketchState();this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_move",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:n,newSketchState:o,delta:{x:r.x,y:r.y,z:r.z},axis:this.dragAxis,direction:this.dragDirection,elementUUIDs:a}),this.sketchManager.snapHelper&&this.sketchManager.snapHelper.updateSnapPoints(),this.sketchManager.editor.showStatus(`Перемещено по оси ${this.dragAxis.toUpperCase()}${this.dragDirection>0?"+":"-"} на ${Math.abs(i).toFixed(1)} мм`,"success"),this.inputStartDistance=e,this.saveOriginalPositions(),this.hideInput()}restoreOriginalPositions(){this.originalPositions.forEach(t=>{t.mesh&&t.points&&(t.mesh.userData.localPoints=t.points.map(t=>t.clone()),this.updateElementGeometry(t.mesh))})}onKeyDown(t){if("Escape"===t.key){if(this.isDragging)return this.cancelDragging(),!0;if("block"===this.inputContainer.style.display)return this.cancelInput(),!0}return"Shift"===t.key&&this.isDragging&&"free"===this.mode&&(this.constrainAxis=!0),super.onKeyDown(t)}onKeyUp(t){return"Shift"===t.key&&this.isDragging&&"free"===this.mode&&(this.constrainAxis=!1),!1}cancelDragging(){this.isDragging&&(this.restoreOriginalPositions(),this.isDragging=!1,this.startPoint=null,this.mode="free",this.dragAxis=null,this.dragDirection=1,this.constrainAxis=!1,this.originalPositions=[],this.previousSketchState=null,this.inputStartDistance=0,this.hideInput(),this.updateArrowsPosition(),this.sketchManager.editor.showStatus("Перемещение отменено","info"))}cancelInput(){const t=this.inputStartDistance;this.inputElement.value=t.toFixed(1),this.applyInputValueRealTime(),this.hideInput()}onDeactivate(){super.onDeactivate(),this.restoreCursor(),this.cancelDragging(),this.removeArrows()}}