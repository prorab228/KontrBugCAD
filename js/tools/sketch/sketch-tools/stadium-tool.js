import*as THREE from"three";import{SketchToolBase}from"./sketch-tool-base.js";export class StadiumSketchTool extends SketchToolBase{constructor(e){super(e,"stadium","fa-running"),this.width=20,this.height=10,this.cornerRadius=5,this.segments=8,this.directionX=1,this.directionY=1,this.dimensionFields=[{label:"Длина",type:"number",value:this.width,unit:"мм",min:1,step:1},{label:"Высота",type:"number",value:this.height,unit:"мм",min:1,step:1},{label:"Радиус скругления",type:"number",value:this.cornerRadius,unit:"мм",min:.5,step:.5}]}onMouseDown(e){if(this.sketchManager.isInputActive)return this.sketchManager.applyDimensionInput(),!0;const t=this.getPointOnPlane(e);return!!t&&(this.isDrawing=!0,this.tempElement={type:"stadium",start:t.clone(),end:t.clone(),width:0,height:0,cornerRadius:this.cornerRadius,segments:this.segments,points:this.calculateStadiumPoints(t,t,this.cornerRadius),color:this.sketchManager.sketchColor},this.directionX=1,this.directionY=1,this.createTempGeometry(),!0)}onMouseMove(e){if(!this.isDrawing||!this.tempElement)return;const t=this.getPointOnPlane(e);if(!t)return;this.tempElement.end=t.clone();const i=t.x-this.tempElement.start.x,n=t.y-this.tempElement.start.y;this.directionX=i>=0?1:-1,this.directionY=n>=0?1:-1,this.tempElement.width=Math.abs(i),this.tempElement.height=Math.abs(n);const s=Math.min(this.tempElement.width,this.tempElement.height)/2;this.tempElement.cornerRadius=Math.min(this.cornerRadius,s),this.tempElement.points=this.calculateStadiumPoints(this.tempElement.start,t,this.tempElement.cornerRadius),this.updateTempGeometry(),this.updateStadiumDimensions(),this.sketchManager.isInputActive&&this.updateInputFields()}onMouseUp(e){if(!this.isDrawing)return;this.getPointOnPlane(e)&&this.tempElement&&this.finishDrawing(e),this.isDrawing=!1}finishDrawing(e){if(!this.tempElement)return void this.onCancel();const t=this.getDimensionConfig();t.fields[0].value=this.tempElement.width.toFixed(1),t.fields[1].value=this.tempElement.height.toFixed(1),t.fields[2].value=this.tempElement.cornerRadius.toFixed(1),this.sketchManager.dimensionManager.showDimensionInput(e,t)}updateInputFields(){this.sketchManager.isInputActive&&this.tempElement&&(this.sketchManager.inputField1&&(this.sketchManager.inputField1.value=this.tempElement.width.toFixed(1)),this.sketchManager.inputField2&&(this.sketchManager.inputField2.value=this.tempElement.height.toFixed(1)),this.sketchManager.inputField3&&(this.sketchManager.inputField3.value=this.tempElement.cornerRadius.toFixed(1)))}applyDimensions(e){if(!this.tempElement)return;e.value1&&e.value1>0&&(this.tempElement.width=e.value1),e.value2&&e.value2>0&&(this.tempElement.height=e.value2),e.value3&&e.value3>0&&(this.tempElement.cornerRadius=e.value3),this.tempElement.end.x=this.tempElement.start.x+this.tempElement.width*this.directionX,this.tempElement.end.y=this.tempElement.start.y+this.tempElement.height*this.directionY;const t=Math.min(this.tempElement.width,this.tempElement.height)/2;this.tempElement.cornerRadius=Math.min(this.tempElement.cornerRadius,t),this.tempElement.points=this.calculateStadiumPoints(this.tempElement.start,this.tempElement.end,this.tempElement.cornerRadius),this.sketchManager.elementManager.addElement(this.tempElement),this.clearTempGeometry(),this.sketchManager.dimensionManager.clearDimensionObjects(),this.tempElement=null}updateStadiumDimensions(){this.tempElement&&(this.sketchManager.dimensionManager.clearDimensionObjects(),this.createStadiumDimensions())}createStadiumDimensions(){if(!this.sketchManager.currentPlane||!this.tempElement)return;const e=this.sketchManager.currentPlane.worldToLocal(this.tempElement.start.clone()),t=this.sketchManager.currentPlane.worldToLocal(this.tempElement.end.clone()),i=Math.min(e.x,t.x),n=Math.max(e.x,t.x),s=Math.min(e.y,t.y),a=Math.max(e.y,t.y),r=n-i,o=a-s,h=this.tempElement.cornerRadius,l=r-2*h,c=new THREE.Vector3(i+h,s-10,.1),m=new THREE.Vector3(n-h,s-10,.1),E=(new THREE.BufferGeometry).setFromPoints([c,m]),u=new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:2}),d=new THREE.Line(E,u),p=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(i+h,s,.1),new THREE.Vector3(i+h,s-10,.1)]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),w=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(n-h,s,.1),new THREE.Vector3(n-h,s-10,.1)]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),M=new THREE.Vector3(i+r/2,s-15,.1);this.createDimensionText(M,`Длина: ${l.toFixed(1)}`);const g=new THREE.Vector3(n+10,s,.1),T=new THREE.Vector3(n+10,a,.1),R=(new THREE.BufferGeometry).setFromPoints([g,T]),H=new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:2}),f=new THREE.Line(R,H),k=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(n,s,.1),new THREE.Vector3(n+10,s,.1)]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),x=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(n,a,.1),new THREE.Vector3(n+10,a,.1)]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),y=new THREE.Vector3(n+15,s+o/2,.1);this.createDimensionText(y,`Высота: ${o.toFixed(1)}`);const P=new THREE.Vector3(i+h,s+h,.1),F=new THREE.Vector3(i+h-10,s+h+10,.1);this.createDimensionText(F,`R: ${h.toFixed(1)}`);[d,p,w,f,k,x,new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(i,s+h,.1),P]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:2,linecap:"round",linejoin:"round"}))].forEach(e=>{e.userData.isDimension=!0,this.sketchManager.currentPlane.add(e),this.sketchManager.dimensionObjects.push(e)})}calculateStadiumPoints(e,t,i){if(!this.sketchManager.currentPlane)return[];const n=this.sketchManager.currentPlane.worldToLocal(e.clone()),s=this.sketchManager.currentPlane.worldToLocal(t.clone()),a=Math.min(n.x,s.x),r=Math.max(n.x,s.x),o=Math.min(n.y,s.y),h=Math.max(n.y,s.y),l=r-a,c=h-o,m=Math.min(i,Math.min(l,c)/2),E=[],u=this.segments;for(let e=0;e<=u;e++){const t=Math.PI-e/u*Math.PI,i=r-m+Math.cos(t)*m,n=h-m+Math.sin(t)*m;E.push(this.sketchManager.currentPlane.localToWorld(new THREE.Vector3(i,n,0)))}E.push(this.sketchManager.currentPlane.localToWorld(new THREE.Vector3(a+m,o,0)));for(let e=0;e<=u;e++){const t=Math.PI+e/u*Math.PI,i=a+m+Math.cos(t)*m,n=o+m+Math.sin(t)*m;E.push(this.sketchManager.currentPlane.localToWorld(new THREE.Vector3(i,n,0)))}return E.push(this.sketchManager.currentPlane.localToWorld(new THREE.Vector3(r-m,h,0))),E.push(E[0].clone()),E}createDimensionText(e,t){const i=document.createElement("canvas"),n=i.getContext("2d");i.width=256,i.height=64,n.clearRect(0,0,i.width,i.height),n.font="bold 14px Arial",n.fillStyle="#00C853",n.textAlign="center",n.textBaseline="middle",n.fillText(t,i.width/2,i.height/2);const s=new THREE.CanvasTexture(i);s.minFilter=THREE.LinearFilter;const a=new THREE.SpriteMaterial({map:s,transparent:!0}),r=new THREE.Sprite(a);r.position.copy(e),r.scale.set(25,5,1),r.userData.isDimension=!0,this.sketchManager.currentPlane.add(r),this.sketchManager.dimensionObjects.push(r)}createGeometry(e){const t=[];e.points.forEach(e=>{const i=this.sketchManager.currentPlane.worldToLocal(e.clone());t.push(i.x,i.y,0)});const i=new THREE.BufferGeometry;return i.setAttribute("position",new THREE.Float32BufferAttribute(t,3)),new THREE.LineLoop(i,new THREE.LineBasicMaterial({color:e.color,linewidth:2}))}updateGeometry(e,t){const i=[];t.points.forEach(e=>{const t=this.sketchManager.currentPlane.worldToLocal(e.clone());i.push(t.x,t.y,0)}),e.geometry.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),e.geometry.attributes.position.needsUpdate=!0}onCancel(){this.isDrawing=!1,this.clearTempGeometry(),this.tempElement=null,this.sketchManager.dimensionManager.clearDimensionObjects(),this.sketchManager.dimensionManager.hideDimensionInput()}}