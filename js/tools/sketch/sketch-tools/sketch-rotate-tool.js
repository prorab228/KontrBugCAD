class RotateSketchTool extends TransformSketchToolBase{constructor(t){super(t,"rotate","fa-sync-alt"),this.isRotating=!1,this.centerPoint=null,this.startAngle=0,this.originalRotations=[],this.currentAngle=0,this.previousSketchState=null,this.rotationArc=null,this.arcGeometry=null,this.arcMaterial=null,this.showRotationArc=!0,this.centerMarker=null,this.inputStartAngle=0,this.initRotationArc(),this.inputElement.addEventListener("input",t=>{this.isInputFocused&&this.centerPoint&&this.applyInputValueRealTime()}),this.inputElement.addEventListener("focus",()=>{this.inputStartAngle=this.currentAngle,this.saveOriginalRotations()})}applyInputValueRealTime(){const t=this.inputElement.value;if(!t||!this.centerPoint)return;const e=parseFloat(t)||0,n=e-this.inputStartAngle,i=THREE.MathUtils.degToRad(n);0===this.originalRotations.length&&this.saveOriginalRotations(),this.restoreOriginalRotations();this.sketchManager.elementManager.selectedElements.forEach((t,e)=>{if(t.mesh&&this.originalRotations[e]){const n=this.originalRotations[e];t.mesh.userData.points&&n.points&&(t.mesh.userData.points=n.points.map(t=>{const e=t.clone().sub(this.centerPoint);return e.applyAxisAngle(new THREE.Vector3(0,0,1),i),e.add(this.centerPoint)}),t.points=t.mesh.userData.points.map(t=>t.clone())),this.updateElementGeometry(t.mesh)}}),this.updateRotationArcFromAngle(e),this.currentAngle=e,this.updateRotationInfo()}updateRotationArcFromAngle(t){if(!this.rotationArc||!this.centerPoint)return;const e=THREE.MathUtils.degToRad(t),n=new THREE.Vector3(this.centerPoint.x+5,this.centerPoint.y,.1),i=this.createArcPoints(this.centerPoint,n,e);this.rotationArc.geometry.setFromPoints(i),this.rotationArc.geometry.attributes.position.needsUpdate=!0}initRotationArc(){this.rotationArc||(this.arcGeometry=new THREE.BufferGeometry,this.arcMaterial=new THREE.LineBasicMaterial({color:16750592,linewidth:2,transparent:!0,opacity:.7,depthTest:!1}),this.rotationArc=new THREE.Line(this.arcGeometry,this.arcMaterial),this.rotationArc.name="sketch_rotation_arc",this.rotationArc.visible=!1,this.rotationArc.renderOrder=999,this.rotationArc.userData.isSketchRotationArc=!0)}createCenterMarker(){if(this.centerMarker&&(this.centerMarker.parent&&this.centerMarker.parent.remove(this.centerMarker),this.centerMarker=null),!this.centerPoint)return;const t=new THREE.Group,e=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(-1,0,.1),new THREE.Vector3(1,0,.1)]),n=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(0,-1,.1),new THREE.Vector3(0,1,.1)]),i=new THREE.LineBasicMaterial({color:16729156,linewidth:2,transparent:!0,opacity:.8}),s=new THREE.Line(e,i),r=new THREE.Line(n,i);t.add(s,r),t.position.copy(this.centerPoint),t.userData.isCenterMarker=!0,this.centerMarker=t,this.sketchManager.currentPlane.add(this.centerMarker)}onActivate(){super.onActivate(),this.setRotateCursor(),this.updateCenterPoint(),this.sketchManager.editor.showStatus("Вращение: перетащите для вращения вокруг центра","info")}setRotateCursor(){this.sketchManager.editor.renderer.domElement.style.cursor="alias"}restoreCursor(){this.sketchManager.editor.renderer.domElement.style.cursor=""}updateCenterPoint(){const t=this.sketchManager.elementManager.selectedElements;t.length>0&&(this.centerPoint=this.calculateSelectionCenter(t),this.createCenterMarker())}calculateSelectionCenter(t){if(0===t.length)return null;let e=0,n=0,i=0;return t.forEach(t=>{if(!t.mesh)return;(t.mesh.userData?.points||[]).forEach(t=>{t&&(e+=t.x,n+=t.y,i++)})}),0===i?null:new THREE.Vector3(e/i,n/i,0)}onMouseDown(t){if(this.sketchManager.dimensionManager.isInputActive)return this.sketchManager.dimensionManager.applyDimensionInput(),!0;this.isDrawing=!0;const e=this.getPointOnPlane(t);if(!e)return!1;const n=this.sketchManager.elementManager.selectedElements;if(0===n.length){const t=this.sketchManager.elementManager.getElementAtPoint(e);return t&&(this.sketchManager.elementManager.selectElement(t),this.updateCenterPoint()),!0}return this.centerPoint||(this.centerPoint=this.calculateSelectionCenter(n),this.createCenterMarker()),this.startRotation(e),!0}startRotation(t){if(0===this.sketchManager.elementManager.selectedElements.length||!this.centerPoint)return;this.previousSketchState=this.sketchManager.elementManager.getCurrentSketchState(),this.isRotating=!0,this.currentAngle=0,this.inputStartAngle=0;const e=t.clone();this.startAngle=this.calculateAngle(this.centerPoint,e),this.saveOriginalRotations(),this.showInput("0.0",t),this.showRotationArc&&this.showRotationArcIndicator(t)}saveOriginalRotations(){const t=this.sketchManager.elementManager.selectedElements;this.originalRotations=[],t.forEach(t=>{t.mesh&&t.mesh.userData?.points&&this.originalRotations.push({mesh:t.mesh,points:t.mesh.userData.points.map(t=>t.clone())})})}showRotationArcIndicator(t){if(!this.rotationArc||!this.sketchManager.currentPlane)return;const e=this.createArcPoints(this.centerPoint,t,0),n=(new THREE.BufferGeometry).setFromPoints(e);this.rotationArc.geometry.dispose(),this.rotationArc.geometry=n,this.rotationArc.parent||this.sketchManager.currentPlane.add(this.rotationArc),this.rotationArc.visible=!0}createArcPoints(t,e,n){const i=[],s=Math.max(5,t.distanceTo(e)),r=this.calculateAngle(t,e);for(let e=0;e<=24;e++){const a=r+n*(e/24),o=t.x+Math.cos(a)*s,h=t.y+Math.sin(a)*s;i.push(new THREE.Vector3(o,h,.1))}return i}calculateAngle(t,e){const n=e.x-t.x,i=e.y-t.y;return Math.atan2(i,n)}onMouseMove(t){if(!this.isRotating||!this.centerPoint)return;const e=this.getPointOnPlane(t);if(!e)return;const n=this.calculateAngle(this.centerPoint,e.clone())-this.startAngle;this.currentAngle=THREE.MathUtils.radToDeg(n),this.currentAngle=Math.round(10*this.currentAngle)/10,this.applyRotationToElements(n),this.showRotationArc&&this.updateRotationArc(e,n),this.inputElement.value=this.currentAngle.toFixed(1),this.inputContainer.style.display="block";const i=this.getArcPoint(this.centerPoint,e,n/2);this.updateInputPosition(i),this.updateRotationInfo()}getArcPoint(t,e,n){const i=Math.max(5,t.distanceTo(e)),s=this.calculateAngle(t,e)+n;return new THREE.Vector3(t.x+Math.cos(s)*i,t.y+Math.sin(s)*i,.1)}updateRotationArc(t,e){if(!this.rotationArc||!this.rotationArc.visible)return;const n=this.createArcPoints(this.centerPoint,t,e);this.rotationArc.geometry.setFromPoints(n),this.rotationArc.geometry.attributes.position.needsUpdate=!0,Math.abs(this.currentAngle)<1?this.arcMaterial.color.setHex(16729156):this.arcMaterial.color.setHex(16750592)}applyRotationToElements(t){this.sketchManager.elementManager.selectedElements.forEach((e,n)=>{if(e.mesh&&this.originalRotations[n]){const i=this.originalRotations[n];e.mesh.userData.points&&i.points&&(e.mesh.userData.points=i.points.map(e=>{const n=e.clone().sub(this.centerPoint);return n.applyAxisAngle(new THREE.Vector3(0,0,1),t),n.add(this.centerPoint)}),e.points=e.mesh.userData.points.map(t=>t.clone())),this.updateElementGeometry(e.mesh)}})}updateElementGeometry(t){if(!t||!t.geometry||!t.userData.points)return;const e=[];t.userData.points.forEach(t=>{e.push(t.x,t.y,0)}),t.geometry.setAttribute("position",new THREE.Float32BufferAttribute(e,3)),t.geometry.attributes.position.needsUpdate=!0,t.computeLineDistances&&t.computeLineDistances()}updateRotationInfo(){const t=document.getElementById("coords");if(t){const e=t.textContent.split("|")[0];t.textContent=`${e} | Угол: ${this.currentAngle.toFixed(1)}°`}}onMouseUp(t){if(!this.isRotating||!this.centerPoint)return;this.isDrawing=!1;const e=this.getPointOnPlane(t);e&&this.finishRotation(e),this.isRotating=!1,this.startAngle=0}finishRotation(t){if(!this.sketchManager.currentPlane||!this.centerPoint)return;if(0===this.sketchManager.elementManager.selectedElements.length)return this.hideRotationArc(),void this.hideInput();const e=t.clone(),n=this.calculateAngle(this.centerPoint,e)-this.startAngle;if(this.currentAngle=THREE.MathUtils.radToDeg(n),this.currentAngle=Math.round(10*this.currentAngle)/10,Math.abs(this.currentAngle)<1)return this.sketchManager.editor.showStatus("Вращение отменено (слишком малый угол)","info"),this.restoreOriginalRotations(),this.hideRotationArc(),void this.hideInput();this.sketchManager.elementManager.updateSketch(),this.sketchManager.editor.showStatus(`Повернуто на ${this.currentAngle.toFixed(1)}°`,"success"),this.inputElement.value=this.currentAngle.toFixed(1),this.inputStartAngle=this.currentAngle,this.saveOriginalRotations(),this.previousSketchState=null}hideRotationArc(){this.rotationArc&&(this.rotationArc.visible=!1)}applyInputValue(){const t=this.inputElement.value;if(!t)return;const e=parseFloat(t)||0;if(Math.abs(e)<.1)return void this.sketchManager.editor.showStatus("Слишком малый угол","warning");const n=this.sketchManager.elementManager.selectedElements;if(0===n.length||!this.centerPoint)return;const i=e-this.inputStartAngle,s=THREE.MathUtils.degToRad(i);this.sketchManager.elementManager.getCurrentSketchState(),n.map(t=>t.mesh.uuid);this.restoreOriginalRotations(),n.forEach(t=>{t.mesh&&t.mesh.userData?.points&&(t.mesh.userData.points=t.mesh.userData.points.map(t=>{const e=t.clone().sub(this.centerPoint);return e.applyAxisAngle(new THREE.Vector3(0,0,1),s),e.add(this.centerPoint)}),t.points=t.mesh.userData.points.map(t=>t.clone()),this.updateElementGeometry(t.mesh))}),this.sketchManager.elementManager.updateSketch(),this.sketchManager.editor.showStatus(`Повернуто на ${e.toFixed(1)}°`,"success"),this.saveOriginalRotations(),this.inputStartAngle=e,this.hideInput()}restoreOriginalRotations(){this.originalRotations.forEach(t=>{t.mesh&&t.points&&(t.mesh.userData.points=t.points.map(t=>t.clone()),this.updateElementGeometry(t.mesh))})}cancelRotation(){this.isRotating&&(this.restoreOriginalRotations(),this.isRotating=!1,this.centerPoint=null,this.startAngle=0,this.currentAngle=0,this.inputStartAngle=0,this.originalRotations=[],this.previousSketchState=null,this.hideRotationArc(),this.hideInput(),this.sketchManager.editor.showStatus("Вращение отменено","info"))}cancelInput(){const t=this.inputStartAngle;this.inputElement.value=t.toFixed(1),this.applyInputValueRealTime(),this.hideInput()}onDeactivate(){super.onDeactivate(),this.restoreCursor(),this.cancelRotation(),this.rotationArc&&this.rotationArc.parent&&this.rotationArc.parent.remove(this.rotationArc),this.arcGeometry&&this.arcGeometry.dispose(),this.arcMaterial&&this.arcMaterial.dispose(),this.centerMarker&&this.centerMarker.parent&&this.centerMarker.parent.remove(this.centerMarker)}}