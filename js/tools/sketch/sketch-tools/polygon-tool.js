class PolygonSketchTool extends SketchToolBase{constructor(e){super(e,"polygon","fa-shapes"),this.radius=5,this.sides=6,this.dimensionFields=[{label:"Радиус опис. окр.",type:"number",value:this.radius,unit:"мм",min:1,step:1},{label:"Вершины",type:"number",value:this.sides,unit:"шт",min:3,max:20,step:1}]}onMouseDown(e){if(this.sketchManager.isInputActive)return this.sketchManager.applyDimensionInput(),!0;const t=this.getPointOnPlane(e);return!!t&&(this.isDrawing=!0,this.tempElement={type:"polygon",center:t.clone(),radius:0,sides:this.sides,points:this.calculatePolygonPoints(t,0,this.sides),color:this.sketchManager.sketchColor},this.createTempGeometry(),!0)}onMouseMove(e){if(!this.isDrawing||!this.tempElement)return;const t=this.getPointOnPlane(e);t&&(this.tempElement.radius=this.tempElement.center.distanceTo(t),this.tempElement.points=this.calculatePolygonPoints(this.tempElement.center,this.tempElement.radius,this.tempElement.sides),this.updateTempGeometry(),this.sketchManager.isInputActive&&this.updateInputFields())}onMouseUp(e){if(!this.isDrawing)return;this.getPointOnPlane(e)&&this.finishDrawing(e),this.isDrawing=!1}onKeyDown(e){return!("Escape"!==e.key||!this.isDrawing)&&(this.onCancel(),!0)}onCancel(){this.isDrawing=!1,this.clearTempGeometry(),this.tempElement=null,this.sketchManager.clearDimensionObjects()}finishDrawing(e){const t=this.getDimensionConfig();t.fields[0].value=this.tempElement.radius.toFixed(1),t.fields[1].value=this.tempElement.sides,this.sketchManager.showDimensionInput(e,t)}updateInputFields(){this.sketchManager.isInputActive&&this.tempElement&&(this.sketchManager.inputField1&&(this.sketchManager.inputField1.value=this.tempElement.radius.toFixed(1)),this.sketchManager.inputField2&&(this.sketchManager.inputField2.value=this.tempElement.sides))}applyDimensions(e){this.tempElement&&(e.value1&&e.value1>0&&(this.tempElement.radius=e.value1),e.value2&&e.value2>=3&&(this.tempElement.sides=Math.min(20,Math.max(3,e.value2))),this.tempElement.points=this.calculatePolygonPoints(this.tempElement.center,this.tempElement.radius,this.tempElement.sides),this.sketchManager.addElement(this.tempElement),this.clearTempGeometry(),this.tempElement=null)}updatePolygonDiameter(e){this.tempElement&&(this.tempElement.diameter=e,this.tempElement.radius=e/2,this.tempElement.points=this.calculatePolygonPoints(this.tempElement.center,this.tempElement.radius,this.tempElement.sides),this.updateTempGeometry(),this.sketchManager.updatePolygonDimensions(this.tempElement.center,this.tempElement.radius,this.tempElement.sides))}updatePolygonSides(e){this.tempElement&&(this.tempElement.sides=Math.max(3,Math.min(50,e)),this.tempElement.points=this.calculatePolygonPoints(this.tempElement.center,this.tempElement.radius,this.tempElement.sides),this.updateTempGeometry(),this.sketchManager.updatePolygonDimensions(this.tempElement.center,this.tempElement.radius,this.tempElement.sides))}calculatePolygonPoints(e,t,s){if(!this.sketchManager.currentPlane)return[];const i=this.sketchManager.currentPlane.worldToLocal(e.clone()),n=[];for(let e=0;e<=s;e++){const a=e/s*Math.PI*2,l=i.x+Math.cos(a)*t,o=i.y+Math.sin(a)*t;n.push(this.sketchManager.currentPlane.localToWorld(new THREE.Vector3(l,o,0)))}return n}createGeometry(e){const t=[];e.points.forEach(e=>{const s=this.sketchManager.currentPlane.worldToLocal(e.clone());t.push(s.x,s.y,0)});const s=new THREE.BufferGeometry;return s.setAttribute("position",new THREE.Float32BufferAttribute(t,3)),new THREE.LineLoop(s,new THREE.LineBasicMaterial({color:e.color,linewidth:2}))}updateGeometry(e,t){const s=[];t.points.forEach(e=>{const t=this.sketchManager.currentPlane.worldToLocal(e.clone());s.push(t.x,t.y,0)}),e.geometry.setAttribute("position",new THREE.Float32BufferAttribute(s,3)),e.geometry.attributes.position.needsUpdate=!0}}