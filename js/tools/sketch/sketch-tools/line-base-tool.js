class LineBaseTool extends SketchToolBase{constructor(e,t,n){super(e,t,n),this.angle=0,this.length=10,this.showAngleIndicator=!0,this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0}onMouseDown(e){if(this.sketchManager.dimensionManager.isInputActive)return this.sketchManager.dimensionManager.applyDimensionInput(),!0;const t=this.getPointOnPlane(e);if(!t)return!1;this.isDrawing=!0,this.tempElement={type:this.name,start:t.clone(),end:t.clone(),length:0,angle:0,points:[t.clone(),t.clone()],color:this.sketchManager.sketchColor,startElement:null};const n=this.sketchManager.snapHelper;return n&&n.currentSnapPoint&&(this.tempElement.startElement=n.currentSnapPoint.element),this.createTempGeometry(),this.updateAngleIndicator(),!0}onMouseMove(e){if(!this.isDrawing||!this.tempElement)return;const t=this.getPointOnPlane(e);t&&(this.tempElement.end=t.clone(),this.tempElement.points[1]=t.clone(),this.calculateLineProperties(),this.updateTempGeometry(),this.updateLineDimensions(),this.updateAngleIndicator(),this.sketchManager.dimensionManager.isInputActive&&(this.sketchManager.dimensionManager.isInputFocused||this.updateInputFields()))}onMouseUp(e){if(!this.isDrawing)return;this.getPointOnPlane(e)&&this.tempElement&&this.finishDrawing(e),this.isDrawing=!1}calculateLineProperties(){if(!this.tempElement||!this.tempElement.start||!this.tempElement.end)return;const e=this.tempElement.end.x-this.tempElement.start.x,t=this.tempElement.end.y-this.tempElement.start.y;this.tempElement.length=Math.sqrt(e*e+t*t);let n=THREE.MathUtils.radToDeg(Math.atan2(t,e));n<0&&(n+=360),this.tempElement.angle=Math.round(10*n)/10}updateLineDimensions(){this.sketchManager.dimensionManager.clearDimensionObjects(),this.createLineDimension()}createLineDimension(){if(!this.sketchManager.currentPlane||!this.tempElement)return;const e=this.tempElement.start,t=this.tempElement.end,n=t.x-e.x,i=t.y-e.y,a=Math.sqrt(n*n+i*i),s=new THREE.Vector3(n,i,0).normalize(),l=new THREE.Vector3(-s.y,s.x,0).normalize(),r=new THREE.Vector3(e.x+10*l.x,e.y+10*l.y,.1),h=new THREE.Vector3(t.x+10*l.x,t.y+10*l.y,.1),o=(new THREE.BufferGeometry).setFromPoints([r,h]),m=new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:2}),c=new THREE.Line(o,m),d=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(e.x,e.y,.1),r]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),p=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(t.x,t.y,.1),h]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),g=(new THREE.Vector3).addVectors(r,h).multiplyScalar(.5).add(new THREE.Vector3(5*-l.y,5*l.x,.1));this.createDimensionText(g,`${a.toFixed(1)} мм`),[c,d,p].forEach(e=>{e.userData.isDimension=!0,this.sketchManager.currentPlane.add(e),this.sketchManager.dimensionObjects.push(e)})}createDimensionText(e,t){const n=document.createElement("canvas"),i=n.getContext("2d");n.width=256,n.height=64,i.clearRect(0,0,n.width,n.height),i.font="bold 16px Arial",i.fillStyle="#00C853",i.textAlign="center",i.textBaseline="middle",i.fillText(t,n.width/2,n.height/2);const a=new THREE.CanvasTexture(n);a.minFilter=THREE.LinearFilter;const s=new THREE.SpriteMaterial({map:a,transparent:!0}),l=new THREE.Sprite(s);l.position.copy(e),l.scale.set(20,5,1),l.userData.isDimension=!0,this.sketchManager.currentPlane.add(l),this.sketchManager.dimensionObjects.push(l)}updateAngleIndicator(){if(!this.showAngleIndicator||!this.tempElement||!this.sketchManager.currentPlane||this.tempElement.length<1)return void this.hideAngleIndicator();const e=this.tempElement.start,t=this.tempElement.end,n=t.x-e.x,i=t.y-e.y;if(Math.sqrt(n*n+i*i)<1)return void this.hideAngleIndicator();let a=Math.atan2(i,n),s=THREE.MathUtils.radToDeg(a);s<0&&(s+=360);let l=!1;const r=Math.round(s);Math.abs(s-r)<.1&&(s=r,l=!0),(Math.abs(s-this.lastAngle)>.5||!this.angleIndicator)&&(this.lastAngle=s,this.hideAngleIndicator(),this.createAngleIndicator(e,t,s,l))}createAngleIndicator(e,t,n,i){const a=i?65280:7829503,s=t.x-e.x,l=t.y-e.y,r=Math.sqrt(s*s+l*l),h=Math.min(3,r/5);let o=Math.atan2(l,s);o<0&&(o+=2*Math.PI);const m=o,c=[];for(let t=0;t<=16;t++){const n=0+t/16*m,i=e.x+Math.cos(n)*h,a=e.y+Math.sin(n)*h;c.push(new THREE.Vector3(i,a,.05))}const d=(new THREE.BufferGeometry).setFromPoints(c),p=new THREE.LineBasicMaterial({color:a,linewidth:2,transparent:!0,opacity:.8});this.angleIndicator=new THREE.Line(d,p),this.angleIndicator.userData.isAngleIndicator=!0,this.createAngleLabel(e,o,h,n),this.sketchManager.currentPlane.add(this.angleIndicator)}createAngleLabel(e,t,n,i){const a=1.5*n;let s=t/2;t>Math.PI&&(s=t+(2*Math.PI-t)/2);const l=e.x+Math.cos(s)*a,r=e.y+Math.sin(s)*a,h=document.createElement("canvas"),o=h.getContext("2d");let m;h.width=300,h.height=90,o.clearRect(0,0,h.width,h.height),o.font="bold 34px Arial",o.fillStyle="#7777FF",o.textAlign="center",o.textBaseline="middle",m=Math.abs(i-0)<.1||Math.abs(i-360)<.1?"0° →":Math.abs(i-45)<.1?"45°":Math.abs(i-90)<.1?"90° ↑":Math.abs(i-135)<.1?"135°":Math.abs(i-180)<.1?"180° ←":Math.abs(i-225)<.1?"225°":Math.abs(i-270)<.1?"270° ↓":Math.abs(i-315)<.1?"315°":`${i.toFixed(1)}°`,o.fillText(m,h.width/2,h.height/2);const c=new THREE.CanvasTexture(h);c.minFilter=THREE.LinearFilter;const d=new THREE.SpriteMaterial({map:c,transparent:!0,opacity:.9});this.angleLabel=new THREE.Sprite(d);const p=new THREE.Vector3(l,r,.1);this.angleLabel.position.copy(p),this.angleLabel.scale.set(8,2,1),this.angleLabel.userData.isAngleLabel=!0,this.sketchManager.currentPlane.add(this.angleLabel)}hideAngleIndicator(){this.angleIndicator&&(this.angleIndicator.parent&&this.angleIndicator.parent.remove(this.angleIndicator),this.angleIndicator.geometry&&this.angleIndicator.geometry.dispose(),this.angleIndicator.material&&this.angleIndicator.material.dispose(),this.angleIndicator=null),this.angleLabel&&(this.angleLabel.parent&&this.angleLabel.parent.remove(this.angleLabel),this.angleLabel.material&&this.angleLabel.material.dispose(),this.angleLabel.material.map&&this.angleLabel.material.map.dispose(),this.angleLabel=null)}finishDrawing(e){if(!this.tempElement)return void this.onCancel();const t=this.getDimensionConfig();this.dimensionFields&&this.dimensionFields.length>0&&(this.dimensionFields[0]&&(this.dimensionFields[0].value=this.tempElement.length.toFixed(1)),this.dimensionFields[1]&&(this.dimensionFields[1].value=this.tempElement.angle.toFixed(1))),this.sketchManager.dimensionManager.showDimensionInput(e,t)}updateInputFields(){if(!this.sketchManager.dimensionManager.isInputActive||!this.tempElement)return;const e=[this.sketchManager.dimensionManager.inputField1,this.sketchManager.dimensionManager.inputField2,this.sketchManager.dimensionManager.inputField3];e[0]&&(e[0].value=this.tempElement.length.toFixed(1)),e[1]&&(e[1].value=this.tempElement.angle.toFixed(1))}applyDimensions(e){this.tempElement&&(e.value1&&e.value1>0&&this.updateLineLength(e.value1),void 0!==e.value2&&this.updateLineAngle(e.value2),this.sketchManager.elementManager.addElement(this.tempElement),this.clearTempGeometry(),this.sketchManager.dimensionManager.clearDimensionObjects(),this.hideAngleIndicator(),this.tempElement=null)}updateLineLength(e){if(!this.tempElement)return;const t=THREE.MathUtils.degToRad(this.tempElement.angle),n=new THREE.Vector3(Math.cos(t),Math.sin(t),0);this.tempElement.end=this.tempElement.start.clone().add(n.multiplyScalar(e)),this.tempElement.points[1]=this.tempElement.end.clone(),this.tempElement.length=e,this.updateTempGeometry(),this.updateLineDimensions(),this.updateAngleIndicator()}updateLineAngle(e){if(!this.tempElement)return;this.tempElement.angle=e;const t=THREE.MathUtils.degToRad(e),n=new THREE.Vector3(Math.cos(t),Math.sin(t),0);this.tempElement.end=this.tempElement.start.clone().add(n.multiplyScalar(this.tempElement.length)),this.tempElement.points[1]=this.tempElement.end.clone(),this.updateTempGeometry(),this.updateLineDimensions(),this.updateAngleIndicator()}onCancel(){this.isDrawing=!1,this.clearTempGeometry(),this.hideAngleIndicator(),this.tempElement=null,this.sketchManager.dimensionManager.clearDimensionObjects()}createTempGeometry(){if(this.clearTempGeometry(),!this.tempElement)return;const e={...this.tempElement};e.color=this.sketchManager.previewColor;const t=this.createGeometry(e);t&&(this.tempGeometry=t,this.tempGeometry.frustumCulled=!1,this.sketchManager.currentPlane.add(this.tempGeometry))}updateTempGeometry(){if(!this.tempGeometry||!this.tempElement)return;const e=[];this.tempElement.points.forEach(t=>{e.push(t.x,t.y,0)}),this.tempGeometry.geometry.setAttribute("position",new THREE.Float32BufferAttribute(e,3)),this.tempGeometry.geometry.attributes.position.needsUpdate=!0}}