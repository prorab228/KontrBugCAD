class LineBaseTool extends SketchToolBase{constructor(e,t,n){super(e,t,n),this.angle=0,this.length=10,this.showAngleIndicator=!0,this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0}getPlaneAxes(){if(!this.sketchManager.currentPlane)return{x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)};const e=this.sketchManager.currentPlane;return{x:new THREE.Vector3(1,0,0).applyQuaternion(e.quaternion),y:new THREE.Vector3(0,1,0).applyQuaternion(e.quaternion),z:new THREE.Vector3(0,0,1).applyQuaternion(e.quaternion)}}getDirectionFromAngle(e){const t=THREE.MathUtils.degToRad(e);this.getPlaneAxes();return new THREE.Vector3(Math.cos(t),Math.sin(t),0).applyQuaternion(this.sketchManager.currentPlane.quaternion)}onMouseDown(e){if(this.sketchManager.dimensionManager.isInputActive)return this.sketchManager.dimensionManager.applyDimensionInput(),!0;const t=this.getPointOnPlane(e);if(!t)return!1;this.isDrawing=!0,this.tempElement={type:this.name,start:t.clone(),end:t.clone(),length:0,angle:0,points:[t.clone(),t.clone()],color:this.sketchManager.sketchColor,startElement:null};const n=this.sketchManager.snapHelper;return n&&n.currentSnapPoint&&(this.tempElement.startElement=n.currentSnapPoint.element),this.createTempGeometry(),this.updateAngleIndicator(),!0}onMouseMove(e){if(!this.isDrawing||!this.tempElement)return;const t=this.getPointOnPlane(e);t&&(this.tempElement.originalEnd=t.clone(),this.tempElement.end=t.clone(),this.tempElement.points[1]=t.clone(),this.calculateLineProperties(),this.updateTempGeometry(),this.updateLineDimensions(),this.updateAngleIndicator(),this.sketchManager.dimensionManager.isInputActive&&(this.sketchManager.dimensionManager.isInputFocused||this.updateInputFields()))}onMouseUp(e){if(!this.isDrawing)return;this.getPointOnPlane(e)&&this.tempElement&&this.finishDrawing(e),this.isDrawing=!1}calculateLineProperties(){if(!this.tempElement||!this.tempElement.start||!this.tempElement.end)return;const e=this.sketchManager.currentPlane;if(!e)return;const t=e.worldToLocal(this.tempElement.start.clone()),n=e.worldToLocal(this.tempElement.end.clone()),i=n.x-t.x,a=n.y-t.y;this.tempElement.length=Math.sqrt(i*i+a*a);let s=THREE.MathUtils.radToDeg(Math.atan2(a,i));s<0&&(s+=360),this.tempElement.angle=Math.round(10*s)/10}updateLineDimensions(){this.sketchManager.dimensionManager.clearDimensionObjects(),this.createLineDimension()}createLineDimension(){if(!this.sketchManager.currentPlane||!this.tempElement)return;const e=this.tempElement.start,t=this.tempElement.end,n=this.sketchManager.currentPlane.worldToLocal(e.clone()),i=this.sketchManager.currentPlane.worldToLocal(t.clone()),a=i.x-n.x,s=i.y-n.y,r=Math.sqrt(a*a+s*s),l=new THREE.Vector3(a,s,0).normalize(),o=new THREE.Vector3(-l.y,l.x,0).normalize(),h=new THREE.Vector3(n.x+10*o.x,n.y+10*o.y,.1),c=new THREE.Vector3(i.x+10*o.x,i.y+10*o.y,.1),m=(new THREE.BufferGeometry).setFromPoints([h,c]),d=new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:2}),p=new THREE.Line(m,d),g=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(n.x,n.y,.1),h]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),E=new THREE.Line((new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(i.x,i.y,.1),c]),new THREE.LineBasicMaterial({color:this.sketchManager.dimensionColor,linewidth:1})),u=(new THREE.Vector3).addVectors(h,c).multiplyScalar(.5).add(new THREE.Vector3(5*-o.y,5*o.x,.1));this.createDimensionText(u,`${r.toFixed(1)} мм`),[p,g,E].forEach(e=>{e.userData.isDimension=!0,this.sketchManager.currentPlane.add(e),this.sketchManager.dimensionObjects.push(e)})}createDimensionText(e,t){const n=document.createElement("canvas"),i=n.getContext("2d");n.width=256,n.height=64,i.clearRect(0,0,n.width,n.height),i.font="bold 16px Arial",i.fillStyle="#00C853",i.textAlign="center",i.textBaseline="middle",i.fillText(t,n.width/2,n.height/2);const a=new THREE.CanvasTexture(n);a.minFilter=THREE.LinearFilter;const s=new THREE.SpriteMaterial({map:a,transparent:!0}),r=new THREE.Sprite(s);r.position.copy(e),r.scale.set(20,5,1),r.userData.isDimension=!0,this.sketchManager.currentPlane.add(r),this.sketchManager.dimensionObjects.push(r)}updateAngleIndicator(){if(!this.showAngleIndicator||!this.tempElement||!this.sketchManager.currentPlane||this.tempElement.length<1)return void this.hideAngleIndicator();const e=this.sketchManager.currentPlane,t=e.worldToLocal(this.tempElement.start.clone()),n=e.worldToLocal(this.tempElement.end.clone()),i=n.x-t.x,a=n.y-t.y;if(Math.sqrt(i*i+a*a)<1)return void this.hideAngleIndicator();let s=Math.atan2(a,i),r=THREE.MathUtils.radToDeg(s);r<0&&(r+=360);let l=!1;const o=Math.round(r);Math.abs(r-o)<.1&&(r=o,l=!0),(Math.abs(r-this.lastAngle)>.5||!this.angleIndicator)&&(this.lastAngle=r,this.hideAngleIndicator(),this.createAngleIndicator(t,n,r,l))}createAngleIndicator(e,t,n,i){const a=this.sketchManager.currentPlane,s=i?65280:7829503,r=t.x-e.x,l=t.y-e.y,o=Math.sqrt(r*r+l*l),h=Math.min(3,o/5);let c=Math.atan2(l,r);c<0&&(c+=2*Math.PI);const m=c,d=[];for(let t=0;t<=16;t++){const n=0+t/16*m,i=e.x+Math.cos(n)*h,a=e.y+Math.sin(n)*h;d.push(new THREE.Vector3(i,a,.05))}const p=(new THREE.BufferGeometry).setFromPoints(d),g=new THREE.LineBasicMaterial({color:s,linewidth:2,transparent:!0,opacity:.8});this.angleIndicator=new THREE.Line(p,g),this.angleIndicator.userData.isAngleIndicator=!0,this.createAngleLabel(e,c,h,n),a.add(this.angleIndicator)}createAngleLabel(e,t,n,i){const a=this.sketchManager.currentPlane,s=1.5*n;let r=t/2;t>Math.PI&&(r=t+(2*Math.PI-t)/2);const l=e.x+Math.cos(r)*s,o=e.y+Math.sin(r)*s,h=document.createElement("canvas"),c=h.getContext("2d");let m;h.width=300,h.height=90,c.clearRect(0,0,h.width,h.height),c.font="bold 34px Arial",c.fillStyle="#7777FF",c.textAlign="center",c.textBaseline="middle",m=Math.abs(i-0)<.1||Math.abs(i-360)<.1?"0° →":Math.abs(i-45)<.1?"45°":Math.abs(i-90)<.1?"90° ↑":Math.abs(i-135)<.1?"135°":Math.abs(i-180)<.1?"180° ←":Math.abs(i-225)<.1?"225°":Math.abs(i-270)<.1?"270° ↓":Math.abs(i-315)<.1?"315°":`${i.toFixed(1)}°`,c.fillText(m,h.width/2,h.height/2);const d=new THREE.CanvasTexture(h);d.minFilter=THREE.LinearFilter;const p=new THREE.SpriteMaterial({map:d,transparent:!0,opacity:.9});this.angleLabel=new THREE.Sprite(p);const g=new THREE.Vector3(l,o,.1);this.angleLabel.position.copy(g),this.angleLabel.scale.set(8,2,1),this.angleLabel.userData.isAngleLabel=!0,a.add(this.angleLabel)}hideAngleIndicator(){this.angleIndicator&&(this.angleIndicator.parent&&this.angleIndicator.parent.remove(this.angleIndicator),this.angleIndicator.geometry&&this.angleIndicator.geometry.dispose(),this.angleIndicator.material&&this.angleIndicator.material.dispose(),this.angleIndicator=null),this.angleLabel&&(this.angleLabel.parent&&this.angleLabel.parent.remove(this.angleLabel),this.angleLabel.material&&this.angleLabel.material.dispose(),this.angleLabel.material.map&&this.angleLabel.material.map.dispose(),this.angleLabel=null)}finishDrawing(e){if(!this.tempElement)return void this.onCancel();const t=this.getDimensionConfig();this.dimensionFields&&this.dimensionFields.length>0&&(this.dimensionFields[0]&&(this.dimensionFields[0].value=this.tempElement.length.toFixed(1)),this.dimensionFields[1]&&(this.dimensionFields[1].value=this.tempElement.angle.toFixed(1))),this.sketchManager.dimensionManager.showDimensionInput(e,t)}updateInputFields(){if(!this.sketchManager.dimensionManager.isInputActive||!this.tempElement)return;const e=[this.sketchManager.dimensionManager.inputField1,this.sketchManager.dimensionManager.inputField2,this.sketchManager.dimensionManager.inputField3];e[0]&&(e[0].value=this.tempElement.length.toFixed(1)),e[1]&&(e[1].value=this.tempElement.angle.toFixed(1))}applyDimensions(e){this.tempElement&&(e.value1&&e.value1>0&&this.updateLineLength(e.value1),void 0!==e.value2&&this.updateLineAngle(e.value2),this.sketchManager.elementManager.addElement(this.tempElement),this.clearTempGeometry(),this.sketchManager.dimensionManager.clearDimensionObjects(),this.hideAngleIndicator(),this.tempElement=null)}updateLineLength(e){if(!this.tempElement)return;const t=this.getDirectionFromAngle(this.tempElement.angle);this.tempElement.end=this.tempElement.start.clone().add(t.multiplyScalar(e)),this.tempElement.points[1]=this.tempElement.end.clone(),this.tempElement.length=e,this.updateTempGeometry(),this.updateLineDimensions(),this.updateAngleIndicator()}updateLineAngle(e){if(!this.tempElement)return;this.tempElement.angle=e;const t=this.getDirectionFromAngle(e);this.tempElement.end=this.tempElement.start.clone().add(t.multiplyScalar(this.tempElement.length)),this.tempElement.points[1]=this.tempElement.end.clone(),this.updateTempGeometry(),this.updateLineDimensions(),this.updateAngleIndicator()}onCancel(){this.isDrawing=!1,this.clearTempGeometry(),this.hideAngleIndicator(),this.tempElement=null,this.sketchManager.dimensionManager.clearDimensionObjects()}clearTempGeometry(){super.clearTempGeometry(),this.hideAngleIndicator()}createTempGeometry(){if(this.clearTempGeometry(),!this.tempElement)return;const e={...this.tempElement};e.color=this.sketchManager.previewColor;const t=this.createGeometry(e);t&&(this.tempGeometry=t,this.sketchManager.currentPlane.add(this.tempGeometry))}updateTempGeometry(){if(!this.tempGeometry||!this.tempElement)return;const e=[];this.tempElement.points.forEach(t=>{const n=this.sketchManager.currentPlane.worldToLocal(t.clone());e.push(n.x,n.y,0)}),this.tempGeometry.geometry.setAttribute("position",new THREE.Float32BufferAttribute(e,3)),this.tempGeometry.geometry.attributes.position.needsUpdate=!0}}