class ArcSketchTool extends SketchToolBase{constructor(e){super(e,"arc","fa-arc"),this.radius=10,this.startAngle=0,this.endAngle=90,this.segments=32,this.drawingStage=0,this.dimensionFields=[{label:"Радиус",type:"number",value:this.radius,unit:"мм",min:1,step:1},{label:"Начальный угол",type:"number",value:this.startAngle,unit:"°",min:0,max:360,step:1},{label:"Конечный угол",type:"number",value:this.endAngle,unit:"°",min:0,max:360,step:1}]}onMouseDown(e){if(this.sketchManager.isInputActive)return this.sketchManager.applyDimensionInput(),!0;const t=this.getPointOnPlane(e);if(!t)return!1;switch(this.drawingStage){case 0:this.tempElement={type:"arc",center:t.clone(),radius:0,startAngle:0,endAngle:0,segments:this.segments,points:[],color:this.sketchManager.sketchColor},this.drawingStage=1,this.sketchManager.editor.showStatus("Укажите начальную точку дуги","info");break;case 1:const n=(new THREE.Vector3).subVectors(t,this.tempElement.center);this.tempElement.radius=n.length(),this.tempElement.startAngle=Math.atan2(n.y,n.x),this.drawingStage=2,this.sketchManager.editor.showStatus("Укажите конечную точку дуги","info"),this.createTempGeometry();break;case 2:const s=(new THREE.Vector3).subVectors(t,this.tempElement.center);this.tempElement.endAngle=Math.atan2(s.y,s.x),this.finishDrawing(e)}return!0}onMouseMove(e){const t=this.getPointOnPlane(e);if(t)if(1===this.drawingStage&&this.tempElement){const e=(new THREE.Vector3).subVectors(t,this.tempElement.center);this.tempElement.radius=e.length(),this.tempElement.startAngle=Math.atan2(e.y,e.x),this.updateArcPreview()}else if(2===this.drawingStage&&this.tempElement){const e=(new THREE.Vector3).subVectors(t,this.tempElement.center);this.tempElement.endAngle=Math.atan2(e.y,e.x),this.updateArcPreview()}}updateArcPreview(){if(!this.tempElement)return;let e=this.tempElement.startAngle,t=this.tempElement.endAngle;t<e&&(t+=2*Math.PI),this.tempElement.points=this.calculateArcPoints(this.tempElement.center,this.tempElement.radius,e,t,this.tempElement.segments),this.tempGeometry?this.updateTempGeometry():this.createTempGeometry()}finishDrawing(e){if(!this.tempElement)return;this.startAngle=THREE.MathUtils.radToDeg(this.tempElement.startAngle),this.endAngle=THREE.MathUtils.radToDeg(this.tempElement.endAngle);const t=this.getDimensionConfig();t.fields[0].value=this.tempElement.radius.toFixed(1),t.fields[1].value=this.startAngle.toFixed(1),t.fields[2].value=this.endAngle.toFixed(1),this.sketchManager.dimensionManager.showDimensionInput(e,t),this.drawingStage=0}applyDimensions(e){if(!this.tempElement)return;e.value1&&e.value1>0&&(this.tempElement.radius=e.value1),void 0!==e.value2&&(this.tempElement.startAngle=THREE.MathUtils.degToRad(e.value2)),void 0!==e.value3&&(this.tempElement.endAngle=THREE.MathUtils.degToRad(e.value3));let t=this.tempElement.startAngle,n=this.tempElement.endAngle;n<t&&(n+=2*Math.PI),this.tempElement.points=this.calculateArcPoints(this.tempElement.center,this.tempElement.radius,t,n,this.tempElement.segments),this.sketchManager.elementManager.addElement(this.tempElement),this.clearTempGeometry(),this.tempElement=null}calculateArcPoints(e,t,n,s,i){const a=[],r=s-n;for(let s=0;s<=i;s++){const l=n+s/i*r,h=e.x+Math.cos(l)*t,m=e.y+Math.sin(l)*t;a.push(new THREE.Vector3(h,m,0))}return a}createGeometry(e){if(!e.points||e.points.length<2)return null;const t=[];e.points.forEach(e=>{t.push(e.x,e.y,0)});const n=new THREE.BufferGeometry;return n.setAttribute("position",new THREE.Float32BufferAttribute(t,3)),new THREE.Line(n,new THREE.LineBasicMaterial({color:e.color,linewidth:2}))}updateGeometry(e,t){if(!t.points||t.points.length<2)return;const n=[];t.points.forEach(e=>{n.push(e.x,e.y,0)}),e.geometry.setAttribute("position",new THREE.Float32BufferAttribute(n,3)),e.geometry.attributes.position.needsUpdate=!0}onCancel(){this.drawingStage=0,super.onCancel()}}