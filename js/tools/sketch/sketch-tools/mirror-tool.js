import*as THREE from"three";import{SketchToolBase}from"./sketch-tool-base.js";export class MirrorSketchTool extends SketchToolBase{constructor(e){super(e,"mirror","fa-balance-scale"),this.mirrorLine=null,this.tempLine=null,this.mirrorMode="select_line",this.selectedElementsForMirror=[],this.dimensionFields=[]}onMouseDown(e){const t=this.getPointOnPlane(e);if(!t)return!1;switch(this.mirrorMode){case"select_line":this.mirrorLine?this.finishMirrorLine(t,e):this.startMirrorLine(t,e);break;case"select_objects":this.selectObjectsForMirror(e)}return!0}onMouseMove(e){const t=this.getPointOnPlane(e);if(t&&"select_line"===this.mirrorMode)this.mirrorLine&&this.mirrorLine.points&&1===this.mirrorLine.points.length&&this.updateMirrorLine(t)}startMirrorLine(e,t){this.mirrorLine={type:"mirror_line",start:e.clone(),end:e.clone(),points:[e.clone(),e.clone()],color:16711680},this.createMirrorLineGeometry(),this.sketchManager.editor.showStatus("Укажите конечную точку оси симметрии","info")}updateMirrorLine(e){this.mirrorLine&&(this.mirrorLine.end=e.clone(),this.mirrorLine.points[1]=e.clone(),this.updateMirrorLineGeometry())}finishMirrorLine(e,t){this.mirrorLine&&(this.mirrorLine.end=e.clone(),this.mirrorLine.points[1]=e.clone(),this.updateMirrorLineGeometry(),this.mirrorMode="select_objects",this.sketchManager.editor.showStatus("Теперь выберите объекты для отражения. Нажмите Enter для применения","info"))}createMirrorLineGeometry(){this.clearTempGeometry();const e=[];this.mirrorLine.points.forEach(t=>{const r=this.sketchManager.currentPlane.worldToLocal(t.clone());e.push(r.x,r.y,0)});const t=new THREE.BufferGeometry;t.setAttribute("position",new THREE.Float32BufferAttribute(e,3));const r=new THREE.LineDashedMaterial({color:this.mirrorLine.color,linewidth:2,dashSize:1,gapSize:1,scale:1});this.tempGeometry=new THREE.Line(t,r),this.tempGeometry.computeLineDistances(),this.sketchManager.currentPlane.add(this.tempGeometry)}updateMirrorLineGeometry(){if(!this.tempGeometry||!this.mirrorLine)return;const e=[];this.mirrorLine.points.forEach(t=>{const r=this.sketchManager.currentPlane.worldToLocal(t.clone());e.push(r.x,r.y,0)}),this.tempGeometry.geometry.setAttribute("position",new THREE.Float32BufferAttribute(e,3)),this.tempGeometry.geometry.attributes.position.needsUpdate=!0,this.tempGeometry.computeLineDistances()}selectObjectsForMirror(e){const t=this.getPointOnPlane(e);if(!t)return;const r=this.sketchManager.elementManager.getElementAtPoint(t);if(r){const e=this.selectedElementsForMirror.indexOf(r);e>-1?(this.selectedElementsForMirror.splice(e,1),this.sketchManager.unhighlightElement(r),this.sketchManager.editor.showStatus(`Элемент удален из выделения. Выбрано: ${this.selectedElementsForMirror.length}`,"info")):(this.selectedElementsForMirror.push(r),this.sketchManager.elementManager.highlightElement(r),this.sketchManager.editor.showStatus(`Элемент добавлен. Выбрано: ${this.selectedElementsForMirror.length}`,"info"))}}onKeyDown(e){return"Escape"===e.key?(this.onCancel(),!0):"Enter"===e.key&&"select_objects"===this.mirrorMode?(this.applyMirror(),!0):!("A"!==e.key||!e.ctrlKey||"select_objects"!==this.mirrorMode)&&(this.selectAllElements(),!0)}selectAllElements(){this.selectedElementsForMirror.forEach(e=>this.sketchManager.unhighlightElement(e)),this.selectedElementsForMirror=[...this.sketchManager.elementManager.elements],this.selectedElementsForMirror.forEach(e=>this.sketchManager.highlightElement(e)),this.sketchManager.editor.showStatus(`Выбрано всех элементов: ${this.selectedElementsForMirror.length}`,"info")}applyMirror(){if(!this.mirrorLine||0===this.selectedElementsForMirror.length)return void this.sketchManager.editor.showStatus("Нет выбранных объектов для отражения","error");const e=this.mirrorLine.start,t=this.mirrorLine.end,r=(new THREE.Vector3).subVectors(t,e);if(r.length()<.1)return void this.sketchManager.editor.showStatus("Линия симметрии слишком короткая","error");r.normalize();const i=new THREE.Vector3(-r.y,r.x,0);i.normalize();const s=[];this.selectedElementsForMirror.forEach(t=>{if(!t||!t.mesh)return;const r=this.createMirroredElement(t,e,i);r&&s.push(r)}),s.forEach(e=>{if(e){if(!e.type)return void console.error("Отраженный элемент не имеет типа:",e);this.sketchManager.elementManager.addElement(e)}}),this.sketchManager.editor.showStatus(`Отражено ${s.length} объектов`,"success"),this.selectedElementsForMirror.forEach(e=>this.sketchManager.unhighlightElement(e)),this.selectedElementsForMirror=[],this.onCancel()}createMirroredElement(e,t,r){try{const i=JSON.parse(JSON.stringify(e));i.mesh=null,i.originalColor=null,i.originalScale=null;const s=e=>{if(!e||"number"!=typeof e.x||"number"!=typeof e.y)return e;const i=(new THREE.Vector3).subVectors(new THREE.Vector3(e.x,e.y,e.z||0),t).dot(r);return new THREE.Vector3(e.x-2*r.x*i,e.y-2*r.y*i,e.z||0)};switch(i.type){case"line":case"polyline":case"curve":i.points&&Array.isArray(i.points)&&(i.points=i.points.map(e=>s(e)));break;case"rectangle":case"stadium":i.start&&(i.start=s(i.start)),i.end&&(i.end=s(i.end)),i.points&&Array.isArray(i.points)&&(i.points=i.points.map(e=>s(e)));break;case"circle":case"oval":case"polygon":case"arc":i.center&&(i.center=s(i.center)),i.points&&Array.isArray(i.points)&&(i.points=i.points.map(e=>s(e)));break;case"text":i.position&&(i.position=s(i.position)),i.contours&&Array.isArray(i.contours)&&(i.contours=i.contours.map(e=>e.map(e=>s(e))));break;default:console.warn("Неизвестный тип элемента для отражения:",i.type)}return i}catch(t){return console.error("Ошибка при создании отраженного элемента:",t,e),null}}onCancel(){this.clearTempGeometry(),this.tempGeometry=null,this.mirrorLine=null,this.mirrorMode="select_line",this.selectedElementsForMirror.forEach(e=>{e&&this.sketchManager.unhighlightElement&&this.sketchManager.unhighlightElement(e)}),this.selectedElementsForMirror=[],this.sketchManager.elementManager.clearSelection(),this.sketchManager.dimensionManager.hideDimensionInput(),this.sketchManager.editor.showStatus("Отражение отменено","info")}}