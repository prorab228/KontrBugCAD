class EnhancedSketchElementManager extends SketchElementManager{constructor(e,t,n){super(e,t,n),this.elementChangeListeners=[],this.pendingChanges=new Set,this.changeDebounceMs=50,this.enableEdgeSplitting=!0,this.splitThreshold=.01}addElement(e){const t=performance.now();if(!e||!e.type)return;const n=this.getCurrentSketchState(),s=["rectangle","circle","polygon","oval","stadium","arc"].includes(e.type),i=this.createElementGeometry(e,s);if(!i)return;const o=this.createElementMesh(e,i,s);o.userData=this.createEnhancedUserData(e,o,s),this.sketchManager.currentPlane.add(o),e.mesh=o,this.elements.push(e),this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_add",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:n,elements:[{uuid:o.uuid,data:this.serializeSketchElement(o)}]}),this.notifyElementChanged(o),this.snapHelper&&this.snapHelper.updateSnapPoints(),this.contourManager.autoDetectContours&&this.queueContourDetection([o]);const r=performance.now();console.log(`Element added in ${(r-t).toFixed(2)}ms`),this.showSuccessMessage(e.type)}deleteSelectedElements(){if(0===this.selectedElements.length)return void this.sketchManager.editor.showStatus("Нет выделенных элементов для удаления","warning");if(!confirm(`Удалить ${this.selectedElements.length} элементов?`))return;const e=performance.now(),t=this.getCurrentSketchState(),n=[...this.selectedElements],s=n.map(e=>e.mesh);this.sketchManager.editor.history&&this.sketchManager.editor.history.addAction({type:"sketch_delete",sketchPlaneId:this.sketchManager.currentPlane.uuid,previousSketchState:t,elements:n.map(e=>({uuid:e.mesh.uuid,data:this.serializeSketchElement(e.mesh)}))}),n.forEach(e=>{e.mesh&&e.mesh.parent&&(e.mesh.parent.remove(e.mesh),e.mesh.geometry&&e.mesh.geometry.dispose(),e.mesh.material&&e.mesh.material.dispose());const t=this.elements.indexOf(e);t>-1&&this.elements.splice(t,1)}),this.selectedElements=[],this.notifyElementsRemoved(s),this.snapHelper&&this.snapHelper.updateSnapPoints(),this.contourManager.autoDetectContours&&this.queueContourDetection(s);const i=performance.now();console.log(`Elements deleted in ${(i-e).toFixed(2)}ms`),this.sketchManager.editor.showStatus(`Удалено элементов: ${n.length}`,"success")}createEnhancedUserData(e,t,n){const s=super.createElementUserData(e,t,n);if(s.contourDetection={requiresSplitting:this.enableEdgeSplitting,isManifold:n,boundingBox:this.calculateElementBoundingBox(e),edgeCount:this.getElementEdgeCount(e),hash:this.computeElementHash(e)},e.points&&e.points.length>1){s.segments=[];for(let t=0;t<e.points.length-1;t++)s.segments.push({start:e.points[t],end:e.points[t+1],length:e.points[t].distanceTo(e.points[t+1])})}return s}queueContourDetection(e){e.forEach(e=>{this.pendingChanges.add(e)}),clearTimeout(this.contourDetectionTimeout),this.contourDetectionTimeout=setTimeout(()=>{if(this.pendingChanges.size>0){const e=Array.from(this.pendingChanges);this.pendingChanges.clear(),this.contourManager&&this.contourManager.onElementsChanged&&this.contourManager.onElementsChanged(e)}},this.changeDebounceMs)}notifyElementChanged(e){this.elementChangeListeners.forEach(t=>{try{t("added",e)}catch(e){console.error("Error in element change listener:",e)}}),this.queueContourDetection([e])}notifyElementsRemoved(e){this.elementChangeListeners.forEach(t=>{try{t("removed",e)}catch(e){console.error("Error in element change listener:",e)}}),this.queueContourDetection(e)}addChangeListener(e){this.elementChangeListeners.includes(e)||this.elementChangeListeners.push(e)}removeChangeListener(e){const t=this.elementChangeListeners.indexOf(e);t>-1&&this.elementChangeListeners.splice(t,1)}calculateElementBoundingBox(e){const t=e.points||[];if(0===t.length)return null;const n=new THREE.Vector3(1/0,1/0,1/0),s=new THREE.Vector3(-1/0,-1/0,-1/0);return t.forEach(e=>{n.x=Math.min(n.x,e.x),n.y=Math.min(n.y,e.y),n.z=Math.min(n.z,e.z),s.x=Math.max(s.x,e.x),s.y=Math.max(s.y,e.y),s.z=Math.max(s.z,e.z)}),{min:n,max:s}}getElementEdgeCount(e){switch(e.type){case"line":return 1;case"rectangle":return 4;case"circle":return 32;case"polygon":return e.points?e.points.length:0;case"polyline":return e.points?e.points.length-1:0;default:return 0}}computeElementHash(e){let t=e.type||"";e.points&&e.points.forEach(e=>{t+=`${e.x.toFixed(3)}|${e.y.toFixed(3)}|${e.z.toFixed(3)}|`});let n=0;for(let e=0;e<t.length;e++){n=(n<<5)-n+t.charCodeAt(e),n&=n}return n.toString(36)}clear(){super.clear(),this.elementChangeListeners=[],this.pendingChanges.clear(),this.contourDetectionTimeout&&(clearTimeout(this.contourDetectionTimeout),this.contourDetectionTimeout=null)}}