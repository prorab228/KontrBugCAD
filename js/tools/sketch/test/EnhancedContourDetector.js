class EnhancedContourDetector{constructor(){this.vertices=new Map,this.edges=new Map,this.faces=new Map,this.spatialGrid=new SpatialGrid(20),this.elementToEdges=new Map,this.dirtyFaces=new Set,this.cachedContours=new Map,this.mergeThreshold=.01,this.minContourArea=1}updateElements(e,t=!1){return t&&this.edges.size?this.incrementalUpdate(e):this.fullRebuild(e)}fullRebuild(e){if(this.clear(),!e||0===e.length)return[];console.log(`Full rebuild with ${e.length} elements`);const t=this.extractEdgesFromElements(e);if(0===t.length)return console.log("No edges extracted"),[];console.log(`Extracted ${t.length} edges`);const n=this.computeIntersectionsAndSplit(t);console.log(`After splitting: ${n.length} edges`),this.buildTopology(n),console.log(`Built topology: ${this.vertices.size} vertices, ${this.edges.size} edges`);const r=this.findFaces();console.log(`Found ${r.length} faces`);const s=this.filterContours(r);return console.log(`Filtered to ${s.length} contours`),s}extractEdgesFromElements(e){const t=[];for(const n of e){const e=n.uuid,r=[];if(!n.userData||!n.userData.elementType){console.warn("Element missing userData:",n);continue}const s=n.userData;switch(s.elementType){case"line":r.push(...this.extractLineEdges(n));break;case"polyline":r.push(...this.extractPolylineEdges(n));break;case"rectangle":r.push(...this.extractRectangleEdges(n));break;case"circle":r.push(...this.extractCircleEdges(n,32));break;case"arc":r.push(...this.extractArcEdges(n,16));break;case"polygon":r.push(...this.extractPolygonEdges(n));break;case"oval":r.push(...this.extractOvalEdges(n,32));break;case"stadium":r.push(...this.extractStadiumEdges(n,16));break;default:console.warn("Unknown element type:",s.elementType)}if(r.length>0){this.elementToEdges.set(e,new Set);for(const s of r)s.elementId=e,s.element=n,t.push(s)}}return t}extractLineEdges(e){const t=e.userData.localPoints;if(!t||t.length<2)return console.warn("Line element missing points:",e),[];const n=new THREE.Vector2(t[0].x,t[0].y),r=new THREE.Vector2(t[1].x,t[1].y);return[{id:`edge_${e.uuid}_0`,start:n,end:r,element:e,curveType:"line"}]}extractPolylineEdges(e){const t=e.userData.localPoints;if(!t||t.length<2)return console.warn("Polyline element missing points:",e),[];const n=[];for(let r=0;r<t.length-1;r++){const s=new THREE.Vector2(t[r].x,t[r].y),o=new THREE.Vector2(t[r+1].x,t[r+1].y);n.push({id:`edge_${e.uuid}_${r}`,start:s,end:o,element:e,curveType:"line"})}return n}extractRectangleEdges(e){const t=e.userData.localPoints;if(!t||t.length<4)return console.warn("Rectangle element missing points:",e),[];const n=[];for(let r=0;r<4;r++){const s=new THREE.Vector2(t[r].x,t[r].y),o=new THREE.Vector2(t[(r+1)%4].x,t[(r+1)%4].y);n.push({id:`edge_${e.uuid}_${r}`,start:s,end:o,element:e,curveType:"line"})}return n}extractCircleEdges(e,t=32){const n=e.userData;let r,s;if(n.centerLocal)r=new THREE.Vector2(n.centerLocal.x,n.centerLocal.y);else{if(!n.center)return console.warn("Circle element missing center:",e),[];r=new THREE.Vector2(n.center.x,n.center.y)}if(void 0!==n.radius)s=n.radius;else{if(void 0===n.diameter)return console.warn("Circle element missing radius/diameter:",e),[];s=n.diameter/2}const o=[];for(let n=0;n<t;n++){const i=n/t*Math.PI*2,c=(n+1)/t*Math.PI*2,a=new THREE.Vector2(r.x+s*Math.cos(i),r.y+s*Math.sin(i)),l=new THREE.Vector2(r.x+s*Math.cos(c),r.y+s*Math.sin(c));o.push({id:`edge_${e.uuid}_circle_${n}`,start:a,end:l,element:e,curveType:"arc",center:r,radius:s,startAngle:i,endAngle:c})}return o}extractArcEdges(e,t=16){const n=e.userData;if(!n.centerLocal&&!n.center)return console.warn("Arc element missing center:",e),[];if(void 0===n.radius)return console.warn("Arc element missing radius:",e),[];if(void 0===n.startAngle||void 0===n.endAngle)return console.warn("Arc element missing angles:",e),[];const r=n.centerLocal?new THREE.Vector2(n.centerLocal.x,n.centerLocal.y):new THREE.Vector2(n.center.x,n.center.y),s=n.radius;let o=n.startAngle,i=n.endAngle;for(;i<o;)i+=2*Math.PI;const c=i-o,a=[];for(let n=0;n<t;n++){const i=o+n/t*c,l=o+(n+1)/t*c,d=new THREE.Vector2(r.x+s*Math.cos(i),r.y+s*Math.sin(i)),h=new THREE.Vector2(r.x+s*Math.cos(l),r.y+s*Math.sin(l));a.push({id:`edge_${e.uuid}_arc_${n}`,start:d,end:h,element:e,curveType:"arc",center:r,radius:s,startAngle:i,endAngle:l})}return a}extractPolygonEdges(e){const t=e.userData.localPoints;if(!t||t.length<3)return console.warn("Polygon element missing points:",e),[];const n=[],r=t.length;for(let s=0;s<r;s++){const o=new THREE.Vector2(t[s].x,t[s].y),i=new THREE.Vector2(t[(s+1)%r].x,t[(s+1)%r].y);n.push({id:`edge_${e.uuid}_${s}`,start:o,end:i,element:e,curveType:"line"})}return n}extractOvalEdges(e,t=32){const n=e.userData;if(!n.centerLocal&&!n.center)return console.warn("Oval element missing center:",e),[];if(void 0===n.radiusX||void 0===n.radiusY)return console.warn("Oval element missing radii:",e),[];const r=n.centerLocal?new THREE.Vector2(n.centerLocal.x,n.centerLocal.y):new THREE.Vector2(n.center.x,n.center.y),s=n.radiusX,o=n.radiusY,i=[];for(let n=0;n<t;n++){const c=n/t*Math.PI*2,a=(n+1)/t*Math.PI*2,l=new THREE.Vector2(r.x+s*Math.cos(c),r.y+o*Math.sin(c)),d=new THREE.Vector2(r.x+s*Math.cos(a),r.y+o*Math.sin(a));i.push({id:`edge_${e.uuid}_oval_${n}`,start:l,end:d,element:e,curveType:"ellipse",center:r,radiusX:s,radiusY:o,startAngle:c,endAngle:a})}return i}extractStadiumEdges(e,t=8){const n=e.userData;if(!n.centerLocal&&!n.center)return console.warn("Stadium element missing center:",e),[];if(void 0===n.width||void 0===n.height)return console.warn("Stadium element missing dimensions:",e),[];const r=n.centerLocal?new THREE.Vector2(n.centerLocal.x,n.centerLocal.y):new THREE.Vector2(n.center.x,n.center.y),s=n.width,o=n.height,i=Math.min(s,o)/2,c=[];if(s>o){const n=s-o,a=new THREE.Vector2(r.x-n/2,r.y);for(let n=0;n<t;n++){const r=Math.PI/2+n/t*Math.PI,s=Math.PI/2+(n+1)/t*Math.PI,o=new THREE.Vector2(a.x+i*Math.cos(r),a.y+i*Math.sin(r)),l=new THREE.Vector2(a.x+i*Math.cos(s),a.y+i*Math.sin(s));c.push({id:`edge_${e.uuid}_left_arc_${n}`,start:o,end:l,element:e,curveType:"arc",center:a,radius:i,startAngle:r,endAngle:s})}const l=new THREE.Vector2(r.x-n/2,r.y+i),d=new THREE.Vector2(r.x+n/2,r.y+i);c.push({id:`edge_${e.uuid}_top`,start:l,end:d,element:e,curveType:"line"});const h=new THREE.Vector2(r.x+n/2,r.y);for(let n=0;n<t;n++){const r=-Math.PI/2+n/t*Math.PI,s=-Math.PI/2+(n+1)/t*Math.PI,o=new THREE.Vector2(h.x+i*Math.cos(r),h.y+i*Math.sin(r)),a=new THREE.Vector2(h.x+i*Math.cos(s),h.y+i*Math.sin(s));c.push({id:`edge_${e.uuid}_right_arc_${n}`,start:o,end:a,element:e,curveType:"arc",center:h,radius:i,startAngle:r,endAngle:s})}const u=new THREE.Vector2(r.x+n/2,r.y-i),g=new THREE.Vector2(r.x-n/2,r.y-i);c.push({id:`edge_${e.uuid}_bottom`,start:u,end:g,element:e,curveType:"line"})}else{const n=o-s,a=new THREE.Vector2(r.x,r.y+n/2);for(let n=0;n<t;n++){const r=Math.PI+n/t*Math.PI,s=Math.PI+(n+1)/t*Math.PI,o=new THREE.Vector2(a.x+i*Math.cos(r),a.y+i*Math.sin(r)),l=new THREE.Vector2(a.x+i*Math.cos(s),a.y+i*Math.sin(s));c.push({id:`edge_${e.uuid}_top_arc_${n}`,start:o,end:l,element:e,curveType:"arc",center:a,radius:i,startAngle:r,endAngle:s})}const l=new THREE.Vector2(r.x+i,r.y+n/2),d=new THREE.Vector2(r.x+i,r.y-n/2);c.push({id:`edge_${e.uuid}_right`,start:l,end:d,element:e,curveType:"line"});const h=new THREE.Vector2(r.x,r.y-n/2);for(let n=0;n<t;n++){const r=0+n/t*Math.PI,s=0+(n+1)/t*Math.PI,o=new THREE.Vector2(h.x+i*Math.cos(r),h.y+i*Math.sin(r)),a=new THREE.Vector2(h.x+i*Math.cos(s),h.y+i*Math.sin(s));c.push({id:`edge_${e.uuid}_bottom_arc_${n}`,start:o,end:a,element:e,curveType:"arc",center:h,radius:i,startAngle:r,endAngle:s})}const u=new THREE.Vector2(r.x-i,r.y-n/2),g=new THREE.Vector2(r.x-i,r.y+n/2);c.push({id:`edge_${e.uuid}_left`,start:u,end:g,element:e,curveType:"line"})}return c}computeIntersectionsAndSplit(e){return e&&0!==e.length?(console.log(`Computing intersections for ${e.length} edges`),e.map((e,t)=>({...e,id:`${e.id}_seg0`}))):[]}buildTopology(e){this.vertices.clear(),this.edges.clear(),this.faces.clear();for(const t of e){if(!t.start||!t.end)continue;const e=this.getVertexKey(t.start),n=this.getVertexKey(t.end);let r=this.vertices.get(e),s=this.vertices.get(n);r||(r={id:e,point:t.start.clone(),edges:new Set,faces:new Set},this.vertices.set(e,r)),s||(s={id:n,point:t.end.clone(),edges:new Set,faces:new Set},this.vertices.set(n,s));const o=this.getEdgeKey(t.start,t.end),i={id:o,start:r,end:s,elementId:t.elementId,curveType:t.curveType,twin:null,next:null,prev:null,leftFace:null,rightFace:null};this.edges.set(o,i),r.edges.add(i),s.edges.add(i)}console.log(`Built simplified topology: ${this.vertices.size} vertices, ${this.edges.size} edges`)}findFaces(){new Set;return console.log("Face finding not yet implemented"),[]}getVertexKey(e){if(!e)return"0,0";let t,n;if(e instanceof THREE.Vector2)t=e.x,n=e.y;else{if(void 0===e.x||void 0===e.y)return console.error("Invalid point format:",e),"0,0";t=e.x,n=e.y}const r=Math.round(t/this.mergeThreshold)*this.mergeThreshold,s=Math.round(n/this.mergeThreshold)*this.mergeThreshold;return`${r.toFixed(3)},${s.toFixed(3)}`}getEdgeKey(e,t){const n=this.getVertexKey(e),r=this.getVertexKey(t);return n<r?`${n}|${r}`:`${r}|${n}`}getEdgeBoundingBox(e){try{if(!e||!e.start||!e.end)return console.warn("Invalid edge in getEdgeBoundingBox:",e),null;const t=e=>e instanceof THREE.Vector2?e:e.point&&e.point instanceof THREE.Vector2?e.point:void 0!==e.x&&void 0!==e.y?new THREE.Vector2(e.x,e.y):(console.warn("Unknown point format:",e),new THREE.Vector2(0,0)),n=t(e.start),r=t(e.end),s=Math.min(n.x,r.x),o=Math.min(n.y,r.y),i=Math.max(n.x,r.x),c=Math.max(n.y,r.y);return{min:new THREE.Vector2(s,o),max:new THREE.Vector2(i,c)}}catch(t){return console.error("Error in getEdgeBoundingBox:",t,e),null}}calculatePolygonArea(e){if(!e||e.length<3)return 0;let t=0;const n=e.length;for(let r=0;r<n;r++){const s=(r+1)%n;t+=e[r].x*e[s].y,t-=e[s].x*e[r].y}return t/2}calculatePolygonCenter(e){const t=new THREE.Vector2(0,0);return e&&0!==e.length?(e.forEach(e=>{t.x+=e.x,t.y+=e.y}),t.x/=e.length,t.y/=e.length,t):t}calculateBoundingBox(e){const t=new THREE.Vector2(1/0,1/0),n=new THREE.Vector2(-1/0,-1/0);return e&&0!==e.length?(e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),n.x=Math.max(n.x,e.x),n.y=Math.max(n.y,e.y)}),{min:t,max:n}):{min:t,max:n}}isPolygonClockwise(e){return this.calculatePolygonArea(e)<0}filterContours(e){new Map;for(const[e]of this.elementToEdges);return console.log("Filter contours: returning empty array for now"),[]}incrementalUpdate(e){return console.log("Incremental update not implemented, using full rebuild"),this.fullRebuild(e)}clear(){this.vertices.clear(),this.edges.clear(),this.faces.clear(),this.spatialGrid.clear(),this.elementToEdges.clear(),this.dirtyFaces.clear(),this.cachedContours.clear()}getCachedContours(){return Array.from(this.cachedContours.values())}}class SpatialGrid{constructor(e){this.cellSize=e,this.grid=new Map}insert(e,t){if(!t||!t.min||!t.max)return;this.getCellsForBoundingBox(t).forEach(t=>{this.grid.has(t)||this.grid.set(t,new Set),this.grid.get(t).add(e)})}query(e){if(!e||!e.min||!e.max)return[];const t=this.getCellsForBoundingBox(e),n=new Set;return t.forEach(e=>{this.grid.has(e)&&this.grid.get(e).forEach(e=>n.add(e))}),Array.from(n)}getCellsForBoundingBox(e){if(!e||!e.min||!e.max)return[];const t=Math.floor(e.min.x/this.cellSize),n=Math.floor(e.max.x/this.cellSize),r=Math.floor(e.min.y/this.cellSize),s=Math.floor(e.max.y/this.cellSize),o=[];for(let e=t;e<=n;e++)for(let t=r;t<=s;t++)o.push(`${e},${t}`);return o}clear(){this.grid.clear()}}