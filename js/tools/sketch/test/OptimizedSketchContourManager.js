class OptimizedSketchContourManager{constructor(e){this.sketchManager=e,this.detector=new EnhancedContourDetector,this.autoDetectContours=!0,this.contourVisualization=null,this.lastDetectionTime=0,this.detectionDebounceMs=100,this.planeCache=new Map,this.elementCache=new Map,this.enableIncremental=!0,this.enableMultithreading=!1,this.progressiveDetection=!1}detectContours(){if(!this.sketchManager.currentPlane||!this.autoDetectContours)return;const e=Date.now();if(e-this.lastDetectionTime<this.detectionDebounceMs)return;this.lastDetectionTime=e;const t=this.collectElementsOnPlane();if(0===t.length)return void this.clearContours();const n=this.checkForChanges(t),i=this.sketchManager.currentPlane.uuid;if(!n&&this.planeCache.has(i)){const e=this.planeCache.get(i);return this.updateFigureManager(e.contours),void(this.autoDetectContours&&this.visualizeContours(e.contours))}const a=this.enableIncremental?this.detector.updateElements(t,!0):this.detector.fullRebuild(t);a.length>0?this.updateFigureManager(a):this.clearFigureManager(),this.autoDetectContours&&this.visualizeContours(a),this.updateCache(i,t,a)}collectElementsOnPlane(){if(!this.sketchManager.currentPlane)return[];const e=[];return this.sketchManager.currentPlane.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)}),e}checkForChanges(e){let t=!1;const n=new Map;for(const i of e){const e=i.uuid,a=this.computeElementHash(i);n.set(e,a),this.elementCache.has(e)&&this.elementCache.get(e)===a||(t=!0)}for(const[e]of this.elementCache)if(!n.has(e)){t=!0;break}return this.elementCache=n,t}computeElementHash(e){const t=e.userData,n=e.geometry;let i="";if(t.elementType&&(i+=t.elementType),t.localPoints&&t.localPoints.forEach(e=>{i+=`${e.x.toFixed(3)}|${e.y.toFixed(3)}|`}),n&&n.attributes&&n.attributes.position){const e=n.attributes.position.array;for(let t=0;t<Math.min(e.length,10);t++)i+=e[t].toFixed(3)}let a=0;for(let e=0;e<i.length;e++){a=(a<<5)-a+i.charCodeAt(e),a&=a}return a.toString(36)}updateFigureManager(e){const t=this.sketchManager.editor.objectsManager?.figureManager;if(!t)return void console.warn("FigureManager не найден");const n=e.map(e=>({...e,planeId:this.sketchManager.currentPlane.uuid,type:"auto_detected",source:"enhanced_detector"}));t.updateWithAutoContours(n)}clearFigureManager(){const e=this.sketchManager.editor.objectsManager?.figureManager;e&&e.clearAutoContours()}visualizeContours(e){if(this.removeContourVisualization(),0===e.length)return;this.contourVisualization=new THREE.Group,this.contourVisualization.name="enhanced_contour_debug";const t=[new THREE.LineBasicMaterial({color:16711680,linewidth:2}),new THREE.LineBasicMaterial({color:65280,linewidth:2}),new THREE.LineBasicMaterial({color:255,linewidth:2}),new THREE.LineBasicMaterial({color:16776960,linewidth:2}),new THREE.LineBasicMaterial({color:16711935,linewidth:2})];e.forEach((e,n)=>{if(!e.points||e.points.length<3)return;const i=[];e.points.forEach(e=>{i.push(e.x,e.y,.15)});const a=e.points[0];i.push(a.x,a.y,.15);const s=new THREE.BufferGeometry;s.setAttribute("position",new THREE.Float32BufferAttribute(i,3));const o=t[n%t.length],r=new THREE.Line(s,o);if(r.userData.isContourDebug=!0,r.userData.contourId=e.id,r.userData.area=e.area,this.contourVisualization.add(r),e.center){const t=new THREE.CircleGeometry(.5,8),n=new THREE.MeshBasicMaterial({color:o.color,transparent:!0,opacity:.7}),i=new THREE.Mesh(t,n);i.position.set(e.center.x,e.center.y,.2),this.contourVisualization.add(i)}}),this.sketchManager.currentPlane&&this.sketchManager.currentPlane.add(this.contourVisualization)}onElementsChanged(e=[]){if(this.autoDetectContours){if(this.enableIncremental&&e.length>0){const t=this.sketchManager.currentPlane?.uuid;t&&this.planeCache.has(t)&&this.invalidateAffectedContours(e)}clearTimeout(this.detectionTimeout),this.detectionTimeout=setTimeout(()=>{this.detectContours()},this.detectionDebounceMs)}}invalidateAffectedContours(e){const t=new Set(e.map(e=>e.uuid)),n=this.sketchManager.currentPlane.uuid;if(this.planeCache.has(n)){const e=this.planeCache.get(n),i=[];for(const n of e.contours)n.elementIds&&n.elementIds.some(e=>t.has(e))&&i.push(n.id);i.length>0&&(e.contours=e.contours.filter(e=>!i.includes(e.id)),this.planeCache.set(n,e))}}updateCache(e,t,n){if(this.planeCache.set(e,{timestamp:Date.now(),contours:n,elementCount:t.length}),this.planeCache.size>10){const e=Array.from(this.planeCache.keys()).reduce((e,t)=>this.planeCache.get(t).timestamp<this.planeCache.get(e).timestamp?t:e);this.planeCache.delete(e)}}clearContours(){this.removeContourVisualization(),this.clearFigureManager();const e=this.sketchManager.currentPlane?.uuid;e&&this.planeCache.delete(e)}removeContourVisualization(){this.contourVisualization&&this.sketchManager.currentPlane&&(this.sketchManager.currentPlane.remove(this.contourVisualization),this.contourVisualization.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.contourVisualization=null)}forceUpdate(){this.elementCache.clear(),this.detector.clear(),this.detectContours()}clear(){this.removeContourVisualization(),this.detector.clear(),this.planeCache.clear(),this.elementCache.clear(),this.autoDetectContours=!1,this.detectionTimeout&&(clearTimeout(this.detectionTimeout),this.detectionTimeout=null)}getStats(){const e=this.sketchManager.currentPlane?.uuid,t=e&&this.planeCache.has(e)?this.planeCache.get(e):null;return{cacheSize:this.planeCache.size,elementCacheSize:this.elementCache.size,cachedContours:t?t.contours.length:0,detectorStats:{vertices:this.detector.vertices.size,edges:this.detector.edges.size,faces:this.detector.faces.size}}}}