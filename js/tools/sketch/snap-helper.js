class SnapHelper{constructor(e){this.sketchManager=e,this.snapPoints=[],this.snapMarkers=[],this.currentSnapPoint=null,this.isHovering=!1,this.snapTolerance=15,this.snapEnabled=!0,this.colors={endpoint:16711680,midpoint:65280,center:255,intersection:16776960,none:8947848},this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0,this.hoverMarker=null,this.hoverTimeout=null}updateSnapPoints(){if(this.clearSnapPoints(),!this.sketchManager.currentPlane||!this.sketchManager.elements)return;const e=this.sketchManager.elements;e.forEach(e=>{this.addElementSnapPoints(e)}),this.addIntersectionPoints(e)}addElementSnapPoints(e){if(!e.mesh)return;const t=e.mesh.userData;if(!t.localPoints||0===t.localPoints.length)return;const n=this.sketchManager.currentPlane,s=t.localPoints;if(s.forEach((t,s)=>{const i=n.localToWorld(new THREE.Vector3(t.x,t.y,0));this.snapPoints.push({point:i,type:"endpoint",element:e,index:s,screenPos:this.worldToScreen(i)})}),s.length>=2)for(let t=0;t<s.length-1;t++){const i=s[t],a=s[t+1],r=(i.x+a.x)/2,o=(i.y+a.y)/2,h=n.localToWorld(new THREE.Vector3(r,o,0));this.snapPoints.push({point:h,type:"midpoint",element:e,segmentIndex:t,screenPos:this.worldToScreen(h)})}if("circle"===e.type&&e.center&&this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"polygon"!==e.type&&"oval"!==e.type&&"stadium"!==e.type||!e.center||this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"rectangle"===e.type&&e.points&&e.points.length>=4)for(let t=0;t<4;t++){const n=e.points[t];this.snapPoints.push({point:n,type:"endpoint",element:e,isCorner:!0,cornerIndex:t,screenPos:this.worldToScreen(n)})}}addIntersectionPoints(e){const t=e.filter(e=>"line"===e.type||"rectangle"===e.type||"polyline"===e.type&&e.points&&e.points.length>=2);for(let e=0;e<t.length;e++)for(let n=e+1;n<t.length;n++){this.findLineIntersections(t[e],t[n]).forEach(s=>{this.snapPoints.push({point:s,type:"intersection",elements:[t[e],t[n]],screenPos:this.worldToScreen(s)})})}}findLineIntersections(e,t){const n=[];if(!e.points||!t.points)return n;const s=this.getElementSegments(e),i=this.getElementSegments(t);for(const e of s)for(const t of i){const s=this.lineSegmentIntersection(e.start,e.end,t.start,t.end);s&&n.push(s)}return n}getElementSegments(e){const t=[];if("line"===e.type&&e.points&&2===e.points.length)t.push({start:e.points[0],end:e.points[1]});else if("rectangle"===e.type&&e.points&&e.points.length>=4)for(let n=0;n<4;n++)t.push({start:e.points[n],end:e.points[(n+1)%4]});else if("polyline"===e.type&&e.points&&e.points.length>=2)for(let n=0;n<e.points.length-1;n++)t.push({start:e.points[n],end:e.points[n+1]});return t}lineSegmentIntersection(e,t,n,s){const i=new THREE.Vector2(e.x,e.y),a=new THREE.Vector2(t.x,t.y),r=new THREE.Vector2(n.x,n.y),o=new THREE.Vector2(s.x,s.y),h=(o.y-r.y)*(a.x-i.x)-(o.x-r.x)*(a.y-i.y);if(Math.abs(h)<1e-4)return null;const l=((o.x-r.x)*(i.y-r.y)-(o.y-r.y)*(i.x-r.x))/h,c=((a.x-i.x)*(i.y-r.y)-(a.y-i.y)*(i.x-r.x))/h;return l>=0&&l<=1&&c>=0&&c<=1?new THREE.Vector3(e.x+l*(t.x-e.x),e.y+l*(t.y-e.y),e.z+l*(t.z-e.z)):null}updateAllScreenPositions(){this.sketchManager.currentPlane&&0!==this.snapPoints.length&&this.snapPoints.forEach(e=>{e.screenPos=this.worldToScreen(e.point)})}findNearestSnapPoint(e,t){if(!this.snapEnabled||0===this.snapPoints.length)return null;this.updateAllScreenPositions();let n=null,s=1/0;return this.snapPoints.forEach(i=>{if(!i.screenPos)return;const a=i.screenPos.x-e,r=i.screenPos.y-t,o=Math.sqrt(a*a+r*r);o<s&&o<this.snapTolerance&&(s=o,n=i)}),n}worldToScreen(e){const t=e.clone(),n=this.sketchManager.editor.camera;t.project(n);const s=this.sketchManager.editor.renderer.domElement.clientWidth,i=this.sketchManager.editor.renderer.domElement.clientHeight;return{x:(.5*t.x+.5)*s,y:(.5*-t.y+.5)*i}}handleMouseMove(e,t=null){if(!this.snapEnabled||!this.sketchManager.currentPlane)return;const n=this.sketchManager.editor.renderer.domElement.getBoundingClientRect(),s=e.clientX-n.left,i=e.clientY-n.top,a=this.findNearestSnapPoint(s,i);this.currentSnapPoint=a,a?(this.showHoverMarker(a),this.isHovering=!0,t&&this.showSnapLine(t,a.point)):(this.hideHoverMarker(),this.isHovering=!1,this.hideSnapLine());const r=this.sketchManager.currentTool;("line"===r||"polyline"===r)&&this.sketchManager.activeTool&&this.sketchManager.activeTool.isDrawing&&this.sketchManager.activeTool.tempElement&&t?this.showAngleIndicator(t):this.hideAngleIndicator()}showHoverMarker(e){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker?this.updateHoverMarkerPosition(e):this.hoverTimeout=setTimeout(()=>{this.createHoverMarker(e)},5)}createHoverMarker(e){if(!this.sketchManager.currentPlane)return;const t=this.colors[e.type]||this.colors.none,n=this.sketchManager.currentPlane,s=n.worldToLocal(e.point.clone()),i=.4,a=new Float32Array([-.4,-.4,0,i,-.4,0,i,i,0,-.4,i,0,-.4,-.4,0]),r=new THREE.BufferGeometry;r.setAttribute("position",new THREE.BufferAttribute(a,3));const o=new THREE.LineBasicMaterial({color:t,linewidth:2,transparent:!0,opacity:.8});this.hoverMarker=new THREE.Line(r,o),this.hoverMarker.position.set(s.x,s.y,.1),this.hoverMarker.userData.isHoverMarker=!0,n.add(this.hoverMarker)}updateHoverMarkerPosition(e){if(!this.hoverMarker||!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane.worldToLocal(e.point.clone());this.hoverMarker.position.set(t.x,t.y,.1);const n=this.colors[e.type]||this.colors.none;this.hoverMarker.material.color.set(n)}hideHoverMarker(){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker&&(this.hoverMarker.parent&&this.hoverMarker.parent.remove(this.hoverMarker),this.hoverMarker.geometry&&this.hoverMarker.geometry.dispose(),this.hoverMarker.material&&this.hoverMarker.material.dispose(),this.hoverMarker=null)}showSnapLine(e,t){if(this.hideSnapLine(),!this.sketchManager.currentPlane)return;const n=this.sketchManager.currentPlane,s=n.worldToLocal(e.clone()),i=n.worldToLocal(t.clone()),a=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(s.x,s.y,.05),new THREE.Vector3(i.x,i.y,.05)]),r=new THREE.LineDashedMaterial({color:65535,linewidth:1,dashSize:.3,gapSize:.3,transparent:!0,opacity:.6});this.snapLine=new THREE.Line(a,r),this.snapLine.computeLineDistances(),this.snapLine.userData.isSnapLine=!0,n.add(this.snapLine)}hideSnapLine(){this.snapLine&&(this.snapLine.parent&&this.snapLine.parent.remove(this.snapLine),this.snapLine.geometry&&this.snapLine.geometry.dispose(),this.snapLine.material&&this.snapLine.material.dispose(),this.snapLine=null)}isLineAligned(e,t,n=.1){const s=Math.atan2(t,e),i=(THREE.MathUtils.radToDeg(s)%360+360)%360;return Math.abs(i-0)<n||Math.abs(i-180)<n||Math.abs(i-360)<n?{isAligned:!0,type:"horizontal",angle:i}:Math.abs(i-90)<n||Math.abs(i-270)<n?{isAligned:!0,type:"vertical",angle:i}:{isAligned:!1,type:"diagonal",angle:i}}showAngleIndicator(e){const t=this.sketchManager.activeTool;if(!(t&&t.tempElement&&t.tempElement.start&&this.sketchManager.currentPlane))return;const n=t.tempElement.start;let s=e;this.currentSnapPoint&&(s=this.currentSnapPoint.point);const i=this.sketchManager.currentPlane,a=i.worldToLocal(n.clone()),r=i.worldToLocal(s.clone()),o=r.x-a.x,h=r.y-a.y;if(Math.sqrt(o*o+h*h)<1)return void this.hideAngleIndicator();let l=Math.atan2(h,o),c=THREE.MathUtils.radToDeg(l);c<0&&(c+=360);Math.round(c/15);let p=!1;Math.abs(c-0)<1||Math.abs(c-360)<1?(c=0,p=!0):Math.abs(c-90)<1?(c=90,p=!0):Math.abs(c-180)<1?(c=180,p=!0):Math.abs(c-270)<1?(c=270,p=!0):Math.abs(Math.abs(h)-Math.abs(o))<.1*Math.max(Math.abs(o),Math.abs(h))&&(Math.abs(c-45)<1?(c=45,p=!0):Math.abs(c-135)<1?(c=135,p=!0):Math.abs(c-225)<1?(c=225,p=!0):Math.abs(c-315)<1&&(c=315,p=!0)),Math.abs(c-this.lastAngle)>.5&&(this.lastAngle=c,this.hideAngleIndicator(),this.createAngleIndicator(a,r,c,p))}createAngleIndicator(e,t,n,s){if(!this.sketchManager.currentPlane)return;const i=this.sketchManager.currentPlane,a=s?16753920:65280,r=t.x-e.x,o=t.y-e.y,h=Math.sqrt(r*r+o*o),l=Math.min(3,h/5);let c=Math.atan2(o,r);c<0&&(c+=2*Math.PI);const p=c,d=[];for(let t=0;t<=16;t++){const n=0+t/16*p,s=e.x+Math.cos(n)*l,i=e.y+Math.sin(n)*l;d.push(new THREE.Vector3(s,i,.05))}const g=(new THREE.BufferGeometry).setFromPoints(d),u=new THREE.LineBasicMaterial({color:a,linewidth:2,transparent:!0,opacity:.8});this.angleIndicator=new THREE.Line(g,u),this.angleIndicator.userData.isAngleIndicator=!0,this.createAngleLabel(e,c,l,n,s),i.add(this.angleIndicator)}createAngleLabel(e,t,n,s,i){if(!this.sketchManager.currentPlane)return;const a=this.sketchManager.currentPlane,r=1.5*n;let o=t/2;t>Math.PI&&(o=t+(2*Math.PI-t)/2);const h=e.x+Math.cos(o)*r,l=e.y+Math.sin(o)*r,c=document.createElement("canvas"),p=c.getContext("2d");let d;c.width=80,c.height=30,p.clearRect(0,0,c.width,c.height),p.font="bold 14px Arial",p.fillStyle=i?"#FFA500":"#00FF00",p.textAlign="center",p.textBaseline="middle",d=i?Math.abs(s-0)<.1||Math.abs(s-360)<.1?"0° →":Math.abs(s-45)<.1?"45°":Math.abs(s-90)<.1?"90° ↑":Math.abs(s-135)<.1?"135°":Math.abs(s-180)<.1?"180° ←":Math.abs(s-225)<.1?"225°":Math.abs(s-270)<.1?"270° ↓":Math.abs(s-315)<.1?"315°":`${Math.round(s)}°`:`${s.toFixed(1)}°`,p.fillText(d,c.width/2,c.height/2);const g=new THREE.CanvasTexture(c);g.minFilter=THREE.LinearFilter;const u=new THREE.SpriteMaterial({map:g,transparent:!0,opacity:.9});this.angleLabel=new THREE.Sprite(u);const M=a.localToWorld(new THREE.Vector3(h,l,.1)),m=a.worldToLocal(M.clone());this.angleLabel.position.set(m.x,m.y,.1),this.angleLabel.scale.set(6,1.5,1),this.angleLabel.userData.isAngleLabel=!0,a.add(this.angleLabel)}calculateAngleInPlane(e,t,n){const s=n.worldToLocal(e.clone()),i=n.worldToLocal(t.clone()),a=i.x-s.x,r=i.y-s.y;let o=Math.atan2(r,a),h=THREE.MathUtils.radToDeg(o);return h<0&&(h+=360),{degrees:h,radians:o,dx:a,dy:r,localStart:s,localEnd:i}}hideAngleIndicator(){this.angleIndicator&&(this.angleIndicator.parent&&this.angleIndicator.parent.remove(this.angleIndicator),this.angleIndicator.geometry&&this.angleIndicator.geometry.dispose(),this.angleIndicator.material&&this.angleIndicator.material.dispose(),this.angleIndicator=null),this.angleLabel&&(this.angleLabel.parent&&this.angleLabel.parent.remove(this.angleLabel),this.angleLabel.material&&this.angleLabel.material.dispose(),this.angleLabel.material.map&&this.angleLabel.material.map.dispose(),this.angleLabel=null),this.lastAngle=0}getSnappedPoint(e){return this.snapEnabled&&this.currentSnapPoint?this.currentSnapPoint.point:e}getCursorPosition(e){return this.snapEnabled&&this.currentSnapPoint?this.currentSnapPoint.point:e}toggleSnap(){return this.snapEnabled=!this.snapEnabled,this.snapEnabled||(this.hideHoverMarker(),this.hideSnapLine(),this.hideAngleIndicator(),this.currentSnapPoint=null),this.snapEnabled}clearSnapPoints(){this.snapPoints=[],this.hideHoverMarker(),this.hideSnapLine(),this.hideAngleIndicator(),this.currentSnapPoint=null,this.isHovering=!1}clear(){this.clearSnapPoints(),this.snapPoints=[]}}