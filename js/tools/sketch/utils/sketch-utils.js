class SketchUtils{static calculateRectanglePoints(t,o){const e=Math.min(t.x,o.x),n=Math.max(t.x,o.x),c=Math.min(t.y,o.y),s=Math.max(t.y,o.y);return[new THREE.Vector3(e,c,0),new THREE.Vector3(n,c,0),new THREE.Vector3(n,s,0),new THREE.Vector3(e,s,0),new THREE.Vector3(e,c,0)]}static calculateCirclePoints(t,o,e=32){const n=[];for(let c=0;c<=e;c++){const s=c/e*Math.PI*2,a=t.x+Math.cos(s)*o,r=t.y+Math.sin(s)*o;n.push(new THREE.Vector3(a,r,0))}return n}static calculatePolygonPoints(t,o,e){const n=[];for(let c=0;c<=e;c++){const s=c/e*Math.PI*2,a=t.x+Math.cos(s)*o,r=t.y+Math.sin(s)*o;n.push(new THREE.Vector3(a,r,0))}return n}static isContourClosed(t,o=.1){if(t.length<3)return!1;const e=t[0],n=t[t.length-1];return e.distanceTo(n)<o}static lineIntersection(t,o,e,n){const c=(n.y-e.y)*(o.x-t.x)-(n.x-e.x)*(o.y-t.y);if(0===c)return null;const s=((n.x-e.x)*(t.y-e.y)-(n.y-e.y)*(t.x-e.x))/c,a=((o.x-t.x)*(t.y-e.y)-(o.y-t.y)*(t.x-e.x))/c;return s>=0&&s<=1&&a>=0&&a<=1?new THREE.Vector3(t.x+s*(o.x-t.x),t.y+s*(o.y-t.y),0):null}static createTextContours(t,o,e){const n=[],c=.6*o,s=o,a=.1*o;for(let o=0;o<t.length;o++){t[o];const r=e.x+o*(c+a),l=e.y,h=[new THREE.Vector3(r,l,0),new THREE.Vector3(r+c,l,0),new THREE.Vector3(r+c,l+s,0),new THREE.Vector3(r,l+s,0),new THREE.Vector3(r,l,0)];n.push(h)}return n}static calculateOvalPoints(t,o,e,n=32){const c=[];for(let s=0;s<=n;s++){const a=s/n*Math.PI*2,r=t.x+Math.cos(a)*o,l=t.y+Math.sin(a)*e;c.push(new THREE.Vector3(r,l,0))}return c}static calculateStadiumPoints(t,o,e){const n=Math.min(t.x,o.x),c=Math.max(t.x,o.x),s=Math.min(t.y,o.y),a=Math.max(t.y,o.y),r=c-n,l=a-s,h=Math.min(e,r/2,l/2),E=[],i=16;E.push(new THREE.Vector3(n+h,a,0)),E.push(new THREE.Vector3(c-h,a,0));for(let t=0;t<=4;t++){const o=t/i*Math.PI*2,e=c-h+Math.cos(o)*h,n=a-h+Math.sin(o)*h;E.push(new THREE.Vector3(e,n,0))}E.push(new THREE.Vector3(c,s+h,0));for(let t=4;t<=8;t++){const o=t/i*Math.PI*2,e=c-h+Math.cos(o)*h,n=s+h+Math.sin(o)*h;E.push(new THREE.Vector3(e,n,0))}E.push(new THREE.Vector3(c-h,s,0)),E.push(new THREE.Vector3(n+h,s,0));for(let t=8;t<=12;t++){const o=t/i*Math.PI*2,e=n+h+Math.cos(o)*h,c=s+h+Math.sin(o)*h;E.push(new THREE.Vector3(e,c,0))}E.push(new THREE.Vector3(n,a-h,0));for(let t=12;t<=i;t++){const o=t/i*Math.PI*2,e=n+h+Math.cos(o)*h,c=a-h+Math.sin(o)*h;E.push(new THREE.Vector3(e,c,0))}return E.push(new THREE.Vector3(n+h,a,0)),E}static calculateArcPoints(t,o,e,n,c=32){const s=[],a=(n-e)/c;for(let n=0;n<=c;n++){const c=e+n*a,r=t.x+Math.cos(c)*o,l=t.y+Math.sin(c)*o;s.push(new THREE.Vector3(r,l,0))}return s}static worldToLocal(t,o){return o?o.worldToLocal(t.clone()):t.clone()}static localToWorld(t,o){return o?o.localToWorld(t.clone()):t.clone()}static pointsToLocal(t,o){return o?t.map(t=>o.worldToLocal(t.clone())):t.map(t=>t.clone())}static pointsToWorld(t,o){return o?t.map(t=>o.localToWorld(t.clone())):t.map(t=>t.clone())}}