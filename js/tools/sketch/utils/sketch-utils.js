class SketchUtils{static calculateRectanglePoints(t,o,e){if(!t)return[];const n=t.worldToLocal(o.clone()),c=t.worldToLocal(e.clone()),r=Math.min(n.x,c.x),l=Math.max(n.x,c.x),a=Math.min(n.y,c.y),s=Math.max(n.y,c.y);return[new THREE.Vector3(r,a,0),new THREE.Vector3(l,a,0),new THREE.Vector3(l,s,0),new THREE.Vector3(r,s,0),new THREE.Vector3(r,a,0)].map(o=>t.localToWorld(o))}static calculateCirclePoints(t,o,e,n=32){if(!t)return[];const c=t.worldToLocal(o.clone()),r=[];for(let o=0;o<=n;o++){const l=o/n*Math.PI*2,a=c.x+Math.cos(l)*e,s=c.y+Math.sin(l)*e;r.push(t.localToWorld(new THREE.Vector3(a,s,0)))}return r}static calculatePolygonPoints(t,o,e,n){if(!t)return[];const c=t.worldToLocal(o.clone()),r=[];for(let o=0;o<=n;o++){const l=o/n*Math.PI*2,a=c.x+Math.cos(l)*e,s=c.y+Math.sin(l)*e;r.push(t.localToWorld(new THREE.Vector3(a,s,0)))}return r}static isContourClosed(t,o=.1){if(t.length<3)return!1;const e=t[0],n=t[t.length-1];return e.distanceTo(n)<o}static lineIntersection(t,o,e,n){const c=(n.y-e.y)*(o.x-t.x)-(n.x-e.x)*(o.y-t.y);if(0===c)return null;const r=((n.x-e.x)*(t.y-e.y)-(n.y-e.y)*(t.x-e.x))/c,l=((o.x-t.x)*(t.y-e.y)-(o.y-t.y)*(t.x-e.x))/c;return r>=0&&r<=1&&l>=0&&l<=1?new THREE.Vector3(t.x+r*(o.x-t.x),t.y+r*(o.y-t.y),0):null}static createTextContours(t,o,e,n){if(!n)return[];const c=n.worldToLocal(e.clone()),r=[],l=.6*o,a=o,s=.1*o;for(let o=0;o<t.length;o++){t[o];const e=c.x+o*(l+s),E=c.y,i=[new THREE.Vector3(e,E,0),new THREE.Vector3(e+l,E,0),new THREE.Vector3(e+l,E+a,0),new THREE.Vector3(e,E+a,0),new THREE.Vector3(e,E,0)];r.push(i.map(t=>n.localToWorld(t)))}return r}}