class ContourDetector{constructor(){this.segments=[],this.points=[],this.edges=[],this.contours=[]}updateElements(t){this.segments=[],this.points=[],this.edges=[],this.contours=[],t.forEach(t=>{if(!t||!t.userData)return;const e=this.getElementPoints(t);if(!(e.length<2)){for(let n=0;n<e.length-1;n++){const s=e[n],o=e[n+1];s.distanceTo(o)<.001||this.segments.push({element:t,start:s.clone(),end:o.clone(),index:this.segments.length,isClosed:n===e.length-2&&t.userData.isClosed})}if(t.userData.isClosed&&e.length>2){const n=e[e.length-1],s=e[0];this.segments.push({element:t,start:n.clone(),end:s.clone(),index:this.segments.length,isClosed:!0})}}}),console.log(`ContourDetector: найдено ${this.segments.length} сегментов`)}getElementPoints(t){const e=[];if(t.userData.localPoints&&t.userData.localPoints.length>0)t.userData.localPoints.forEach(t=>{e.push(new THREE.Vector2(t.x,t.y))});else if(t.geometry&&t.geometry.attributes.position){const n=t.geometry.attributes.position.array;for(let t=0;t<n.length;t+=3)e.push(new THREE.Vector2(n[t],n[t+1]))}return e}findClosedContours(){return console.log("ContourDetector: поиск замкнутых контуров..."),this.segments.length<3?(console.log("Недостаточно сегментов для поиска контуров"),[]):(this.findIntersections(),this.buildGraph(),this.findAllContours(),console.log(`ContourDetector: найдено ${this.contours.length} контуров`),this.contours.forEach((t,e)=>{console.log(`Контур ${e}: площадь ${t.area}, точек ${t.points.length}`)}),this.contours)}findIntersections(){console.log("Поиск пересечений...");const t=new Map;for(let e=0;e<this.segments.length;e++)t.set(e,[]);for(let e=0;e<this.segments.length;e++)for(let n=e+1;n<this.segments.length;n++){const s=this.getLineIntersection(this.segments[e].start,this.segments[e].end,this.segments[n].start,this.segments[n].end);s&&(t.get(e).push({point:s,distance:this.getDistanceAlongSegment(s,this.segments[e])}),t.get(n).push({point:s,distance:this.getDistanceAlongSegment(s,this.segments[n])}))}this.splitSegmentsAtIntersections(t)}getLineIntersection(t,e,n,s){if(t.equals(n)||t.equals(s)||e.equals(n)||e.equals(s))return null;const o=(s.y-n.y)*(e.x-t.x)-(s.x-n.x)*(e.y-t.y);if(Math.abs(o)<1e-4)return null;const i=((s.x-n.x)*(t.y-n.y)-(s.y-n.y)*(t.x-n.x))/o,r=((e.x-t.x)*(t.y-n.y)-(e.y-t.y)*(t.x-n.x))/o;if(i>=-1e-4&&i<=1.0001&&r>=-1e-4&&r<=1.0001){const n=Math.max(0,Math.min(1,i));return new THREE.Vector2(t.x+n*(e.x-t.x),t.y+n*(e.y-t.y))}return null}getDistanceAlongSegment(t,e){const n=e.end.x-e.start.x,s=e.end.y-e.start.y;return Math.abs(n)>Math.abs(s)?(t.x-e.start.x)/n:(t.y-e.start.y)/s}splitSegmentsAtIntersections(t){const e=[];this.segments.forEach((n,s)=>{const o=t.get(s);if(0===o.length)return void e.push(n);o.sort((t,e)=>t.distance-e.distance);let i=n.start.clone();const r=[i.clone()];o.forEach(t=>{i.distanceTo(t.point)>.001&&(r.push(t.point.clone()),i=t.point.clone())}),i.distanceTo(n.end)>.001&&r.push(n.end.clone());for(let t=0;t<r.length-1;t++)e.push({element:n.element,start:r[t],end:r[t+1],index:e.length,originalIndex:s})}),this.segments=e,console.log(`После разбиения: ${this.segments.length} сегментов`)}buildGraph(){console.log("Построение графа...");const t=new Map,e=t=>`${t.x.toFixed(4)},${t.y.toFixed(4)}`;this.segments.forEach(n=>{const s=e(n.start),o=e(n.end);t.has(s)||t.set(s,{point:n.start.clone(),edges:[]}),t.has(o)||t.set(o,{point:n.end.clone(),edges:[]});const i=t.get(s),r=t.get(o);i.edges.push({to:o,segmentIndex:n.index}),r.edges.push({to:s,segmentIndex:n.index})}),this.points=Array.from(t.values()),console.log(`Граф построен: ${this.points.length} вершин`)}findAllContours(){return console.log("Поиск всех контуров..."),this.contours=[],this.segments.length<3?(console.log("Недостаточно сегментов для поиска контуров"),[]):(this.findIntersections(),this.buildGraph(),this.findContoursSimple(),console.log(`ContourDetector: найдено ${this.contours.length} контуров`),this.contours.forEach((t,e)=>{console.log(`Контур ${e}: площадь ${t.area}, точек ${t.points.length}`)}),this.contours)}findContoursSimple(){if(console.log("Упрощенный поиск контуров..."),!this.points||0===this.points.length)return;const t=[],e=new Set,n=new Set;for(const s of this.points){const o=this.getVertexKey(s.point);if(n.has(o))continue;this.findContoursFromVertexSimple(s,e).forEach(e=>{e.points&&e.points.length>0&&(e.points.forEach(t=>{const e=this.getVertexKey(t);n.add(e)}),t.push(e))})}console.log(`Найдено циклов: ${t.length}`),this.processFoundContours(t)}findContoursFromVertexSimple(t,e){const n=[];if(t.edges.length<2)return n;const s=[],o=this.getVertexKey(t.point);for(s.push({vertex:t,path:[t],edgePath:[],visited:new Set});s.length>0;){const t=s.shift(),i=t.vertex,r=t.path,l=t.edgePath,h=t.visited;for(const t of i.edges){const c=this.getEdgeKey(i.point,t.to);if(h.has(c))continue;if(e.has(c))continue;const a=this.points.find(e=>this.getVertexKey(e.point)===t.to);if(!a)continue;const g=this.getVertexKey(a.point);if(g===o&&r.length>=3){const s=this.createContourFromPath(r,l.concat(t.segmentIndex));if(s&&s.area>.01)return n.push(s),l.forEach(t=>{const n=this.segments[t];if(n){const t=this.getEdgeKey(n.start,n.end);e.add(t)}}),e.add(c),n}if(r.some(t=>this.getVertexKey(t.point)===g))continue;const u=new Set(h);u.add(c),s.push({vertex:a,path:[...r,a],edgePath:[...l,t.segmentIndex],visited:u})}}return n}findContoursFromVertex(t,e){const n=[];if(t.edges.length<2)return n;const s=[[t,null,[t],[],new Set]];for(;s.length>0;){const[e,o,i,r,l]=s.pop();if(i.length>2&&e===t){if(i.length>=3){const t=this.createContourFromPath(i,r);t&&t.area>.01&&n.push(t)}}else if(e===t||!i.includes(e))for(const t of e.edges){const n=this.getEdgeKey(e.point,t.to);if(l.has(n))continue;if(o&&t.to===o)continue;const h=this.points.find(e=>this.getVertexKey(e.point)===t.to);if(!h)continue;const c=[...i,h],a=[...r,t.segmentIndex],g=new Set(l);g.add(n),s.push([h,this.getVertexKey(e.point),c,a,g])}}return n}getContourHashSimple(t){if(!t.points||0===t.points.length)return"";return`${Math.round(100*t.area)/100}|${t.elements?t.elements.map(t=>t.uuid).sort().join(","):""}`}processFoundContours(t){const e=[],n=new Set;t.forEach(t=>{if(!t.isValid||t.points.length<3)return;const s=this.getContourHashSimple(t);n.has(s)||(n.add(s),e.push(t))}),console.log(`Всего уникальных контуров: ${e.length}`);const s=e.filter(t=>{const e=new Set(t.elements.map(t=>t.userData.elementType));return 1===e.size&&e.has("circle")}),o=e.filter(t=>{const e=new Set(t.elements.map(t=>t.userData.elementType));return e.has("circle")&&e.has("line")});console.log(`Контуров только из круга: ${s.length}`),console.log(`Контуров из круга и линии: ${o.length}`);const i=[];o.length>0?(console.log("Есть разрезанные контуры, удаляем целый круг"),e.forEach(t=>{new Set(t.elements.map(t=>t.userData.elementType)).has("line")&&i.push(t)})):i.push(...e);const r=[];for(let t=0;t<i.length;t++){const e=i[t];let n=!1;for(let s=0;s<i.length;s++){if(t===s)continue;const o=i[s],r=new Set(e.elements.map(t=>t.uuid)),l=new Set(o.elements.map(t=>t.uuid));let h=!0;for(const t of r)if(!l.has(t)){h=!1;break}if(h&&l.size>r.size&&o.area>e.area){console.log(`Удаляем контур ${t} (площадь ${e.area}), так как он входит в контур ${s} (площадь ${o.area})`),n=!0;break}}n||r.push(e)}this.contours=r,console.log(`Обработано контуров: ${this.contours.length}`)}createContourFromPath(t,e){if(t.length<3)return null;const n=t.map(t=>t.point.clone());n.push(n[0].clone());const s=this.calculatePolygonArea(n);if(Math.abs(s)<.01)return null;const o=s<0;o&&n.reverse();const i=new Set;return e.forEach(t=>{this.segments[t]&&i.add(this.segments[t].element)}),{elements:Array.from(i),points:n.slice(0,-1),area:Math.abs(s),isClockwise:o,isValid:!0}}calculatePolygonCentroid(t){let e=0,n=0,s=0;const o=t.length;for(let i=0;i<o;i++){const r=(i+1)%o,l=t[i].x*t[r].y-t[r].x*t[i].y;e+=l,n+=(t[i].x+t[r].x)*l,s+=(t[i].y+t[r].y)*l}if(e*=.5,Math.abs(e)<1e-4)return new THREE.Vector2(t[0].x,t[0].y);const i=1/(6*e);return n*=i,s*=i,new THREE.Vector2(n,s)}getContourHash(t){if(!t.points||0===t.points.length)return"";const e=this.calculatePolygonCentroid(t.points),n=t.points.map(t=>({x:Math.round(1e3*(t.x-e.x))/1e3,y:Math.round(1e3*(t.y-e.y))/1e3})),s=n.map(t=>Math.atan2(t.y,t.x)),o=s.indexOf(Math.min(...s)),i=[];for(let t=0;t<n.length;t++){const e=(o+t)%n.length;i.push(n[e])}return`${i.map(t=>`${t.x},${t.y}`).join("|")}|${t.elements?t.elements.map(t=>t.uuid).sort().join(","):""}`}getVertexKey(t){return`${t.x.toFixed(4)},${t.y.toFixed(4)}`}getEdgeKey(t,e){const n=this.getVertexKey(t);return n<e?`${n}-${e}`:`${e}-${n}`}calculatePolygonArea(t){let e=0;const n=t.length;for(let s=0;s<n;s++){const o=(s+1)%n;e+=t[s].x*t[o].y,e-=t[o].x*t[s].y}return e/2}calculateContourCenter(t){const e=new THREE.Vector2(0,0);return t.forEach(t=>{e.x+=t.x,e.y+=t.y}),t.length>0&&(e.x/=t.length,e.y/=t.length),e}clear(){this.segments=[],this.points=[],this.edges=[],this.contours=[]}}