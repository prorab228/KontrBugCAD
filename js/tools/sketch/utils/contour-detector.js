class ContourDetector{constructor(){this.clipperScale=1e5,this.clipper=window.ClipperLib||null,this.segments=[]}updateElements(t){this.segments=[],t.forEach(t=>{const e=this.getElementPoints(t);if(!(e.length<2)){for(let n=0;n<e.length-1;n++)this.segments.push({element:t,start:e[n],end:e[n+1]});t.userData?.isClosed&&e.length>2&&this.segments.push({element:t,start:e[e.length-1],end:e[0]})}}),console.log(`ContourDetector: ${this.segments.length} сегментов`)}getElementPoints(t){return t.userData?"circle"===t.userData.elementType&&t.userData.centerLocal?this.approximateCircle(t.userData.centerLocal,t.userData.radius,64):"arc"===t.userData.elementType&&t.userData.centerLocal?this.approximateArc(t.userData.centerLocal,t.userData.radius,t.userData.startAngle||0,t.userData.endAngle||2*Math.PI,32):t.userData.localPoints?t.userData.localPoints.map(t=>new THREE.Vector2(t.x,t.y)):[]:[]}approximateCircle(t,e,n){const s=[];for(let r=0;r<n;r++){const a=r/n*Math.PI*2;s.push(new THREE.Vector2(t.x+Math.cos(a)*e,t.y+Math.sin(a)*e))}return s}approximateArc(t,e,n,s,r){const a=[],i=s-n;for(let s=0;s<=r;s++){const o=n+s/r*i;a.push(new THREE.Vector2(t.x+Math.cos(o)*e,t.y+Math.sin(o)*e))}return a}findClosedContours(){if(!this.clipper||0===this.segments.length)return[];try{const t=this.segmentsToClipperPaths(),e=new this.clipper.Clipper;e.AddPaths(t,this.clipper.PolyType.ptSubject,!0);const n=new this.clipper.Paths;return e.Execute(this.clipper.ClipType.ctUnion,n,this.clipper.PolyFillType.pftEvenOdd)&&0!==n.length?this.clipperSolutionToContours(n):[]}catch(t){return console.error("Ошибка Clipper:",t),[]}}segmentsToClipperPaths(){const t=[],e=.1/this.clipperScale,n=new Map;return this.segments.forEach(t=>{n.has(t.element)||n.set(t.element,[]),n.get(t.element).push(t)}),n.forEach(n=>{const s=new Map;n.forEach(t=>{const n=this.pointToKey(t.start,e),r=this.pointToKey(t.end,e);s.has(n)||s.set(n,t.start),s.has(r)||s.set(r,t.end)});this.findElementCycles(n,s,e).forEach(n=>{if(n.length<3)return;const s=n.map(t=>({X:Math.round(t.x*this.clipperScale),Y:Math.round(t.y*this.clipperScale)}));this.arePointsEqual(n[0],n[n.length-1],e)||s.push({X:Math.round(n[0].x*this.clipperScale),Y:Math.round(n[0].y*this.clipperScale)}),t.push(s)})}),t}pointToKey(t,e){return`${Math.round(t.x/e)},${Math.round(t.y/e)}`}arePointsEqual(t,e,n){return Math.abs(t.x-e.x)<n&&Math.abs(t.y-e.y)<n}findElementCycles(t,e,n){const s=[],r=new Set;return t.forEach(e=>{if(r.has(e))return;const a=this.findPathBetweenPoints(e.start,e.end,t,r,n);a&&a.length>2&&s.push(a)}),s}findPathBetweenPoints(t,e,n,s,r,a=10){if(a<=0)return null;for(const a of n)if(!s.has(a)){if(this.arePointsEqual(a.start,t,r)&&this.arePointsEqual(a.end,e,r))return s.add(a),[t,e];if(this.arePointsEqual(a.end,t,r)&&this.arePointsEqual(a.start,e,r))return s.add(a),[e,t]}for(const i of n)if(!s.has(i)&&this.arePointsEqual(i.start,t,r)){s.add(i);const o=this.findPathBetweenPoints(i.end,e,n,s,r,a-1);if(o)return[t,...o];s.delete(i)}return null}clipperSolutionToContours(t){const e=[];return t.forEach((t,n)=>{if(t.length<3)return;const s=t.map(t=>({x:t.X/this.clipperScale,y:t.Y/this.clipperScale})),r=[];if(s.forEach(t=>{(0===r.length||this.pointDistance(r[r.length-1],t)>.001)&&r.push(t)}),r.length<3)return;this.pointDistance(r[0],r[r.length-1])>.001&&r.push({x:r[0].x,y:r[0].y});const a=this.calculatePolygonArea(r);if(Math.abs(a)<.01)return;const i=a<0,o=this.findElementsForContour(r);e.push({id:`contour_${n}`,points:r,area:Math.abs(a),isClockwise:i,isClosed:!0,elements:o,type:"auto_detected"})}),e}pointDistance(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}calculatePolygonArea(t){let e=0;const n=t.length;for(let s=0;s<n;s++){const r=(s+1)%n;e+=t[s].x*t[r].y,e-=t[r].x*t[s].y}return e/2}findElementsForContour(t){const e=new Set;return this.segments.forEach(n=>{for(let s=0;s<t.length-1;s++)if(this.isSegmentOnLine({start:n.start,end:n.end},{start:t[s],end:t[s+1]},.5)){e.add(n.element);break}}),Array.from(e)}isSegmentOnLine(t,e,n){return this.pointLineDistance(t.start,e.start,e.end)<n&&this.pointLineDistance(t.end,e.start,e.end)<n}pointLineDistance(t,e,n){const s=t.x-e.x,r=t.y-e.y,a=n.x-e.x,i=n.y-e.y,o=a*a+i*i;let l,h,c=-1;0!==o&&(c=(s*a+r*i)/o),c<0?(l=e.x,h=e.y):c>1?(l=n.x,h=n.y):(l=e.x+c*a,h=e.y+c*i);const p=t.x-l,u=t.y-h;return Math.sqrt(p*p+u*u)}clear(){this.segments=[]}}