class SnapHelper{constructor(e){this.sketchManager=e,this.snapPoints=[],this.snapMarkers=[],this.currentSnapPoint=null,this.isHovering=!1,this.snapTolerance=15,this.snapEnabled=!0,this.edgeSnapEnabled=!0,this.contourSnapEnabled=!0,this.perpendicularSnapEnabled=!0,this.colors={endpoint:16711680,midpoint:65280,center:255,intersection:16776960,perpendicular:16753920,edge:43775,contour:11141375,parallel:16711935,tangent:65535,none:8947848},this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0,this.hoverMarker=null,this.hoverTimeout=null,this.perpendicularGuide=null,this.edgeGuide=null,this.contourGuide=null,this.parallelGuide=null,this.snapLine=null,this.perpendicularActive=!1,this.edgeActive=!1,this.contourActive=!1,this.parallelActive=!1,this.currentPerpendicularSegment=null,this.currentEdgeSegment=null,this.currentContourSegment=null,this.currentParallelSegment=null,this.perpendicularToleranceDegrees=3,this.edgeSnapTolerance=2,this.contourSnapTolerance=2,this.AngleIndicatorFPS=5,this.AngleIndicatorFPSCounter=0,this.cachedSegments=[],this.cachedEdges=[],this.cachedContours=[],this.cachedCircles=[],this.segmentsDirty=!0,this.edgesDirty=!0,this.contoursDirty=!0,this.circlesDirty=!0}initialize(){this.clear()}updateSnapPoints(){if(this.clearSnapPoints(),this.markAllDirty(),!this.sketchManager.currentPlane||!this.sketchManager.elementManager.elements)return;const e=this.sketchManager.elementManager.elements;e.forEach(e=>{this.addElementSnapPoints(e)}),this.addIntersectionPoints(e),this.addEdgePoints(e),this.addContourPoints(),this.addCirclePoints(e)}markAllDirty(){this.segmentsDirty=!0,this.edgesDirty=!0,this.contoursDirty=!0,this.circlesDirty=!0}addElementSnapPoints(e){if(!e.mesh)return;const t=e.mesh.userData;if(!t.localPoints||0===t.localPoints.length)return;const n=this.sketchManager.currentPlane,i=t.localPoints;if(i.forEach((t,i)=>{const r=n.localToWorld(new THREE.Vector3(t.x,t.y,0));this.snapPoints.push({point:r,type:"endpoint",element:e,index:i,screenPos:this.worldToScreen(r)})}),i.length>=2)for(let t=0;t<i.length-1;t++){const r=i[t],s=i[t+1],a=(r.x+s.x)/2,o=(r.y+s.y)/2,l=n.localToWorld(new THREE.Vector3(a,o,0));this.snapPoints.push({point:l,type:"midpoint",element:e,segmentIndex:t,screenPos:this.worldToScreen(l)})}if("circle"===e.type&&e.center&&this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"polygon"!==e.type&&"oval"!==e.type&&"stadium"!==e.type||!e.center||this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"rectangle"===e.type&&e.points&&e.points.length>=4)for(let t=0;t<4;t++){const n=e.points[t];this.snapPoints.push({point:n,type:"endpoint",element:e,isCorner:!0,cornerIndex:t,screenPos:this.worldToScreen(n)})}}addIntersectionPoints(e){const t=e.filter(e=>"line"===e.type||"rectangle"===e.type||"polyline"===e.type&&e.points&&e.points.length>=2);for(let e=0;e<t.length;e++)for(let n=e+1;n<t.length;n++){this.findLineIntersections(t[e],t[n]).forEach(i=>{this.snapPoints.push({point:i,type:"intersection",elements:[t[e],t[n]],screenPos:this.worldToScreen(i)})})}}addEdgePoints(e){if(!this.sketchManager.currentPlane||!this.edgeSnapEnabled)return;const t=this.sketchManager.currentPlane;this.getAllEdges().forEach(e=>{for(let n=1;n<5;n++){const i=n/5,r=e.start.x+i*(e.end.x-e.start.x),s=e.start.y+i*(e.end.y-e.start.y),a=t.localToWorld(new THREE.Vector3(r,s,0));this.snapPoints.push({point:a,type:"edge",element:e.element,segment:e,t:i,screenPos:this.worldToScreen(a)})}})}addContourPoints(){if(!this.sketchManager.currentPlane||!this.contourSnapEnabled)return;const e=this.sketchManager.currentPlane;this.getAllContours().forEach(t=>{for(let n=0;n<=8;n++){const i=n/8,r=t.start.x+i*(t.end.x-t.start.x),s=t.start.y+i*(t.end.y-t.start.y),a=e.localToWorld(new THREE.Vector3(r,s,0));this.snapPoints.push({point:a,type:"contour",element:null,contour:t.contour,t:i,screenPos:this.worldToScreen(a)})}})}addCirclePoints(e){if(!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane;e.filter(e=>"circle"===e.type).forEach(e=>{if(!e.center||!e.radius)return;const n=t.worldToLocal(e.center.clone()),i=e.radius;for(let r=0;r<360;r+=45){const s=THREE.MathUtils.degToRad(r),a=n.x+Math.cos(s)*i,o=n.y+Math.sin(s)*i,l=t.localToWorld(new THREE.Vector3(a,o,0));this.snapPoints.push({point:l,type:"endpoint",element:e,isCirclePoint:!0,angle:r,screenPos:this.worldToScreen(l)})}})}getAllSegments(){if(this.segmentsDirty||0===this.cachedSegments.length){this.cachedSegments=[];(this.sketchManager.elementManager.elements||[]).forEach(e=>{this.getElementSegments(e).forEach(t=>{t.element=e,t.type="segment",this.cachedSegments.push(t)})}),this.segmentsDirty=!1}return this.cachedSegments}getAllEdges(){if(this.edgesDirty||0===this.cachedEdges.length){this.cachedEdges=[];(this.sketchManager.elementManager.elements||[]).forEach(e=>{if("rectangle"===e.type||"polygon"===e.type||"circle"===e.type||"oval"===e.type||"stadium"===e.type){this.getElementSegments(e).forEach(t=>{t.element=e,t.type="edge",this.cachedEdges.push(t)})}}),this.edgesDirty=!1}return this.cachedEdges}getAllContours(){if(this.contoursDirty||0===this.cachedContours.length){if(this.cachedContours=[],this.sketchManager.contourManager&&this.sketchManager.contourManager.contourDetector){(this.sketchManager.contourManager.contourDetector.contours||[]).forEach(e=>{if(e.points&&e.points.length>=2)for(let t=0;t<e.points.length;t++){const n=e.points[t],i=e.points[(t+1)%e.points.length];this.cachedContours.push({start:new THREE.Vector3(n.x,n.y,0),end:new THREE.Vector3(i.x,i.y,0),element:null,type:"contour",contour:e})}})}this.contoursDirty=!1}return this.cachedContours}getElementSegments(e){const t=[];if("line"===e.type&&e.points&&2===e.points.length){const n=this.sketchManager.currentPlane.worldToLocal(e.points[0].clone()),i=this.sketchManager.currentPlane.worldToLocal(e.points[1].clone());t.push({start:new THREE.Vector3(n.x,n.y,0),end:new THREE.Vector3(i.x,i.y,0)})}else if("rectangle"===e.type&&e.points&&e.points.length>=4)for(let n=0;n<4;n++){const i=this.sketchManager.currentPlane.worldToLocal(e.points[n].clone()),r=this.sketchManager.currentPlane.worldToLocal(e.points[(n+1)%4].clone());t.push({start:new THREE.Vector3(i.x,i.y,0),end:new THREE.Vector3(r.x,r.y,0)})}else if("polyline"===e.type&&e.points&&e.points.length>=2)for(let n=0;n<e.points.length-1;n++){const i=this.sketchManager.currentPlane.worldToLocal(e.points[n].clone()),r=this.sketchManager.currentPlane.worldToLocal(e.points[n+1].clone());t.push({start:new THREE.Vector3(i.x,i.y,0),end:new THREE.Vector3(r.x,r.y,0)})}else if("polygon"===e.type&&e.points&&e.points.length>=3)for(let n=0;n<e.points.length;n++){const i=this.sketchManager.currentPlane.worldToLocal(e.points[n].clone()),r=this.sketchManager.currentPlane.worldToLocal(e.points[(n+1)%e.points.length].clone());t.push({start:new THREE.Vector3(i.x,i.y,0),end:new THREE.Vector3(r.x,r.y,0)})}else if("circle"===e.type&&e.center&&e.radius){const n=this.sketchManager.currentPlane.worldToLocal(e.center.clone()),i=e.radius,r=32;for(let e=0;e<r;e++){const s=e/r*Math.PI*2,a=(e+1)/r*Math.PI*2;t.push({start:new THREE.Vector3(n.x+Math.cos(s)*i,n.y+Math.sin(s)*i,0),end:new THREE.Vector3(n.x+Math.cos(a)*i,n.y+Math.sin(a)*i,0),isArc:!0})}}return t}findLineIntersections(e,t){const n=[];if(!e.points||!t.points)return n;const i=this.getElementSegments(e),r=this.getElementSegments(t);for(const e of i)for(const t of r){const i=this.lineSegmentIntersection(e.start,e.end,t.start,t.end);i&&n.push(i)}return n}lineSegmentIntersection(e,t,n,i){const r=new THREE.Vector2(e.x,e.y),s=new THREE.Vector2(t.x,t.y),a=new THREE.Vector2(n.x,n.y),o=new THREE.Vector2(i.x,i.y),l=(o.y-a.y)*(s.x-r.x)-(o.x-a.x)*(s.y-r.y);if(Math.abs(l)<1e-4)return null;const h=((o.x-a.x)*(r.y-a.y)-(o.y-a.y)*(r.x-a.x))/l,c=((s.x-r.x)*(r.y-a.y)-(s.y-r.y)*(r.x-a.x))/l;return h>=0&&h<=1&&c>=0&&c<=1?new THREE.Vector3(e.x+h*(t.x-e.x),e.y+h*(t.y-e.y),e.z+h*(t.z-e.z)):null}handleMouseMove(e,t=null){if(!this.snapEnabled||!this.sketchManager.currentPlane)return;const n=this.sketchManager.editor.renderer.domElement.getBoundingClientRect(),i=e.clientX-n.left,r=e.clientY-n.top,s=this.findNearestSnapPoint(i,r);this.currentSnapPoint=s,t&&this.checkDynamicSnaps(t),s?(this.showHoverMarker(s),this.isHovering=!0,t&&this.showSnapLine(t,s.point)):(this.hideHoverMarker(),this.isHovering=!1,this.hideSnapLine());const a=this.sketchManager.toolManager.currentTool,o=this.sketchManager.toolManager.currentToolName;("line"===o||"polyline"===o)&&a&&a.isDrawing&&a.tempElement&&a.tempElement.start&&t?this.AngleIndicatorFPSCounter>=this.AngleIndicatorFPS?(this.showAngleIndicator(t),this.AngleIndicatorFPSCounter=0):this.AngleIndicatorFPSCounter+=1:(this.hideAngleIndicator(),this.hidePerpendicularGuide(),this.hideEdgeGuide(),this.hideContourGuide(),this.hideParallelGuide())}checkDynamicSnaps(e){const t=this.sketchManager.currentPlane,n=t.worldToLocal(e.clone());this.edgeSnapEnabled&&(this.checkEdgeSnap(n,t),this.edgeActive)||this.contourSnapEnabled&&(this.checkContourSnap(n,t),this.contourActive)||(this.perpendicularSnapEnabled&&this.checkPerpendicularAlignment(n,t),this.checkParallelAlignment(n,t))}checkEdgeSnap(e,t){const n=this.getAllEdges();let i=null,r=1/0,s=null;for(const t of n){const n=this.distanceToSegment(e,t);n.distance<r&&n.distance<this.edgeSnapTolerance&&(r=n.distance,i=t,s=n.point)}if(i&&r<this.edgeSnapTolerance){this.edgeActive=!0,this.currentEdgeSegment=i;const e=t.localToWorld(s);this.showEdgeGuide(i,t),this.adjustToolPoint(e)}else this.edgeActive=!1,this.currentEdgeSegment=null,this.hideEdgeGuide()}checkContourSnap(e,t){const n=this.getAllContours();let i=null,r=1/0,s=null;for(const t of n){const n=this.distanceToSegment(e,t);n.distance<r&&n.distance<this.contourSnapTolerance&&(r=n.distance,i=t,s=n.point)}if(i&&r<this.contourSnapTolerance){this.contourActive=!0,this.currentContourSegment=i;const e=t.localToWorld(s);this.showContourGuide(i,t),this.adjustToolPoint(e)}else this.contourActive=!1,this.currentContourSegment=null,this.hideContourGuide()}checkPerpendicularAlignment(e,t){const n=this.sketchManager.toolManager.currentTool;if(!(n&&n.isDrawing&&n.tempElement&&n.tempElement.start))return;const i=t.worldToLocal(n.tempElement.start.clone()),r=new THREE.Vector2(e.x-i.x,e.y-i.y);if(r.length()<.1)return this.hidePerpendicularGuide(),void(this.perpendicularActive=!1);const s=Math.atan2(r.y,r.x),a=this.getAllSegments();let o=null,l=1/0,h=0;for(const e of a){const t=new THREE.Vector2(e.end.x-e.start.x,e.end.y-e.start.y);if(t.length()<.1)continue;const n=Math.atan2(t.y,t.x),i=n+Math.PI/2,r=n-Math.PI/2,a=this.normalizeAngle(s-i),c=this.normalizeAngle(s-r),d=Math.min(Math.abs(a),Math.abs(c));d<l&&(l=d,o=e,h=Math.abs(a)<Math.abs(c)?i:r)}const c=this.perpendicularToleranceDegrees*Math.PI/180;if(o&&l<c){this.perpendicularActive=!0,this.currentPerpendicularSegment=o,this.showPerpendicularGuide(i,h);const e=r.length(),n=new THREE.Vector2(Math.cos(h)*e,Math.sin(h)*e),s=new THREE.Vector3(i.x+n.x,i.y+n.y,0),a=t.localToWorld(s);this.adjustToolPoint(a)}else this.hidePerpendicularGuide(),this.perpendicularActive=!1,this.currentPerpendicularSegment=null}checkParallelAlignment(e,t){const n=this.sketchManager.toolManager.currentTool;if(!(n&&n.isDrawing&&n.tempElement&&n.tempElement.start))return;const i=t.worldToLocal(n.tempElement.start.clone()),r=new THREE.Vector2(e.x-i.x,e.y-i.y);if(r.length()<.1)return this.hideParallelGuide(),void(this.parallelActive=!1);const s=Math.atan2(r.y,r.x),a=this.getAllSegments();let o=null,l=1/0,h=0;for(const e of a){const t=new THREE.Vector2(e.end.x-e.start.x,e.end.y-e.start.y);if(t.length()<.1)continue;const n=Math.atan2(t.y,t.x),i=Math.abs(this.normalizeAngle(s-n));i<l&&(l=i,o=e,h=n)}const c=this.perpendicularToleranceDegrees*Math.PI/180;if(o&&l<c){this.parallelActive=!0,this.currentParallelSegment=o,this.showParallelGuide(i,h);const e=r.length(),n=new THREE.Vector2(Math.cos(h)*e,Math.sin(h)*e),s=new THREE.Vector3(i.x+n.x,i.y+n.y,0),a=t.localToWorld(s);this.adjustToolPoint(a)}else this.hideParallelGuide(),this.parallelActive=!1,this.currentParallelSegment=null}adjustToolPoint(e){const t=this.sketchManager.toolManager.currentTool;if(t&&t.isDrawing&&t.tempElement&&(t.tempElement.end=e.clone(),t.tempElement.points&&t.tempElement.points.length>1&&(t.tempElement.points[1]=e.clone()),t.updateTempGeometry&&t.updateTempGeometry(),t.updateLineDimensions)){const n=t.tempElement.start;t.updateLineDimensions(n,e)}}distanceToSegment(e,t){const n=new THREE.Vector2(t.start.x,t.start.y),i=new THREE.Vector2(t.end.x,t.end.y),r=new THREE.Vector2(e.x,e.y),s=n.distanceToSquared(i);if(0===s)return{distance:r.distanceTo(n),point:t.start,t:0};const a=Math.max(0,Math.min(1,((r.x-n.x)*(i.x-n.x)+(r.y-n.y)*(i.y-n.y))/s)),o=new THREE.Vector3(n.x+a*(i.x-n.x),n.y+a*(i.y-n.y),0);return{distance:Math.sqrt(r.distanceToSquared(new THREE.Vector2(o.x,o.y))),point:o,t:a}}normalizeAngle(e){for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e}findNearestSnapPoint(e,t){if(!this.snapEnabled||0===this.snapPoints.length)return null;this.updateAllScreenPositions();let n=null,i=1/0;return this.snapPoints.forEach(r=>{if(!r.screenPos)return;const s=r.screenPos.x-e,a=r.screenPos.y-t,o=Math.sqrt(s*s+a*a);o<i&&o<this.snapTolerance&&(i=o,n=r)}),n}updateAllScreenPositions(){this.sketchManager.currentPlane&&0!==this.snapPoints.length&&this.snapPoints.forEach(e=>{e.screenPos=this.worldToScreen(e.point)})}worldToScreen(e){const t=e.clone(),n=this.sketchManager.editor.camera;t.project(n);const i=this.sketchManager.editor.renderer.domElement.clientWidth,r=this.sketchManager.editor.renderer.domElement.clientHeight;return{x:(.5*t.x+.5)*i,y:(.5*-t.y+.5)*r}}showHoverMarker(e){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker?this.updateHoverMarkerPosition(e):this.hoverTimeout=setTimeout(()=>{this.createHoverMarker(e)},5)}createHoverMarker(e){if(!this.sketchManager.currentPlane)return;const t=this.colors[e.type]||this.colors.none,n=this.sketchManager.currentPlane,i=n.worldToLocal(e.point.clone());let r,s,a;switch(e.type){case"edge":r=new THREE.CircleGeometry(.3,8),s=new THREE.MeshBasicMaterial({color:t,transparent:!0,opacity:.8}),a=new THREE.Mesh(r,s),a.userData.tooltip="Край фигуры";break;case"contour":const e=new THREE.Shape;e.moveTo(0,.4),e.lineTo(.4,0),e.lineTo(0,-.4),e.lineTo(-.4,0),e.lineTo(0,.4),r=new THREE.ShapeGeometry(e),s=new THREE.MeshBasicMaterial({color:t,transparent:!0,opacity:.8}),a=new THREE.Mesh(r,s),a.userData.tooltip="Контур";break;case"perpendicular":r=new THREE.ConeGeometry(.4,.8,3),s=new THREE.MeshBasicMaterial({color:t,transparent:!0,opacity:.8}),a=new THREE.Mesh(r,s),a.userData.tooltip="Перпендикуляр";break;default:const n=new Float32Array([-.4,-.4,0,.4,-.4,0,.4,.4,0,-.4,.4,0,-.4,-.4,0]);r=new THREE.BufferGeometry,r.setAttribute("position",new THREE.BufferAttribute(n,3)),s=new THREE.LineBasicMaterial({color:t,linewidth:2,transparent:!0,opacity:.8}),a=new THREE.Line(r,s)}a.position.set(i.x,i.y,.1),a.userData.isHoverMarker=!0,n.add(a),this.hoverMarker=a}updateHoverMarkerPosition(e){if(!this.hoverMarker||!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane.worldToLocal(e.point.clone());this.hoverMarker.position.set(t.x,t.y,.1);const n=this.colors[e.type]||this.colors.none;this.hoverMarker.material&&this.hoverMarker.material.color&&this.hoverMarker.material.color.set(n)}hideHoverMarker(){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker&&(this.hoverMarker.parent&&this.hoverMarker.parent.remove(this.hoverMarker),this.hoverMarker.geometry&&this.hoverMarker.geometry.dispose(),this.hoverMarker.material&&this.hoverMarker.material.dispose(),this.hoverMarker=null)}getCursorPosition(e){if(!this.snapEnabled)return e;if(this.currentSnapPoint)return this.currentSnapPoint.point;if(this.perpendicularActive){const e=this.sketchManager.toolManager.currentTool;if(e&&e.tempElement&&e.tempElement.end)return e.tempElement.end}const t=[{active:this.edgeActive,tool:this.sketchManager.toolManager.currentTool},{active:this.contourActive,tool:this.sketchManager.toolManager.currentTool},{active:this.perpendicularActive,tool:this.sketchManager.toolManager.currentTool},{active:this.parallelActive,tool:this.sketchManager.toolManager.currentTool}];for(const e of t)if(e.active&&e.tool&&e.tool.tempElement&&e.tool.tempElement.end)return e.tool.tempElement.end;return e}showSnapLine(e,t){if(this.hideSnapLine(),!this.sketchManager.currentPlane)return;const n=this.sketchManager.currentPlane,i=n.worldToLocal(e.clone()),r=n.worldToLocal(t.clone()),s=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(i.x,i.y,.05),new THREE.Vector3(r.x,r.y,.05)]),a=new THREE.LineDashedMaterial({color:65535,linewidth:1,dashSize:.3,gapSize:.3,transparent:!0,opacity:.6});this.snapLine=new THREE.Line(s,a),this.snapLine.computeLineDistances(),this.snapLine.userData.isSnapLine=!0,n.add(this.snapLine)}hideSnapLine(){this.snapLine&&(this.snapLine.parent&&this.snapLine.parent.remove(this.snapLine),this.snapLine.geometry&&this.snapLine.geometry.dispose(),this.snapLine.material&&this.snapLine.material.dispose(),this.snapLine=null)}showPerpendicularGuide(e,t){this.hidePerpendicularGuide();const n=this.sketchManager.currentPlane,i=1e3,r=Math.cos(t),s=Math.sin(t),a=new THREE.Vector3(e.x-r*i,e.y-s*i,.05),o=new THREE.Vector3(e.x+r*i,e.y+s*i,.05),l=(new THREE.BufferGeometry).setFromPoints([a,o]),h=new THREE.LineDashedMaterial({color:this.colors.perpendicular,linewidth:1,dashSize:.3,gapSize:.3,transparent:!0,opacity:.6});this.perpendicularGuide=new THREE.Line(l,h),this.perpendicularGuide.computeLineDistances(),this.perpendicularGuide.userData.isPerpendicularGuide=!0,n.add(this.perpendicularGuide)}showEdgeGuide(e,t){this.hideEdgeGuide();const n=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(e.start.x,e.start.y,.05),new THREE.Vector3(e.end.x,e.end.y,.05)]),i=new THREE.LineDashedMaterial({color:this.colors.edge,linewidth:2,dashSize:.2,gapSize:.1,transparent:!0,opacity:.5});this.edgeGuide=new THREE.Line(n,i),this.edgeGuide.computeLineDistances(),this.edgeGuide.userData.isEdgeGuide=!0,t.add(this.edgeGuide)}showContourGuide(e,t){this.hideContourGuide();const n=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(e.start.x,e.start.y,.05),new THREE.Vector3(e.end.x,e.end.y,.05)]),i=new THREE.LineDashedMaterial({color:this.colors.contour,linewidth:2,dashSize:.15,gapSize:.15,transparent:!0,opacity:.4});this.contourGuide=new THREE.Line(n,i),this.contourGuide.computeLineDistances(),this.contourGuide.userData.isContourGuide=!0,t.add(this.contourGuide)}showParallelGuide(e,t){this.hideParallelGuide();const n=this.sketchManager.currentPlane,i=1e3,r=Math.cos(t),s=Math.sin(t),a=new THREE.Vector3(e.x-r*i,e.y-s*i,.05),o=new THREE.Vector3(e.x+r*i,e.y+s*i,.05),l=(new THREE.BufferGeometry).setFromPoints([a,o]),h=new THREE.LineDashedMaterial({color:this.colors.parallel,linewidth:1,dashSize:.2,gapSize:.4,transparent:!0,opacity:.5});this.parallelGuide=new THREE.Line(l,h),this.parallelGuide.computeLineDistances(),this.parallelGuide.userData.isParallelGuide=!0,n.add(this.parallelGuide)}hidePerpendicularGuide(){this.removeGuide(this.perpendicularGuide),this.perpendicularGuide=null}hideEdgeGuide(){this.removeGuide(this.edgeGuide),this.edgeGuide=null}hideContourGuide(){this.removeGuide(this.contourGuide),this.contourGuide=null}hideParallelGuide(){this.removeGuide(this.parallelGuide),this.parallelGuide=null}removeGuide(e){e&&(e.parent&&e.parent.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}showAngleIndicator(e){const t=this.sketchManager.toolManager.currentTool;if(!(t&&t.tempElement&&t.tempElement.start&&this.sketchManager.currentPlane))return;const n=t.tempElement.start;let i=e;this.currentSnapPoint&&(i=this.currentSnapPoint.point);const r=this.sketchManager.currentPlane,s=r.worldToLocal(n.clone()),a=r.worldToLocal(i.clone()),o=a.x-s.x,l=a.y-s.y;if(Math.sqrt(o*o+l*l)<1)return void this.hideAngleIndicator();let h=Math.atan2(l,o),c=THREE.MathUtils.radToDeg(h);c<0&&(c+=360);let d=this.perpendicularActive,u=!1,p=this.parallelActive;Math.abs(c-0)<1||Math.abs(c-360)<1?(c=0,u=!0):Math.abs(c-90)<1?(c=90,u=!0):Math.abs(c-180)<1?(c=180,u=!0):Math.abs(c-270)<1?(c=270,u=!0):Math.abs(Math.abs(l)-Math.abs(o))<.1*Math.max(Math.abs(o),Math.abs(l))&&(Math.abs(c-45)<1?(c=45,u=!0):Math.abs(c-135)<1?(c=135,u=!0):Math.abs(c-225)<1?(c=225,u=!0):Math.abs(c-315)<1&&(c=315,u=!0)),(Math.abs(c-this.lastAngle)>.5||d!==(this.lastIsPerpendicular||!1)||p!==(this.lastIsParallel||!1))&&(this.lastAngle=c,this.lastIsPerpendicular=d,this.lastIsParallel=p,this.hideAngleIndicator(),this.createAngleIndicator(s,a,c,u,d,p))}createAngleIndicator(e,t,n,i,r,s){if(!this.sketchManager.currentPlane)return;const a=this.sketchManager.currentPlane;let o;o=r?this.colors.perpendicular:s?this.colors.parallel:i?65280:7829503;const l=t.x-e.x,h=t.y-e.y,c=Math.sqrt(l*l+h*h),d=Math.min(3,c/5);let u=Math.atan2(h,l);u<0&&(u+=2*Math.PI);const p=u,g=[];for(let t=0;t<=16;t++){const n=0+t/16*p,i=e.x+Math.cos(n)*d,r=e.y+Math.sin(n)*d;g.push(new THREE.Vector3(i,r,.05))}const E=(new THREE.BufferGeometry).setFromPoints(g),m=new THREE.LineBasicMaterial({color:o,linewidth:2,transparent:!0,opacity:.8});this.angleIndicator=new THREE.Line(E,m),this.angleIndicator.userData.isAngleIndicator=!0,this.createAngleLabel(e,u,d,n,i,r,s),a.add(this.angleIndicator)}createAngleLabel(e,t,n,i,r,s,a){if(!this.sketchManager.currentPlane)return;const o=this.sketchManager.currentPlane,l=1.5*n;let h=t/2;t>Math.PI&&(h=t+(2*Math.PI-t)/2);const c=e.x+Math.cos(h)*l,d=e.y+Math.sin(h)*l,u=document.createElement("canvas"),p=u.getContext("2d");let g;u.width=100,u.height=30,p.clearRect(0,0,u.width,u.height),p.font="bold 14px Arial",p.fillStyle=s?"#FFA500":a?"#FF00FF":r?"#00FF00":"#7777FF",p.textAlign="center",p.textBaseline="middle",g=s?`${Math.round(i)}° ⟂`:a?`${Math.round(i)}° ∥`:r?Math.abs(i-0)<.1||Math.abs(i-360)<.1?"0° →":Math.abs(i-45)<.1?"45°":Math.abs(i-90)<.1?"90° ↑":Math.abs(i-135)<.1?"135°":Math.abs(i-180)<.1?"180° ←":Math.abs(i-225)<.1?"225°":Math.abs(i-270)<.1?"270° ↓":Math.abs(i-315)<.1?"315°":`${Math.round(i)}°`:`${i.toFixed(1)}°`,p.fillText(g,u.width/2,u.height/2);const E=new THREE.CanvasTexture(u);E.minFilter=THREE.LinearFilter;const m=new THREE.SpriteMaterial({map:E,transparent:!0,opacity:.9});this.angleLabel=new THREE.Sprite(m);const M=new THREE.Vector3(c,d,.1);this.angleLabel.position.copy(M),this.angleLabel.scale.set(8,2,1),this.angleLabel.userData.isAngleLabel=!0,o.add(this.angleLabel)}hideAngleIndicator(){this.angleIndicator&&(this.removeGuide(this.angleIndicator),this.angleIndicator=null),this.angleLabel&&(this.removeGuide(this.angleLabel),this.angleLabel=null),this.lastAngle=0,this.lastIsPerpendicular=!1,this.lastIsParallel=!1}getSnappedPoint(e,t=null){if(!this.snapEnabled)return e;if(this.currentSnapPoint)return this.currentSnapPoint.point;const n=[{active:this.edgeActive,tool:t},{active:this.contourActive,tool:t},{active:this.perpendicularActive,tool:t},{active:this.parallelActive,tool:t}];for(const e of n)if(e.active&&e.tool&&e.tool.tempElement&&e.tool.tempElement.end)return e.tool.tempElement.end;return e}toggleSnap(){return this.snapEnabled=!this.snapEnabled,this.snapEnabled||this.clearAllVisuals(),this.snapEnabled}toggleEdgeSnap(){return this.edgeSnapEnabled=!this.edgeSnapEnabled,this.edgeSnapEnabled||(this.edgeActive=!1,this.hideEdgeGuide()),this.edgeSnapEnabled}toggleContourSnap(){return this.contourSnapEnabled=!this.contourSnapEnabled,this.contourSnapEnabled||(this.contourActive=!1,this.hideContourGuide()),this.contourSnapEnabled}togglePerpendicularSnap(){return this.perpendicularSnapEnabled=!this.perpendicularSnapEnabled,this.perpendicularSnapEnabled||(this.perpendicularActive=!1,this.hidePerpendicularGuide()),this.perpendicularSnapEnabled}clearSnapPoints(){this.snapPoints=[],this.hideHoverMarker(),this.hideSnapLine(),this.currentSnapPoint=null,this.isHovering=!1}clearAllVisuals(){this.hideHoverMarker(),this.hideSnapLine(),this.hideAngleIndicator(),this.hidePerpendicularGuide(),this.hideEdgeGuide(),this.hideContourGuide(),this.hideParallelGuide(),this.perpendicularActive=!1,this.edgeActive=!1,this.contourActive=!1,this.parallelActive=!1,this.currentPerpendicularSegment=null,this.currentEdgeSegment=null,this.currentContourSegment=null,this.currentParallelSegment=null}clear(){this.clearSnapPoints(),this.clearAllVisuals(),this.snapPoints=[],this.cachedSegments=[],this.cachedEdges=[],this.cachedContours=[],this.cachedCircles=[],this.markAllDirty()}}