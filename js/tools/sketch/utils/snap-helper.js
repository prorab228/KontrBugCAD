class SnapHelper{constructor(e){this.sketchManager=e,this.gridSnapEnabled=!0,this.parallelActive=!1,this.snapPoints=[],this.currentSnapPoint=null,this.isHovering=!1,this.snapTolerance=10,this.snapEnabled=!0,this.angleSnapEnabled=!0,this.lineSnapEnabled=!0,this.colors={endpoint:16711680,midpoint:65280,center:255,intersection:16776960,perpendicular:16753920,none:8947848},this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0,this.hoverMarker=null,this.hoverTimeout=null,this.perpendicularGuide=null,this.snapLine=null,this.lineHighlight=null,this.circleHighlight=null,this.perpendicularActive=!1,this.lineSnapActive=!1,this.circleSnapActive=!1,this.currentSnapSegment=null,this.currentSnapCircle=null,this.perpendicularToleranceDegrees=3,this.lineSnapDistance=.6,this.circleSnapDistance=.6,this.snappedPoint=null,this.AngleIndicatorFPS=5,this.AngleIndicatorFPSCounter=0,this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0}forceUpdate(){this.clear(),this.segmentsDirty=!0,this.circlesDirty=!0,this.updateSnapPoints()}snapToGrid(e){if(!this.gridSnapEnabled||!this.sketchManager.currentPlane)return e;const t=e.clone();let n=this.sketchManager.gridStep;return"inch"===this.sketchManager.editor.gridUnit&&(n*=25.4),t.x=Math.round(t.x/n)*n,t.y=Math.round(t.y/n)*n,t}updateSnapPoints(){if(this.clearSnapPoints(),this.segmentsDirty=!0,this.circlesDirty=!0,!this.sketchManager.currentPlane||!this.sketchManager.elementManager.elements)return;const e=this.sketchManager.elementManager.elements;e.forEach(e=>{this.addElementSnapPoints(e)}),this.addIntersectionPoints(e),console.log("Обновлено точек привязки:",this.snapPoints.length)}addElementSnapPoints(e){if(!e.mesh)return;const t=e.mesh.userData;if(!t.localPoints||0===t.localPoints.length)return;const n=this.sketchManager.currentPlane,i=t.localPoints;if(i.forEach((t,i)=>{this.snapPoints.push({point:t,type:"endpoint",element:e,index:i,screenPos:this.localToScreen(t,n)})}),("line"===e.type||"polyline"===e.type||"dashedline"===e.type)&&i.length>=2)for(let t=0;t<i.length-1;t++){const r=i[t],s=i[t+1],a=(r.x+s.x)/2,l=(r.y+s.y)/2,h=new THREE.Vector3(a,l,0);this.snapPoints.push({point:h,type:"midpoint",element:e,segmentIndex:t,screenPos:this.localToScreen(h,n)})}if("rectangle"===e.type&&i.length>=4)for(let t=0;t<4;t++){const r=i[t],s=i[(t+1)%4],a=(r.x+s.x)/2,l=(r.y+s.y)/2,h=new THREE.Vector3(a,l,0);this.snapPoints.push({point:h,type:"midpoint",element:e,sideIndex:t,screenPos:this.localToScreen(h,n)})}if("polygon"===e.type&&i.length>=3)for(let t=0;t<i.length;t++){const r=i[t],s=i[(t+1)%i.length],a=(r.x+s.x)/2,l=(r.y+s.y)/2,h=new THREE.Vector3(a,l,0);this.snapPoints.push({point:h,type:"midpoint",element:e,sideIndex:t,screenPos:this.localToScreen(h,n)})}if("circle"===e.type){let r=null;if(t.centerLocal)r=this.ensureVector3(t.centerLocal);else if(e.centerLocal)r=this.ensureVector3(e.centerLocal);else if(e.center)r=e.center.clone();else if(i.length>0){r=(new THREE.Box3).setFromPoints(i).getCenter(new THREE.Vector3)}r&&this.snapPoints.push({point:r,type:"center",element:e,screenPos:this.localToScreen(r,n)})}if("polygon"===e.type||"oval"===e.type||"stadium"===e.type){let r=null;if(t.centerLocal)r=this.ensureVector3(t.centerLocal);else if(e.centerLocal)r=this.ensureVector3(e.centerLocal);else if(i.length>0){r=(new THREE.Box3).setFromPoints(i).getCenter(new THREE.Vector3)}r&&this.snapPoints.push({point:r,type:"center",element:e,screenPos:this.localToScreen(r,n)})}if("rectangle"===e.type&&i&&i.length>=4){for(let t=0;t<4;t++){const r=i[t];this.snapPoints.push({point:r,type:"endpoint",element:e,isCorner:!0,cornerIndex:t,screenPos:this.localToScreen(r,n)})}if(i.length>=4){const t=new THREE.Vector3;for(let e=0;e<4;e++)t.add(i[e]);t.divideScalar(4),this.snapPoints.push({point:t,type:"center",element:e,screenPos:this.localToScreen(t,n)})}}}ensureVector3(e){return e.isVector3?e.clone():Array.isArray(e)?new THREE.Vector3(e[0]||0,e[1]||0,e[2]||0):e&&"object"==typeof e?new THREE.Vector3(e.x||0,e.y||0,e.z||0):null}addIntersectionPoints(e){const t=e.filter(e=>"line"===e.type||"rectangle"===e.type||"polyline"===e.type&&e.points&&e.points.length>=2);for(let e=0;e<t.length;e++)for(let n=e+1;n<t.length;n++){this.findLineIntersections(t[e],t[n]).forEach(i=>{this.snapPoints.push({point:i,type:"intersection",elements:[t[e],t[n]],screenPos:this.localToScreen(i,this.sketchManager.currentPlane)})})}}handleMouseMove(e,t=null){if(!this.snapEnabled||!this.sketchManager.currentPlane)return;const n=this.sketchManager.editor.renderer.domElement.getBoundingClientRect(),i=e.clientX-n.left,r=e.clientY-n.top,s=this.findNearestSnapPoint(i,r);if(this.currentSnapPoint=s,this.snappedPoint=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.parallelActive=!1,this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),s)this.snappedPoint=s.point,this.showHoverMarker(s),this.isHovering=!0;else{this.hideHoverMarker(),this.isHovering=!1,this.lineSnapEnabled&&t&&this.checkLineSnap(t),t&&this.checkCircleSnap(t);const e=this.sketchManager.toolManager.currentTool,n=this.sketchManager.toolManager.currentToolName;("line"===n||"polyline"===n||"dashedline"===n)&&e&&e.isDrawing&&e.tempElement&&e.tempElement.start&&t&&this.checkAlignment(e.tempElement.start,t)}!this.snappedPoint&&t&&(this.snappedPoint=t.clone())}checkCircleSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.getAllCircles();if(0===t.length)return;let n=null,i=1/0,r=null;for(const s of t){if(!s.localCenter)continue;const t=s.localCenter,a=s.radius,l=e.distanceTo(t),h=Math.abs(l-a);if(h<i&&h<this.circleSnapDistance)if(i=h,n=s,l>0){const n=e.clone().sub(t).normalize();r=t.clone().add(n.multiplyScalar(a))}else r=t.clone().add(new THREE.Vector3(a,0,0))}if(n&&i<this.circleSnapDistance){this.circleSnapActive=!0,this.currentSnapCircle=n,this.showCircleHighlight(n),this.snappedPoint=r;const e=this.sketchManager.toolManager.currentTool;e&&e.isDrawing&&e.tempElement&&(e.tempElement.end=r.clone(),e.tempElement.points&&e.tempElement.points.length>1&&(e.tempElement.points[1]=r.clone()),e.updateTempGeometry&&e.updateTempGeometry())}}checkLineSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.getAllSegments();if(0===t.length)return;let n=null,i=1/0,r=null;for(const s of t){if(s.isArc)continue;const t=s.localStart,a=s.localEnd,l=this.distanceToSegment(e,{start:t,end:a});l.distance<i&&l.distance<this.lineSnapDistance&&(i=l.distance,n=s,r=l.point)}if(n&&i<this.lineSnapDistance){this.lineSnapActive=!0,this.currentSnapSegment=n,this.showLineHighlight(n);let t=r;this.gridSnapEnabled&&r&&(t=this.snapLinePointToGrid(n,t,e)),this.snappedPoint=t,this.adjustToolPoint(t)}}snapLinePointToGrid(e,t,n){if(!this.gridSnapEnabled)return t;t.clone();const i=e.localStart,r=e.localEnd;let s=this.sketchManager.gridStep;"inch"===this.sketchManager.editor.gridUnit&&(s*=25.4);const a=r.x-i.x,l=r.y-i.y;return Math.abs(a)<.001||Math.abs(l)<.001?this.snapAxisAlignedLineToGrid(e,t,n,s):t}snapAxisAlignedLineToGrid(e,t,n,i){const r=t.clone(),s=e.localStart,a=e.localEnd,l=a.x-s.x,h=a.y-s.y;if(Math.abs(l)<.001){const e=s.x,t=Math.round(e/i)*i;if(Math.abs(t-e)<.1*i){const e=Math.round(r.y/i)*i,n=Math.min(s.y,a.y),l=Math.max(s.y,a.y);if(e>=n&&e<=l)return new THREE.Vector3(t,e,0)}}else if(Math.abs(h)<.001){const e=s.y,t=Math.round(e/i)*i;if(Math.abs(t-e)<.1*i){const e=Math.round(r.x/i)*i,n=Math.min(s.x,a.x),l=Math.max(s.x,a.x);if(e>=n&&e<=l)return new THREE.Vector3(e,t,0)}}return t}showLineHighlight(e){this.hideLineHighlight();const t=this.sketchManager.currentPlane;if(!t)return;const n=e.localStart.clone(),i=e.localEnd.clone(),r=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(n.x,n.y,.05),new THREE.Vector3(i.x,i.y,.05)]),s=new THREE.LineBasicMaterial({color:43775,linewidth:4,transparent:!0,opacity:.6});this.lineHighlight=new THREE.Line(r,s),this.lineHighlight.userData.isLineHighlight=!0,t.add(this.lineHighlight)}hideLineHighlight(){this.lineHighlight&&(this.lineHighlight.parent&&this.lineHighlight.parent.remove(this.lineHighlight),this.lineHighlight.geometry&&this.lineHighlight.geometry.dispose(),this.lineHighlight.material&&this.lineHighlight.material.dispose(),this.lineHighlight=null)}showCircleHighlight(e){if(this.hideCircleHighlight(),!e.localCenter)return;const t=this.sketchManager.currentPlane;if(!t)return;const n=[],i=e.localCenter,r=e.radius;for(let e=0;e<=32;e++){const t=e/32*Math.PI*2,s=i.x+Math.cos(t)*r,a=i.y+Math.sin(t)*r;n.push(new THREE.Vector3(s,a,.05))}const s=(new THREE.BufferGeometry).setFromPoints(n),a=new THREE.LineBasicMaterial({color:43775,linewidth:3,transparent:!0,opacity:.6});this.circleHighlight=new THREE.Line(s,a),this.circleHighlight.userData.isCircleHighlight=!0,t.add(this.circleHighlight)}hideCircleHighlight(){this.circleHighlight&&(this.circleHighlight.parent&&this.circleHighlight.parent.remove(this.circleHighlight),this.circleHighlight.geometry&&this.circleHighlight.geometry.dispose(),this.circleHighlight.material&&this.circleHighlight.material.dispose(),this.circleHighlight=null)}getAllSegments(){if(this.segmentsDirty||0===this.cachedSegments.length){this.cachedSegments=[];const e=this.sketchManager.elementManager.elements||[];if(!this.sketchManager.currentPlane)return[];e.forEach(e=>{this.getElementSegments(e).forEach(t=>{this.cachedSegments.push({element:e,localStart:t.start,localEnd:t.end,isArc:t.isArc||!1})})}),this.segmentsDirty=!1}return this.cachedSegments}getAllCircles(){if(this.circlesDirty||0===this.cachedCircles.length){this.cachedCircles=[];const e=this.sketchManager.elementManager.elements||[];if(!this.sketchManager.currentPlane)return[];e.forEach(e=>{if("circle"===e.type){let t=null,n=null;if(e.mesh&&e.mesh.userData){const i=e.mesh.userData;i.centerLocal&&(t=this.ensureVector3(i.centerLocal)),void 0!==i.radius&&(n=i.radius)}if(!t&&e.centerLocal&&(t=this.ensureVector3(e.centerLocal)),n||void 0===e.radius||(n=e.radius),!t&&e.mesh&&e.mesh.userData&&e.mesh.userData.localPoints){const n=e.mesh.userData.localPoints;if(n.length>0){t=(new THREE.Box3).setFromPoints(n).getCenter(new THREE.Vector3)}}t&&void 0!==n&&this.cachedCircles.push({element:e,localCenter:t,radius:n})}}),this.circlesDirty=!1}return this.cachedCircles}getElementSegments(e){const t=[];if(!e||!e.mesh)return t;const n=e.mesh.userData||{},i=n.elementType||e.type||"unknown",r=n.localPoints||[];if(0===r.length)return t;switch(i.toLowerCase()){case"line":case"dashedline":r.length>=2&&t.push({start:r[0],end:r[1]});break;case"rectangle":if(r.length>=4)for(let e=0;e<4;e++)t.push({start:r[e],end:r[(e+1)%4]});break;case"polyline":for(let e=0;e<r.length-1;e++)t.push({start:r[e],end:r[e+1]});break;case"polygon":if(r.length>=3)for(let e=0;e<r.length;e++)t.push({start:r[e],end:r[(e+1)%r.length]});break;case"circle":if(n.centerLocal&&n.radius){const e=this.ensureVector3(n.centerLocal),i=n.radius,r=16;for(let n=0;n<r;n++){const s=n/r*Math.PI*2,a=(n+1)/r*Math.PI*2;t.push({start:new THREE.Vector3(e.x+Math.cos(s)*i,e.y+Math.sin(s)*i,0),end:new THREE.Vector3(e.x+Math.cos(a)*i,e.y+Math.sin(a)*i,0),isArc:!0})}}}return t}checkAlignment(e,t){if(!this.sketchManager.currentPlane||!this.angleSnapEnabled)return;const n=this.sketchManager.toolManager.currentTool;if(!(n&&n.isDrawing&&n.tempElement&&n.tempElement.start))return;const i=e.clone(),r=t.clone(),s=new THREE.Vector2(r.x-i.x,r.y-i.y);if(s.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const a=this.getAllSegments();if(0===a.length)return;let l=a;this.lineSnapActive&&this.currentSnapSegment&&(l=a.filter(e=>!(e.localStart&&e.localEnd&&this.currentSnapSegment.localStart&&this.currentSnapSegment.localEnd)||!(this.pointsEqual(e.localStart,this.currentSnapSegment.localStart)&&this.pointsEqual(e.localEnd,this.currentSnapSegment.localEnd))));let h=null,o=1/0,c=null;for(const e of l){if(e.isArc)continue;const t=this.distanceToSegment(i,{start:e.localStart,end:e.localEnd});t.distance<o&&t.distance<3*this.lineSnapDistance&&(o=t.distance,h=e,c=t.point)}if(!h||o>=3*this.lineSnapDistance)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const p=Math.atan2(s.y,s.x),d=new THREE.Vector2(h.localEnd.x-h.localStart.x,h.localEnd.y-h.localStart.y);if(d.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const u=Math.atan2(d.y,d.x),g=u+Math.PI/2,m=u-Math.PI/2,E=u,y=u+Math.PI;let P=null,M=1/0,S=null;[{angle:g,type:"perpendicular"},{angle:m,type:"perpendicular"},{angle:E,type:"parallel"},{angle:y,type:"parallel"}].forEach(e=>{const t=Math.abs(this.normalizeAngle(p-e.angle));t<M&&(M=t,P=e.angle,S=e.type)});const f=this.perpendicularToleranceDegrees*Math.PI/180;if(M<f){let e;"perpendicular"===S?(this.perpendicularActive=!0,this.parallelActive=!1,this.showPerpendicularGuide(i,P,"perpendicular")):(this.parallelActive=!0,this.perpendicularActive=!1,this.showPerpendicularGuide(i,P,"parallel"));const t=s.length(),r=new THREE.Vector2(Math.cos(P),Math.sin(P));e=new THREE.Vector3(i.x+r.x*t,i.y+r.y*t,0),this.snappedPoint=e,n.tempElement.end=e.clone(),n.tempElement.points&&n.tempElement.points.length>1&&(n.tempElement.points[1]=e.clone()),n.updateTempGeometry&&n.updateTempGeometry()}else this.hidePerpendicularGuide(),this.perpendicularActive=!1,this.parallelActive=!1}pointsEqual(e,t,n=.001){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n&&Math.abs(e.z-t.z)<n}getSnapPointAtPosition(e){if(!this.snapEnabled||0===this.snapPoints.length)return null;let t=null,n=1/0;return this.snapPoints.forEach(i=>{const r=e.distanceTo(i.point);r<n&&r<.5&&(n=r,t=i)}),t}normalizeAngle(e){for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e}showPerpendicularGuide(e,t,n="perpendicular"){this.hidePerpendicularGuide();const i=this.sketchManager.currentPlane;if(!i)return;const r=1e3,s=Math.cos(t),a=Math.sin(t),l=new THREE.Vector3(e.x-s*r,e.y-a*r,.05),h=new THREE.Vector3(e.x+s*r,e.y+a*r,.05),o=(new THREE.BufferGeometry).setFromPoints([l,h]);let c,p,d;"perpendicular"===n?(c=this.colors.perpendicular,p=.3,d=.3):(c=16711935,p=.5,d=.2);const u=new THREE.LineDashedMaterial({color:c,linewidth:1,dashSize:p,gapSize:d,transparent:!0,opacity:.6});this.perpendicularGuide=new THREE.Line(o,u),this.perpendicularGuide.computeLineDistances(),this.perpendicularGuide.userData.isPerpendicularGuide=!0,this.perpendicularGuide.userData.guideType=n,i.add(this.perpendicularGuide)}hidePerpendicularGuide(){this.perpendicularGuide&&(this.perpendicularGuide.parent&&this.perpendicularGuide.parent.remove(this.perpendicularGuide),this.perpendicularGuide.geometry&&this.perpendicularGuide.geometry.dispose(),this.perpendicularGuide.material&&this.perpendicularGuide.material.dispose(),this.perpendicularGuide=null)}distanceToSegment(e,t){const n=new THREE.Vector2(t.start.x,t.start.y),i=new THREE.Vector2(t.end.x,t.end.y),r=new THREE.Vector2(e.x,e.y),s=n.distanceToSquared(i);if(0===s)return{distance:r.distanceTo(n),point:t.start,t:0};const a=Math.max(0,Math.min(1,((r.x-n.x)*(i.x-n.x)+(r.y-n.y)*(i.y-n.y))/s)),l=new THREE.Vector3(n.x+a*(i.x-n.x),n.y+a*(i.y-n.y),0);return{distance:Math.sqrt(r.distanceToSquared(new THREE.Vector2(l.x,l.y))),point:l,t:a}}findNearestSnapPoint(e,t){if(!this.snapEnabled||0===this.snapPoints.length)return null;this.updateAllScreenPositions();let n=null,i=1/0;return this.snapPoints.forEach(r=>{if(!r.screenPos)return;const s=r.screenPos.x-e,a=r.screenPos.y-t,l=Math.sqrt(s*s+a*a);l<i&&l<this.snapTolerance&&(i=l,n=r)}),n}updateAllScreenPositions(){if(!this.sketchManager.currentPlane||0===this.snapPoints.length)return;const e=this.sketchManager.currentPlane;this.snapPoints.forEach(t=>{t.screenPos=this.localToScreen(t.point,e)})}localToScreen(e,t){const n=t.localToWorld(e.clone()).clone(),i=this.sketchManager.editor.camera;n.project(i);const r=this.sketchManager.editor.renderer.domElement.clientWidth,s=this.sketchManager.editor.renderer.domElement.clientHeight;return{x:(.5*n.x+.5)*r,y:(.5*-n.y+.5)*s}}showHoverMarker(e){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker?this.updateHoverMarkerPosition(e):this.hoverTimeout=setTimeout(()=>{this.createHoverMarker(e)},5)}createHoverMarker(e){if(!this.sketchManager.currentPlane)return;const t=this.colors[e.type]||this.colors.none,n=this.sketchManager.currentPlane,i=e.point.clone(),r=.3,s=new Float32Array([-.3,-.3,0,r,-.3,0,r,r,0,-.3,r,0,-.3,-.3,0]),a=new THREE.BufferGeometry;a.setAttribute("position",new THREE.BufferAttribute(s,3));const l=new THREE.LineBasicMaterial({color:t,linewidth:2,transparent:!0,opacity:.8});this.hoverMarker=new THREE.Line(a,l),this.hoverMarker.position.set(i.x,i.y,.1),this.hoverMarker.userData.isHoverMarker=!0,n.add(this.hoverMarker)}updateHoverMarkerPosition(e){if(!this.hoverMarker||!this.sketchManager.currentPlane)return;this.sketchManager.currentPlane;const t=e.point.clone();this.hoverMarker.position.set(t.x,t.y,.1);const n=this.colors[e.type]||this.colors.none;this.hoverMarker.material.color.set(n)}hideHoverMarker(){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker&&(this.hoverMarker.parent&&this.hoverMarker.parent.remove(this.hoverMarker),this.hoverMarker.geometry&&this.hoverMarker.geometry.dispose(),this.hoverMarker.material&&this.hoverMarker.material.dispose(),this.hoverMarker=null)}adjustToolPoint(e){const t=this.sketchManager.toolManager.currentTool;t&&t.isDrawing&&t.tempElement&&(t.tempElement.end=e.clone(),t.tempElement.points&&t.tempElement.points.length>1&&(t.tempElement.points[1]=e.clone()),t.updateTempGeometry&&t.updateTempGeometry())}getSnappedPoint(e,t=null){return this.snapEnabled&&this.sketchManager.currentPlane?this.snappedPoint&&(this.perpendicularActive||this.parallelActive)?this.snappedPoint:this.currentSnapPoint?(this.snappedPoint=this.currentSnapPoint.point,this.snappedPoint):(this.snappedPoint&&(this.lineSnapActive||this.circleSnapActive)||(this.gridSnapEnabled?this.snappedPoint=this.snapToGrid(e):this.snappedPoint=e),this.snappedPoint):e}getCursorPosition(e){if(!this.snapEnabled)return e;if(this.currentSnapPoint)return this.currentSnapPoint.point;if(this.snappedPoint)return this.snappedPoint;const t=this.sketchManager.toolManager.currentTool;return this.perpendicularActive&&t&&t.tempElement&&t.tempElement.end?t.tempElement.end:e}clear(){this.clearSnapPoints(),this.hideHoverMarker(),this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),this.snapPoints=[],this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0,this.currentSnapPoint=null,this.currentSnapSegment=null,this.currentSnapCircle=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.parallelActive=!1,this.isHovering=!1,this.snappedPoint=null,this.lastAngle=0,this.AngleIndicatorFPSCounter=0}clearSnapPoints(){this.snapPoints=[],this.hideHoverMarker(),this.currentSnapPoint=null,this.isHovering=!1,this.snappedPoint=null}toggleLineSnap(){return this.lineSnapEnabled=!this.lineSnapEnabled,this.lineSnapEnabled||(this.lineSnapActive=!1,this.hideLineHighlight()),this.lineSnapEnabled}findLineIntersections(e,t){const n=[];if(!e.mesh||!t.mesh)return n;const i=this.getElementSegments(e),r=this.getElementSegments(t);for(const e of i)for(const t of r){const i=this.lineSegmentIntersection(e.start,e.end,t.start,t.end);i&&n.push(i)}return n}lineSegmentIntersection(e,t,n,i){const r=new THREE.Vector2(e.x,e.y),s=new THREE.Vector2(t.x,t.y),a=new THREE.Vector2(n.x,n.y),l=new THREE.Vector2(i.x,i.y),h=(l.y-a.y)*(s.x-r.x)-(l.x-a.x)*(s.y-r.y);if(Math.abs(h)<1e-4)return null;const o=((l.x-a.x)*(r.y-a.y)-(l.y-a.y)*(r.x-a.x))/h,c=((s.x-r.x)*(r.y-a.y)-(s.y-r.y)*(r.x-a.x))/h;return o>=0&&o<=1&&c>=0&&c<=1?new THREE.Vector3(e.x+o*(t.x-e.x),e.y+o*(t.y-e.y),0):null}}