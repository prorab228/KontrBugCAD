class SnapHelper{constructor(e){this.sketchManager=e,this.gridSnapEnabled=!0,this.parallelActive=!1,this.snapPoints=[],this.currentSnapPoint=null,this.isHovering=!1,this.snapTolerance=10,this.snapEnabled=!0,this.angleSnapEnabled=!0,this.lineSnapEnabled=!0,this.colors={endpoint:16711680,midpoint:65280,center:255,intersection:16776960,perpendicular:16753920,none:8947848},this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0,this.hoverMarker=null,this.hoverTimeout=null,this.perpendicularGuide=null,this.snapLine=null,this.lineHighlight=null,this.circleHighlight=null,this.perpendicularActive=!1,this.lineSnapActive=!1,this.circleSnapActive=!1,this.currentSnapSegment=null,this.currentSnapCircle=null,this.perpendicularToleranceDegrees=3,this.lineSnapDistance=.6,this.circleSnapDistance=.6,this.snappedPoint=null,this.AngleIndicatorFPS=5,this.AngleIndicatorFPSCounter=0,this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0}forceUpdate(){this.clear(),this.segmentsDirty=!0,this.circlesDirty=!0,this.updateSnapPoints()}snapToGrid(e){if(!this.gridSnapEnabled||!this.sketchManager.currentPlane)return e;const t=this.sketchManager.currentPlane.worldToLocal(e.clone());let n=this.sketchManager.gridStep;return"inch"===this.sketchManager.editor.gridUnit&&(n*=25.4),t.x=Math.round(t.x/n)*n,t.y=Math.round(t.y/n)*n,this.sketchManager.currentPlane.localToWorld(t)}updateSnapPoints(){if(this.clearSnapPoints(),this.segmentsDirty=!0,this.circlesDirty=!0,!this.sketchManager.currentPlane||!this.sketchManager.elementManager.elements)return;const e=this.sketchManager.elementManager.elements;e.forEach(e=>{this.addElementSnapPoints(e)}),this.addIntersectionPoints(e),console.log("snap-helper updateSnapPoints cashe:",this.cachedSegments,this.cachedCircles)}addElementSnapPoints(e){if(!e.mesh)return;const t=e.mesh.userData;if(!t.localPoints||0===t.localPoints.length)return;const n=this.sketchManager.currentPlane,i=t.localPoints;if(i.forEach((t,i)=>{const r=n.localToWorld(new THREE.Vector3(t.x,t.y,0));this.snapPoints.push({point:r,type:"endpoint",element:e,index:i,screenPos:this.worldToScreen(r)})}),("line"===e.type||"polyline"===e.type||"dashed-line"===e.type)&&i.length>=2)for(let t=0;t<i.length-1;t++){const r=i[t],s=i[t+1],l=(r.x+s.x)/2,a=(r.y+s.y)/2,o=n.localToWorld(new THREE.Vector3(l,a,0));this.snapPoints.push({point:o,type:"midpoint",element:e,segmentIndex:t,screenPos:this.worldToScreen(o)})}if("rectangle"===e.type&&i.length>=4)for(let t=0;t<4;t++){const r=i[t],s=i[(t+1)%4],l=(r.x+s.x)/2,a=(r.y+s.y)/2,o=n.localToWorld(new THREE.Vector3(l,a,0));this.snapPoints.push({point:o,type:"midpoint",element:e,sideIndex:t,screenPos:this.worldToScreen(o)})}if("polygon"===e.type&&i.length>=3)for(let t=0;t<i.length;t++){const r=i[t],s=i[(t+1)%i.length],l=(r.x+s.x)/2,a=(r.y+s.y)/2,o=n.localToWorld(new THREE.Vector3(l,a,0));this.snapPoints.push({point:o,type:"midpoint",element:e,sideIndex:t,screenPos:this.worldToScreen(o)})}if("circle"===e.type&&e.center&&this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"polygon"!==e.type&&"oval"!==e.type&&"stadium"!==e.type||!e.center||this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"rectangle"===e.type&&e.points&&e.points.length>=4){for(let t=0;t<4;t++){const n=e.points[t];this.snapPoints.push({point:n,type:"endpoint",element:e,isCorner:!0,cornerIndex:t,screenPos:this.worldToScreen(n)})}const t=new THREE.Vector3;e.points.forEach(e=>t.add(e)),t.divideScalar(4),this.snapPoints.push({point:t,type:"center",element:e,screenPos:this.worldToScreen(t)})}}addIntersectionPoints(e){const t=e.filter(e=>"line"===e.type||"rectangle"===e.type||"polyline"===e.type&&e.points&&e.points.length>=2);for(let e=0;e<t.length;e++)for(let n=e+1;n<t.length;n++){this.findLineIntersections(t[e],t[n]).forEach(i=>{this.snapPoints.push({point:i,type:"intersection",elements:[t[e],t[n]],screenPos:this.worldToScreen(i)})})}}handleMouseMove(e,t=null){if(!this.snapEnabled||!this.sketchManager.currentPlane)return;const n=this.sketchManager.editor.renderer.domElement.getBoundingClientRect(),i=e.clientX-n.left,r=e.clientY-n.top,s=this.findNearestSnapPoint(i,r);if(this.currentSnapPoint=s,this.snappedPoint=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.parallelActive=!1,this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),s)this.snappedPoint=s.point,this.showHoverMarker(s),this.isHovering=!0;else{this.hideHoverMarker(),this.isHovering=!1,this.lineSnapEnabled&&t&&this.checkLineSnap(t),t&&this.checkCircleSnap(t);const e=this.sketchManager.toolManager.currentTool,n=this.sketchManager.toolManager.currentToolName;if(("line"===n||"polyline"===n||"dashedline"===n)&&e&&e.isDrawing&&e.tempElement&&e.tempElement.start&&t){let n=t;this.snappedPoint&&(n=this.snappedPoint),this.checkAlignment(e.tempElement.start,n)}}}checkCircleSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane,n=t.worldToLocal(e.clone()),i=this.getAllCircles();let r=null,s=1/0,l=null;for(const e of i){const i=t.worldToLocal(e.center.clone()),a=new THREE.Vector2(i.x,i.y),o=new THREE.Vector2(n.x,n.y),c=a.distanceTo(o),h=Math.abs(c-e.radius);if(h<s&&h<this.circleSnapDistance)if(s=h,r=e,c>0){const n=e.radius/c,i=new THREE.Vector3(a.x+(o.x-a.x)*n,a.y+(o.y-a.y)*n,0);l=t.localToWorld(i)}else{const n=new THREE.Vector3(a.x+e.radius,a.y,0);l=t.localToWorld(n)}}if(r&&s<this.circleSnapDistance){this.circleSnapActive=!0,this.currentSnapCircle=r,this.showCircleHighlight(r,t),this.snappedPoint=l;const e=this.sketchManager.toolManager.currentTool;e&&e.isDrawing&&e.tempElement&&(e.tempElement.end=l.clone(),e.tempElement.points&&e.tempElement.points.length>1&&(e.tempElement.points[1]=l.clone()),e.updateTempGeometry&&e.updateTempGeometry())}}checkLineSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane,n=t.worldToLocal(e.clone()),i=this.getAllSegments();let r=null,s=1/0,l=null,a=null;for(const e of i){if(e.isArc)continue;const i=this.distanceToSegment(n,{start:e.localStart,end:e.localEnd});i.distance<s&&i.distance<this.lineSnapDistance&&(s=i.distance,r=e,a=i.point,l=t.localToWorld(i.point))}if(r&&s<this.lineSnapDistance){this.lineSnapActive=!0,this.currentSnapSegment=r,this.showLineHighlight(r,t);let e=l;this.gridSnapEnabled&&a&&(e=this.snapLinePointToGrid(r,e,t,n)),this.snappedPoint=e,this.adjustToolPoint(e)}}snapLinePointToGrid(e,t,n,i){if(!this.gridSnapEnabled)return t;n.worldToLocal(t.clone());const r=n.worldToLocal(e.start.clone()),s=n.worldToLocal(e.end.clone());let l=this.sketchManager.gridStep;"inch"===this.sketchManager.editor.gridUnit&&(l*=25.4);const a=s.x-r.x,o=s.y-r.y;return Math.abs(a)<.001||Math.abs(o)<.001?this.snapAxisAlignedLineToGrid(e,t,n,l):this.snapDiagonalLineToGrid(e,t,n,i,l)}snapAxisAlignedLineToGrid(e,t,n,i){const r=n.worldToLocal(t.clone()),s=n.worldToLocal(e.start.clone()),l=n.worldToLocal(e.end.clone()),a=l.x-s.x,o=l.y-s.y;if(Math.abs(a)<.001){const e=s.x,t=Math.round(e/i)*i;if(Math.abs(t-e)<.1*i){const e=Math.round(r.y/i)*i,a=Math.min(s.y,l.y),o=Math.max(s.y,l.y);if(e>=a&&e<=o)return n.localToWorld(new THREE.Vector3(t,e,0))}}else if(Math.abs(o)<.001){const e=s.y,t=Math.round(e/i)*i;if(Math.abs(t-e)<.1*i){const e=Math.round(r.x/i)*i,a=Math.min(s.x,l.x),o=Math.max(s.x,l.x);if(e>=a&&e<=o)return n.localToWorld(new THREE.Vector3(e,t,0))}}return t}snapDiagonalLineToGrid(e,t,n,i,r){const s=n.worldToLocal(t.clone()),l=n.worldToLocal(e.start.clone()),a=n.worldToLocal(e.end.clone()),o=a.x-l.x,c=(a.y-l.y)/o,h=l.y-c*l.x,p=(s.x,l.x,Math.round(s.x/r)),d=Math.round(s.y/r);let u=null,g=1/0;for(let e=-1;e<=1;e++)for(let t=-1;t<=1;t++){const n=(p+e)*r,s=(d+t)*r;if(Math.abs(c*n-s+h)/Math.sqrt(c*c+1)<.1*r){const e=(n-l.x)/o;if(e>=0&&e<=1){const e=Math.sqrt(Math.pow(n-i.x,2)+Math.pow(s-i.y,2));e<g&&(g=e,u=new THREE.Vector3(n,s,0))}}}return u&&g<1.5*r?n.localToWorld(u):t}showLineHighlight(e,t){this.hideLineHighlight();const n=e.localStart.clone(),i=e.localEnd.clone(),r=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(n.x,n.y,.05),new THREE.Vector3(i.x,i.y,.05)]),s=new THREE.LineBasicMaterial({color:43775,linewidth:10,transparent:!0,opacity:.6});this.lineHighlight=new THREE.Line(r,s),this.lineHighlight.userData.isLineHighlight=!0,t.add(this.lineHighlight)}hideLineHighlight(){this.lineHighlight&&(this.lineHighlight.parent&&this.lineHighlight.parent.remove(this.lineHighlight),this.lineHighlight.geometry&&this.lineHighlight.geometry.dispose(),this.lineHighlight.material&&this.lineHighlight.material.dispose(),this.lineHighlight=null)}showCircleHighlight(e,t){if(this.hideCircleHighlight(),!e.localCenter)return;const n=[],i=e.localCenter,r=e.radius;for(let e=0;e<=32;e++){const t=e/32*Math.PI*2,s=i.x+Math.cos(t)*r,l=i.y+Math.sin(t)*r;n.push(new THREE.Vector3(s,l,.05))}const s=(new THREE.BufferGeometry).setFromPoints(n),l=new THREE.LineBasicMaterial({color:43775,linewidth:3,transparent:!0,opacity:.6});this.circleHighlight=new THREE.Line(s,l),this.circleHighlight.userData.isCircleHighlight=!0,t.add(this.circleHighlight)}hideCircleHighlight(){this.circleHighlight&&(this.circleHighlight.parent&&this.circleHighlight.parent.remove(this.circleHighlight),this.circleHighlight.geometry&&this.circleHighlight.geometry.dispose(),this.circleHighlight.material&&this.circleHighlight.material.dispose(),this.circleHighlight=null)}getAllSegments(){if(this.segmentsDirty||0===this.cachedSegments.length){this.cachedSegments=[];const e=this.sketchManager.elementManager.elements||[],t=this.sketchManager.currentPlane;if(!t)return[];e.forEach(e=>{this.getElementSegments(e).forEach(n=>{const i=t.localToWorld(n.start.clone()),r=t.localToWorld(n.end.clone());this.cachedSegments.push({start:i,end:r,element:e,localStart:n.start,localEnd:n.end,isArc:n.isArc||!1})})}),this.segmentsDirty=!1}return this.cachedSegments}getAllCircles(){if(this.circlesDirty||0===this.cachedCircles.length){this.cachedCircles=[];const e=this.sketchManager.elementManager.elements||[],t=this.sketchManager.currentPlane;if(!t)return[];e.forEach(e=>{if("circle"===e.type){let n=null,i=null;if(e.mesh&&e.mesh.userData&&e.mesh.userData.centerLocal){const t=e.mesh.userData;n=this.ensureVector3(t.centerLocal),i=t.radius}!n&&e.centerLocal&&(n=this.ensureVector3(e.centerLocal)),!n&&e.center&&(n=t.worldToLocal(e.center.clone())),i||void 0===e.radius||(i=e.radius),n&&void 0!==i&&this.cachedCircles.push({element:e,center:t.localToWorld(n.clone()),localCenter:n,radius:i})}}),this.circlesDirty=!1}return this.cachedCircles}ensureVector3(e){return e.isVector3?e.clone():Array.isArray(e)?new THREE.Vector3(e[0]||0,e[1]||0,e[2]||0):e&&"object"==typeof e?new THREE.Vector3(e.x||0,e.y||0,e.z||0):null}getElementSegments(e){const t=[];if(!e||!e.mesh)return t;const n=e.mesh.userData||{},i=n.elementType||e.type||"unknown";let r=n.localPoints||[];if(0===r.length)return console.warn("No local points found for element:",i,e),t;if(!this.sketchManager.currentPlane)return t;const s=r.map(e=>e.isVector3?new THREE.Vector3(e.x,e.y,0):new THREE.Vector3(e.x||0,e.y||0,0));switch(i.toLowerCase()){case"line":case"dashed-line":s.length>=2&&t.push({start:s[0],end:s[1]});break;case"rectangle":if(s.length>=4)for(let e=0;e<4;e++)t.push({start:s[e],end:s[(e+1)%4]});break;case"polyline":for(let e=0;e<s.length-1;e++)t.push({start:s[e],end:s[e+1]});break;case"polygon":if(s.length>=3)for(let e=0;e<s.length;e++)t.push({start:s[e],end:s[(e+1)%s.length]});break;case"circle":if(n.center&&n.radius){const e=n.centerLocal||new THREE.Vector3(0,0,0),i=n.radius,r=32;for(let n=0;n<r;n++){const s=n/r*Math.PI*2,l=(n+1)/r*Math.PI*2;t.push({start:new THREE.Vector3(e.x+Math.cos(s)*i,e.y+Math.sin(s)*i,0),end:new THREE.Vector3(e.x+Math.cos(l)*i,e.y+Math.sin(l)*i,0),isArc:!0})}}}return t}extractPointsFromGeometry(e){const t=[];if(e.attributes&&e.attributes.position){const n=e.attributes.position.array;for(let e=0;e<n.length;e+=3)t.push(new THREE.Vector3(n[e],n[e+1],n[e+2]))}return t}checkAlignment(e,t){if(!this.sketchManager.currentPlane)return;const n=this.sketchManager.toolManager.currentTool;if(!(n&&n.isDrawing&&n.tempElement&&n.tempElement.start))return;const i=this.sketchManager.currentPlane,r=i.worldToLocal(e.clone()),s=i.worldToLocal(t.clone()),l=this.getAllSegments();let a=l;this.lineSnapActive&&this.currentSnapSegment&&(a=l.filter(e=>!(e.localStart&&e.localEnd&&this.currentSnapSegment.localStart&&this.currentSnapSegment.localEnd)||!(e.localStart.equals(this.currentSnapSegment.localStart)&&e.localEnd.equals(this.currentSnapSegment.localEnd))));let o=null,c=1/0,h=null,p=null;for(const e of a){if(e.isArc)continue;const t=this.distanceToSegment(r,{start:e.localStart,end:e.localEnd});t.distance<c&&t.distance<2*this.lineSnapDistance&&(c=t.distance,o=e,p=t.point,h=i.localToWorld(t.point))}if(!o||c>=2*this.lineSnapDistance)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const d=new THREE.Vector2(s.x-r.x,s.y-r.y);if(d.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const u=Math.atan2(d.y,d.x),g=new THREE.Vector2(o.localEnd.x-o.localStart.x,o.localEnd.y-o.localStart.y);if(g.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const m=Math.atan2(g.y,g.x),E=m+Math.PI/2,y=m-Math.PI/2,T=m,M=m+Math.PI;let S=null,P=1/0,f=null;[{angle:E,type:"perpendicular"},{angle:y,type:"perpendicular"},{angle:T,type:"parallel"},{angle:M,type:"parallel"}].forEach(e=>{const t=Math.abs(this.normalizeAngle(u-e.angle));t<P&&(P=t,S=e.angle,f=e.type)});const H=this.perpendicularToleranceDegrees*Math.PI/180;if(P<H){let e;if("perpendicular"===f?(this.perpendicularActive=!0,this.parallelActive=!1,this.showPerpendicularGuide(r,S,"perpendicular")):(this.parallelActive=!0,this.perpendicularActive=!1,this.showPerpendicularGuide(r,S,"parallel")),this.lineSnapActive&&this.snappedPoint){e=this.snappedPoint.clone();const t=i.worldToLocal(this.snappedPoint.clone()),n=new THREE.Vector2(Math.cos(S),Math.sin(S)),s=new THREE.Vector2(t.x-r.x,t.y-r.y).dot(n),l=new THREE.Vector3(r.x+n.x*s,r.y+n.y*s,0);if(this.currentSnapSegment){const t=this.distanceToSegment(l,{start:this.currentSnapSegment.localStart,end:this.currentSnapSegment.localEnd});t.distance<this.lineSnapDistance&&(e=i.localToWorld(t.point))}}else{const t=d.length(),n=new THREE.Vector2(Math.cos(S)*t,Math.sin(S)*t),s=new THREE.Vector3(r.x+n.x,r.y+n.y,0);e=i.localToWorld(s)}this.snappedPoint=e,n.tempElement.end=e.clone(),n.tempElement.points&&n.tempElement.points.length>1&&(n.tempElement.points[1]=e.clone()),n.updateTempGeometry&&n.updateTempGeometry()}else this.hidePerpendicularGuide(),this.perpendicularActive=!1,this.parallelActive=!1}getSnapPointAtPosition(e){if(!this.snapEnabled||0===this.snapPoints.length)return null;const t=this.worldToScreen(e);let n=null,i=1/0;return this.snapPoints.forEach(e=>{if(!e.screenPos)return;const r=e.screenPos.x-t.x,s=e.screenPos.y-t.y,l=Math.sqrt(r*r+s*s);l<i&&l<this.snapTolerance&&(i=l,n=e)}),n}normalizeAngle(e){for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e}showPerpendicularGuide(e,t,n="perpendicular"){this.hidePerpendicularGuide();const i=this.sketchManager.currentPlane,r=1e3,s=Math.cos(t),l=Math.sin(t),a=new THREE.Vector3(e.x-s*r,e.y-l*r,.05),o=new THREE.Vector3(e.x+s*r,e.y+l*r,.05),c=(new THREE.BufferGeometry).setFromPoints([a,o]);let h,p,d;"perpendicular"===n?(h=this.colors.perpendicular,p=.3,d=.3):(h=16711935,p=.5,d=.2);const u=new THREE.LineDashedMaterial({color:h,linewidth:1,dashSize:p,gapSize:d,transparent:!0,opacity:.6});this.perpendicularGuide=new THREE.Line(c,u),this.perpendicularGuide.computeLineDistances(),this.perpendicularGuide.userData.isPerpendicularGuide=!0,this.perpendicularGuide.userData.guideType=n,i.add(this.perpendicularGuide)}hidePerpendicularGuide(){this.perpendicularGuide&&(this.perpendicularGuide.parent&&this.perpendicularGuide.parent.remove(this.perpendicularGuide),this.perpendicularGuide.geometry&&this.perpendicularGuide.geometry.dispose(),this.perpendicularGuide.material&&this.perpendicularGuide.material.dispose(),this.perpendicularGuide=null)}distanceToSegment(e,t){const n=new THREE.Vector2(t.start.x,t.start.y),i=new THREE.Vector2(t.end.x,t.end.y),r=new THREE.Vector2(e.x,e.y),s=n.distanceToSquared(i);if(0===s)return{distance:r.distanceTo(n),point:t.start,t:0};const l=Math.max(0,Math.min(1,((r.x-n.x)*(i.x-n.x)+(r.y-n.y)*(i.y-n.y))/s)),a=new THREE.Vector3(n.x+l*(i.x-n.x),n.y+l*(i.y-n.y),0);return{distance:Math.sqrt(r.distanceToSquared(new THREE.Vector2(a.x,a.y))),point:a,t:l}}findNearestSnapPoint(e,t){if(!this.snapEnabled||0===this.snapPoints.length)return null;this.updateAllScreenPositions();let n=null,i=1/0;return this.snapPoints.forEach(r=>{if(!r.screenPos)return;const s=r.screenPos.x-e,l=r.screenPos.y-t,a=Math.sqrt(s*s+l*l);a<i&&a<this.snapTolerance&&(i=a,n=r)}),n}updateAllScreenPositions(){this.sketchManager.currentPlane&&0!==this.snapPoints.length&&this.snapPoints.forEach(e=>{e.screenPos=this.worldToScreen(e.point)})}worldToScreen(e){const t=e.clone(),n=this.sketchManager.editor.camera;t.project(n);const i=this.sketchManager.editor.renderer.domElement.clientWidth,r=this.sketchManager.editor.renderer.domElement.clientHeight;return{x:(.5*t.x+.5)*i,y:(.5*-t.y+.5)*r}}showHoverMarker(e){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker?this.updateHoverMarkerPosition(e):this.hoverTimeout=setTimeout(()=>{this.createHoverMarker(e)},5)}createHoverMarker(e){if(!this.sketchManager.currentPlane)return;const t=this.colors[e.type]||this.colors.none,n=this.sketchManager.currentPlane,i=n.worldToLocal(e.point.clone()),r=.3,s=new Float32Array([-.3,-.3,0,r,-.3,0,r,r,0,-.3,r,0,-.3,-.3,0]),l=new THREE.BufferGeometry;l.setAttribute("position",new THREE.BufferAttribute(s,3));const a=new THREE.LineBasicMaterial({color:t,linewidth:2,transparent:!0,opacity:.8});this.hoverMarker=new THREE.Line(l,a),this.hoverMarker.position.set(i.x,i.y,.1),this.hoverMarker.userData.isHoverMarker=!0,n.add(this.hoverMarker)}updateHoverMarkerPosition(e){if(!this.hoverMarker||!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane.worldToLocal(e.point.clone());this.hoverMarker.position.set(t.x,t.y,.1);const n=this.colors[e.type]||this.colors.none;this.hoverMarker.material.color.set(n)}hideHoverMarker(){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker&&(this.hoverMarker.parent&&this.hoverMarker.parent.remove(this.hoverMarker),this.hoverMarker.geometry&&this.hoverMarker.geometry.dispose(),this.hoverMarker.material&&this.hoverMarker.material.dispose(),this.hoverMarker=null)}adjustToolPoint(e){const t=this.sketchManager.toolManager.currentTool;t&&t.isDrawing&&t.tempElement&&(t.tempElement.end=e.clone(),t.tempElement.points&&t.tempElement.points.length>1&&(t.tempElement.points[1]=e.clone()),t.updateTempGeometry&&t.updateTempGeometry())}getSnappedPoint(e,t=null){if(!this.snapEnabled)return e;let n=e;if(this.currentSnapPoint)return n=this.currentSnapPoint.point,n;const i=this.sketchManager.toolManager.currentToolName,r="line"===i||"polyline"===i||"dashedline"===i;return this.angleSnapEnabled&&(this.perpendicularActive||this.parallelActive)&&t&&t.tempElement&&t.tempElement.end&&r?(n=t.tempElement.end,n):this.snappedPoint&&(this.lineSnapActive||this.circleSnapActive)?(n=this.snappedPoint,n):(this.gridSnapEnabled&&(n=this.snapToGrid(e)),n)}getCursorPosition(e){if(!this.snapEnabled)return e;if(this.currentSnapPoint)return this.currentSnapPoint.point;if(this.snappedPoint)return this.snappedPoint;const t=this.sketchManager.toolManager.currentTool;return this.perpendicularActive&&t&&t.tempElement&&t.tempElement.end?t.tempElement.end:e}clear(){this.clearSnapPoints(),this.hideHoverMarker(),this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),this.snapPoints=[],this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0,this.currentSnapPoint=null,this.currentSnapSegment=null,this.currentSnapCircle=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.isHovering=!1,this.snappedPoint=null,this.lastAngle=0,this.AngleIndicatorFPSCounter=0}clearSnapPoints(){this.snapPoints=[],this.hideHoverMarker(),this.currentSnapPoint=null,this.isHovering=!1,this.snappedPoint=null}toggleLineSnap(){return this.lineSnapEnabled=!this.lineSnapEnabled,this.lineSnapEnabled||(this.lineSnapActive=!1,this.hideLineHighlight()),this.lineSnapEnabled}findLineIntersections(e,t){const n=[];if(!e.points||!t.points)return n;const i=this.getElementSegments(e),r=this.getElementSegments(t);for(const e of i)for(const t of r){const i=this.lineSegmentIntersection(e.start,e.end,t.start,t.end);i&&n.push(i)}return n}lineSegmentIntersection(e,t,n,i){const r=new THREE.Vector2(e.x,e.y),s=new THREE.Vector2(t.x,t.y),l=new THREE.Vector2(n.x,n.y),a=new THREE.Vector2(i.x,i.y),o=(a.y-l.y)*(s.x-r.x)-(a.x-l.x)*(s.y-r.y);if(Math.abs(o)<1e-4)return null;const c=((a.x-l.x)*(r.y-l.y)-(a.y-l.y)*(r.x-l.x))/o,h=((s.x-r.x)*(r.y-l.y)-(s.y-r.y)*(r.x-l.x))/o;return c>=0&&c<=1&&h>=0&&h<=1?new THREE.Vector3(e.x+c*(t.x-e.x),e.y+c*(t.y-e.y),e.z+c*(t.z-e.z)):null}}