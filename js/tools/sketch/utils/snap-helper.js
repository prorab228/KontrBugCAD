class SnapHelper{constructor(e){this.sketchManager=e,this.gridSnapEnabled=!0,this.parallelActive=!1,this.parallelToleranceDegrees=3,this.snapPoints=[],this.currentSnapPoint=null,this.isHovering=!1,this.snapTolerance=15,this.snapEnabled=!0,this.lineSnapEnabled=!0,this.colors={endpoint:16711680,midpoint:65280,center:255,intersection:16776960,perpendicular:16753920,none:8947848},this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0,this.hoverMarker=null,this.hoverTimeout=null,this.perpendicularGuide=null,this.snapLine=null,this.lineHighlight=null,this.circleHighlight=null,this.perpendicularActive=!1,this.lineSnapActive=!1,this.circleSnapActive=!1,this.currentSnapSegment=null,this.currentSnapCircle=null,this.perpendicularToleranceDegrees=3,this.lineSnapDistance=.6,this.circleSnapDistance=.6,this.snappedPoint=null,this.AngleIndicatorFPS=5,this.AngleIndicatorFPSCounter=0,this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0}forceUpdate(){this.clear(),this.segmentsDirty=!0,this.circlesDirty=!0,this.updateSnapPoints()}snapToGrid(e){if(!this.gridSnapEnabled||!this.sketchManager.currentPlane)return e;const t=this.sketchManager.currentPlane.worldToLocal(e.clone());let n=this.sketchManager.gridStep;return"inch"===this.sketchManager.editor.gridUnit&&(n*=25.4),t.x=Math.round(t.x/n)*n,t.y=Math.round(t.y/n)*n,this.sketchManager.currentPlane.localToWorld(t)}updateSnapPoints(){if(this.clearSnapPoints(),this.segmentsDirty=!0,this.circlesDirty=!0,!this.sketchManager.currentPlane||!this.sketchManager.elementManager.elements)return;const e=this.sketchManager.elementManager.elements;e.forEach(e=>{this.addElementSnapPoints(e)}),this.addIntersectionPoints(e),console.log("snap-helper updateSnapPoints cashe:",this.cachedSegments,this.cachedCircles)}addElementSnapPoints(e){if(!e.mesh)return;const t=e.mesh.userData;if(!t.localPoints||0===t.localPoints.length)return;const n=this.sketchManager.currentPlane,i=t.localPoints;if(i.forEach((t,i)=>{const r=n.localToWorld(new THREE.Vector3(t.x,t.y,0));this.snapPoints.push({point:r,type:"endpoint",element:e,index:i,screenPos:this.worldToScreen(r)})}),("line"===e.type||"polyline"===e.type||"dashed-line"===e.type)&&i.length>=2)for(let t=0;t<i.length-1;t++){const r=i[t],s=i[t+1],a=(r.x+s.x)/2,l=(r.y+s.y)/2,o=n.localToWorld(new THREE.Vector3(a,l,0));this.snapPoints.push({point:o,type:"midpoint",element:e,segmentIndex:t,screenPos:this.worldToScreen(o)})}if("rectangle"===e.type&&i.length>=4)for(let t=0;t<4;t++){const r=i[t],s=i[(t+1)%4],a=(r.x+s.x)/2,l=(r.y+s.y)/2,o=n.localToWorld(new THREE.Vector3(a,l,0));this.snapPoints.push({point:o,type:"midpoint",element:e,sideIndex:t,screenPos:this.worldToScreen(o)})}if("polygon"===e.type&&i.length>=3)for(let t=0;t<i.length;t++){const r=i[t],s=i[(t+1)%i.length],a=(r.x+s.x)/2,l=(r.y+s.y)/2,o=n.localToWorld(new THREE.Vector3(a,l,0));this.snapPoints.push({point:o,type:"midpoint",element:e,sideIndex:t,screenPos:this.worldToScreen(o)})}if("circle"===e.type&&e.center&&this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"polygon"!==e.type&&"oval"!==e.type&&"stadium"!==e.type||!e.center||this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"rectangle"===e.type&&e.points&&e.points.length>=4){for(let t=0;t<4;t++){const n=e.points[t];this.snapPoints.push({point:n,type:"endpoint",element:e,isCorner:!0,cornerIndex:t,screenPos:this.worldToScreen(n)})}const t=new THREE.Vector3;e.points.forEach(e=>t.add(e)),t.divideScalar(4),this.snapPoints.push({point:t,type:"center",element:e,screenPos:this.worldToScreen(t)})}}addIntersectionPoints(e){const t=e.filter(e=>"line"===e.type||"rectangle"===e.type||"polyline"===e.type&&e.points&&e.points.length>=2);for(let e=0;e<t.length;e++)for(let n=e+1;n<t.length;n++){this.findLineIntersections(t[e],t[n]).forEach(i=>{this.snapPoints.push({point:i,type:"intersection",elements:[t[e],t[n]],screenPos:this.worldToScreen(i)})})}}handleMouseMove(e,t=null){if(!this.snapEnabled||!this.sketchManager.currentPlane)return;const n=this.sketchManager.editor.renderer.domElement.getBoundingClientRect(),i=e.clientX-n.left,r=e.clientY-n.top,s=this.findNearestSnapPoint(i,r);if(this.currentSnapPoint=s,this.snappedPoint=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.parallelActive=!1,this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),s)this.snappedPoint=s.point,this.showHoverMarker(s),this.isHovering=!0;else{this.hideHoverMarker(),this.isHovering=!1,this.lineSnapEnabled&&t&&this.checkLineSnap(t),t&&this.checkCircleSnap(t);const e=this.sketchManager.toolManager.currentTool,n=this.sketchManager.toolManager.currentToolName;if(("line"===n||"polyline"===n||"dashedline"===n)&&e&&e.isDrawing&&e.tempElement&&e.tempElement.start&&t){let n=t;this.snappedPoint&&(n=this.snappedPoint),this.checkAlignment(e.tempElement.start,n)}}const a=this.sketchManager.toolManager.currentTool,l=this.sketchManager.toolManager.currentToolName;("line"===l||"polyline"===l||"dashedline"===l)&&a&&a.isDrawing&&a.tempElement&&a.tempElement.start&&t?this.AngleIndicatorFPSCounter>=this.AngleIndicatorFPS?(this.showAngleIndicator(t),this.AngleIndicatorFPSCounter=0):this.AngleIndicatorFPSCounter+=1:this.hideAngleIndicator()}checkCircleSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane,n=t.worldToLocal(e.clone()),i=this.getAllCircles();let r=null,s=1/0,a=null;for(const e of i){const t=new THREE.Vector2(e.center.x,e.center.y),i=new THREE.Vector2(n.x,n.y),l=t.distanceTo(i),o=Math.abs(l-e.radius);if(o<s&&o<this.circleSnapDistance)if(s=o,r=e,l>0){const n=e.radius/l;a=new THREE.Vector3(t.x+(i.x-t.x)*n,t.y+(i.y-t.y)*n,0)}else a=new THREE.Vector3(t.x+e.radius,t.y,0)}if(r&&s<this.circleSnapDistance){this.circleSnapActive=!0,this.currentSnapCircle=r,this.showCircleHighlight(r,t);const e=t.localToWorld(a);this.snappedPoint=e;const n=this.sketchManager.toolManager.currentTool;n&&n.isDrawing&&n.tempElement&&(n.tempElement.end=e.clone(),n.tempElement.points&&n.tempElement.points.length>1&&(n.tempElement.points[1]=e.clone()),n.updateTempGeometry&&n.updateTempGeometry())}}checkLineSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane,n=t.worldToLocal(e.clone()),i=this.getAllSegments();let r=null,s=1/0,a=null;for(const e of i){if(e.isArc)continue;const t=this.distanceToSegment(n,e);t.distance<s&&t.distance<this.lineSnapDistance&&(s=t.distance,r=e,a=t.point)}if(r&&s<this.lineSnapDistance){this.lineSnapActive=!0,this.currentSnapSegment=r,this.showLineHighlight(r,t);let e=t.localToWorld(a);this.gridSnapEnabled&&(e=this.snapLinePointToGrid(r,e,t,n)),this.snappedPoint=e}}snapLinePointToGrid(e,t,n,i){if(!this.gridSnapEnabled)return t;n.worldToLocal(t.clone());const r=n.worldToLocal(e.start.clone()),s=n.worldToLocal(e.end.clone());let a=this.sketchManager.gridStep;"inch"===this.sketchManager.editor.gridUnit&&(a*=25.4);const l=s.x-r.x,o=s.y-r.y;return Math.abs(l)<.001||Math.abs(o)<.001?this.snapAxisAlignedLineToGrid(e,t,n,a):this.snapDiagonalLineToGrid(e,t,n,i,a)}snapAxisAlignedLineToGrid(e,t,n,i){const r=n.worldToLocal(t.clone()),s=n.worldToLocal(e.start.clone()),a=n.worldToLocal(e.end.clone()),l=a.x-s.x,o=a.y-s.y;if(Math.abs(l)<.001){const e=s.x,t=Math.round(e/i)*i;if(Math.abs(t-e)<.1*i){const e=Math.round(r.y/i)*i,l=Math.min(s.y,a.y),o=Math.max(s.y,a.y);if(e>=l&&e<=o)return n.localToWorld(new THREE.Vector3(t,e,0))}}else if(Math.abs(o)<.001){const e=s.y,t=Math.round(e/i)*i;if(Math.abs(t-e)<.1*i){const e=Math.round(r.x/i)*i,l=Math.min(s.x,a.x),o=Math.max(s.x,a.x);if(e>=l&&e<=o)return n.localToWorld(new THREE.Vector3(e,t,0))}}return t}snapDiagonalLineToGrid(e,t,n,i,r){const s=n.worldToLocal(t.clone()),a=n.worldToLocal(e.start.clone()),l=n.worldToLocal(e.end.clone()),o=l.x-a.x,h=(l.y-a.y)/o,c=a.y-h*a.x,p=(s.x,a.x,Math.round(s.x/r)),d=Math.round(s.y/r);let u=null,g=1/0;for(let e=-1;e<=1;e++)for(let t=-1;t<=1;t++){const n=(p+e)*r,s=(d+t)*r;if(Math.abs(h*n-s+c)/Math.sqrt(h*h+1)<.1*r){const e=(n-a.x)/o;if(e>=0&&e<=1){const e=Math.sqrt(Math.pow(n-i.x,2)+Math.pow(s-i.y,2));e<g&&(g=e,u=new THREE.Vector3(n,s,0))}}}return u&&g<1.5*r?n.localToWorld(u):t}showLineHighlight(e,t){this.hideLineHighlight();const n=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(e.start.x,e.start.y,.05),new THREE.Vector3(e.end.x,e.end.y,.05)]),i=new THREE.LineBasicMaterial({color:43775,linewidth:10,transparent:!0,opacity:.6});this.lineHighlight=new THREE.Line(n,i),this.lineHighlight.userData.isLineHighlight=!0,t.add(this.lineHighlight)}hideLineHighlight(){this.lineHighlight&&(this.lineHighlight.parent&&this.lineHighlight.parent.remove(this.lineHighlight),this.lineHighlight.geometry&&this.lineHighlight.geometry.dispose(),this.lineHighlight.material&&this.lineHighlight.material.dispose(),this.lineHighlight=null)}showCircleHighlight(e,t){this.hideCircleHighlight();const n=[];for(let t=0;t<=32;t++){const i=t/32*Math.PI*2,r=e.center.x+Math.cos(i)*e.radius,s=e.center.y+Math.sin(i)*e.radius;n.push(new THREE.Vector3(r,s,.05))}const i=(new THREE.BufferGeometry).setFromPoints(n),r=new THREE.LineBasicMaterial({color:43775,linewidth:3,transparent:!0,opacity:.6});this.circleHighlight=new THREE.Line(i,r),this.circleHighlight.userData.isCircleHighlight=!0,t.add(this.circleHighlight)}hideCircleHighlight(){this.circleHighlight&&(this.circleHighlight.parent&&this.circleHighlight.parent.remove(this.circleHighlight),this.circleHighlight.geometry&&this.circleHighlight.geometry.dispose(),this.circleHighlight.material&&this.circleHighlight.material.dispose(),this.circleHighlight=null)}getAllSegments(){if(this.segmentsDirty||0===this.cachedSegments.length){this.cachedSegments=[];(this.sketchManager.elementManager.elements||[]).forEach(e=>{this.getElementSegments(e).forEach(t=>{t.element=e,this.cachedSegments.push(t)})}),this.segmentsDirty=!1}return this.cachedSegments}getAllCircles(){if(this.circlesDirty||0===this.cachedCircles.length){this.cachedCircles=[];(this.sketchManager.elementManager.elements||[]).forEach(e=>{if("circle"===e.type&&e.center&&e.radius){const t=this.sketchManager.currentPlane;if(!t)return;const n=t.worldToLocal(e.center.clone());this.cachedCircles.push({element:e,center:new THREE.Vector3(n.x,n.y,0),radius:e.radius})}}),this.circlesDirty=!1}return this.cachedCircles}getElementSegments(e){const t=[];if(!e||!e.mesh)return t;const n=e.mesh.userData||{},i=n.elementType||e.type||"unknown";let r=n.localPoints||[];if(0===r.length)return console.warn("No local points found for element:",i,e),t;if(!this.sketchManager.currentPlane)return t;const s=r.map(e=>e.isVector3?new THREE.Vector3(e.x,e.y,0):new THREE.Vector3(e.x||0,e.y||0,0));switch(i.toLowerCase()){case"line":case"dashed-line":s.length>=2&&t.push({start:s[0],end:s[1]});break;case"rectangle":if(s.length>=4)for(let e=0;e<4;e++)t.push({start:s[e],end:s[(e+1)%4]});break;case"polyline":for(let e=0;e<s.length-1;e++)t.push({start:s[e],end:s[e+1]});break;case"polygon":if(s.length>=3)for(let e=0;e<s.length;e++)t.push({start:s[e],end:s[(e+1)%s.length]});break;case"circle":if(n.center&&n.radius){const e=n.centerLocal||new THREE.Vector3(0,0,0),i=n.radius,r=32;for(let n=0;n<r;n++){const s=n/r*Math.PI*2,a=(n+1)/r*Math.PI*2;t.push({start:new THREE.Vector3(e.x+Math.cos(s)*i,e.y+Math.sin(s)*i,0),end:new THREE.Vector3(e.x+Math.cos(a)*i,e.y+Math.sin(a)*i,0),isArc:!0})}}}return t}extractPointsFromGeometry(e){const t=[];if(e.attributes&&e.attributes.position){const n=e.attributes.position.array;for(let e=0;e<n.length;e+=3)t.push(new THREE.Vector3(n[e],n[e+1],n[e+2]))}return t}checkAlignment(e,t){if(!this.sketchManager.currentPlane)return;const n=this.sketchManager.toolManager.currentTool;if(!(n&&n.isDrawing&&n.tempElement&&n.tempElement.start))return;const i=this.sketchManager.currentPlane,r=i.worldToLocal(e.clone()),s=i.worldToLocal(t.clone()),a=this.getAllSegments();let l=a;this.lineSnapActive&&this.currentSnapSegment&&(l=a.filter(e=>!(e.start.equals(this.currentSnapSegment.start)&&e.end.equals(this.currentSnapSegment.end))));let o=null,h=1/0,c=null;for(const e of l){if(e.isArc)continue;const t=this.distanceToSegment(r,e);t.distance<h&&t.distance<2*this.lineSnapDistance&&(h=t.distance,o=e,c=t.point)}if(!o||h>=2*this.lineSnapDistance)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const p=new THREE.Vector2(s.x-r.x,s.y-r.y);if(p.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const d=Math.atan2(p.y,p.x),u=new THREE.Vector2(o.end.x-o.start.x,o.end.y-o.start.y);if(u.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const g=Math.atan2(u.y,u.x),m=g+Math.PI/2,E=g-Math.PI/2,M=g,y=g+Math.PI;let T=null,P=1/0,S=null;[{angle:m,type:"perpendicular"},{angle:E,type:"perpendicular"},{angle:M,type:"parallel"},{angle:y,type:"parallel"}].forEach(e=>{const t=Math.abs(this.normalizeAngle(d-e.angle));t<P&&(P=t,T=e.angle,S=e.type)});const f=this.perpendicularToleranceDegrees*Math.PI/180;if(P<f){let e;if("perpendicular"===S?(this.perpendicularActive=!0,this.parallelActive=!1,this.showPerpendicularGuide(r,T,"perpendicular")):(this.parallelActive=!0,this.perpendicularActive=!1,this.showPerpendicularGuide(r,T,"parallel")),this.lineSnapActive&&this.snappedPoint){e=this.snappedPoint.clone();const t=i.worldToLocal(this.snappedPoint.clone()),n=new THREE.Vector2(Math.cos(T),Math.sin(T)),s=new THREE.Vector2(t.x-r.x,t.y-r.y).dot(n),a=new THREE.Vector3(r.x+n.x*s,r.y+n.y*s,0);if(this.currentSnapSegment){const t=this.distanceToSegment(new THREE.Vector3(a.x,a.y,0),this.currentSnapSegment);t.distance<this.lineSnapDistance&&(e=i.localToWorld(t.point))}}else{const t=p.length(),n=new THREE.Vector2(Math.cos(T)*t,Math.sin(T)*t),s=new THREE.Vector3(r.x+n.x,r.y+n.y,0);e=i.localToWorld(s)}this.snappedPoint=e,n.tempElement.end=e.clone(),n.tempElement.points&&n.tempElement.points.length>1&&(n.tempElement.points[1]=e.clone()),n.updateTempGeometry&&n.updateTempGeometry()}else this.hidePerpendicularGuide(),this.perpendicularActive=!1,this.parallelActive=!1}getSnapPointAtPosition(e){if(!this.snapEnabled||0===this.snapPoints.length)return null;const t=this.worldToScreen(e);let n=null,i=1/0;return this.snapPoints.forEach(e=>{if(!e.screenPos)return;const r=e.screenPos.x-t.x,s=e.screenPos.y-t.y,a=Math.sqrt(r*r+s*s);a<i&&a<this.snapTolerance&&(i=a,n=e)}),n}normalizeAngle(e){for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e}showPerpendicularGuide(e,t,n="perpendicular"){this.hidePerpendicularGuide();const i=this.sketchManager.currentPlane,r=1e3,s=Math.cos(t),a=Math.sin(t),l=new THREE.Vector3(e.x-s*r,e.y-a*r,.05),o=new THREE.Vector3(e.x+s*r,e.y+a*r,.05),h=(new THREE.BufferGeometry).setFromPoints([l,o]);let c,p,d;"perpendicular"===n?(c=this.colors.perpendicular,p=.3,d=.3):(c=16711935,p=.5,d=.2);const u=new THREE.LineDashedMaterial({color:c,linewidth:1,dashSize:p,gapSize:d,transparent:!0,opacity:.6});this.perpendicularGuide=new THREE.Line(h,u),this.perpendicularGuide.computeLineDistances(),this.perpendicularGuide.userData.isPerpendicularGuide=!0,this.perpendicularGuide.userData.guideType=n,i.add(this.perpendicularGuide)}hidePerpendicularGuide(){this.perpendicularGuide&&(this.perpendicularGuide.parent&&this.perpendicularGuide.parent.remove(this.perpendicularGuide),this.perpendicularGuide.geometry&&this.perpendicularGuide.geometry.dispose(),this.perpendicularGuide.material&&this.perpendicularGuide.material.dispose(),this.perpendicularGuide=null)}distanceToSegment(e,t){const n=new THREE.Vector2(t.start.x,t.start.y),i=new THREE.Vector2(t.end.x,t.end.y),r=new THREE.Vector2(e.x,e.y),s=n.distanceToSquared(i);if(0===s)return{distance:r.distanceTo(n),point:t.start,t:0};const a=Math.max(0,Math.min(1,((r.x-n.x)*(i.x-n.x)+(r.y-n.y)*(i.y-n.y))/s)),l=new THREE.Vector3(n.x+a*(i.x-n.x),n.y+a*(i.y-n.y),0);return{distance:Math.sqrt(r.distanceToSquared(new THREE.Vector2(l.x,l.y))),point:l,t:a}}findNearestSnapPoint(e,t){if(!this.snapEnabled||0===this.snapPoints.length)return null;this.updateAllScreenPositions();let n=null,i=1/0;return this.snapPoints.forEach(r=>{if(!r.screenPos)return;const s=r.screenPos.x-e,a=r.screenPos.y-t,l=Math.sqrt(s*s+a*a);l<i&&l<this.snapTolerance&&(i=l,n=r)}),n}updateAllScreenPositions(){this.sketchManager.currentPlane&&0!==this.snapPoints.length&&this.snapPoints.forEach(e=>{e.screenPos=this.worldToScreen(e.point)})}worldToScreen(e){const t=e.clone(),n=this.sketchManager.editor.camera;t.project(n);const i=this.sketchManager.editor.renderer.domElement.clientWidth,r=this.sketchManager.editor.renderer.domElement.clientHeight;return{x:(.5*t.x+.5)*i,y:(.5*-t.y+.5)*r}}showHoverMarker(e){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker?this.updateHoverMarkerPosition(e):this.hoverTimeout=setTimeout(()=>{this.createHoverMarker(e)},5)}createHoverMarker(e){if(!this.sketchManager.currentPlane)return;const t=this.colors[e.type]||this.colors.none,n=this.sketchManager.currentPlane,i=n.worldToLocal(e.point.clone()),r=.3,s=new Float32Array([-.3,-.3,0,r,-.3,0,r,r,0,-.3,r,0,-.3,-.3,0]),a=new THREE.BufferGeometry;a.setAttribute("position",new THREE.BufferAttribute(s,3));const l=new THREE.LineBasicMaterial({color:t,linewidth:2,transparent:!0,opacity:.8});this.hoverMarker=new THREE.Line(a,l),this.hoverMarker.position.set(i.x,i.y,.1),this.hoverMarker.userData.isHoverMarker=!0,n.add(this.hoverMarker)}updateHoverMarkerPosition(e){if(!this.hoverMarker||!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane.worldToLocal(e.point.clone());this.hoverMarker.position.set(t.x,t.y,.1);const n=this.colors[e.type]||this.colors.none;this.hoverMarker.material.color.set(n)}hideHoverMarker(){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker&&(this.hoverMarker.parent&&this.hoverMarker.parent.remove(this.hoverMarker),this.hoverMarker.geometry&&this.hoverMarker.geometry.dispose(),this.hoverMarker.material&&this.hoverMarker.material.dispose(),this.hoverMarker=null)}adjustToolPoint(e){const t=this.sketchManager.toolManager.currentTool;t&&t.isDrawing&&t.tempElement&&(t.tempElement.end=e.clone(),t.tempElement.points&&t.tempElement.points.length>1&&(t.tempElement.points[1]=e.clone()),t.updateTempGeometry&&t.updateTempGeometry())}getSnappedPoint(e,t=null){if(!this.snapEnabled)return e;let n=e;if(this.currentSnapPoint)return n=this.currentSnapPoint.point,n;if(this.snappedPoint&&(this.lineSnapActive||this.circleSnapActive))return n=this.snappedPoint,n;const i=this.sketchManager.toolManager.currentToolName,r="line"===i||"polyline"===i||"dashedline"===i;if((this.perpendicularActive||this.parallelActive)&&t&&t.tempElement&&t.tempElement.end&&r){if(n=t.tempElement.end,this.gridSnapEnabled&&this.currentSnapSegment){const e=this.snapLinePointToGrid(this.currentSnapSegment,n,this.sketchManager.currentPlane,this.sketchManager.currentPlane.worldToLocal(n.clone()));e&&(n=e)}return n}return this.gridSnapEnabled&&(n=this.snapToGrid(e)),n}getCursorPosition(e){if(!this.snapEnabled)return e;if(this.currentSnapPoint)return this.currentSnapPoint.point;if(this.snappedPoint)return this.snappedPoint;const t=this.sketchManager.toolManager.currentTool;return this.perpendicularActive&&t&&t.tempElement&&t.tempElement.end?t.tempElement.end:e}clear(){this.clearSnapPoints(),this.hideHoverMarker(),this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),this.hideAngleIndicator(),this.snapPoints=[],this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0,this.currentSnapPoint=null,this.currentSnapSegment=null,this.currentSnapCircle=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.isHovering=!1,this.snappedPoint=null,this.lastAngle=0,this.AngleIndicatorFPSCounter=0}clearSnapPoints(){this.snapPoints=[],this.hideHoverMarker(),this.currentSnapPoint=null,this.isHovering=!1,this.snappedPoint=null}hideAngleIndicator(){this.angleIndicator&&(this.angleIndicator.parent&&this.angleIndicator.parent.remove(this.angleIndicator),this.angleIndicator.geometry&&this.angleIndicator.geometry.dispose(),this.angleIndicator.material&&this.angleIndicator.material.dispose(),this.angleIndicator=null),this.angleLabel&&(this.angleLabel.parent&&this.angleLabel.parent.remove(this.angleLabel),this.angleLabel.material&&this.angleLabel.material.dispose(),this.angleLabel.material.map&&this.angleLabel.material.map.dispose(),this.angleLabel=null),this.lastAngle=0}toggleLineSnap(){return this.lineSnapEnabled=!this.lineSnapEnabled,this.lineSnapEnabled||(this.lineSnapActive=!1,this.hideLineHighlight()),this.lineSnapEnabled}showAngleIndicator(e){const t=this.sketchManager.toolManager.currentTool;if(!(t&&t.tempElement&&t.tempElement.start&&this.sketchManager.currentPlane))return;const n=t.tempElement.start;let i=e;this.currentSnapPoint&&(i=this.currentSnapPoint.point);const r=this.sketchManager.currentPlane,s=r.worldToLocal(n.clone()),a=r.worldToLocal(i.clone()),l=a.x-s.x,o=a.y-s.y;if(Math.sqrt(l*l+o*o)<1)return void this.hideAngleIndicator();let h=Math.atan2(o,l),c=THREE.MathUtils.radToDeg(h);c<0&&(c+=360);let p=this.perpendicularActive,d=!1,u=this.parallelActive;Math.abs(c-0)<1||Math.abs(c-360)<1?(c=0,d=!0):Math.abs(c-90)<1?(c=90,d=!0):Math.abs(c-180)<1?(c=180,d=!0):Math.abs(c-270)<1?(c=270,d=!0):Math.abs(Math.abs(o)-Math.abs(l))<.1*Math.max(Math.abs(l),Math.abs(o))&&(Math.abs(c-45)<1?(c=45,d=!0):Math.abs(c-135)<1?(c=135,d=!0):Math.abs(c-225)<1?(c=225,d=!0):Math.abs(c-315)<1&&(c=315,d=!0)),(Math.abs(c-this.lastAngle)>.5||p!==(this.lastIsPerpendicular||!1)||u!==(this.lastIsParallel||!1))&&(this.lastAngle=c,this.lastIsPerpendicular=p,this.lastIsParallel=u,this.hideAngleIndicator(),this.createAngleIndicator(s,a,c,d,p,u))}createAngleIndicator(e,t,n,i,r,s){if(!this.sketchManager.currentPlane)return;const a=this.sketchManager.currentPlane;let l;l=r?this.colors.perpendicular:s?this.colors.parallel:i?65280:7829503;const o=t.x-e.x,h=t.y-e.y,c=Math.sqrt(o*o+h*h),p=Math.min(3,c/5);let d=Math.atan2(h,o);d<0&&(d+=2*Math.PI);const u=d,g=[];for(let t=0;t<=16;t++){const n=0+t/16*u,i=e.x+Math.cos(n)*p,r=e.y+Math.sin(n)*p;g.push(new THREE.Vector3(i,r,.05))}const m=(new THREE.BufferGeometry).setFromPoints(g),E=new THREE.LineBasicMaterial({color:l,linewidth:2,transparent:!0,opacity:.8});this.angleIndicator=new THREE.Line(m,E),this.angleIndicator.userData.isAngleIndicator=!0,this.createAngleLabel(e,d,p,n,i,r,s),a.add(this.angleIndicator)}createAngleLabel(e,t,n,i,r,s,a){if(!this.sketchManager.currentPlane)return;const l=this.sketchManager.currentPlane,o=1.5*n;let h=t/2;t>Math.PI&&(h=t+(2*Math.PI-t)/2);const c=e.x+Math.cos(h)*o,p=e.y+Math.sin(h)*o,d=document.createElement("canvas"),u=d.getContext("2d");let g;d.width=300,d.height=90,u.clearRect(0,0,d.width,d.height),u.font="bold 34px Arial",u.fillStyle=s?"#FFA500":a?"#FF00FF":r?"#00FF00":"#7777FF",u.textAlign="center",u.textBaseline="middle",g=s?`${Math.round(i)}° ⟂`:a?`${Math.round(i)}° ∥`:r?Math.abs(i-0)<.1||Math.abs(i-360)<.1?"0° →":Math.abs(i-45)<.1?"45°":Math.abs(i-90)<.1?"90° ↑":Math.abs(i-135)<.1?"135°":Math.abs(i-180)<.1?"180° ←":Math.abs(i-225)<.1?"225°":Math.abs(i-270)<.1?"270° ↓":Math.abs(i-315)<.1?"315°":`${Math.round(i)}°`:`${i.toFixed(1)}°`,u.fillText(g,d.width/2,d.height/2);const m=new THREE.CanvasTexture(d);m.minFilter=THREE.LinearFilter;const E=new THREE.SpriteMaterial({map:m,transparent:!0,opacity:.9});this.angleLabel=new THREE.Sprite(E);const M=new THREE.Vector3(c,p,.1);this.angleLabel.position.copy(M),this.angleLabel.scale.set(8,2,1),this.angleLabel.userData.isAngleLabel=!0,l.add(this.angleLabel)}findLineIntersections(e,t){const n=[];if(!e.points||!t.points)return n;const i=this.getElementSegments(e),r=this.getElementSegments(t);for(const e of i)for(const t of r){const i=this.lineSegmentIntersection(e.start,e.end,t.start,t.end);i&&n.push(i)}return n}lineSegmentIntersection(e,t,n,i){const r=new THREE.Vector2(e.x,e.y),s=new THREE.Vector2(t.x,t.y),a=new THREE.Vector2(n.x,n.y),l=new THREE.Vector2(i.x,i.y),o=(l.y-a.y)*(s.x-r.x)-(l.x-a.x)*(s.y-r.y);if(Math.abs(o)<1e-4)return null;const h=((l.x-a.x)*(r.y-a.y)-(l.y-a.y)*(r.x-a.x))/o,c=((s.x-r.x)*(r.y-a.y)-(s.y-r.y)*(r.x-a.x))/o;return h>=0&&h<=1&&c>=0&&c<=1?new THREE.Vector3(e.x+h*(t.x-e.x),e.y+h*(t.y-e.y),e.z+h*(t.z-e.z)):null}}