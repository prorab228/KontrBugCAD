class SnapHelper{constructor(e){this.sketchManager=e,this.gridSnapEnabled=!0,this.parallelActive=!1,this.parallelToleranceDegrees=3,this.snapPoints=[],this.currentSnapPoint=null,this.isHovering=!1,this.snapTolerance=15,this.snapEnabled=!0,this.lineSnapEnabled=!0,this.colors={endpoint:16711680,midpoint:65280,center:255,intersection:16776960,perpendicular:16753920,none:8947848},this.angleIndicator=null,this.angleLabel=null,this.lastAngle=0,this.hoverMarker=null,this.hoverTimeout=null,this.perpendicularGuide=null,this.snapLine=null,this.lineHighlight=null,this.circleHighlight=null,this.perpendicularActive=!1,this.lineSnapActive=!1,this.circleSnapActive=!1,this.currentSnapSegment=null,this.currentSnapCircle=null,this.perpendicularToleranceDegrees=3,this.lineSnapDistance=.6,this.circleSnapDistance=.6,this.snappedPoint=null,this.AngleIndicatorFPS=5,this.AngleIndicatorFPSCounter=0,this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0}forceUpdate(){this.segmentsDirty=!0,this.circlesDirty=!0,this.updateSnapPoints()}snapToGrid(e){if(!this.gridSnapEnabled||!this.sketchManager.currentPlane)return e;const t=this.sketchManager.currentPlane.worldToLocal(e.clone());let n=this.sketchManager.gridStep;return"inch"===this.sketchManager.editor.gridUnit&&(n*=25.4),t.x=Math.round(t.x/n)*n,t.y=Math.round(t.y/n)*n,this.sketchManager.currentPlane.localToWorld(t)}updateSnapPoints(){if(this.clearSnapPoints(),this.segmentsDirty=!0,this.circlesDirty=!0,!this.sketchManager.currentPlane||!this.sketchManager.elementManager.elements)return;const e=this.sketchManager.elementManager.elements;e.forEach(e=>{this.addElementSnapPoints(e)}),this.addIntersectionPoints(e)}addElementSnapPoints(e){if(!e.mesh)return;const t=e.mesh.userData;if(!t.localPoints||0===t.localPoints.length)return;const n=this.sketchManager.currentPlane,i=t.localPoints;if(i.forEach((t,i)=>{const r=n.localToWorld(new THREE.Vector3(t.x,t.y,0));this.snapPoints.push({point:r,type:"endpoint",element:e,index:i,screenPos:this.worldToScreen(r)})}),("line"===e.type||"polyline"===e.type)&&i.length>=2)for(let t=0;t<i.length-1;t++){const r=i[t],s=i[t+1],a=(r.x+s.x)/2,l=(r.y+s.y)/2,h=n.localToWorld(new THREE.Vector3(a,l,0));this.snapPoints.push({point:h,type:"midpoint",element:e,segmentIndex:t,screenPos:this.worldToScreen(h)})}if("circle"===e.type&&e.center&&this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"polygon"!==e.type&&"oval"!==e.type&&"stadium"!==e.type||!e.center||this.snapPoints.push({point:e.center,type:"center",element:e,screenPos:this.worldToScreen(e.center)}),"rectangle"===e.type&&e.points&&e.points.length>=4){for(let t=0;t<4;t++){const n=e.points[t];this.snapPoints.push({point:n,type:"endpoint",element:e,isCorner:!0,cornerIndex:t,screenPos:this.worldToScreen(n)})}const t=new THREE.Vector3;e.points.forEach(e=>t.add(e)),t.divideScalar(4),this.snapPoints.push({point:t,type:"center",element:e,screenPos:this.worldToScreen(t)})}}addIntersectionPoints(e){const t=e.filter(e=>"line"===e.type||"rectangle"===e.type||"polyline"===e.type&&e.points&&e.points.length>=2);for(let e=0;e<t.length;e++)for(let n=e+1;n<t.length;n++){this.findLineIntersections(t[e],t[n]).forEach(i=>{this.snapPoints.push({point:i,type:"intersection",elements:[t[e],t[n]],screenPos:this.worldToScreen(i)})})}}handleMouseMove(e,t=null){if(!this.snapEnabled||!this.sketchManager.currentPlane)return;const n=this.sketchManager.editor.renderer.domElement.getBoundingClientRect(),i=e.clientX-n.left,r=e.clientY-n.top,s=this.findNearestSnapPoint(i,r);this.currentSnapPoint=s,this.snappedPoint=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.parallelActive=!1,this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),s?(this.snappedPoint=s.point,this.showHoverMarker(s),this.isHovering=!0):(this.hideHoverMarker(),this.isHovering=!1,this.lineSnapEnabled&&t&&this.checkLineSnap(t),t&&!this.lineSnapActive&&this.checkCircleSnap(t));const a=this.sketchManager.toolManager.currentTool,l=this.sketchManager.toolManager.currentToolName;("line"===l||"polyline"===l)&&a&&a.isDrawing&&a.tempElement&&a.tempElement.start&&t?(s||this.lineSnapActive||this.circleSnapActive||this.checkAlignment(a.tempElement.start,t),this.AngleIndicatorFPSCounter>=this.AngleIndicatorFPS?(this.showAngleIndicator(t),this.AngleIndicatorFPSCounter=0):this.AngleIndicatorFPSCounter+=1):this.hideAngleIndicator()}checkCircleSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane,n=t.worldToLocal(e.clone()),i=this.getAllCircles();let r=null,s=1/0,a=null;for(const e of i){const t=new THREE.Vector2(e.center.x,e.center.y),i=new THREE.Vector2(n.x,n.y),l=t.distanceTo(i),h=Math.abs(l-e.radius);if(h<s&&h<this.circleSnapDistance)if(s=h,r=e,l>0){const n=e.radius/l;a=new THREE.Vector3(t.x+(i.x-t.x)*n,t.y+(i.y-t.y)*n,0)}else a=new THREE.Vector3(t.x+e.radius,t.y,0)}if(r&&s<this.circleSnapDistance){this.circleSnapActive=!0,this.currentSnapCircle=r,this.showCircleHighlight(r,t);const e=t.localToWorld(a);this.snappedPoint=e;const n=this.sketchManager.toolManager.currentTool;n&&n.isDrawing&&n.tempElement&&(n.tempElement.end=e.clone(),n.tempElement.points&&n.tempElement.points.length>1&&(n.tempElement.points[1]=e.clone()),n.updateTempGeometry&&n.updateTempGeometry())}}checkLineSnap(e){if(!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane,n=t.worldToLocal(e.clone()),i=this.getAllSegments();let r=null,s=1/0,a=null;for(const e of i){if(e.isArc)continue;const t=this.distanceToSegment(n,e);t.distance<s&&t.distance<this.lineSnapDistance&&(s=t.distance,r=e,a=t.point)}if(r&&s<this.lineSnapDistance){this.lineSnapActive=!0,this.currentSnapSegment=r,this.showLineHighlight(r,t);const e=t.localToWorld(a);this.snappedPoint=e;const n=this.sketchManager.toolManager.currentTool;n&&n.isDrawing&&n.tempElement&&(n.tempElement.end=e.clone(),n.tempElement.points&&n.tempElement.points.length>1&&(n.tempElement.points[1]=e.clone()),n.updateTempGeometry&&n.updateTempGeometry())}}showLineHighlight(e,t){this.hideLineHighlight();const n=(new THREE.BufferGeometry).setFromPoints([new THREE.Vector3(e.start.x,e.start.y,.05),new THREE.Vector3(e.end.x,e.end.y,.05)]),i=new THREE.LineBasicMaterial({color:43775,linewidth:10,transparent:!0,opacity:.6});this.lineHighlight=new THREE.Line(n,i),this.lineHighlight.userData.isLineHighlight=!0,t.add(this.lineHighlight)}hideLineHighlight(){this.lineHighlight&&(this.lineHighlight.parent&&this.lineHighlight.parent.remove(this.lineHighlight),this.lineHighlight.geometry&&this.lineHighlight.geometry.dispose(),this.lineHighlight.material&&this.lineHighlight.material.dispose(),this.lineHighlight=null)}showCircleHighlight(e,t){this.hideCircleHighlight();const n=[];for(let t=0;t<=32;t++){const i=t/32*Math.PI*2,r=e.center.x+Math.cos(i)*e.radius,s=e.center.y+Math.sin(i)*e.radius;n.push(new THREE.Vector3(r,s,.05))}const i=(new THREE.BufferGeometry).setFromPoints(n),r=new THREE.LineBasicMaterial({color:43775,linewidth:3,transparent:!0,opacity:.6});this.circleHighlight=new THREE.Line(i,r),this.circleHighlight.userData.isCircleHighlight=!0,t.add(this.circleHighlight)}hideCircleHighlight(){this.circleHighlight&&(this.circleHighlight.parent&&this.circleHighlight.parent.remove(this.circleHighlight),this.circleHighlight.geometry&&this.circleHighlight.geometry.dispose(),this.circleHighlight.material&&this.circleHighlight.material.dispose(),this.circleHighlight=null)}getAllSegments(){if(this.segmentsDirty||0===this.cachedSegments.length){this.cachedSegments=[];(this.sketchManager.elementManager.elements||[]).forEach(e=>{this.getElementSegments(e).forEach(t=>{t.element=e,this.cachedSegments.push(t)})}),this.segmentsDirty=!1}return this.cachedSegments}getAllCircles(){if(this.circlesDirty||0===this.cachedCircles.length){this.cachedCircles=[];(this.sketchManager.elementManager.elements||[]).forEach(e=>{if("circle"===e.type&&e.center&&e.radius){const t=this.sketchManager.currentPlane;if(!t)return;const n=t.worldToLocal(e.center.clone());this.cachedCircles.push({element:e,center:new THREE.Vector3(n.x,n.y,0),radius:e.radius})}}),this.circlesDirty=!1}return this.cachedCircles}getElementSegments(e){const t=[];if(!e)return t;const n=(e.mesh,e),i=n.userData||n.mesh?.userData||{},r=i.elementType||n.type||"unknown";let s=i.localPoints||n.localPoints||[];if(0===s.length&&n.geometry&&(s=this.extractPointsFromGeometry(n.geometry)),0===s.length)return t;const a=this.sketchManager.currentPlane;if(!a)return t;const l=s.map(e=>{if(e.isVector3){const t=a.worldToLocal(e.clone());return new THREE.Vector3(t.x,t.y,0)}return Array.isArray(e)?new THREE.Vector3(e[0]||0,e[1]||0,0):new THREE.Vector3(e.x||0,e.y||0,0)});switch(r.toLowerCase()){case"line":l.length>=2&&t.push({start:l[0],end:l[1]});break;case"rectangle":if(l.length>=4)for(let e=0;e<4;e++)t.push({start:l[e],end:l[(e+1)%4]});break;case"polyline":for(let e=0;e<l.length-1;e++)t.push({start:l[e],end:l[e+1]});break;case"polygon":if(l.length>=3)for(let e=0;e<l.length;e++)t.push({start:l[e],end:l[(e+1)%l.length]});break;case"circle":if(i.center&&i.radius){const e=a.worldToLocal(i.center.clone()),n=i.radius,r=32;for(let i=0;i<r;i++){const s=i/r*Math.PI*2,a=(i+1)/r*Math.PI*2;t.push({start:new THREE.Vector3(e.x+Math.cos(s)*n,e.y+Math.sin(s)*n,0),end:new THREE.Vector3(e.x+Math.cos(a)*n,e.y+Math.sin(a)*n,0),isArc:!0})}}}return t}extractPointsFromGeometry(e){const t=[];if(e.attributes&&e.attributes.position){const n=e.attributes.position.array;for(let e=0;e<n.length;e+=3)t.push(new THREE.Vector3(n[e],n[e+1],n[e+2]))}return t}checkAlignment(e,t){if(!this.sketchManager.currentPlane)return;const n=this.sketchManager.toolManager.currentTool;if(!(n&&n.isDrawing&&n.tempElement&&n.tempElement.start))return;const i=this.sketchManager.currentPlane,r=i.worldToLocal(e.clone()),s=i.worldToLocal(t.clone()),a=this.getAllSegments();let l=null,h=1/0,o=null;for(const e of a){const t=this.distanceToSegment(r,e);t.distance<h&&t.distance<this.lineSnapDistance&&(h=t.distance,l=e,o=t.point)}if(!l||h>=this.lineSnapDistance)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const c=new THREE.Vector2(s.x-r.x,s.y-r.y);if(c.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const p=Math.atan2(c.y,c.x),d=new THREE.Vector2(l.end.x-l.start.x,l.end.y-l.start.y);if(d.length()<.1)return this.hidePerpendicularGuide(),this.perpendicularActive=!1,void(this.parallelActive=!1);const u=Math.atan2(d.y,d.x),g=u+Math.PI/2,m=u-Math.PI/2,E=u,M=u+Math.PI;let y=null,P=1/0,T=null;[{angle:g,type:"perpendicular"},{angle:m,type:"perpendicular"},{angle:E,type:"parallel"},{angle:M,type:"parallel"}].forEach(e=>{const t=Math.abs(this.normalizeAngle(p-e.angle));t<P&&(P=t,y=e.angle,T=e.type)});const S=this.perpendicularToleranceDegrees*Math.PI/180;if(P<S){"perpendicular"===T?(this.perpendicularActive=!0,this.parallelActive=!1,this.showPerpendicularGuide(r,y,"perpendicular")):(this.parallelActive=!0,this.perpendicularActive=!1,this.showPerpendicularGuide(r,y,"parallel")),this.currentSnapSegment=l;const e=c.length(),t=new THREE.Vector2(Math.cos(y)*e,Math.sin(y)*e),s=new THREE.Vector3(r.x+t.x,r.y+t.y,0),a=i.localToWorld(s);this.snappedPoint=a,n.tempElement.end=a.clone(),n.tempElement.points&&n.tempElement.points.length>1&&(n.tempElement.points[1]=a.clone()),n.updateTempGeometry&&n.updateTempGeometry()}else this.hidePerpendicularGuide(),this.perpendicularActive=!1,this.parallelActive=!1,this.currentSnapSegment=null}getSnapPointAtPosition(e){if(!this.snapEnabled||0===this.snapPoints.length)return null;const t=this.worldToScreen(e);let n=null,i=1/0;return this.snapPoints.forEach(e=>{if(!e.screenPos)return;const r=e.screenPos.x-t.x,s=e.screenPos.y-t.y,a=Math.sqrt(r*r+s*s);a<i&&a<this.snapTolerance&&(i=a,n=e)}),n}normalizeAngle(e){for(;e>Math.PI;)e-=2*Math.PI;for(;e<-Math.PI;)e+=2*Math.PI;return e}showPerpendicularGuide(e,t,n="perpendicular"){this.hidePerpendicularGuide();const i=this.sketchManager.currentPlane,r=1e3,s=Math.cos(t),a=Math.sin(t),l=new THREE.Vector3(e.x-s*r,e.y-a*r,.05),h=new THREE.Vector3(e.x+s*r,e.y+a*r,.05),o=(new THREE.BufferGeometry).setFromPoints([l,h]);let c,p,d;"perpendicular"===n?(c=this.colors.perpendicular,p=.3,d=.3):(c=16711935,p=.5,d=.2);const u=new THREE.LineDashedMaterial({color:c,linewidth:1,dashSize:p,gapSize:d,transparent:!0,opacity:.6});this.perpendicularGuide=new THREE.Line(o,u),this.perpendicularGuide.computeLineDistances(),this.perpendicularGuide.userData.isPerpendicularGuide=!0,this.perpendicularGuide.userData.guideType=n,i.add(this.perpendicularGuide)}hidePerpendicularGuide(){this.perpendicularGuide&&(this.perpendicularGuide.parent&&this.perpendicularGuide.parent.remove(this.perpendicularGuide),this.perpendicularGuide.geometry&&this.perpendicularGuide.geometry.dispose(),this.perpendicularGuide.material&&this.perpendicularGuide.material.dispose(),this.perpendicularGuide=null)}distanceToSegment(e,t){const n=new THREE.Vector2(t.start.x,t.start.y),i=new THREE.Vector2(t.end.x,t.end.y),r=new THREE.Vector2(e.x,e.y),s=n.distanceToSquared(i);if(0===s)return{distance:r.distanceTo(n),point:t.start,t:0};const a=Math.max(0,Math.min(1,((r.x-n.x)*(i.x-n.x)+(r.y-n.y)*(i.y-n.y))/s)),l=new THREE.Vector3(n.x+a*(i.x-n.x),n.y+a*(i.y-n.y),0);return{distance:Math.sqrt(r.distanceToSquared(new THREE.Vector2(l.x,l.y))),point:l,t:a}}findNearestSnapPoint(e,t){if(!this.snapEnabled||0===this.snapPoints.length)return null;this.updateAllScreenPositions();let n=null,i=1/0;return this.snapPoints.forEach(r=>{if(!r.screenPos)return;const s=r.screenPos.x-e,a=r.screenPos.y-t,l=Math.sqrt(s*s+a*a);l<i&&l<this.snapTolerance&&(i=l,n=r)}),n}updateAllScreenPositions(){this.sketchManager.currentPlane&&0!==this.snapPoints.length&&this.snapPoints.forEach(e=>{e.screenPos=this.worldToScreen(e.point)})}worldToScreen(e){const t=e.clone(),n=this.sketchManager.editor.camera;t.project(n);const i=this.sketchManager.editor.renderer.domElement.clientWidth,r=this.sketchManager.editor.renderer.domElement.clientHeight;return{x:(.5*t.x+.5)*i,y:(.5*-t.y+.5)*r}}showHoverMarker(e){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker?this.updateHoverMarkerPosition(e):this.hoverTimeout=setTimeout(()=>{this.createHoverMarker(e)},5)}createHoverMarker(e){if(!this.sketchManager.currentPlane)return;const t=this.colors[e.type]||this.colors.none,n=this.sketchManager.currentPlane,i=n.worldToLocal(e.point.clone()),r=.3,s=new Float32Array([-.3,-.3,0,r,-.3,0,r,r,0,-.3,r,0,-.3,-.3,0]),a=new THREE.BufferGeometry;a.setAttribute("position",new THREE.BufferAttribute(s,3));const l=new THREE.LineBasicMaterial({color:t,linewidth:2,transparent:!0,opacity:.8});this.hoverMarker=new THREE.Line(a,l),this.hoverMarker.position.set(i.x,i.y,.1),this.hoverMarker.userData.isHoverMarker=!0,n.add(this.hoverMarker)}updateHoverMarkerPosition(e){if(!this.hoverMarker||!this.sketchManager.currentPlane)return;const t=this.sketchManager.currentPlane.worldToLocal(e.point.clone());this.hoverMarker.position.set(t.x,t.y,.1);const n=this.colors[e.type]||this.colors.none;this.hoverMarker.material.color.set(n)}hideHoverMarker(){this.hoverTimeout&&(clearTimeout(this.hoverTimeout),this.hoverTimeout=null),this.hoverMarker&&(this.hoverMarker.parent&&this.hoverMarker.parent.remove(this.hoverMarker),this.hoverMarker.geometry&&this.hoverMarker.geometry.dispose(),this.hoverMarker.material&&this.hoverMarker.material.dispose(),this.hoverMarker=null)}adjustToolPoint(e){const t=this.sketchManager.toolManager.currentTool;t&&t.isDrawing&&t.tempElement&&(t.tempElement.end=e.clone(),t.tempElement.points&&t.tempElement.points.length>1&&(t.tempElement.points[1]=e.clone()),t.updateTempGeometry&&t.updateTempGeometry())}getSnappedPoint(e,t=null){if(!this.snapEnabled)return e;let n=e;return this.currentSnapPoint?(n=this.currentSnapPoint.point,n):this.snappedPoint&&(this.lineSnapActive||this.circleSnapActive)?(n=this.snappedPoint,n):(this.perpendicularActive||this.parallelActive)&&t&&t.tempElement&&t.tempElement.end?(n=t.tempElement.end,n):(this.gridSnapEnabled&&(n=this.snapToGrid(e)),n)}getCursorPosition(e){if(!this.snapEnabled)return e;if(this.currentSnapPoint)return this.currentSnapPoint.point;if(this.snappedPoint)return this.snappedPoint;const t=this.sketchManager.toolManager.currentTool;return this.perpendicularActive&&t&&t.tempElement&&t.tempElement.end?t.tempElement.end:e}clear(){this.clearSnapPoints(),this.hideHoverMarker(),this.hideLineHighlight(),this.hideCircleHighlight(),this.hidePerpendicularGuide(),this.hideAngleIndicator(),this.snapPoints=[],this.cachedSegments=[],this.cachedCircles=[],this.segmentsDirty=!0,this.circlesDirty=!0,this.currentSnapPoint=null,this.currentSnapSegment=null,this.currentSnapCircle=null,this.lineSnapActive=!1,this.circleSnapActive=!1,this.perpendicularActive=!1,this.isHovering=!1,this.snappedPoint=null,this.lastAngle=0,this.AngleIndicatorFPSCounter=0}clearSnapPoints(){this.snapPoints=[],this.hideHoverMarker(),this.currentSnapPoint=null,this.isHovering=!1,this.snappedPoint=null}hideAngleIndicator(){this.angleIndicator&&(this.angleIndicator.parent&&this.angleIndicator.parent.remove(this.angleIndicator),this.angleIndicator.geometry&&this.angleIndicator.geometry.dispose(),this.angleIndicator.material&&this.angleIndicator.material.dispose(),this.angleIndicator=null),this.angleLabel&&(this.angleLabel.parent&&this.angleLabel.parent.remove(this.angleLabel),this.angleLabel.material&&this.angleLabel.material.dispose(),this.angleLabel.material.map&&this.angleLabel.material.map.dispose(),this.angleLabel=null),this.lastAngle=0}toggleLineSnap(){return this.lineSnapEnabled=!this.lineSnapEnabled,this.lineSnapEnabled||(this.lineSnapActive=!1,this.hideLineHighlight()),this.lineSnapEnabled}showAngleIndicator(e){const t=this.sketchManager.toolManager.currentTool;if(!(t&&t.tempElement&&t.tempElement.start&&this.sketchManager.currentPlane))return;const n=t.tempElement.start;let i=e;this.currentSnapPoint&&(i=this.currentSnapPoint.point);const r=this.sketchManager.currentPlane,s=r.worldToLocal(n.clone()),a=r.worldToLocal(i.clone()),l=a.x-s.x,h=a.y-s.y;if(Math.sqrt(l*l+h*h)<1)return void this.hideAngleIndicator();let o=Math.atan2(h,l),c=THREE.MathUtils.radToDeg(o);c<0&&(c+=360);let p=this.perpendicularActive,d=!1,u=this.parallelActive;Math.abs(c-0)<1||Math.abs(c-360)<1?(c=0,d=!0):Math.abs(c-90)<1?(c=90,d=!0):Math.abs(c-180)<1?(c=180,d=!0):Math.abs(c-270)<1?(c=270,d=!0):Math.abs(Math.abs(h)-Math.abs(l))<.1*Math.max(Math.abs(l),Math.abs(h))&&(Math.abs(c-45)<1?(c=45,d=!0):Math.abs(c-135)<1?(c=135,d=!0):Math.abs(c-225)<1?(c=225,d=!0):Math.abs(c-315)<1&&(c=315,d=!0)),(Math.abs(c-this.lastAngle)>.5||p!==(this.lastIsPerpendicular||!1)||u!==(this.lastIsParallel||!1))&&(this.lastAngle=c,this.lastIsPerpendicular=p,this.lastIsParallel=u,this.hideAngleIndicator(),this.createAngleIndicator(s,a,c,d,p,u))}createAngleIndicator(e,t,n,i,r,s){if(!this.sketchManager.currentPlane)return;const a=this.sketchManager.currentPlane;let l;l=r?this.colors.perpendicular:s?this.colors.parallel:i?65280:7829503;const h=t.x-e.x,o=t.y-e.y,c=Math.sqrt(h*h+o*o),p=Math.min(3,c/5);let d=Math.atan2(o,h);d<0&&(d+=2*Math.PI);const u=d,g=[];for(let t=0;t<=16;t++){const n=0+t/16*u,i=e.x+Math.cos(n)*p,r=e.y+Math.sin(n)*p;g.push(new THREE.Vector3(i,r,.05))}const m=(new THREE.BufferGeometry).setFromPoints(g),E=new THREE.LineBasicMaterial({color:l,linewidth:2,transparent:!0,opacity:.8});this.angleIndicator=new THREE.Line(m,E),this.angleIndicator.userData.isAngleIndicator=!0,this.createAngleLabel(e,d,p,n,i,r,s),a.add(this.angleIndicator)}createAngleLabel(e,t,n,i,r,s,a){if(!this.sketchManager.currentPlane)return;const l=this.sketchManager.currentPlane,h=1.5*n;let o=t/2;t>Math.PI&&(o=t+(2*Math.PI-t)/2);const c=e.x+Math.cos(o)*h,p=e.y+Math.sin(o)*h,d=document.createElement("canvas"),u=d.getContext("2d");let g;d.width=100,d.height=30,u.clearRect(0,0,d.width,d.height),u.font="bold 14px Arial",u.fillStyle=s?"#FFA500":a?"#FF00FF":r?"#00FF00":"#7777FF",u.textAlign="center",u.textBaseline="middle",g=s?`${Math.round(i)}° ⟂`:a?`${Math.round(i)}° ∥`:r?Math.abs(i-0)<.1||Math.abs(i-360)<.1?"0° →":Math.abs(i-45)<.1?"45°":Math.abs(i-90)<.1?"90° ↑":Math.abs(i-135)<.1?"135°":Math.abs(i-180)<.1?"180° ←":Math.abs(i-225)<.1?"225°":Math.abs(i-270)<.1?"270° ↓":Math.abs(i-315)<.1?"315°":`${Math.round(i)}°`:`${i.toFixed(1)}°`,u.fillText(g,d.width/2,d.height/2);const m=new THREE.CanvasTexture(d);m.minFilter=THREE.LinearFilter;const E=new THREE.SpriteMaterial({map:m,transparent:!0,opacity:.9});this.angleLabel=new THREE.Sprite(E);const M=new THREE.Vector3(c,p,.1);this.angleLabel.position.copy(M),this.angleLabel.scale.set(8,2,1),this.angleLabel.userData.isAngleLabel=!0,l.add(this.angleLabel)}findLineIntersections(e,t){const n=[];if(!e.points||!t.points)return n;const i=this.getElementSegments(e),r=this.getElementSegments(t);for(const e of i)for(const t of r){const i=this.lineSegmentIntersection(e.start,e.end,t.start,t.end);i&&n.push(i)}return n}lineSegmentIntersection(e,t,n,i){const r=new THREE.Vector2(e.x,e.y),s=new THREE.Vector2(t.x,t.y),a=new THREE.Vector2(n.x,n.y),l=new THREE.Vector2(i.x,i.y),h=(l.y-a.y)*(s.x-r.x)-(l.x-a.x)*(s.y-r.y);if(Math.abs(h)<1e-4)return null;const o=((l.x-a.x)*(r.y-a.y)-(l.y-a.y)*(r.x-a.x))/h,c=((s.x-r.x)*(r.y-a.y)-(s.y-r.y)*(r.x-a.x))/h;return o>=0&&o<=1&&c>=0&&c<=1?new THREE.Vector3(e.x+o*(t.x-e.x),e.y+o*(t.y-e.y),e.z+o*(t.z-e.z)):null}}