import*as THREE from"three";import{ParametricOperation}from"/js/core/parametric/ParametricOperation.js";import{Tool}from"./tool.js";export class PaintTool extends Tool{constructor(e){super("paint","fa-paint-brush",e),this.currentColor=16711680,this.mode="single",this.selectedFaces=new Map,this.highlightMesh=null,this.highlightMaterial=null,this.colorPicker=null,this.floodFillTolerance=0}onActivate(){this.createPropertiesSection(),this.createHighlightMesh(),document.body.style.cursor="crosshair",this.editor.showStatus("Режим раскраски граней: клик по грани для покраски. Ctrl+клик – добавить к выделению, Shift+клик – заливка области","info")}onDeactivate(){this.clearSelection(),this.removePropertiesSection(),this.disposeHighlightMesh(),document.body.style.cursor="default"}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","paint"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="paint"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <div class="property-group" data-type="paint-settings">\n                <h4>РАСКРАСКА ГРАНЕЙ</h4>\n                <div class="property-row">\n                    <label>Цвет:</label>\n                    <input type="color" id="paintColorPicker" value="${"#"+this.currentColor.toString(16).padStart(6,"0")}">\n                </div>\n                <div class="property-row">\n                    <label>Режим:</label>\n                    <select id="paintModeSelect">\n                        <option value="single" ${"single"===this.mode?"selected":""}>Одиночный</option>\n                        <option value="multi" ${"multi"===this.mode?"selected":""}>Множественный</option>\n                        <option value="flood" ${"flood"===this.mode?"selected":""}>Заливка</option>\n                    </select>\n                </div>\n                <div class="property-row">\n                    <label>Выделено граней:</label>\n                    <span id="selectedFacesCount">0</span>\n                </div>\n                <div class="property-buttons">\n                    <button id="paintApplyBtn" class="btn-primary" style="flex: 1;">\n                        <i class="fas fa-check"></i> Применить\n                    </button>\n                    <button id="paintClearBtn" class="btn-secondary">\n                        <i class="fas fa-times"></i> Сбросить\n                    </button>\n                </div>\n                <div class="property-hint">\n                    <p><i class="fas fa-info-circle"></i>\n                    Ctrl+клик – добавить грань к выделению<br>\n                    Shift+клик – заливка связной области<br>\n                    После выбора граней нажмите "Применить" для создания операции.</p>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#paintColorPicker");e&&e.addEventListener("input",e=>{this.currentColor=parseInt(e.target.value.substring(1),16),this.updateHighlightColor()});const t=this.propertiesElement.querySelector("#paintModeSelect");t&&t.addEventListener("change",e=>{this.mode=e.target.value,this.clearSelection(),this.updateStatusMessage()});const i=this.propertiesElement.querySelector("#paintApplyBtn");i&&i.addEventListener("click",()=>this.applyPainting());const o=this.propertiesElement.querySelector("#paintClearBtn");o&&o.addEventListener("click",()=>{this.clearSelection(),this.editor.showStatus("Выделение сброшено","info")})}updateSelectedFacesCount(){const e=this.propertiesElement?.querySelector("#selectedFacesCount");if(e){let t=0;for(const e of this.selectedFaces.values())t+=e.size;e.textContent=t}}updateStatusMessage(){this.editor.showStatus(`Режим: ${{single:"одиночный",multi:"множественный",flood:"заливка"}[this.mode]}. Ctrl+клик – добавить, Shift+клик – заливка`,"info")}createHighlightMesh(){const e=new THREE.BufferGeometry,t=new THREE.MeshBasicMaterial({color:16776960,transparent:!0,opacity:.3,side:THREE.DoubleSide});this.highlightMesh=new THREE.Mesh(e,t),this.highlightMesh.visible=!1,this.editor.scene.add(this.highlightMesh)}disposeHighlightMesh(){this.highlightMesh&&(this.editor.scene.remove(this.highlightMesh),this.highlightMesh.geometry&&this.highlightMesh.geometry.dispose(),this.highlightMesh=null)}updateHighlightColor(){this.highlightMesh&&this.highlightMesh.material&&this.highlightMesh.material.color.setHex(this.currentColor)}showHighlight(e){if(!e||!e.face||!e.object)return void(this.highlightMesh.visible=!1);const t=e.object,i=e.faceIndex;if(void 0===i)return;const o=t.geometry,s=o.attributes.position,r=o.index;let n,l,a;if(r){const e=r.getX(3*i),t=r.getX(3*i+1),o=r.getX(3*i+2);n=(new THREE.Vector3).fromBufferAttribute(s,e),l=(new THREE.Vector3).fromBufferAttribute(s,t),a=(new THREE.Vector3).fromBufferAttribute(s,o)}else{const e=3*i;n=(new THREE.Vector3).fromBufferAttribute(s,e),l=(new THREE.Vector3).fromBufferAttribute(s,e+1),a=(new THREE.Vector3).fromBufferAttribute(s,e+2)}n.applyMatrix4(t.matrixWorld),l.applyMatrix4(t.matrixWorld),a.applyMatrix4(t.matrixWorld);const c=[n.x,n.y,n.z,l.x,l.y,l.z,a.x,a.y,a.z],h=new THREE.BufferGeometry;h.setAttribute("position",new THREE.Float32BufferAttribute(c,3)),h.setIndex([0,1,2]),h.computeVertexNormals(),this.highlightMesh.geometry.dispose(),this.highlightMesh.geometry=h,this.highlightMesh.visible=!0}onMouseMove(e){if(!this.editor.raycaster)return;const t=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((e.clientX-t.left)/t.width*2-1,-(e.clientY-t.top)/t.height*2+1);this.editor.raycaster.setFromCamera(i,this.editor.camera);const o=this.editor.objectsGroup.children.filter(e=>e.isMesh),s=this.editor.raycaster.intersectObjects(o);s.length>0?this.showHighlight(s[0]):this.highlightMesh.visible=!1}onMouseDown(e){if(0!==e.button)return!1;const t=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((e.clientX-t.left)/t.width*2-1,-(e.clientY-t.top)/t.height*2+1);this.editor.raycaster.setFromCamera(i,this.editor.camera);const o=this.editor.objectsGroup.children.filter(e=>e.isMesh),s=this.editor.raycaster.intersectObjects(o);if(0===s.length)return!1;const r=s[0],n=r.object,l=r.faceIndex;if(void 0===l)return!1;const a=e.ctrlKey||e.metaKey;return e.shiftKey?this.floodFill(n,l):a&&"multi"===this.mode?this.toggleFaceSelection(n,l):"single"===this.mode?this.applyColorToFace(n,[l]):"multi"===this.mode&&(this.clearSelection(),this.addFaceSelection(n,l)),!0}toggleFaceSelection(e,t){this.selectedFaces.has(e.uuid)||this.selectedFaces.set(e.uuid,new Set);const i=this.selectedFaces.get(e.uuid);i.has(t)?(i.delete(t),0===i.size&&this.selectedFaces.delete(e.uuid)):i.add(t),this.updateSelectedFacesCount()}addFaceSelection(e,t){this.selectedFaces.has(e.uuid)||this.selectedFaces.set(e.uuid,new Set),this.selectedFaces.get(e.uuid).add(t),this.updateSelectedFacesCount()}clearSelection(){this.selectedFaces.clear(),this.updateSelectedFacesCount()}floodFill(e,t){const i=e.geometry,o=i.attributes.position.array,s=i.index;let r;r=s?s.count/3:o.length/9;const n=this.buildFaceAdjacency(i),l=this.getFaceColors(e),a=l[t];if(a===this.currentColor)return;const c=new Array(r).fill(!1),h=[t],d=[];for(;h.length>0;){const e=h.shift();if(!c[e]&&(c[e]=!0,l[e]===a)){d.push(e);for(const t of n[e]||[])c[t]||h.push(t)}}this.applyColorToFace(e,d)}buildFaceAdjacency(e){return console.warn("Flood fill requires proper adjacency calculation – using placeholder"),[]}applyColorToFace(e,t){if(0===t.length)return;let i=e.userData.faceColors;const o=e.geometry;let s;if(s=o.index?o.index.count/3:o.attributes.position.count/3,!i){const t=this.getDefaultColor(e);i=new Array(s).fill(t)}for(const e of t)e>=0&&e<s&&(i[e]=this.currentColor);e.userData.pendingFaceColors=i,this.previewColors(e)}previewColors(e){if(!e.userData.pendingFaceColors)return;new PaintFacesExecutor(this.editor).preview(e,e.userData.pendingFaceColors)}applyPainting(){const e=new Set;for(const[t,i]of this.selectedFaces){const o=this.editor.parametricModel.objectMap.get(t);if(!o)continue;let s=o.userData.faceColors||[];const r=o.geometry,n=r.index?r.index.count/3:r.attributes.position.count/3;if(s.length!==n){const e=this.getDefaultColor(o);s=new Array(n).fill(e)}for(const e of i)s[e]=this.currentColor;o.userData.pendingFaceColors=s,e.add(o)}for(const t of e){const e=new ParametricOperation("paint_faces",{target:t.uuid,faceColors:t.userData.pendingFaceColors},[]);this.editor.parametricModel.addOperation(e,!1),delete t.userData.pendingFaceColors}this.clearSelection(),this.editor.showStatus("Раскраска применена","success")}getDefaultColor(e){return e.material?Array.isArray(e.material)?e.material[0].color.getHex():e.material.color.getHex():16777215}getFaceColors(e){if(e.userData.faceColors)return e.userData.faceColors;const t=this.getDefaultColor(e),i=e.geometry,o=i.index?i.index.count/3:i.attributes.position.count/3;return new Array(o).fill(t)}onKeyDown(e){return"Escape"===e.key&&(this.clearSelection(),this.editor.showStatus("Выделение сброшено","info"),!0)}}