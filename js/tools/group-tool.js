import*as THREE from"three";import{ParametricOperation}from"/js/core/parametric/ParametricOperation.js";import{Tool}from"./tool.js";export class GroupTool extends Tool{constructor(t){super("group","fa-object-group",t),this.requiresSelection=!0,this.minObjects=2}onActivate(){if(this.canActivate()){if(this.editor.selectedObjects.length<this.minObjects)return this.editor.showStatus(`Для группировки нужно выбрать минимум ${this.minObjects} объекта`,"error"),void this.editor.toolManager.restorePreviousTool();this.performGrouping(),setTimeout(()=>{this.editor.toolManager.restorePreviousTool()},100)}else this.editor.toolManager.restorePreviousTool()}performGrouping(){const t=this.editor.selectedObjects.slice().filter(t=>"group"!==t.userData?.type);if(t.length<2)return void this.editor.showStatus("Недостаточно объектов для группировки","error");const e=t.map(t=>t.uuid),o=new THREE.Vector3;t.forEach(t=>{const e=new THREE.Vector3;t.getWorldPosition(e),o.add(e)}),o.divideScalar(t.length);const r=new ParametricOperation("group",{childIds:e,groupPosition:o.toArray(),groupRotation:[0,0,0],groupScale:[1,1,1]},[]);this.editor.parametricModel.addOperation(r),setTimeout(()=>{if(r.outputs.length>0){const t=r.outputs[0],e=this.editor.parametricModel.objectMap.get(t);e&&(this.editor.clearSelection(),this.editor.selectSingleObject(e))}},0),this.editor.showStatus(`Объекты сгруппированы (${t.length} шт.)`,"success")}onDeactivate(){}}