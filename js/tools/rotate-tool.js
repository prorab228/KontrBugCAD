class RotateTool extends TransformToolBase{constructor(t){super("rotate","fa-sync-alt",t),this.startQuaternion=new THREE.Quaternion,this.useLocalCoordinates=!1,this.accumulatedAngle=0,this.gizmoWorldPosition=new THREE.Vector3,this.rotationPlane=null,this.startVector=null,this.hoveredArc=null,this.angleIndicator=null,this.currentAngle=0,this.arcGeometries={},this.halfSize=new THREE.Vector3,this._inputContainer=null,this._inputElement=null,this._isInputFocused=!1,this._lastInputValue=0,this._isDragging=!1,this._currentDragAxis=null,this.axisArrows={},this.initGizmo(),this.initAngleInput()}initGizmo(){for(;this.gizmoGroup.children.length>0;){const t=this.gizmoGroup.children[0];t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose(),this.gizmoGroup.remove(t)}this.createRotateGizmo(),this.gizmoGroup.visible=!1}initAngleInput(){this._inputContainer=document.createElement("div"),this._inputContainer.className="distance-input-container",this._inputContainer.style.display="none",this._inputElement=document.createElement("input"),this._inputElement.type="number",this._inputElement.step="1",this._inputElement.value="0",this._inputElement.style.width="60px",this._inputContainer.appendChild(this._inputElement),document.body.appendChild(this._inputContainer),this._inputElement.addEventListener("focus",()=>{this._isInputFocused=!0}),this._inputElement.addEventListener("blur",()=>{this._isInputFocused=!1}),this._inputElement.addEventListener("input",t=>{const e=parseFloat(t.target.value);isNaN(e)||this.updateFromInput(e)})}updateFromInput(t){if(!this.attachedObject||!this._currentDragAxis)return;this.attachedObject.userData.transformStartState||(this.attachedObject.userData.transformStartState={rotation:this.attachedObject.quaternion.clone()});const e=THREE.MathUtils.degToRad(t),i=new THREE.Quaternion;"x"===this._currentDragAxis?i.setFromAxisAngle(new THREE.Vector3(1,0,0),e):"y"===this._currentDragAxis?i.setFromAxisAngle(new THREE.Vector3(0,1,0),e):"z"===this._currentDragAxis&&i.setFromAxisAngle(new THREE.Vector3(0,0,1),e),this.useLocalCoordinates?(this.attachedObject.quaternion.copy(this.startQuaternion),this.attachedObject.quaternion.multiply(i)):(i.multiply(this.startQuaternion),this.attachedObject.quaternion.copy(i)),this.accumulatedAngle=e,this.currentAngle=t,this.updateGizmoPosition(),this.updateAngleIndicator()}createRotateGizmo(){this.arcGeometries={};const t=Math.PI/2;["x","y","z"].forEach(e=>{const i=new THREE.TorusGeometry(12,.6,6,32,t);this.arcGeometries[e]=i;const s=new THREE.MeshBasicMaterial({color:this.axisColors[e],transparent:!0,opacity:.8,side:THREE.DoubleSide}),r=new THREE.Mesh(i,s);r.renderOrder=1,r.name=`rotate_${e}`,r.userData.type="rotate",r.userData.axis=e,r.userData.isArc=!0,this.gizmoGroup.add(r)}),this.createAngleIndicator()}createAngleIndicator(){const t=new THREE.TorusGeometry(1.3,.3,6,32,2*Math.PI),e=new THREE.MeshBasicMaterial({color:16776960,transparent:!0,opacity:.9,side:THREE.DoubleSide});this.angleIndicator=new THREE.Mesh(t,e),this.angleIndicator.name="angle_indicator",this.angleIndicator.visible=!1,this.gizmoGroup.add(this.angleIndicator)}updateGizmoPosition(){if(!this.attachedObject)return;const t=new THREE.Vector3;this.attachedObject.getWorldPosition(t),this.gizmoGroup.position.copy(t),this.useLocalCoordinates?this.gizmoGroup.quaternion.copy(this.attachedObject.quaternion):this.gizmoGroup.quaternion.identity();const e=(new THREE.Box3).setFromObject(this.attachedObject),i=new THREE.Vector3;e.getSize(i),this.halfSize.copy(i).multiplyScalar(.5);const s=1.5;["x","y","z"].forEach(t=>{const e=this.gizmoGroup.getObjectByName(`rotate_${t}`);if(!e)return;let i,r=new THREE.Vector3;"x"===t?(i=Math.max(this.halfSize.y,this.halfSize.z)+s,r.set(this.halfSize.x+s,0,0),e.rotation.set(0,Math.PI/2,0)):"y"===t?(i=Math.max(this.halfSize.x,this.halfSize.z)+s,r.set(0,this.halfSize.y+s,0),e.rotation.set(Math.PI/2,0,0)):"z"===t&&(i=Math.max(this.halfSize.x,this.halfSize.y)+s,r.set(0,0,this.halfSize.z+s),e.rotation.set(0,0,0)),e.position.copy(r),this.hoveredArc===e?(e.material.color.set(16776960),e.material.opacity=1):(e.material.color.set(this.axisColors[t]),e.material.opacity=.8)}),this.angleIndicator&&this.angleIndicator.visible&&this.currentAxis&&this.updateAngleIndicator()}updateAngleIndicator(){if(!this.angleIndicator||!this.currentAxis)return;const t=this.gizmoGroup.getObjectByName(`rotate_${this.currentAxis}`);if(!t)return;this.angleIndicator.position.copy(t.position),this.angleIndicator.rotation.copy(t.rotation),this.angleIndicator.scale.copy(t.scale);const e=Math.abs(this.currentAngle%360)/360*120,i=(new THREE.Color).setHSL(e/360,.9,.5);this.angleIndicator.material.color.copy(i),this.updateInputPosition()}updateInputPosition(){if(!this._inputContainer||!this.angleIndicator||!this.angleIndicator.visible)return;const t=new THREE.Vector3;this.angleIndicator.getWorldPosition(t);const e=this.worldToScreen(t,this.editor.camera,this.editor.renderer);this._inputContainer.style.left=e.x-60+"px",this._inputContainer.style.top=`${e.y+30}px`}worldToScreen(t,e,i){const s=t.clone();s.project(e);return{x:(.5*s.x+.5)*i.domElement.clientWidth,y:(-.5*s.y+.5)*i.domElement.clientHeight}}getPropertiesHTML(){return`\n            <div class="property-group" data-type="rotate-rotation">\n                <h4><i class="fas fa-sync-alt"></i> Вращение</h4>\n                <div class="property-row">\n                    <label>Локальные координаты:</label>\n                    <input type="checkbox" id="localCoordinates" ${this.useLocalCoordinates?"checked":""}>\n                </div>\n                <div class="property-row">\n                    <label>X (°):</label>\n                    <input type="number" id="rotateX" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Y (°):</label>\n                    <input type="number" id="rotateY" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Z (°):</label>\n                    <input type="number" id="rotateZ" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <button id="applyRotation" class="btn-small">\n                        <i class="fas fa-check"></i> Применить вращение\n                    </button>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const t=this.propertiesElement.querySelector("#rotateX"),e=this.propertiesElement.querySelector("#rotateY"),i=this.propertiesElement.querySelector("#rotateZ"),s=this.propertiesElement.querySelector("#applyRotation"),r=this.propertiesElement.querySelector("#localCoordinates");t&&t.addEventListener("change",t=>this.onRotationChange("x",t)),e&&e.addEventListener("change",t=>this.onRotationChange("y",t)),i&&i.addEventListener("change",t=>this.onRotationChange("z",t)),s&&s.addEventListener("click",()=>this.applyRotationFromInputs()),r&&(r.checked=this.useLocalCoordinates,r.addEventListener("change",t=>{this.useLocalCoordinates=t.target.checked,this.updateGizmoPosition()}))}onRotationChange(t,e){if(!this.attachedObject)return;const i=parseFloat(e.target.value);if(isNaN(i))return;const s=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ");s[t]=THREE.MathUtils.degToRad(i),this.attachedObject.quaternion.setFromEuler(s),this.updateGizmoPosition()}applyRotationFromInputs(){if(!this.propertiesElement||!this.attachedObject)return;const t=parseFloat(this.propertiesElement.querySelector("#rotateX").value),e=parseFloat(this.propertiesElement.querySelector("#rotateY").value),i=parseFloat(this.propertiesElement.querySelector("#rotateZ").value);if(isNaN(t)||isNaN(e)||isNaN(i))return void this.editor.showStatus("Некорректные значения вращения","error");const s=new THREE.Euler(THREE.MathUtils.degToRad(t),THREE.MathUtils.degToRad(e),THREE.MathUtils.degToRad(i));this.attachedObject.quaternion.setFromEuler(s),this.updateGizmoPosition();const r=new ParametricOperation("rotate",{target:this.attachedObject.uuid,rotation:[s.x,s.y,s.z]},[]);this.editor.parametricModel.addOperation(r),this.editor.showStatus(`Вращение установлено: ${t}°, ${e}°, ${i}°`,"success")}updatePropertiesValues(){if(!this.propertiesElement||!this.attachedObject)return;const t=this.propertiesElement.querySelector("#rotateX"),e=this.propertiesElement.querySelector("#rotateY"),i=this.propertiesElement.querySelector("#rotateZ"),s=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ");t&&(t.value=THREE.MathUtils.radToDeg(s.x).toFixed(2)),e&&(e.value=THREE.MathUtils.radToDeg(s.y).toFixed(2)),i&&(i.value=THREE.MathUtils.radToDeg(s.z).toFixed(2))}onMouseDown(t){if(0!==t.button)return!1;this.snapEnabled=!t.ctrlKey,this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.isArc&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(i.length>0){const e=i[0].object.userData.axis;return this.startDragging(e,t),!0}const s=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(s.length>0){const t=this.editor.objectsManager.findTopParent(s[0].object);if(this.canTransformObject(t))return this.editor.selectSingleObject(t),this.attachToObject(t),!0}return!1}onMouseMove(t){if(super.onMouseMove(t),this.isDragging)return;this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.isArc&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(this.hoveredArc&&this.hoveredArc.userData&&this.hoveredArc.userData.axis){const t=this.hoveredArc.userData.axis;this.hoveredArc.material.color.set(this.axisColors[t]),this.hoveredArc.material.opacity=.8,this.hoveredArc=null}i.length>0&&(this.hoveredArc=i[0].object,this.hoveredArc.material.color.set(16776960),this.hoveredArc.material.opacity=1)}startDragging(t,e){super.startDragging(t,e),this.attachedObject&&(this.startQuaternion.copy(this.attachedObject.quaternion),this.accumulatedAngle=0,this.currentAngle=0,this._currentDragAxis=t,this._isDragging=!0,this.attachedObject.userData.transformStartState={rotation:this.attachedObject.quaternion.clone()},this.gizmoGroup.getWorldPosition(this.gizmoWorldPosition),this.rotationAxis=new THREE.Vector3,"x"===t?this.rotationAxis.set(1,0,0):"y"===t?this.rotationAxis.set(0,1,0):"z"===t&&this.rotationAxis.set(0,0,1),this.useLocalCoordinates&&this.rotationAxis.applyQuaternion(this.attachedObject.quaternion),this.rotationPlane=new THREE.Plane,this.rotationPlane.setFromNormalAndCoplanarPoint(this.rotationAxis.clone().normalize(),this.gizmoWorldPosition),this.startProjection=this.getPlaneIntersection(e),this.startProjection&&(this.startVector=(new THREE.Vector3).subVectors(this.startProjection,this.gizmoWorldPosition).normalize()),this.angleIndicator&&(this.angleIndicator.visible=!0,this.updateAngleIndicator()),this._inputContainer&&(this._inputContainer.style.display="block",this._inputElement.value="0.0","x"===t?this._inputContainer.style.borderColor="#ff4444":"y"===t?this._inputContainer.style.borderColor="#44ff44":"z"===t&&(this._inputContainer.style.borderColor="#4444ff"),this.updateInputPosition()))}getPlaneIntersection(t){if(!this.rotationPlane)return null;const e=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((t.clientX-e.left)/e.width*2-1,-(t.clientY-e.top)/e.height*2+1),s=new THREE.Raycaster;s.setFromCamera(i,this.editor.camera);const r=new THREE.Vector3;return s.ray.intersectPlane(this.rotationPlane,r)?r:null}handleTransform(t,e){if(!(this.attachedObject&&this.currentAxis&&this.rotationPlane&&this.startVector))return;const i={clientX:this.startMouse.x+t,clientY:this.startMouse.y+e},s=this.getPlaneIntersection(i);if(!s)return;const r=(new THREE.Vector3).subVectors(s,this.gizmoWorldPosition).normalize(),a=this.startVector.dot(r),n=(new THREE.Vector3).crossVectors(this.startVector,r),o=Math.atan2(n.dot(this.rotationAxis),a);let h=o;if(this.snapEnabled&&!this.editor.spacePressed){const t=THREE.MathUtils.radToDeg(o),e=Math.round(t/this.rotateSnapValue)*this.rotateSnapValue;h=THREE.MathUtils.degToRad(e)}if(Math.abs(h)<.001)return;if(this.accumulatedAngle+=h,this.currentAngle=THREE.MathUtils.radToDeg(this.accumulatedAngle),this.useLocalCoordinates){let t=new THREE.Vector3;"x"===this.currentAxis?t.set(1,0,0):"y"===this.currentAxis?t.set(0,1,0):"z"===this.currentAxis&&t.set(0,0,1);const e=new THREE.Quaternion;e.setFromAxisAngle(t.normalize(),this.accumulatedAngle),this.attachedObject.quaternion.copy(this.startQuaternion),this.attachedObject.quaternion.multiply(e)}else{let t=new THREE.Vector3;"x"===this.currentAxis?t.set(1,0,0):"y"===this.currentAxis?t.set(0,1,0):"z"===this.currentAxis&&t.set(0,0,1);const e=new THREE.Quaternion;e.setFromAxisAngle(t.normalize(),this.accumulatedAngle),this.attachedObject.quaternion.copy(e),this.attachedObject.quaternion.multiply(this.startQuaternion)}this.startVector.copy(r),this.updateAngleIndicator(),!this._isInputFocused&&this._inputElement&&(this._inputElement.value=this.currentAngle.toFixed(1));const c=this.currentAngle<0;"x"===this.currentAxis?this._inputContainer.style.borderColor=c?"#ff8888":"#ff4444":"y"===this.currentAxis?this._inputContainer.style.borderColor=c?"#88ff88":"#44ff44":"z"===this.currentAxis&&(this._inputContainer.style.borderColor=c?"#8888ff":"#4444ff")}saveToHistory(){if(!this.attachedObject)return;const t=this.attachedObject.userData.transformStartState;if(t){if(t.rotation.equals(this.attachedObject.quaternion))delete this.attachedObject.userData.transformStartState;else{const t=this.attachedObject.uuid,e=new ParametricOperation("rotate",{target:t,rotation:this.attachedObject.quaternion.toArray()},[]);this.editor.parametricModel.addOperation(e);const i=this.editor.findObjectByUuid(t);i?(this.attachedObject=i,this.startQuaternion.copy(i.quaternion),delete i.userData.transformStartState):this.detach(),this.editor.showStatus("Объект повёрнут","info")}}}onMouseUp(t){this.isDragging&&(this.isDragging=!1,this.saveToHistory(),this.hoveredArc=null,this.attachedObject?(this.gizmoGroup.visible=!0,this.updateGizmoPosition()):this.gizmoGroup.visible=!1),this._isDragging=!1}detach(){this._inputContainer&&(this._inputContainer.style.display="none"),this.angleIndicator&&(this.angleIndicator.visible=!1),this._currentDragAxis=null,this._isDragging=!1,this.hoveredArc=null,super.detach()}onDeactivate(){this._inputContainer&&(this._inputContainer.style.display="none"),this.angleIndicator&&(this.angleIndicator.visible=!1),this._currentDragAxis=null,this._isDragging=!1,this.hoveredArc=null,super.onDeactivate()}createHistoryAction(){return null}}