class RotateTool extends TransformToolBase{constructor(t){super("rotate","fa-sync-alt",t),this.startQuaternion=new THREE.Quaternion,this.useLocalCoordinates=!1,this.accumulatedAngle=0,this.gizmoWorldPosition=new THREE.Vector3,this.rotationPlane=null,this.startVector=null,this.hoveredArc=null,this.angleIndicator=null,this.currentAngle=0,this.arcGeometries={},this.halfSize=new THREE.Vector3,this._inputContainer=null,this._inputElement=null,this._isInputFocused=!1,this._lastInputValue=0,this._isDragging=!1,this._currentDragAxis=null,this.initGizmo(),this.initAngleInput()}initGizmo(){for(;this.gizmoGroup.children.length>0;){const t=this.gizmoGroup.children[0];t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose(),this.gizmoGroup.remove(t)}this.createRotateGizmo(),this.gizmoGroup.visible=!1}initAngleInput(){this._inputContainer=document.createElement("div"),this._inputContainer.className="distance-input-container",this._inputContainer.style.display="none",this._inputElement=document.createElement("input"),this._inputElement.type="number",this._inputElement.step="1",this._inputElement.value="0",this._inputContainer.appendChild(this._inputElement),document.body.appendChild(this._inputContainer),this._inputElement.addEventListener("focus",()=>{this._isInputFocused=!0}),this._inputElement.addEventListener("blur",()=>{this._isInputFocused=!1}),this._inputElement.addEventListener("input",t=>{const e=parseFloat(t.target.value);isNaN(e)||this.updateFromInput(e)})}updateFromInput(t){if(!this.attachedObject||!this._currentDragAxis)return;this.attachedObject.userData.transformStartState||(this.attachedObject.userData.transformStartState={position:this.attachedObject.position.clone(),rotation:this.attachedObject.quaternion.clone(),scale:this.attachedObject.scale.clone()});const e=THREE.MathUtils.degToRad(t),i=new THREE.Quaternion;"x"===this._currentDragAxis?i.setFromAxisAngle(new THREE.Vector3(1,0,0),e):"y"===this._currentDragAxis?i.setFromAxisAngle(new THREE.Vector3(0,1,0),e):"z"===this._currentDragAxis&&i.setFromAxisAngle(new THREE.Vector3(0,0,1),e),this.useLocalCoordinates?(this.attachedObject.quaternion.copy(this.startQuaternion),this.attachedObject.quaternion.multiply(i)):(i.multiply(this.startQuaternion),this.attachedObject.quaternion.copy(i)),this.accumulatedAngle=e,this.currentAngle=t,this.updateGizmoPosition(),this.updateAngleIndicator()}createRotateGizmo(){this.arcGeometries||(this.arcGeometries={});const t=Math.PI/3;["x","y","z"].forEach(e=>{const i=new THREE.TorusGeometry(1,.03,6,32,t);this.arcGeometries[e]=i;const o=new THREE.MeshBasicMaterial({color:this.axisColors[e],transparent:!0,opacity:.8,side:THREE.DoubleSide}),n=new THREE.Mesh(i,o);n.name=`rotate_${e}`,n.userData.type="rotate",n.userData.axis=e,n.userData.isArc=!0,this.gizmoGroup.add(n)}),this.createAngleIndicator()}createAngleIndicator(){const t=new THREE.TorusGeometry(1.3,.03,6,32,2*Math.PI),e=new THREE.MeshBasicMaterial({color:16776960,transparent:!0,opacity:.9,side:THREE.DoubleSide});this.angleIndicator=new THREE.Mesh(t,e),this.angleIndicator.name="angle_indicator",this.angleIndicator.visible=!1,this.gizmoGroup.add(this.angleIndicator)}updateGizmoPosition(){if(!this.attachedObject)return;const t=new THREE.Vector3;this.attachedObject.getWorldPosition(t),this.gizmoGroup.position.copy(t),this.useLocalCoordinates?this.gizmoGroup.quaternion.copy(this.attachedObject.quaternion):this.gizmoGroup.quaternion.identity();const e=(new THREE.Box3).setFromObject(this.attachedObject),i=new THREE.Vector3;e.getSize(i),this.halfSize.copy(i).multiplyScalar(.5);const o=1.5;["x","y","z"].forEach(t=>{const e=this.gizmoGroup.getObjectByName(`rotate_${t}`);if(!e)return;let i,n=new THREE.Vector3;"x"===t?(i=Math.max(this.halfSize.y,this.halfSize.z)+o,n.set(this.halfSize.x+o,0,0),e.rotation.set(0,Math.PI/2,0)):"y"===t?(i=Math.max(this.halfSize.x,this.halfSize.z)+o,n.set(0,this.halfSize.y+o,0),e.rotation.set(Math.PI/2,0,0)):"z"===t&&(i=Math.max(this.halfSize.x,this.halfSize.y)+o,n.set(0,0,this.halfSize.z+o),e.rotation.set(0,0,0)),e.position.copy(n),e.scale.setScalar(12),this.hoveredArc===e?(e.material.color.set(16776960),e.material.opacity=1):(e.material.color.set(this.axisColors[t]),e.material.opacity=.8)}),this.angleIndicator&&this.angleIndicator.visible&&this.currentAxis&&this.updateAngleIndicator()}updateAngleIndicator(){if(!this.angleIndicator||!this.currentAxis)return;const t=this.gizmoGroup.getObjectByName(`rotate_${this.currentAxis}`);if(!t)return;this.angleIndicator.position.copy(t.position),this.angleIndicator.rotation.copy(t.rotation),this.angleIndicator.scale.copy(t.scale);let e=Math.abs(this.currentAngle%360)/360*120;const i=(new THREE.Color).setHSL(e/360,.9,.5);this.angleIndicator.material.color.copy(i),this.updateInputPosition()}updateInputPosition(){if(!this._inputContainer||!this.angleIndicator||!this.angleIndicator.visible)return;const t=new THREE.Vector3;this.angleIndicator.getWorldPosition(t);const e=this.worldToScreen(t,this.editor.camera,this.editor.renderer);this._inputContainer.style.left=e.x-60+"px",this._inputContainer.style.top=`${e.y+30}px`}worldToScreen(t,e,i){const o=t.clone();o.project(e);return{x:(.5*o.x+.5)*i.domElement.clientWidth,y:(-.5*o.y+.5)*i.domElement.clientHeight}}getPropertiesHTML(){return console.log("RotateTool: создание HTML свойств"),`\n            <div class="property-group" data-type="rotate-rotation">\n                <h4><i class="fas fa-sync-alt"></i> Вращение</h4>\n\n                <div class="property-row">\n                    <label>Локальные координаты:</label>\n                    <input type="checkbox" id="localCoordinates" ${this.useLocalCoordinates?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>X (°):</label>\n                    <input type="number" id="rotateX" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Y (°):</label>\n                    <input type="number" id="rotateY" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Z (°):</label>\n                    <input type="number" id="rotateZ" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <button id="applyRotation" class="btn-small">\n                        <i class="fas fa-check"></i> Применить вращение\n                    </button>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return void console.log("RotateTool: propertiesElement отсутствует");console.log("RotateTool: привязка событий");const t=this.propertiesElement.querySelector("#rotateX"),e=this.propertiesElement.querySelector("#rotateY"),i=this.propertiesElement.querySelector("#rotateZ"),o=this.propertiesElement.querySelector("#applyRotation"),n=this.propertiesElement.querySelector("#localCoordinates");t&&(t.addEventListener("change",t=>this.onRotationChange("x",t)),t.addEventListener("input",t=>this.onRotationChange("x",t))),e&&(e.addEventListener("change",t=>this.onRotationChange("y",t)),e.addEventListener("input",t=>this.onRotationChange("y",t))),i&&(i.addEventListener("change",t=>this.onRotationChange("z",t)),i.addEventListener("input",t=>this.onRotationChange("z",t))),o&&o.addEventListener("click",()=>this.applyRotationFromInputs()),n&&(n.checked=this.useLocalCoordinates,n.addEventListener("change",t=>{this.useLocalCoordinates=t.target.checked,this.updateGizmoPosition()}))}onRotationChange(t,e){if(!this.attachedObject)return;const i=parseFloat(e.target.value);if(isNaN(i))return;const o=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ");o[t]=THREE.MathUtils.degToRad(i),this.attachedObject.quaternion.setFromEuler(o),this.updateGizmoPosition()}applyRotationFromInputs(){if(!this.propertiesElement||!this.attachedObject)return;const t=parseFloat(this.propertiesElement.querySelector("#rotateX").value),e=parseFloat(this.propertiesElement.querySelector("#rotateY").value),i=parseFloat(this.propertiesElement.querySelector("#rotateZ").value);if(isNaN(t)||isNaN(e)||isNaN(i))return void this.editor.showStatus("Некорректные значения вращения","error");const o=this.attachedObject.quaternion.clone(),n=new THREE.Euler(THREE.MathUtils.degToRad(t),THREE.MathUtils.degToRad(e),THREE.MathUtils.degToRad(i));this.attachedObject.quaternion.setFromEuler(n),this.updateGizmoPosition(),this.editor.history.addAction({type:"modify_rotation",object:this.attachedObject.uuid,data:{rotation:n.toArray(),previousRotation:(new THREE.Euler).setFromQuaternion(o,"XYZ").toArray()}}),this.editor.showStatus(`Вращение установлено: ${t}°, ${e}°, ${i}°`,"success")}updatePropertiesValues(){if(!this.propertiesElement||!this.attachedObject)return;const t=this.propertiesElement.querySelector("#rotateX"),e=this.propertiesElement.querySelector("#rotateY"),i=this.propertiesElement.querySelector("#rotateZ"),o=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ");t&&(t.value=THREE.MathUtils.radToDeg(o.x).toFixed(2)),e&&(e.value=THREE.MathUtils.radToDeg(o.y).toFixed(2)),i&&(i.value=THREE.MathUtils.radToDeg(o.z).toFixed(2))}onMouseDown(t){if(0!==t.button)return!1;this.snapEnabled=!t.ctrlKey,this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.isArc&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(i.length>0){const e=i[0].object.userData.axis;return this.startDragging(e,t),!0}const o=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(o.length>0){const t=this.editor.objectsManager.findTopParent(o[0].object);if(this.canTransformObject(t))return this.editor.selectSingleObject(t),this.attachToObject(t),!0}return!1}onMouseMove(t){if(super.onMouseMove(t),this.isDragging)return;this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.isArc&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(this.hoveredArc&&this.hoveredArc.userData&&this.hoveredArc.userData.axis){const t=this.hoveredArc.userData.axis;this.hoveredArc.material.color.set(this.axisColors[t]),this.hoveredArc.material.opacity=.8,this.hoveredArc=null}if(i.length>0){const t=i[0].object;this.hoveredArc=t,t.material.color.set(16776960),t.material.opacity=1}}startDragging(t,e){super.startDragging(t,e),this.attachedObject&&(this.startQuaternion.copy(this.attachedObject.quaternion),this.accumulatedAngle=0,this.currentAngle=0,this._currentDragAxis=t,this._isDragging=!0,this.gizmoGroup.getWorldPosition(this.gizmoWorldPosition),this.rotationAxis=new THREE.Vector3,"x"===t?this.rotationAxis.set(1,0,0):"y"===t?this.rotationAxis.set(0,1,0):"z"===t&&this.rotationAxis.set(0,0,1),this.useLocalCoordinates&&this.rotationAxis.applyQuaternion(this.attachedObject.quaternion),this.rotationPlane=new THREE.Plane,this.rotationPlane.setFromNormalAndCoplanarPoint(this.rotationAxis.clone().normalize(),this.gizmoWorldPosition),this.startProjection=this.getPlaneIntersection(e),this.startProjection&&(this.startVector=(new THREE.Vector3).subVectors(this.startProjection,this.gizmoWorldPosition).normalize()),this.angleIndicator&&(this.angleIndicator.visible=!0,this.updateAngleIndicator()),this._inputContainer&&(this._inputContainer.style.display="block",this._inputElement.value="0.0","x"===t?this._inputContainer.style.borderColor="#ff4444":"y"===t?this._inputContainer.style.borderColor="#44ff44":"z"===t&&(this._inputContainer.style.borderColor="#4444ff"),this.updateInputPosition()))}getPlaneIntersection(t){if(!this.rotationPlane)return null;const e=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((t.clientX-e.left)/e.width*2-1,-(t.clientY-e.top)/e.height*2+1),o=new THREE.Raycaster;o.setFromCamera(i,this.editor.camera);const n=new THREE.Vector3;return o.ray.intersectPlane(this.rotationPlane,n)?n:null}handleTransform(t,e){if(!(this.attachedObject&&this.currentAxis&&this.rotationPlane&&this.startVector))return;const i={clientX:this.startMouse.x+t,clientY:this.startMouse.y+e},o=this.getPlaneIntersection(i);if(!o)return;const n=(new THREE.Vector3).subVectors(o,this.gizmoWorldPosition).normalize(),s=this.startVector.dot(n),r=(new THREE.Vector3).crossVectors(this.startVector,n),a=Math.atan2(r.dot(this.rotationAxis),s);let h=a;if(this.snapEnabled&&!this.editor.spacePressed){const t=THREE.MathUtils.radToDeg(a),e=Math.round(t/this.rotateSnapValue)*this.rotateSnapValue;h=THREE.MathUtils.degToRad(e)}if(!(Math.abs(h)<.001)){if(this.accumulatedAngle+=h,this.currentAngle=THREE.MathUtils.radToDeg(this.accumulatedAngle),this.useLocalCoordinates){let t=new THREE.Vector3;"x"===this.currentAxis?t.set(1,0,0):"y"===this.currentAxis?t.set(0,1,0):"z"===this.currentAxis&&t.set(0,0,1);const e=new THREE.Quaternion;e.setFromAxisAngle(t.normalize(),this.accumulatedAngle),this.attachedObject.quaternion.copy(this.startQuaternion),this.attachedObject.quaternion.multiply(e)}else{let t=new THREE.Vector3;"x"===this.currentAxis?t.set(1,0,0):"y"===this.currentAxis?t.set(0,1,0):"z"===this.currentAxis&&t.set(0,0,1);const e=new THREE.Quaternion;e.setFromAxisAngle(t.normalize(),this.accumulatedAngle),this.attachedObject.quaternion.copy(e),this.attachedObject.quaternion.multiply(this.startQuaternion)}this.startVector.copy(n),this.updateAngleIndicator(),!this._isInputFocused&&this._inputElement&&(this._inputElement.value=this.currentAngle.toFixed(1))}}onMouseUp(t){super.onMouseUp(t),this._isDragging=!1,this.angleIndicator&&(this.angleIndicator.visible=!1)}detach(){this._inputContainer&&(this._inputContainer.style.display="none"),this.angleIndicator&&(this.angleIndicator.visible=!1),this._currentDragAxis=null,this._isDragging=!1,this.hoveredArc=null,super.detach()}onDeactivate(){this._inputContainer&&(this._inputContainer.style.display="none"),this.angleIndicator&&(this.angleIndicator.visible=!1),this._currentDragAxis=null,this._isDragging=!1,this.hoveredArc=null,super.onDeactivate()}getTooltipContent(){if(!this.attachedObject)return"";const t=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ");return`\n            <div style="font-weight: 600; margin-bottom: 6px; color: #fff;">Вращение объекта (°):</div>\n\n            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">\n                <div style="color: #ff6b6b;">\n                    <div style="font-size: 10px; opacity: 0.8;">X</div>\n                    <div>${THREE.MathUtils.radToDeg(t.x).toFixed(1)}</div>\n                </div>\n                <div style="color: #51cf66;">\n                    <div style="font-size: 10px; opacity: 0.8;">Y</div>\n                    <div>${THREE.MathUtils.radToDeg(t.y).toFixed(1)}</div>\n                </div>\n                <div style="color: #339af0;">\n                    <div style="font-size: 10px; opacity: 0.8;">Z</div>\n                    <div>${THREE.MathUtils.radToDeg(t.z).toFixed(1)}</div>\n                </div>\n            </div>\n            <div style="margin-top: 8px; font-size: 10px; opacity: 0.7; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px;">\n                Режим: ${this.useLocalCoordinates?"локальные":"глобальные"} |\n                Ctrl: ${this.snapEnabled?"с привязкой":"без привязки"}\n            </div>\n        `}createHistoryAction(){if(!this.attachedObject||!this.attachedObject.userData.transformStartState)return null;const t=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ"),e=(new THREE.Euler).setFromQuaternion(this.attachedObject.userData.transformStartState.rotation,"XYZ");return{type:"modify_rotation",object:this.attachedObject.uuid,data:{rotation:t.toArray(),previousRotation:e.toArray()}}}getHistoryActionType(){return"modify_rotation"}}