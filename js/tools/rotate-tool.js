class RotateTool extends TransformToolBase{constructor(t){super("rotate","fa-sync-alt",t),this.startQuaternion=new THREE.Quaternion,this.useLocalCoordinates=!1,this.accumulatedAngle=0,this.gizmoWorldPosition=new THREE.Vector3,this.rotationPlane=null,this.startVector=null,this.hoveredArc=null,this.angleIndicator=null,this.currentAngle=0,this.arcGeometries={},this.halfSize=new THREE.Vector3,this.initGizmo()}initGizmo(){for(;this.gizmoGroup.children.length>0;){const t=this.gizmoGroup.children[0];t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose(),this.gizmoGroup.remove(t)}this.createRotateGizmo(),this.gizmoGroup.visible=!1}createRotateGizmo(){this.arcGeometries||(this.arcGeometries={});const t=Math.PI/3;["x","y","z"].forEach(e=>{const i=new THREE.TorusGeometry(1,.03,6,32,t);this.arcGeometries[e]=i;const o=new THREE.MeshBasicMaterial({color:this.axisColors[e],transparent:!0,opacity:.8,side:THREE.DoubleSide}),s=new THREE.Mesh(i,o);s.name=`rotate_${e}`,s.userData.type="rotate",s.userData.axis=e,s.userData.isArc=!0,this.gizmoGroup.add(s)}),this.createAngleIndicator()}createAngleIndicator(){const t=new THREE.TorusGeometry(1.3,.03,6,32,2*Math.PI),e=new THREE.MeshBasicMaterial({color:16776960,transparent:!0,opacity:.9,side:THREE.DoubleSide});this.angleIndicator=new THREE.Mesh(t,e),this.angleIndicator.name="angle_indicator",this.angleIndicator.visible=!1,this.angleText=null,this.gizmoGroup.add(this.angleIndicator)}updateGizmoPosition(){if(!this.attachedObject)return;const t=new THREE.Vector3;this.attachedObject.getWorldPosition(t),this.gizmoGroup.position.copy(t),this.useLocalCoordinates?this.gizmoGroup.quaternion.copy(this.attachedObject.quaternion):this.gizmoGroup.quaternion.identity();const e=(new THREE.Box3).setFromObject(this.attachedObject),i=new THREE.Vector3;e.getSize(i),this.halfSize.copy(i).multiplyScalar(.5);const o=1.5;["x","y","z"].forEach(t=>{const e=this.gizmoGroup.getObjectByName(`rotate_${t}`);if(!e)return;let i,s=new THREE.Vector3;"x"===t?(i=Math.max(this.halfSize.y,this.halfSize.z)+o,s.set(this.halfSize.x+o,0,0),e.rotation.set(0,Math.PI/2,0)):"y"===t?(i=Math.max(this.halfSize.x,this.halfSize.z)+o,s.set(0,this.halfSize.y+o,0),e.rotation.set(Math.PI/2,0,0)):"z"===t&&(i=Math.max(this.halfSize.x,this.halfSize.y)+o,s.set(0,0,this.halfSize.z+o),e.rotation.set(0,0,0)),e.position.copy(s),e.scale.setScalar(12),this.hoveredArc===e?(e.material.color.set(16776960),e.material.opacity=1):(e.material.color.set(this.axisColors[t]),e.material.opacity=.8)}),this.angleIndicator&&this.angleIndicator.visible&&this.currentAxis&&this.updateAngleIndicator()}updateAngleIndicator(){if(!this.angleIndicator||!this.currentAxis)return;const t=this.gizmoGroup.getObjectByName(`rotate_${this.currentAxis}`);if(!t)return;this.angleIndicator.position.copy(t.position),this.angleIndicator.rotation.copy(t.rotation),this.angleIndicator.scale.copy(t.scale);let e=Math.abs(this.currentAngle%360)/360*120;const i=(new THREE.Color).setHSL(e/360,.9,.5);this.angleIndicator.material.color.copy(i),this.angleText&&this.angleText.parent&&(this.angleText.parent.remove(this.angleText),this.angleText=null);const o=document.createElement("canvas"),s=o.getContext("2d");o.width=256,o.height=128,s.clearRect(0,0,o.width,o.height),s.fillStyle="#ffffff",s.font="68px Arial",s.textAlign="center",s.textBaseline="middle";const a=`${Math.abs(this.currentAngle).toFixed(1)}°`;s.fillText(a,o.width/2,o.height/2);const r=new THREE.CanvasTexture(o);r.needsUpdate=!0;const n=new THREE.SpriteMaterial({map:r,transparent:!0,opacity:.9,depthTest:!1});this.angleText=new THREE.Sprite(n),this.angleText.scale.set(10,5.5,1);const c=new THREE.Vector3;this.angleIndicator.getWorldPosition(c);const h=(new THREE.Vector3).subVectors(this.editor.camera.position,c).normalize(),l=c.clone().add(h.multiplyScalar(3));l.y+=2,this.angleText.position.copy(l),this.angleText.lookAt(this.editor.camera.position),this.editor.scene.add(this.angleText)}getPropertiesHTML(){return console.log("RotateTool: создание HTML свойств"),`\n            <div class="property-group" data-type="rotate-rotation">\n                <h4><i class="fas fa-sync-alt"></i> Вращение</h4>\n\n                <div class="property-row">\n                    <label>Локальные координаты:</label>\n                    <input type="checkbox" id="localCoordinates" ${this.useLocalCoordinates?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>X (°):</label>\n                    <input type="number" id="rotateX" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Y (°):</label>\n                    <input type="number" id="rotateY" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Z (°):</label>\n                    <input type="number" id="rotateZ" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <button id="applyRotation" class="btn-small">\n                        <i class="fas fa-check"></i> Применить вращение\n                    </button>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return void console.log("RotateTool: propertiesElement отсутствует");console.log("RotateTool: привязка событий");const t=this.propertiesElement.querySelector("#rotateX"),e=this.propertiesElement.querySelector("#rotateY"),i=this.propertiesElement.querySelector("#rotateZ"),o=this.propertiesElement.querySelector("#applyRotation"),s=this.propertiesElement.querySelector("#localCoordinates");t&&(t.addEventListener("change",t=>this.onRotationChange("x",t)),t.addEventListener("input",t=>this.onRotationChange("x",t))),e&&(e.addEventListener("change",t=>this.onRotationChange("y",t)),e.addEventListener("input",t=>this.onRotationChange("y",t))),i&&(i.addEventListener("change",t=>this.onRotationChange("z",t)),i.addEventListener("input",t=>this.onRotationChange("z",t))),o&&o.addEventListener("click",()=>this.applyRotationFromInputs()),s&&(s.checked=this.useLocalCoordinates,s.addEventListener("change",t=>{this.useLocalCoordinates=t.target.checked,this.updateGizmoPosition()}))}onRotationChange(t,e){if(!this.attachedObject)return;const i=parseFloat(e.target.value);if(isNaN(i))return;const o=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ");o[t]=THREE.MathUtils.degToRad(i),this.attachedObject.quaternion.setFromEuler(o),this.updateGizmoPosition()}applyRotationFromInputs(){if(!this.propertiesElement||!this.attachedObject)return;const t=parseFloat(this.propertiesElement.querySelector("#rotateX").value),e=parseFloat(this.propertiesElement.querySelector("#rotateY").value),i=parseFloat(this.propertiesElement.querySelector("#rotateZ").value);if(isNaN(t)||isNaN(e)||isNaN(i))return void this.editor.showStatus("Некорректные значения вращения","error");const o=this.attachedObject.quaternion.clone(),s=new THREE.Euler(THREE.MathUtils.degToRad(t),THREE.MathUtils.degToRad(e),THREE.MathUtils.degToRad(i));this.attachedObject.quaternion.setFromEuler(s),this.updateGizmoPosition(),this.editor.history.addAction({type:"modify_rotation",object:this.attachedObject.uuid,data:{rotation:s.toArray(),previousRotation:(new THREE.Euler).setFromQuaternion(o,"XYZ").toArray()}}),this.editor.showStatus(`Вращение установлено: ${t}°, ${e}°, ${i}°`,"success")}updatePropertiesValues(){if(!this.propertiesElement||!this.attachedObject)return;const t=this.propertiesElement.querySelector("#rotateX"),e=this.propertiesElement.querySelector("#rotateY"),i=this.propertiesElement.querySelector("#rotateZ"),o=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ");t&&(t.value=THREE.MathUtils.radToDeg(o.x).toFixed(2)),e&&(e.value=THREE.MathUtils.radToDeg(o.y).toFixed(2)),i&&(i.value=THREE.MathUtils.radToDeg(o.z).toFixed(2))}onMouseDown(t){if(0!==t.button)return!1;this.snapEnabled=!t.ctrlKey,this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.isArc&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(i.length>0){const e=i[0].object.userData.axis;return this.startDragging(e,t),!0}const o=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(o.length>0){const t=this.editor.objectsManager.findTopParent(o[0].object);if(this.canTransformObject(t))return this.editor.selectSingleObject(t),this.attachToObject(t),!0}return!1}onMouseMove(t){if(super.onMouseMove(t),this.isDragging)return;this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.isArc&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(this.hoveredArc&&this.hoveredArc.userData&&this.hoveredArc.userData.axis){const t=this.hoveredArc.userData.axis;this.hoveredArc.material.color.set(this.axisColors[t]),this.hoveredArc.material.opacity=.8,this.hoveredArc=null}if(i.length>0){const t=i[0].object;this.hoveredArc=t,t.material.color.set(16776960),t.material.opacity=1}}startDragging(t,e){super.startDragging(t,e),this.attachedObject&&(this.startQuaternion.copy(this.attachedObject.quaternion),this.accumulatedAngle=0,this.currentAngle=0,this.gizmoGroup.getWorldPosition(this.gizmoWorldPosition),this.rotationAxis=new THREE.Vector3,"x"===t?this.rotationAxis.set(1,0,0):"y"===t?this.rotationAxis.set(0,1,0):"z"===t&&this.rotationAxis.set(0,0,1),this.useLocalCoordinates&&this.rotationAxis.applyQuaternion(this.attachedObject.quaternion),this.rotationPlane=new THREE.Plane,this.rotationPlane.setFromNormalAndCoplanarPoint(this.rotationAxis.clone().normalize(),this.gizmoWorldPosition),this.startProjection=this.getPlaneIntersection(e),this.startProjection&&(this.startVector=(new THREE.Vector3).subVectors(this.startProjection,this.gizmoWorldPosition).normalize()),this.angleIndicator&&(this.angleIndicator.visible=!0,this.updateAngleIndicator()))}getPlaneIntersection(t){if(!this.rotationPlane)return null;const e=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((t.clientX-e.left)/e.width*2-1,-(t.clientY-e.top)/e.height*2+1),o=new THREE.Raycaster;o.setFromCamera(i,this.editor.camera);const s=new THREE.Vector3;return o.ray.intersectPlane(this.rotationPlane,s)?s:null}handleTransform(t,e){if(!(this.attachedObject&&this.currentAxis&&this.rotationPlane&&this.startVector))return;const i={clientX:this.startMouse.x+t,clientY:this.startMouse.y+e},o=this.getPlaneIntersection(i);if(!o)return;const s=(new THREE.Vector3).subVectors(o,this.gizmoWorldPosition).normalize(),a=this.startVector.dot(s),r=(new THREE.Vector3).crossVectors(this.startVector,s),n=Math.atan2(r.dot(this.rotationAxis),a);let c=n;if(this.snapEnabled&&!this.editor.spacePressed){const t=THREE.MathUtils.radToDeg(n),e=Math.round(t/this.rotateSnapValue)*this.rotateSnapValue;c=THREE.MathUtils.degToRad(e)}if(!(Math.abs(c)<.001)){if(this.accumulatedAngle+=c,this.currentAngle=THREE.MathUtils.radToDeg(this.accumulatedAngle),this.useLocalCoordinates){let t=new THREE.Vector3;"x"===this.currentAxis?t.set(1,0,0):"y"===this.currentAxis?t.set(0,1,0):"z"===this.currentAxis&&t.set(0,0,1);const e=new THREE.Quaternion;e.setFromAxisAngle(t.normalize(),this.accumulatedAngle),this.attachedObject.quaternion.copy(this.startQuaternion),this.attachedObject.quaternion.multiply(e)}else{let t=new THREE.Vector3;"x"===this.currentAxis?t.set(1,0,0):"y"===this.currentAxis?t.set(0,1,0):"z"===this.currentAxis&&t.set(0,0,1);const e=new THREE.Quaternion;e.setFromAxisAngle(t.normalize(),this.accumulatedAngle),this.attachedObject.quaternion.copy(e),this.attachedObject.quaternion.multiply(this.startQuaternion)}this.startVector.copy(s),this.updateAngleIndicator()}}onMouseUp(t){super.onMouseUp(t),this.angleIndicator&&(this.angleIndicator.visible=!1),this.angleText&&this.angleText.parent&&(this.angleText.parent.remove(this.angleText),this.angleText=null)}getTooltipContent(){if(!this.attachedObject)return"";const t=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ"),e=THREE.MathUtils.radToDeg(t.x).toFixed(1),i=THREE.MathUtils.radToDeg(t.y).toFixed(1),o=THREE.MathUtils.radToDeg(t.z).toFixed(1);let s="";if(this.isDragging&&this.currentAxis){const t={x:"X",y:"Y",z:"Z"},e={x:"#ff6b6b",y:"#51cf66",z:"#339af0"};s=`\n                <div style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; border-left: 3px solid ${e[this.currentAxis]}">\n                    <div style="font-size: 11px; opacity: 0.8;">Текущее вращение:</div>\n                    <div style="font-size: 16px; font-weight: bold; color: ${e[this.currentAxis]}">\n                        ${this.currentAngle.toFixed(1)}° ${this.currentAngle>=0?"↻":"↺"}\n                    </div>\n                    <div style="font-size: 10px; opacity: 0.7;">Вокруг оси ${t[this.currentAxis]}</div>\n                </div>\n            `}return`\n            <div style="font-weight: 600; margin-bottom: 6px; color: #fff;">Вращение объекта (°):</div>\n            ${s}\n            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">\n                <div style="color: #ff6b6b;">\n                    <div style="font-size: 10px; opacity: 0.8;">X</div>\n                    <div>${e}</div>\n                </div>\n                <div style="color: #51cf66;">\n                    <div style="font-size: 10px; opacity: 0.8;">Y</div>\n                    <div>${i}</div>\n                </div>\n                <div style="color: #339af0;">\n                    <div style="font-size: 10px; opacity: 0.8;">Z</div>\n                    <div>${o}</div>\n                </div>\n            </div>\n            <div style="margin-top: 8px; font-size: 10px; opacity: 0.7; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px;">\n                Режим: ${this.useLocalCoordinates?"локальные":"глобальные"} |\n                Ctrl: ${this.snapEnabled?"с привязкой":"без привязки"}\n            </div>\n        `}createHistoryAction(){if(!this.attachedObject||!this.attachedObject.userData.transformStartState)return null;const t=(new THREE.Euler).setFromQuaternion(this.attachedObject.quaternion,"XYZ"),e=(new THREE.Euler).setFromQuaternion(this.attachedObject.userData.transformStartState.rotation,"XYZ");return{type:"modify_rotation",object:this.attachedObject.uuid,data:{rotation:t.toArray(),previousRotation:e.toArray()}}}getHistoryActionType(){return"modify_rotation"}}