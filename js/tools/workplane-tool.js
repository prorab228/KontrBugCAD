class WorkPlaneTool extends Tool{constructor(e){super("workplane","fa-square",e),this.planesManager=e.planesManager,this.workPlaneMode=null,this.faceSelectionObject=null,this.tempWorkPlane=null,this.hoveredPlane=null,this.hoveredObject=null,this.currentIntersection=null;const t=localStorage.getItem("cad-face-grouping");null!==t&&this.editor.planesManager.setFaceGroupingEnabled("true"===t)}createWorkPlane(){this.workPlaneMode="active",this.editor.basePlanes&&(this.editor.basePlanes.visible=!0),this.editor.showStatus("Выберите базовую плоскость (XY, XZ, YZ) или грань любого объекта для создания рабочей плоскости","info")}handleSelection(e){if(this.currentIntersection&&this.currentIntersection.face)return this.planesManager.enableFaceGrouping?this.createWorkPlaneOnFaceCenter(this.currentIntersection):this.createWorkPlaneAtIntersectionPoint(this.currentIntersection);this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.basePlanes?this.editor.basePlanes.children:[],r=this.editor.raycaster.intersectObjects(t);if(r.length>0){const e=r[0].object;return this.createWorkPlaneOnBasePlane(e)}const i=this.getAllSelectableObjects(),o=this.editor.raycaster.intersectObjects(i,!0);if(o.length>0){const e=o[0];return this.planesManager.enableFaceGrouping?this.createWorkPlaneOnFaceCenter(e):this.createWorkPlaneAtIntersectionPoint(e)}return!1}createWorkPlaneOnFaceCenter(e){const t=this.planesManager.createWorkPlaneOnFaceIntersection(e);return!!t&&(this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.workPlanes.push(t),this.editor.history&&this.editor.history.addAction({type:"create",object:t.uuid,data:this.editor.projectManager.serializeObjectForHistory(t)}),this.exitWorkPlaneMode(),this.editor.clearSelection(),this.editor.selectSingleObject(t),this.editor.showStatus("Создана рабочая плоскость по центру грани объекта","success"),!0)}createWorkPlaneAtIntersectionPoint(e){if(!e||!e.face)return console.warn("Нет данных о грани для создания плоскости в точке указателя"),!1;const t=e.object,r=e.point;let i=e.face.normal.clone();if(t.matrixWorld){const e=(new THREE.Matrix3).getNormalMatrix(t.matrixWorld);i.applyMatrix3(e).normalize()}const o=new THREE.Vector3;t.getWorldPosition(o);o.clone().sub(r).normalize();let s=new THREE.Vector3(0,1,0);if(Math.abs(i.y)>.9)s=new THREE.Vector3(1,0,0);else{s=new THREE.Vector3(0,1,0);const e=s.clone().projectOnPlane(i).normalize();s=e.length()<.1?new THREE.Vector3(1,0,0).projectOnPlane(i).normalize():e}const n={position:r,normal:i,up:s,name:"Рабочая плоскость (в точке указателя)",planeType:"face_point"},a=this.planesManager.createWorkPlaneObject(n);return!!a&&(a.userData.parentObject=t.uuid,a.userData.intersectionPoint=r.clone(),a.userData.faceNormal=i.clone(),this.editor.objectsGroup.add(a),this.editor.objects.push(a),this.editor.workPlanes.push(a),this.editor.history&&this.editor.history.addAction({type:"create",object:a.uuid,data:this.editor.projectManager.serializeObjectForHistory(a)}),this.exitWorkPlaneMode(),this.editor.clearSelection(),this.editor.selectSingleObject(a),this.editor.showStatus("Создана рабочая плоскость в точке указателя","success"),!0)}handleHighlight(e){this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera),this.resetPreviousHighlight();let t=!1;const r=this.editor.basePlanes?this.editor.basePlanes.children:[],i=this.editor.raycaster.intersectObjects(r);if(i.length>0){t=!0;const e=i[0].object;return this.hoveredPlane=e,e.material.opacity=.4,void(document.body.style.cursor="pointer")}const o=this.getAllSelectableObjects(),s=this.editor.raycaster.intersectObjects(o,!0);if(s.length>0){t=!0;const e=s[0];this.currentIntersection=e,this.createOrUpdateTempWorkPlane(e);let r=e.object;for(;r.parent&&r.parent!==this.editor.objectsGroup&&"Scene"!==r.parent.type;)r=r.parent;return this.hoveredObject=r,this.editor.objectsManager.highlightSingleObject(r),void(document.body.style.cursor="pointer")}t||(document.body.style.cursor="default",this.currentIntersection=null)}getAllSelectableObjects(){return this.faceSelectionObject?[this.faceSelectionObject]:this.editor.objectsGroup.children.filter(e=>{const t=e.userData?.type;return!("work_plane"===t||"sketch_plane"===t||"base_plane"===t)&&e.isMesh&&e.geometry&&e.geometry.attributes&&e.geometry.attributes.position})}createWorkPlaneOnBasePlane(e){const t=this.planesManager.createWorkPlaneObject(e.userData.planeType.toUpperCase());return t.position.copy(e.position),t.quaternion.copy(e.quaternion),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.workPlanes.push(t),this.editor.history&&this.editor.history.addAction({type:"create",object:t.uuid,data:this.editor.projectManager.serializeObjectForHistory(t)}),this.exitWorkPlaneMode(),this.editor.clearSelection(),this.editor.selectSingleObject(t),this.editor.showStatus(`Создана рабочая плоскость на ${e.userData.planeType.toUpperCase()}`,"success"),!0}createOrUpdateTempWorkPlane(e){if(!e||!e.face)return void(this.tempWorkPlane&&(this.editor.objectsGroup.remove(this.tempWorkPlane),this.tempWorkPlane.geometry.dispose(),this.tempWorkPlane.material.dispose(),this.tempWorkPlane=null));const t=e.object,r=e.point;let i,o=e.face.normal.clone();if(t.matrixWorld){const e=(new THREE.Matrix3).getNormalMatrix(t.matrixWorld);o.applyMatrix3(e).normalize()}i=this.planesManager.enableFaceGrouping?this.planesManager.getFaceCenter(t,e.faceIndex):r.clone();const s=new THREE.Vector3;t.getWorldPosition(s);s.clone().sub(r).normalize();let n=new THREE.Vector3(0,1,0);if(Math.abs(o.y)>.9)n=new THREE.Vector3(1,0,0);else{n=new THREE.Vector3(0,1,0);const e=n.clone().projectOnPlane(o).normalize();n=e.length()<.1?new THREE.Vector3(1,0,0).projectOnPlane(o).normalize():e}if(!this.tempWorkPlane){const e=new THREE.PlaneGeometry(30,30),t=new THREE.MeshBasicMaterial({color:16750592,transparent:!0,opacity:.4,side:THREE.DoubleSide,depthWrite:!1,depthTest:!0});this.tempWorkPlane=new THREE.Mesh(e,t),this.editor.objectsGroup.add(this.tempWorkPlane)}this.tempWorkPlane.position.copy(i);const a=new THREE.Vector3(0,0,1),l=new THREE.Quaternion,c=a.dot(o);if(Math.abs(c+1)<1e-4)l.setFromAxisAngle(new THREE.Vector3(1,0,0),Math.PI);else if(Math.abs(c-1)<1e-4)l.identity();else{const e=(new THREE.Vector3).crossVectors(a,o).normalize(),t=Math.acos(a.dot(o));l.setFromAxisAngle(e,t)}this.tempWorkPlane.quaternion.copy(l);const h=o.clone().multiplyScalar(.01);this.tempWorkPlane.position.add(h),this.planesManager.enableFaceGrouping?this.tempWorkPlane.material.color.setHex(16750592):this.tempWorkPlane.material.color.setHex(2201331)}resetPreviousHighlight(){this.hoveredPlane&&(this.hoveredPlane.material.opacity=.1,this.hoveredPlane=null),this.hoveredObject&&(this.editor.objectsManager.unhighlightObject(this.hoveredObject),this.hoveredObject=null),this.tempWorkPlane&&(this.editor.objectsGroup.remove(this.tempWorkPlane),this.tempWorkPlane.geometry.dispose(),this.tempWorkPlane.material.dispose(),this.tempWorkPlane=null)}exitWorkPlaneMode(){this.workPlaneMode=null,this.faceSelectionObject=null,this.currentIntersection=null,this.editor.basePlanes&&(this.editor.basePlanes.visible=!1),this.resetPreviousHighlight(),this.editor.showStatus("Режим создания рабочей плоскости завершен","info")}startWorkPlaneFaceSelection(){return 1===this.editor.selectedObjects.length&&"work_plane"!==this.editor.selectedObjects[0].userData.type&&"sketch_plane"!==this.editor.selectedObjects[0].userData.type&&"base_plane"!==this.editor.selectedObjects[0].userData.type&&(this.faceSelectionObject=this.editor.selectedObjects[0],this.workPlaneMode="active",this.editor.basePlanes&&(this.editor.basePlanes.visible=!1),this.editor.showStatus("Выберите грань выделенного объекта для создания рабочей плоскости","info"),!0)}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","workplane"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="workplane"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <div class="property-group" data-type="workplane-settings">\n                <h4>РАБОЧАЯ ПЛОСКОСТЬ</h4>\n                <div class="property-row">\n                    <h5>Настройки создания на грани</h5>\n                </div>\n                <div class="property-row">\n                    <label>Центрировать по всей грани (группировка полигонов):</label>\n                    <input type="checkbox" id="faceGroupingEnabled" ${this.editor.planesManager.enableFaceGrouping?"checked":""}>\n                </div>\n                <div class="property-row">\n                    <p style="font-size: 12px; color: #888; margin-top: 5px;">\n                        Если <strong>включено</strong>: плоскость создается по центру всей грани (объединение смежных полигонов).<br>\n                        Если <strong>выключено</strong>: плоскость создается в точке указателя (месте пересечения).\n                    </p>\n                </div>\n                <div class="property-row">\n                    <div style="display: flex; gap: 10px; margin-top: 10px;">\n                        <div style="display: flex; align-items: center;">\n                            <div style="width: 15px; height: 15px; background-color: #FF9800; margin-right: 5px;"></div>\n                            <span style="font-size: 12px;">Центр грани</span>\n                        </div>\n                        <div style="display: flex; align-items: center;">\n                            <div style="width: 15px; height: 15px; background-color: #2196F3; margin-right: 5px;"></div>\n                            <span style="font-size: 12px;">Точка указателя</span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#faceGroupingEnabled");e&&e.addEventListener("change",e=>{const t=e.target.checked;this.editor.planesManager.setFaceGroupingEnabled(t),localStorage.setItem("cad-face-grouping",t?"true":"false");const r=t?"Центрирование по всей грани: ВКЛ (плоскость создается по центру грани)":"Центрирование по всей грани: ВЫКЛ (плоскость создается в точке указателя)";this.editor.showStatus(r,"info")})}onActivate(){return this.createPropertiesSection(),1===this.editor.selectedObjects.length&&"work_plane"!==this.editor.selectedObjects[0].userData.type&&"sketch_plane"!==this.editor.selectedObjects[0].userData.type&&"base_plane"!==this.editor.selectedObjects[0].userData.type?(this.faceSelectionObject=this.editor.selectedObjects[0],this.workPlaneMode="active",this.editor.basePlanes&&(this.editor.basePlanes.visible=!1),this.editor.showStatus("Выберите грань выделенного объекта для создания рабочей плоскости","info")):this.createWorkPlane(),!0}onDeactivate(){this.exitWorkPlaneMode(),this.removePropertiesSection()}onMouseDown(e){return!("active"!==this.workPlaneMode||!this.handleSelection(e))&&(this.editor.toolManager.setCurrentTool("select"),!0)}onMouseMove(e){"active"===this.workPlaneMode&&this.handleHighlight(e)}onKeyDown(e){return!("Escape"!==e.key||!this.workPlaneMode)&&(this.editor.toolManager.setCurrentTool("select"),!0)}}