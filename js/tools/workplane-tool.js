class WorkPlaneTool extends Tool{constructor(e){super("workplane","fa-square",e),this.planesManager=e.planesManager,this.workPlaneMode=null,this.faceSelectionObject=null,this.tempWorkPlane=null,this.hoveredPlane=null,this.hoveredObject=null,this.currentIntersection=null;const t=localStorage.getItem("cad-face-grouping");null!==t&&this.editor.planesManager.setFaceGroupingEnabled("true"===t)}createWorkPlane(){this.workPlaneMode="active",this.editor.basePlanes&&(this.editor.basePlanes.visible=!0),this.editor.showStatus("Выберите базовую плоскость (XY, XZ, YZ) или грань любого объекта для создания рабочей плоскости","info")}handleSelection(e){if(this.currentIntersection&&this.currentIntersection.face)return this.planesManager.enableFaceGrouping?this.createWorkPlaneOnFaceCenter(this.currentIntersection):this.createWorkPlaneAtIntersectionPoint(this.currentIntersection);this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.basePlanes?this.editor.basePlanes.children:[],r=this.editor.raycaster.intersectObjects(t);if(r.length>0){const e=r[0].object;return this.createWorkPlaneOnBasePlane(e)}const n=this.getAllSelectableObjects(),o=this.editor.raycaster.intersectObjects(n,!0);if(o.length>0){const e=o[0];return this.planesManager.enableFaceGrouping?this.createWorkPlaneOnFaceCenter(e):this.createWorkPlaneAtIntersectionPoint(e)}return!1}createWorkPlaneOnFaceCenter(e){const t=this.planesManager.createWorkPlaneOnFaceIntersection(e);if(!t)return!1;const r=new ParametricOperation("create_workplane",{position:t.position.toArray(),normal:t.userData.faceNormal.toArray(),up:t.userData.originalUp.toArray(),name:"Рабочая плоскость (центр грани)",planeType:"face_center",parentObject:e.object.uuid,faceIndex:e.faceIndex},[]);return this.editor.parametricModel.addOperation(r),this.exitWorkPlaneMode(),this.editor.showStatus("Создана рабочая плоскость по центру грани объекта","success"),!0}createWorkPlaneAtIntersectionPoint(e){if(!e||!e.face)return!1;const t=e.object,r=e.point;let n=e.face.normal.clone();if(t.matrixWorld){const e=(new THREE.Matrix3).getNormalMatrix(t.matrixWorld);n.applyMatrix3(e).normalize()}let o=new THREE.Vector3(0,1,0);if(Math.abs(n.y)>.9)o=new THREE.Vector3(1,0,0);else{const e=o.clone().projectOnPlane(n).normalize();o=e.length()<.1?new THREE.Vector3(1,0,0).projectOnPlane(n).normalize():e}const i=new ParametricOperation("create_workplane",{position:r.toArray(),normal:n.toArray(),up:o.toArray(),name:"Рабочая плоскость (точка указателя)",planeType:"face_point",parentObject:t.uuid,faceIndex:e.faceIndex},[]);return this.editor.parametricModel.addOperation(i),this.exitWorkPlaneMode(),this.editor.showStatus("Создана рабочая плоскость в точке указателя","success"),!0}createWorkPlaneOnBasePlane(e){const t=e.userData.normal?e.userData.normal:new THREE.Vector3(0,0,1),r=e.userData.up?e.userData.up:new THREE.Vector3(0,1,0),n=new ParametricOperation("create_workplane",{position:e.position.toArray(),normal:t.toArray(),up:r.toArray(),name:`Рабочая плоскость на ${e.userData.planeType}`,planeType:e.userData.planeType},[]);return this.editor.parametricModel.addOperation(n),this.exitWorkPlaneMode(),this.editor.showStatus(`Создана рабочая плоскость на ${e.userData.planeType}`,"success"),!0}handleHighlight(e){this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera),this.resetPreviousHighlight();let t=!1;const r=this.editor.basePlanes?this.editor.basePlanes.children:[],n=this.editor.raycaster.intersectObjects(r);if(n.length>0){t=!0;const e=n[0].object;return this.hoveredPlane=e,e.material.opacity=.4,void(document.body.style.cursor="pointer")}const o=this.getAllSelectableObjects(),i=this.editor.raycaster.intersectObjects(o,!0);if(i.length>0)return t=!0,this.currentIntersection=i[0],this.createOrUpdateTempWorkPlane(this.currentIntersection),void(document.body.style.cursor="pointer");t||(document.body.style.cursor="default",this.currentIntersection=null)}getAllSelectableObjects(){return this.faceSelectionObject?[this.faceSelectionObject]:this.editor.objectsGroup.children.filter(e=>{const t=e.userData?.type;return!("work_plane"===t||"sketch_plane"===t||"base_plane"===t)&&e.isMesh&&e.geometry})}createOrUpdateTempWorkPlane(e){if(!e||!e.face)return void(this.tempWorkPlane&&(this.editor.objectsGroup.remove(this.tempWorkPlane),this.tempWorkPlane.geometry.dispose(),this.tempWorkPlane.material.dispose(),this.tempWorkPlane=null));const t=e.object,r=e.point;let n,o=e.face.normal.clone();if(t.matrixWorld){const e=(new THREE.Matrix3).getNormalMatrix(t.matrixWorld);o.applyMatrix3(e).normalize()}n=this.planesManager.enableFaceGrouping?this.planesManager.getFaceCenter(t,e.faceIndex):r.clone();let i=new THREE.Vector3(0,1,0);if(Math.abs(o.y)>.9)i=new THREE.Vector3(1,0,0);else{const e=i.clone().projectOnPlane(o).normalize();i=e.length()<.1?new THREE.Vector3(1,0,0).projectOnPlane(o).normalize():e}if(!this.tempWorkPlane){const e=new THREE.PlaneGeometry(30,30),t=new THREE.MeshBasicMaterial({color:16750592,transparent:!0,opacity:.4,side:THREE.DoubleSide});this.tempWorkPlane=new THREE.Mesh(e,t),this.editor.objectsGroup.add(this.tempWorkPlane)}this.tempWorkPlane.position.copy(n);const a=new THREE.Vector3(0,0,1),s=(new THREE.Quaternion).setFromUnitVectors(a,o);this.tempWorkPlane.quaternion.copy(s);const l=o.clone().multiplyScalar(.01);this.tempWorkPlane.position.add(l),this.planesManager.enableFaceGrouping?this.tempWorkPlane.material.color.setHex(16750592):this.tempWorkPlane.material.color.setHex(2201331)}resetPreviousHighlight(){this.hoveredPlane&&(this.hoveredPlane.material.opacity=.1,this.hoveredPlane=null),this.hoveredObject&&(this.editor.objectsManager.unhighlightObject(this.hoveredObject),this.hoveredObject=null),this.tempWorkPlane&&(this.editor.objectsGroup.remove(this.tempWorkPlane),this.tempWorkPlane.geometry.dispose(),this.tempWorkPlane.material.dispose(),this.tempWorkPlane=null)}exitWorkPlaneMode(){this.workPlaneMode=null,this.faceSelectionObject=null,this.currentIntersection=null,this.editor.basePlanes&&(this.editor.basePlanes.visible=!1),this.resetPreviousHighlight(),this.editor.showStatus("Режим создания рабочей плоскости завершен","info")}startWorkPlaneFaceSelection(){return 1===this.editor.selectedObjects.length&&"work_plane"!==this.editor.selectedObjects[0].userData.type&&"sketch_plane"!==this.editor.selectedObjects[0].userData.type&&"base_plane"!==this.editor.selectedObjects[0].userData.type&&(this.faceSelectionObject=this.editor.selectedObjects[0],this.workPlaneMode="active",this.editor.basePlanes&&(this.editor.basePlanes.visible=!1),this.editor.showStatus("Выберите грань выделенного объекта для создания рабочей плоскости","info"),!0)}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","workplane"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="workplane"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <div class="property-group" data-type="workplane-settings">\n                <h4>РАБОЧАЯ ПЛОСКОСТЬ</h4>\n                <div class="property-row">\n                    <h5>Настройки создания на грани</h5>\n                </div>\n                <div class="property-row">\n                    <label>Центрировать по всей грани (группировка полигонов):</label>\n                    <input type="checkbox" id="faceGroupingEnabled" ${this.editor.planesManager.enableFaceGrouping?"checked":""}>\n                </div>\n                <div class="property-row">\n                    <p style="font-size: 12px; color: #888; margin-top: 5px;">\n                        Если <strong>включено</strong>: плоскость создается по центру всей грани.<br>\n                        Если <strong>выключено</strong>: плоскость создается в точке указателя.\n                    </p>\n                </div>\n                <div class="property-row">\n                    <div style="display: flex; gap: 10px; margin-top: 10px;">\n                        <div style="display: flex; align-items: center;">\n                            <div style="width: 15px; height: 15px; background-color: #FF9800; margin-right: 5px;"></div>\n                            <span style="font-size: 12px;">Центр грани</span>\n                        </div>\n                        <div style="display: flex; align-items: center;">\n                            <div style="width: 15px; height: 15px; background-color: #2196F3; margin-right: 5px;"></div>\n                            <span style="font-size: 12px;">Точка указателя</span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#faceGroupingEnabled");e&&e.addEventListener("change",e=>{const t=e.target.checked;this.editor.planesManager.setFaceGroupingEnabled(t),localStorage.setItem("cad-face-grouping",t?"true":"false"),this.editor.showStatus("Центрирование по всей грани: "+(t?"ВКЛ":"ВЫКЛ"),"info")})}onActivate(){return this.createPropertiesSection(),this.createWorkPlane(),!0}onDeactivate(){this.exitWorkPlaneMode(),this.removePropertiesSection()}onMouseDown(e){return!("active"!==this.workPlaneMode||!this.handleSelection(e))&&(this.editor.toolManager.setCurrentTool("select"),!0)}onMouseMove(e){"active"===this.workPlaneMode&&this.handleHighlight(e)}onKeyDown(e){return!("Escape"!==e.key||!this.workPlaneMode)&&(this.editor.toolManager.setCurrentTool("select"),!0)}}