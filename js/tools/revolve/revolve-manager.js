class RevolveManager{constructor(e){this.editor=e,this.figureManager=e.objectsManager.figureManager,this.revolvePreviewGroup=null,this.previewMaterial=null,this.selectedFigures=new Map,this.basePlane=null,this.revolveAxis=null,this.isDraggingAxis=!1,this.axisStartAngle=0,this.startMouseX=0,this.hoveredFigure=null,this.hoveredColor=16776960,this.selectedColor=26367,this.isProcessingClick=!1,this.mergeConnectedFigures=!0,this.mergeThreshold=.1,this.clipperScale=1e5,this.clipperAvailable=!1,this.initializeClipper(),this.rotationAxis="x",this.axisLine=null,this.axisHandle=null,console.log("RevolveManager: создан (аналогично Extrude)")}initializeClipper(){"undefined"!=typeof ClipperLib?(this.clipperAvailable=!0,console.log("Clipper.js доступен"),ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale):(console.error("Clipper.js не найден! Объединение фигур будет недоступно."),this.clipperAvailable=!1)}initialize(){console.log("RevolveManager: инициализация"),this.figureManager?this.figureManager.collectAllFigures():console.error("RevolveManager: FigureManager не найден!")}handleFigureClick(e){if(console.log("=== handleFigureClick (Revolve) ==="),this.isProcessingClick)return!1;this.isProcessingClick=!0;try{const t=this.figureManager.getAllFigures();if(0===t.length)return console.log("Нет фигур для выбора"),!1;const i=this.findFigureAtPoint(e,t);return i?(console.log("Найдена фигура:",i.id,"плоскость:",this.getFigurePlane(i)?.uuid),this.toggleSelection(i),this.updateRevolvePreview(),this.updateRevolveUI(),this.createRevolveAxisIndicator(),!0):(console.log("Не найдена фигура под курсором"),!1)}finally{setTimeout(()=>{this.isProcessingClick=!1},50)}}isPlaneVisible(e){if(!e)return!1;if(!e.visible)return!1;if(e.userData&&!1===e.userData.visible)return!1;let t=e.parent;for(;t;){if(!t.visible)return!1;t=t.parent}return!0}findFigureAtPoint(e,t){const i=[...t].sort((e,t)=>e.depth!==t.depth?t.depth-e.depth:e.area-t.area);for(const t of i){if(!t.outer||!t.outer.points)continue;const i=this.getFigurePlane(t);if(!i)continue;if(!this.isPlaneVisible(i))continue;const o=this.getPointOnPlane(e,i);if(!o)continue;const r=i.worldToLocal(o.clone()),s=new THREE.Vector2(r.x,r.y);if(this.isPointInContour(s,t.outer.points))return t}return null}recalculateBasePlane(){if(0===this.selectedFigures.size)return void(this.basePlane=null);const e=this.selectedFigures.values().next().value;this.basePlane=this.getFigurePlane(e),console.log("Пересчитана базовая плоскость:",this.basePlane?.uuid)}toggleSelection(e){const t=e.id;if(this.selectedFigures.has(t))this.selectedFigures.delete(t),this.unhighlightFigure(e),0===this.selectedFigures.size?this.basePlane=null:this.recalculateBasePlane();else{this.selectedFigures.set(t,e);const i=this.getFigurePlane(e);if(this.basePlane){if(!this.arePlanesCompatible(this.basePlane,i))return this.editor.showStatus("Выбраны фигуры на разных плоскостях!","error"),void this.selectedFigures.delete(t)}else this.basePlane=i;this.highlightFigure(e,this.selectedColor)}console.log("Выделено фигур:",this.selectedFigures.size,"Базовая плоскость:",this.basePlane?.uuid)}getFiguresForRevolve(){if(console.log("=== getFiguresForRevolve ==="),0===this.selectedFigures.size)return[];if(1===this.selectedFigures.size){const e=this.selectedFigures.values().next().value;return console.log(`Одна фигура: ${e.id}, isHole: ${e.isHole}`),[this.createRevolveFigure(e)]}if(!this.mergeConnectedFigures||!this.clipperAvailable)return console.log("Объединение отключено или Clipper недоступен"),this.getIndividualFigures(Array.from(this.selectedFigures.values()));const e=Array.from(this.selectedFigures.values());if(!this.areAllFiguresOnSamePlane(e))return console.log("Фигуры на разных плоскостях, не объединяем"),this.getIndividualFigures(e);!this.basePlane&&e.length>0&&(this.basePlane=this.getFigurePlane(e[0])),console.log(`Выбрано фигур: ${e.length}`);const t=this.getIndependentFigures(e);console.log(`Независимых фигур: ${t.length}`);const i=[];return t.forEach(e=>{if(1===e.length){const t=e[0],o=this.createRevolveFigure(t);i.push(o)}else{const t=this.mergeFigureGroup(e);t.length>0?i.push(...t):e.forEach(e=>{i.push(this.createRevolveFigure(e))})}}),console.log(`Итоговое количество фигур для вращения: ${i.length}`),i}getIndependentFigures(e){console.log("=== getIndependentFigures (Revolve) ==="),console.log(`Обработка ${e.length} выбранных фигур`);const t=[...e].sort((e,t)=>e.depth!==t.depth?e.depth-t.depth:t.area-e.area);console.log("Отсортированные фигуры:",t.map(e=>`ID: ${e.id}, depth: ${e.depth}, area: ${e.area?.toFixed(2)}`));const i=[],o=new Set,r=new Map;return t.forEach(e=>r.set(e.id,e)),t.forEach(e=>{if(o.has(e.id))return;const s=this.buildRelatedGroup(e,t,o,r);s.length>0&&(i.push(s),console.log(`Создана группа: ${s.map(e=>e.id).join(", ")}`))}),console.log(`Итого создано ${i.length} групп`),i}buildRelatedGroup(e,t,i,o){const r=[],s=[e];for(;s.length>0;){const e=s.pop();if(!i.has(e.id)){r.push(e),i.add(e.id);for(const o of t){if(i.has(o.id))continue;if(e.id===o.id)continue;let t=!1;(e.childrenIds&&e.childrenIds.includes(o.id)||o.childrenIds&&o.childrenIds.includes(e.id)||this.areFiguresRelated(e,o))&&(t=!0),t&&s.push(o)}}}return r}areFiguresRelated(e,t){if(e.childrenIds&&e.childrenIds.includes(t.id))return console.log(`  ${e.id} и ${t.id}: родитель-ребенок`),!0;if(t.childrenIds&&t.childrenIds.includes(e.id))return console.log(`  ${e.id} и ${t.id}: родитель-ребенок`),!0;const i=this.getFigurePointsForBasePlane(e),o=this.getFigurePointsForBasePlane(t);if(0===i.length||0===o.length)return!1;const r=this.calculateBoundingBox(i),s=this.calculateBoundingBox(o);if(!this.doBoundingBoxesIntersect(r,s))return!1;const n=Math.abs((e.depth||0)-(t.depth||0));if(n>1)return console.log(`  ${e.id} и ${t.id}: разные уровни вложенности (${n}) - не связаны`),!1;const l=i[0],a=o[0],c=this.isPointInContour(l,o),h=this.isPointInContour(a,i);if((c||h)&&n<=1)return console.log(`  ${e.id} и ${t.id}: одна внутри другой, глубина ${n} - связаны`),!0;if(n<=1){for(let r=0;r<i.length;r++)if(this.isPointInContour(i[r],o))return console.log(`  ${e.id} и ${t.id}: пересекаются (точка в контуре) - связаны`),!0;for(let r=0;r<o.length;r++)if(this.isPointInContour(o[r],i))return console.log(`  ${e.id} и ${t.id}: пересекаются (точка в контуре) - связаны`),!0}return console.log(`  ${e.id} и ${t.id}: не связаны`),!1}mergeFigureGroup(e){if(0===e.length)return[];console.log(`Объединение группы из ${e.length} фигур`);const t=[];return e.forEach(e=>{const i=this.getFigurePointsForBasePlane(e);if(i.length>=3){const o=this.calculateSignedPolygonArea(i),r=o<0?i.reverse():i;t.push({points:r,figureId:e.id,originalIsHole:e.isHole,area:Math.abs(o)})}this.getAllImmediateHoles(e).forEach(i=>{const o=i.points||[];if(o.length>=3){const i=this.calculateSignedPolygonArea(o),r=i<0?o:o.reverse();t.push({points:r,figureId:e.id,originalIsHole:!0,area:Math.abs(i)})}})}),console.log(`Всего контуров в группе: ${t.length}`),this.mergeAllContours(t)}mergeAllContours(e){if(0===e.length)return[];console.log(`Начинаем объединение ${e.length} контуров`);try{const t=[],i=[];if(e.forEach(e=>{const o=e.points;if(o.length<3)return;const r=this.calculateSignedPolygonArea(o);r<0?i.push({points:o,originalIsHole:e.originalIsHole,area:Math.abs(r)}):t.push({points:o,originalIsHole:e.originalIsHole,area:Math.abs(r)})}),console.log(`Внешних контуров: ${t.length}, отверстий: ${i.length}`),0===t.length)return console.log("Нет внешних контуров для объединения"),[];if(1===t.length&&0===i.length)return console.log("Только один внешний контур, без отверстий"),[this.createFigureFromContour(t[0],[])];const o=this.mergeOuterContours(t);console.log(`Объединено внешних контуров: ${o.length}`);const r=[];return o.forEach((e,t)=>{const o=i.filter(t=>{if(0===t.points.length)return!1;const i=t.points[0];return this.isPointInContour(i,e.points)});console.log(`Внешний контур ${t}: найдено ${o.length} отверстий`);const s=this.filterNestedHoles(o);console.log(`Внешний контур ${t}: отверстий первого уровня ${s.length}`);const n=this.createFigureFromContour(e,s);r.push(n)}),r}catch(e){return console.error("Ошибка при объединении контуров:",e),[]}}mergeOuterContours(e){if(0===e.length)return[];try{const t=new ClipperLib.Clipper;e.forEach(e=>{const i=e.points;if(i.length>=3){const e=this.pointsToClipperPath(i);t.AddPath(e,ClipperLib.PolyType.ptSubject,!0)}});const i=new ClipperLib.Paths;if(!t.Execute(ClipperLib.ClipType.ctUnion,i,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)||0===i.length)return console.log("Clipper не смог объединить внешние контуры"),e;console.log(`Clipper вернул ${i.length} внешних контуров`);const o=[];return i.forEach(e=>{const t=this.clipperPathToPoints(e);if(t.length>=3){const e=this.calculateSignedPolygonArea(t);e<0?o.push({points:t.reverse(),area:Math.abs(e)}):o.push({points:t,area:Math.abs(e)})}}),o}catch(t){return console.error("Ошибка при объединении внешних контуров:",t),e}}filterNestedHoles(e){if(e.length<=1)return e;const t=[];for(let i=0;i<e.length;i++){const o=e[i];let r=!1;for(let t=0;t<e.length;t++){if(i===t)continue;const s=e[t];if(o.points.length>0&&s.points.length>0){const e=o.points[0];if(this.isPointInContour(e,s.points)){r=!0;break}}}r||t.push(o)}return t}createFigureFromContour(e,t){const i=this.basePlane;return{id:`merged_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,outer:{points:e.points,center:this.calculateContourCenter(e.points),area:e.area},holes:t.map(e=>({points:e.points,center:this.calculateContourCenter(e.points),area:e.area})),area:e.area,isHole:!1,isMerged:!0,geometricMerge:!0,plane:i,planeId:i?i.uuid:null}}getIndividualFigures(e){return e.map(e=>this.createRevolveFigure(e))}createRevolveFigure(e){const t=this.getAllImmediateHoles(e),i=this.getFigurePlane(e);return{id:e.id,outer:e.outer,holes:t,area:e.area,isHole:e.isHole,parentId:e.parentId,childrenIds:e.childrenIds,depth:e.depth,plane:i,planeId:i?i.uuid:null,element:e.element}}getAllImmediateHoles(e){const t=[];if(e.childrenIds&&e.childrenIds.length>0)for(const i of e.childrenIds){const o=this.figureManager.getFigureById(i);o&&(!e.isHole&&o.isHole||e.isHole&&!o.isHole)&&(t.push(o.outer),console.log(`    Добавлено отверстие: ${i}, родитель isHole=${e.isHole}, ребенок isHole=${o.isHole}`))}return t}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=this.getFigurePlane(e[0]);if(!t)return!1;for(let i=1;i<e.length;i++){const o=this.getFigurePlane(e[i]);if(!o||!this.arePlanesCompatible(t,o))return!1}return!0}createRevolveGeometryFromFigures(e,t,i,o){if(0===e.length||!this.basePlane)return null;if(0===e.length||!this.basePlane)return console.error("Нет базовой плоскости для создания геометрии вращения!"),null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;const r=[];if(e.forEach(e=>{console.log(`Создание фигуры для вращения: ${e.id}, isHole: ${e.isHole}, отверстий: ${e.holes?e.holes.length:0}`);const s=this.getFigurePointsForBasePlane(e);if(s.length<3)return void console.log(`  Недостаточно точек: ${s.length}`);let n=!1;e.isHole&&(n=!1);const l=this.fixContourOrientation(s,n);try{const s=new THREE.Shape(l.map(e=>new THREE.Vector2(e.x,e.y)));e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{const i=this.getContourPointsForBasePlane(e);if(i.length>=3){const e=this.fixContourOrientation(i,!0);try{const i=new THREE.Path(e.map(e=>new THREE.Vector2(e.x,e.y)));s.holes.push(i),console.log(`    Добавлено отверстие ${t}`)}catch(e){console.error(`    Ошибка создания отверстия ${t}:`,e)}}});const n=s.extractPoints();if(!n||!n.shape||0===n.shape.length)return void console.error(`Не удалось извлечь точки из формы для фигуры ${e.id}`);const a=n.shape.map(e=>new THREE.Vector3(e.x,0,e.y)),c=THREE.MathUtils.degToRad(t),h=Math.max(12,Math.round(t/5)),u=0,d=c,g=(Math.abs(t),new THREE.LatheGeometry(a,h,u,d));this.rotateGeometryForAxis(g,i,o),r.push(g),console.log(`  Геометрия вращения создана, точек: ${a.length}`)}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),0===r.length)return console.log("Нет фигур для создания геометрии вращения"),null;console.log(`Создано ${r.length} геометрий вращения`);let s=null;if(1===r.length)s=r[0];else if(void 0!==THREE.BufferGeometryUtils)try{s=THREE.BufferGeometryUtils.mergeBufferGeometries(r,!1),console.log("Геометрии успешно объединены")}catch(e){console.error("Ошибка объединения геометрий:",e),s=r[0]}else console.warn("THREE.BufferGeometryUtils не доступен, используем первую геометрию"),s=r[0];if(!s)return console.error("Не удалось создать объединенную геометрию"),null;const n=new THREE.Matrix4;return n.makeTranslation(0,0,0),s.applyMatrix4(n),console.log("Геометрия вращения успешно создана, вершин:",s.attributes.position?s.attributes.position.count:"неизвестно"),s}rotateGeometryForAxis(e,t,i){const o=new THREE.Matrix4;switch(t){case"x":o.makeRotationZ(Math.PI/2),"negative"===i&&o.multiply((new THREE.Matrix4).makeRotationY(Math.PI));break;case"y":"negative"===i&&o.makeRotationY(Math.PI);break;case"z":o.makeRotationX(Math.PI/2),"negative"===i&&o.multiply((new THREE.Matrix4).makeRotationY(Math.PI))}e.applyMatrix4(o)}rotateGeometryForAxis(e,t,i){const o=new THREE.Matrix4;switch(t){case"x":o.makeRotationX(Math.PI/2),"negative"===i&&o.multiply((new THREE.Matrix4).makeRotationY(Math.PI));break;case"y":"negative"===i&&o.makeRotationY(Math.PI);break;case"z":o.makeRotationZ(Math.PI/2),"negative"===i&&o.multiply((new THREE.Matrix4).makeRotationX(Math.PI))}e.applyMatrix4(o)}createRevolveAxisIndicator(){this.revolveAxis&&(this.revolveAxis.parent&&this.revolveAxis.parent.remove(this.revolveAxis),this.revolveAxis=null);const e=this.getFiguresForRevolve();if(!e||0===e.length||!this.basePlane)return;if(!this.isPlaneVisible(this.basePlane))return void console.log("Базовая плоскость скрыта, не создаем ось вращения");const t=document.getElementById("revolveAngle")?.value||360,i=document.getElementById("revolveAxis")?.value||"y",o=document.getElementById("revolveDirection")?.value||"positive";this.revolveAxis=new THREE.Group,this.revolveAxis.userData.isRevolveAxis=!0,this.revolveAxis.userData.isDraggable=!0,this.revolveAxis.raycast=()=>{};const r=new THREE.CylinderGeometry(.5,.5,50,8),s=new THREE.MeshBasicMaterial({color:16711680,transparent:!0,opacity:.7,depthTest:!1}),n=new THREE.Mesh(r,s);n.renderOrder=999,n.userData.isAxisPart=!0,n.userData.isDraggable=!0,n.userData.isAxisHandle=!0,this.revolveAxis.add(n);const l=new THREE.SphereGeometry(2,8,8),a=new THREE.MeshBasicMaterial({color:16711680,transparent:!0,opacity:.9,depthTest:!1}),c=new THREE.Mesh(l,a);c.renderOrder=999,c.position.y=-25,c.userData.isAxisPart=!0,c.userData.isAxisHandle=!0,this.revolveAxis.add(c);const h=new THREE.Mesh(l,a);if(h.renderOrder=999,h.position.y=25,h.userData.isAxisPart=!0,h.userData.isAxisHandle=!0,this.revolveAxis.add(h),t<360){const e=this.createAngleArc(25,t);e&&(e.renderOrder=998,this.revolveAxis.add(e))}this.updateAxisOrientation(i,o),this.updateAxisPosition(),this.editor.scene.add(this.revolveAxis)}createAngleArc(e,t){if(t>=360)return null;const i=Math.max(16,Math.round(t/5)),o=new THREE.BufferGeometry,r=[],s=THREE.MathUtils.degToRad(t);for(let t=0;t<=i;t++){const o=t/i*s;r.push(new THREE.Vector3(Math.cos(o)*e,Math.sin(o)*e,0))}o.setFromPoints(r);const n=new THREE.LineBasicMaterial({color:16776960,transparent:!0,opacity:.6,linewidth:2});return new THREE.Line(o,n)}updateAxisOrientation(e,t){if(!this.revolveAxis)return;const i=new THREE.Matrix4;switch(e){case"x":i.makeRotationZ(Math.PI/2);break;case"y":break;case"z":i.makeRotationX(Math.PI/2)}"negative"===t&&i.multiply((new THREE.Matrix4).makeRotationY(Math.PI)),this.revolveAxis.applyMatrix4(i)}updateAxisPosition(){if(!this.revolveAxis||!this.basePlane)return;parseFloat(document.getElementById("revolveAngle")?.value);const e=document.getElementById("revolveAxis")?.value||"y",t=document.getElementById("revolveDirection")?.value||"positive",i=this.getFiguresForRevolve();if(0===i.length)return;const o=new THREE.Vector3(0,0,0);let r=0;i.forEach(e=>{if(e.outer&&e.outer.center){const t=e.outer.area||1;o.x+=e.outer.center.x*t,o.y+=e.outer.center.y*t,r+=t}}),r>0&&(o.x/=r,o.y/=r);const s=this.basePlane.localToWorld(o.clone()),n=new THREE.Vector3;this.basePlane.getWorldPosition(n);const l=(new THREE.Vector3).subVectors(s,n),a=n.clone().add(l);this.revolveAxis.position.copy(a),this.updateAxisOrientation(e,t),this.revolveAxis.updateMatrixWorld(!0)}handleAxisDragStart(e){if(!this.revolveAxis)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.revolveAxis&&this.revolveAxis.traverse(e=>{e.userData&&(e.userData.isDraggable||e.userData.isAxisHandle)&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingAxis=!0,this.startMouseX=e.clientX,this.axisStartAngle=parseFloat(document.getElementById("revolveAngle")?.value)||360,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleAxisDrag(e){if(!this.isDraggingAxis||!this.revolveAxis||!this.basePlane)return;let t=.5*(e.clientX-this.startMouseX),i=this.axisStartAngle+t;i=Math.max(0,Math.min(360,i)),i=Math.round(i);const o=document.getElementById("revolveAngle");if(o){o.value=i;const e=new Event("input",{bubbles:!0});o.dispatchEvent(e),this.updateRevolvePreview(),this.updateAxisPosition()}e.preventDefault()}handleAxisDragEnd(){this.isDraggingAxis=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor="default",this.updateRevolvePreview(),this.updateAxisPosition();const e=parseFloat(document.getElementById("revolveAngle")?.value)||360;this.editor.showStatus(`Угол установлен: ${e.toFixed(0)}°`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingAxis&&this.handleAxisDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingAxis&&0===e.button&&this.handleAxisDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}updateRevolvePreview(){const e=this.getFiguresForRevolve();if(0===e.length)return void this.removeRevolvePreview();const t=parseFloat(document.getElementById("revolveAngle")?.value)||360,i=document.getElementById("revolveAxis")?.value||"y",o=document.getElementById("revolveDirection")?.value||"positive";if(this.revolvePreviewGroup&&this.revolvePreviewGroup.children.length>0){const r=this.revolvePreviewGroup.children[0],s=this.createRevolveGeometryFromFigures(e,t,i,o);s&&(r.geometry.dispose(),r.geometry=s,this.updatePreviewPosition(r,t,i,o))}else this.createNewRevolvePreview(e,t,i,o)}createNewRevolvePreview(e,t,i,o){this.removeRevolvePreview();const r=this.createRevolveGeometryFromFigures(e,t,i,o);if(!r)return;this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:16750592,transparent:!0,opacity:.3,side:THREE.DoubleSide}));const s=new THREE.Mesh(r,this.previewMaterial);this.updatePreviewPosition(s,t,i,o),this.revolvePreviewGroup=new THREE.Group,this.revolvePreviewGroup.add(s),this.editor.objectsGroup.add(this.revolvePreviewGroup)}updatePreviewPosition(e,t,i,o){if(!e||!this.basePlane)return;const r=new THREE.Vector3;this.basePlane.getWorldPosition(r),e.position.copy(r),e.quaternion.copy(this.basePlane.quaternion);e.position.y+=.1}removeRevolvePreview(){this.revolvePreviewGroup&&(this.editor.objectsGroup.remove(this.revolvePreviewGroup),this.revolvePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.revolvePreviewGroup=null)}showRevolveUI(){const e=document.getElementById("revolveUI");e&&e.remove();const t=this.selectedFigures.size,i=document.createElement("div");i.id="revolveUI",i.className="revolve-ui",i.innerHTML=`\n            <div class="revolve-header">\n                <h3><i class="fas fa-sync-alt"></i> Вращение фигур</h3>\n                <button id="cancelRevolve" class="btn-secondary">\n                    <i class="fas fa-times"></i> Отмена\n                </button>\n            </div>\n            <div class="revolve-controls">\n                <div class="control-group">\n                    <label>Угол (°):</label>\n                    <input type="number" id="revolveAngle" value="360" step="1" min="0" max="360" style="width: 100px;">\n                </div>\n                <div class="control-group">\n                    <label>Ось вращения:</label>\n                    <select id="revolveAxis">\n                        <option value="x">Ось X</option>\n                        <option value="y" selected>Ось Y</option>\n                        <option value="z">Ось Z</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>Направление:</label>\n                    <select id="revolveDirection">\n                        <option value="positive">Положительное</option>\n                        <option value="negative">Отрицательное</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>Операция:</label>\n                    <select id="revolveOperation">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>\n                        Автоматически объединять соединённые фигуры\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                        ${this.clipperAvailable?"":" (Clipper.js не найден)"}\n                    </label>\n                </div>\n                <div class="revolve-info">\n                    <div id="selectedContourInfo">\n                        ${t>0?`Выбрано фигур: ${t}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" style="font-size: 12px; color: #888; margin-top: 5px;"></div>\n                    <div id="clipperStatus" style="font-size: 12px; color: #888; margin-top: 2px;"></div>\n                </div>\n                <button id="performRevolve" class="btn-primary" ${t>0?"":"disabled"}>\n                    <i class="fas fa-check"></i> Выполнить вращение\n                </button>\n            </div>\n            <div class="revolve-hint">\n                <i class="fas fa-info-circle"></i>\n                <div>• Клик по фигуре: выделить/снять выделение</div>\n                <div>• Соединённые фигуры будут объединены при вращении</div>\n                <div>• Перетаскивайте ось вращения для изменения угла (шаг 1°)</div>\n                <div>• Escape для отмены, Enter для подтверждения</div>\n                ${this.clipperAvailable?"<div>• Используется Clipper.js для точного объединения</div>":'<div style="color: #f44336;">• Clipper.js не найден. Объединение фигур будет недоступно.</div>'}\n            </div>\n        `,document.querySelector(".viewport-container").appendChild(i),i.querySelector("#cancelRevolve").addEventListener("click",()=>{this.exitRevolveMode()}),i.querySelector("#performRevolve").addEventListener("click",()=>{this.performRevolve()});i.querySelector("#revolveAngle").addEventListener("input",()=>{this.updateRevolvePreview(),this.updateAxisPosition()});i.querySelector("#revolveAxis").addEventListener("change",()=>{this.updateRevolvePreview(),this.updateAxisPosition()});i.querySelector("#revolveDirection").addEventListener("change",()=>{this.updateRevolvePreview(),this.updateAxisPosition()});const o=i.querySelector("#revolveOperation");o.addEventListener("change",()=>{this.currentOperation=o.value,this.updateRevolveUI()});const r=i.querySelector("#mergeFigures");r.addEventListener("change",e=>{this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(r.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","error")),this.updateRevolvePreview(),this.updateRevolveUI()}),this.updateRevolveUI()}updateRevolveUI(){const e=document.getElementById("selectedContourInfo"),t=document.getElementById("mergeStatus"),i=document.getElementById("clipperStatus"),o=document.getElementById("performRevolve"),r=document.getElementById("mergeFigures");if(r&&(r.disabled=!this.clipperAvailable),e){const o=this.selectedFigures.size;if(o>0){if(e.textContent=`Выбрано фигур: ${o}`,e.style.color="#FF9800",t)if(o>1&&this.mergeConnectedFigures&&this.clipperAvailable){const e=Array.from(this.selectedFigures.values());this.areAllFiguresOnSamePlane(e)?(t.textContent="✓ Фигуры будут объединены",t.style.color="#4CAF50"):(t.textContent="✗ Фигуры на разных плоскостях",t.style.color="#f44336")}else!this.clipperAvailable&&o>1?(t.textContent="⚠ Clipper.js не найден, объединение недоступно",t.style.color="#FF9800"):t.textContent="";i&&(this.clipperAvailable?(i.textContent="✓ Clipper.js доступен",i.style.color="#4CAF50"):(i.textContent="✗ Clipper.js не найден",i.style.color="#f44336"))}else e.textContent="Кликните по фигуре для выбора",e.style.color="#888",t&&(t.textContent=""),i&&(i.textContent="")}o&&(o.disabled=0===this.selectedFigures.size)}performRevolve(){const e=this.getFiguresForRevolve();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вращения","error");const t=parseFloat(document.getElementById("revolveAngle")?.value)||360,i=document.getElementById("revolveAxis")?.value||"y",o=document.getElementById("revolveDirection")?.value||"positive",r=document.getElementById("revolveOperation")?.value||"new";if(isNaN(t)||t<=0)return void this.editor.showStatus("Введите корректный угол вращения","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const s=this.createRevolveGeometryFromFigures(e,t,i,o);if(!s)return void this.editor.showStatus("Не удалось создать геометрию вращения","error");const n=this.createRevolveMesh(s,t,i,o,e);if(!n)return void this.editor.showStatus("Не удалось создать объект вращения","error");const l=new THREE.Vector3;this.basePlane.getWorldPosition(l),n.position.copy(l),n.quaternion.copy(this.basePlane.quaternion);const a={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),angle:t,axis:i,direction:o,operation:r,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures};switch(r){case"new":this.handleNewOperation(n,a);break;case"cut":this.handleCutOperation(n,a);break;case"join":this.handleJoinOperation(n,a)}this.exitRevolveMode();const c=e.filter(e=>e.isMerged).length,h=e.length;c>0&&h>c?this.editor.showStatus(`Выполнено вращение (${t}°): ${c} объединенных + ${h-c} отдельных фигур`,"success"):c>0?this.editor.showStatus(`Выполнено вращение (${t}°) с объединением ${c} фигур`,"success"):this.editor.showStatus(`Выполнено вращение (${t}°) ${h} фигур`,"success")}createRevolveMesh(e,t,i,o,r){if(!e)return null;const s=new THREE.MeshStandardMaterial({color:16750592,transparent:!0,opacity:1,side:THREE.DoubleSide}),n=new THREE.Mesh(e,s);n.castShadow=!0,n.receiveShadow=!0;const l=r.some(e=>e.isMerged),a=r.filter(e=>e.isMerged),c=a.length;return n.userData={type:"revolve",sourceFigureIds:r.flatMap(e=>e.sourceFigures||[e.id]),angle:t,axis:i,direction:o,operation:this.currentOperation,name:`Вращение (${t}°)${l?` [${c} объединенных]`:""}`,figureCount:r.length,holeCount:r.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:l,mergedFrom:l?a.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures},n}handleNewOperation(e,t){const i=e.position.clone(),o=e.scale.clone();this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectSingleObject(e);const r=this.editor.projectManager.serializeObjectForHistory(e);r.userData.finalPosition=i.toArray(),r.userData.finalScale=o.toArray(),this.editor.history.addAction({type:"create",subtype:"revolve",object:e.uuid,data:{...t,objectData:r,finalPosition:i.toArray(),finalScale:o.toArray()}})}handleCutOperation(e,t){const i=this.findIntersectingObjects(e);if(0===i.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=i.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let r=!1,s=null;i.forEach(i=>{try{const n=this.editor.booleanOps.subtract(i,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(s=n,this.replaceObjectsWithResult([i],s,"cut",{sourceRevolve:t,targetObjectData:o}),r=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),r||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){const i=this.findIntersectingObjects(e);if(0===i.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=i.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),r=this.editor.projectManager.serializeObjectForHistory(e);try{const s=[...i,e],n=this.editor.booleanOps.unionMultiple(s);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(s,n,"join",{sourceObjectsData:o,revolveData:r,sourceRevolve:t})}catch(i){console.error("Ошибка соединения:",i),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],i=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(o=>{if(o===e||"sketch_plane"===o.userData.type||"work_plane"===o.userData.type||"sketch_element"===o.userData.type)return;const r=(new THREE.Box3).setFromObject(o);i.intersectsBox(r)&&t.push(o)}),t}replaceObjectsWithResult(e,t,i,o){const r=this.editor.projectManager.serializeObjectForHistory(t);console.log("Result data:",r);const s={type:"boolean",operation:i,result:t.uuid,sourceObjects:e.map(e=>e.uuid),resultData:r,context:o?.sourceRevolve};console.log("Adding to history:",s),this.editor.history.addAction(s),e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectSingleObject(t)}exitRevolveMode(){this.editor.toolManager.setCurrentTool("select")}cancelRevolveMode(){this.clearSelection(),this.revolveAxis&&(this.editor.scene.remove(this.revolveAxis),this.revolveAxis=null),this.removeRevolvePreview();const e=document.getElementById("revolveUI");e&&e.remove();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.editor.showStatus("Режим вращения завершен","info"),document.body.style.cursor="default"}highlightRevolvableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,16750592):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,16750592)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вращения","warning")}getPointOnPlane(e,t=null){const i=this.editor.renderer.domElement.getBoundingClientRect(),o=new THREE.Vector2((e.clientX-i.left)/i.width*2-1,-(e.clientY-i.top)/i.height*2+1);if(this.editor.raycaster.setFromCamera(o,this.editor.camera),t){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(t.quaternion);const i=new THREE.Plane;i.setFromNormalAndCoplanarPoint(e,t.position);const o=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(i,o))return o}if(this.basePlane){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(this.basePlane.quaternion);const t=new THREE.Plane;t.setFromNormalAndCoplanarPoint(e,this.basePlane.position);const i=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(t,i))return i}const r=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];for(const e of r){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const i=new THREE.Plane;i.setFromNormalAndCoplanarPoint(t,e.position);const o=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(i,o))return o}return null}isPointInContour(e,t){if(t.length<3)return!1;let i=0;const o=t.length;for(let r=0;r<o;r++){const s=t[r],n=t[(r+1)%o];s.y<=e.y?n.y>e.y&&this.isLeft(s,n,e)>0&&i++:n.y<=e.y&&this.isLeft(s,n,e)<0&&i--}return 0!==i}isLeft(e,t,i){return(t.x-e.x)*(i.y-e.y)-(i.x-e.x)*(t.y-e.y)}getFigurePlane(e){if(e.plane)return e.plane;if(e.planeId){const t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId);if(t)return e.plane=t,t}let t=null;if(e.element?t=e.element:e.outer&&e.outer.element?t=e.outer.element:e.outer&&e.outer.elements&&e.outer.elements.length>0&&(t=e.outer.elements[0]),t){const i=this.findSketchPlaneForElement(t);return i&&(e.plane=i,e.planeId=i.uuid),i}return console.warn(`Не удалось определить плоскость для фигуры ${e.id}`),null}findSketchPlaneForElement(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}return this.editor.sketchPlanes.length>0?this.editor.sketchPlanes[0]:this.editor.workPlanes.length>0?this.editor.workPlanes[0]:null}calculateSignedPolygonArea(e){if(e.length<3)return 0;let t=0;const i=e.length;for(let o=0;o<i;o++){const r=(o+1)%i;t+=e[o].x*e[r].y,t-=e[r].x*e[o].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,i=0;return e.forEach(e=>{t+=e.x,i+=e.y}),new THREE.Vector2(t/e.length,i/e.length)}fixContourOrientation(e,t){if(e.length<3)return e;return this.calculateSignedPolygonArea(e)<0!==t?[...e].reverse():e}getFigurePointsForBasePlane(e){const t=this.getFigurePlane(e);return t?!this.basePlane||this.arePlanesCompatible(t,this.basePlane)?e.outer.points||[]:(e.outer.points||[]).map(e=>{const i=new THREE.Vector3(e.x,e.y,0),o=t.localToWorld(i.clone()),r=this.basePlane.worldToLocal(o.clone());return new THREE.Vector2(r.x,r.y)}):e.outer.points||[]}getContourPointsForBasePlane(e){return e.points||[]}arePlanesCompatible(e,t){if(!e||!t)return console.log("Одна из плоскостей null!"),!1;if(e.uuid===t.uuid)return!0;const i=e.position,o=t.position,r=e.quaternion,s=t.quaternion,n=i.distanceTo(o),l=r.angleTo(s),a=n<.001&&l<.001;return a||(console.log(`Плоскости не совместимы: ${e.uuid} и ${t.uuid}`),console.log(`  Расстояние: ${n}, угол: ${l}`)),a}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let i=0;i<e.length;i++)t[i]=new ClipperLib.IntPoint(Math.round(e[i].x*this.clipperScale),Math.round(e[i].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let i=0;i<e.length;i++)t.push(new THREE.Vector2(e[i].X/this.clipperScale,e[i].Y/this.clipperScale));return t}highlightFigure(e,t){e&&e.outer&&(e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,t):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,t)}))}unhighlightFigure(e){e&&e.outer&&(this.selectedFigures.has(e.id)||(e.outer.element?this.editor.objectsManager.safeRestoreElementColor(e.outer.element):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)})))}highlightFiguresOnHover(e){if(this.hoveredFigure&&!this.selectedFigures.has(this.hoveredFigure.id)&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),this.isDraggingAxis)return;const t=this.figureManager.getAllFigures(),i=this.findFigureAtPoint(e,t);if(i){if(this.selectedFigures.has(i.id))return this.hoveredFigure&&(this.hoveredFigure=null),void(document.body.style.cursor="default");this.hoveredFigure=i,this.highlightFigure(i,this.hoveredColor),document.body.style.cursor="pointer"}else document.body.style.cursor="default"}clearSelection(){console.log("=== clearSelection (Revolve) ===");for(const e of this.selectedFigures.values())this.unhighlightFigure(e);this.selectedFigures.clear(),this.basePlane=null,this.hoveredFigure&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),document.body.style.cursor="default"}calculateBoundingBox(e){if(0===e.length)return{min:new THREE.Vector2(0,0),max:new THREE.Vector2(0,0)};const t=new THREE.Vector2(1/0,1/0),i=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),i.x=Math.max(i.x,e.x),i.y=Math.max(i.y,e.y)}),{min:t,max:i}}doBoundingBoxesIntersect(e,t){return!(e.max.x<t.min.x||e.min.x>t.max.x||e.max.y<t.min.y||e.min.y>t.max.y)}}