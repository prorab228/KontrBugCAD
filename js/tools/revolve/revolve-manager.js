class RevolveManager{constructor(e){this.editor=e,this.figureManager=e.objectsManager.figureManager,this.revolvePreviewGroup=null,this.previewMaterial=null,this.selectedFigures=new Map,this.basePlane=null,this.hoveredFigure=null,this.hoveredColor=16776960,this.selectedColor=26367,this.isProcessingClick=!1,this.mergeConnectedFigures=!0,this.mergeThreshold=.1,this.clipperScale=1e5,this.clipperAvailable=!1,this.initializeClipper(),this.currentOperation="new",this.selectedAxis="y",this.selectedAxisLine=null,this.isSelectingAxis=!1,this.axisHelper=null,this.axisStartPoint=null,this.axisDirection=new THREE.Vector3(0,1,0),this.axisPoint=new THREE.Vector3(0,0,0),console.log("RevolveManager: создан (доработанная версия)")}initializeClipper(){"undefined"!=typeof ClipperLib?(this.clipperAvailable=!0,console.log("Clipper.js доступен"),ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale):(console.error("Clipper.js не найден! Объединение фигур будет недоступно."),this.clipperAvailable=!1)}initialize(){console.log("RevolveManager: инициализация"),this.figureManager?this.figureManager.collectAllFigures():console.error("RevolveManager: FigureManager не найден!")}handleFigureClick(e){if(console.log("=== handleFigureClick (Revolve) ==="),this.isProcessingClick)return!1;this.isProcessingClick=!0;try{if(this.isSelectingAxis)return this.handleAxisSelection(e);const t=this.figureManager.getAllFigures();if(0===t.length)return console.log("Нет фигур для выбора"),!1;const i=this.findFigureAtPoint(e,t);return i?(console.log("Найдена фигура:",i.id,"плоскость:",this.getFigurePlane(i)?.uuid),this.toggleSelection(i),this.updateRevolvePreview(),this.updateRevolveUI(),!0):(console.log("Не найдена фигура под курсором"),!1)}finally{setTimeout(()=>{this.isProcessingClick=!1},50)}}isPlaneVisible(e){if(!e)return!1;if(!e.visible)return!1;if(e.userData&&!1===e.userData.visible)return!1;let t=e.parent;for(;t;){if(!t.visible)return!1;t=t.parent}return!0}findFigureAtPoint(e,t){const i=[...t].sort((e,t)=>e.depth!==t.depth?t.depth-e.depth:e.area-t.area);for(const t of i){if(!t.outer||!t.outer.points)continue;const i=this.getFigurePlane(t);if(!i)continue;if(!this.isPlaneVisible(i))continue;const o=this.getPointOnPlane(e,i);if(!o)continue;const s=i.worldToLocal(o.clone()),r=new THREE.Vector2(s.x,s.y);if(this.isPointInContour(r,t.outer.points))return t}return null}recalculateBasePlane(){if(0===this.selectedFigures.size)return void(this.basePlane=null);const e=this.selectedFigures.values().next().value;this.basePlane=this.getFigurePlane(e),console.log("Пересчитана базовая плоскость:",this.basePlane?.uuid)}toggleSelection(e){const t=e.id;if(this.selectedFigures.has(t))this.selectedFigures.delete(t),this.unhighlightFigure(e),0===this.selectedFigures.size?this.basePlane=null:this.recalculateBasePlane();else{this.selectedFigures.set(t,e);const i=this.getFigurePlane(e);if(this.basePlane){if(!this.arePlanesCompatible(this.basePlane,i))return this.editor.showStatus("Выбраны фигуры на разных плоскостях!","error"),void this.selectedFigures.delete(t)}else this.basePlane=i;this.highlightFigure(e,this.selectedColor)}console.log("Выделено фигур:",this.selectedFigures.size,"Базовая плоскость:",this.basePlane?.uuid)}getFiguresForRevolve(){if(console.log("=== getFiguresForRevolve (улучшенная логика) ==="),0===this.selectedFigures.size)return[];if(1===this.selectedFigures.size){const e=this.selectedFigures.values().next().value;return console.log(`Одна фигура: ${e.id}, isHole: ${e.isHole}`),[this.createRevolveFigure(e)]}if(!this.mergeConnectedFigures||!this.clipperAvailable)return console.log("Объединение отключено или Clipper недоступен"),this.getIndividualFigures(Array.from(this.selectedFigures.values()));const e=Array.from(this.selectedFigures.values());if(!this.areAllFiguresOnSamePlane(e))return console.log("Фигуры на разных плоскостях, не объединяем"),this.getIndividualFigures(e);!this.basePlane&&e.length>0&&(this.basePlane=this.getFigurePlane(e[0])),console.log(`Выбрано фигур: ${e.length}`);const t=this.getIndependentFigures(e);console.log(`Независимых фигур: ${t.length}`);const i=[];return t.forEach(e=>{if(1===e.length){const t=e[0],o=this.createRevolveFigure(t);i.push(o)}else{const t=this.mergeFigureGroup(e);t.length>0?i.push(...t):e.forEach(e=>{i.push(this.createRevolveFigure(e))})}}),console.log(`Итоговое количество фигур для вращения: ${i.length}`),i}getIndependentFigures(e){console.log("=== getIndependentFigures ==="),console.log(`Обработка ${e.length} выбранных фигур`);const t=[...e].sort((e,t)=>e.depth!==t.depth?e.depth-t.depth:t.area-e.area);console.log("Отсортированные фигуры:",t.map(e=>`ID: ${e.id}, depth: ${e.depth}, area: ${e.area?.toFixed(2)}`));const i=[],o=new Set,s=new Map;return t.forEach(e=>s.set(e.id,e)),t.forEach(e=>{if(o.has(e.id))return;const r=this.buildRelatedGroup(e,t,o,s);r.length>0&&(i.push(r),console.log(`Создана группа: ${r.map(e=>e.id).join(", ")}`))}),console.log(`Итого создано ${i.length} групп`),i}buildRelatedGroup(e,t,i,o){const s=[],r=[e];for(;r.length>0;){const e=r.pop();if(!i.has(e.id)){s.push(e),i.add(e.id);for(const o of t){if(i.has(o.id))continue;if(e.id===o.id)continue;let t=!1;(e.childrenIds&&e.childrenIds.includes(o.id)||o.childrenIds&&o.childrenIds.includes(e.id)||this.areFiguresRelated(e,o))&&(t=!0),t&&r.push(o)}}}return s}areFiguresRelated(e,t){if(e.childrenIds&&e.childrenIds.includes(t.id))return!0;if(t.childrenIds&&t.childrenIds.includes(e.id))return!0;const i=this.getFigurePointsForBasePlane(e),o=this.getFigurePointsForBasePlane(t);if(0===i.length||0===o.length)return!1;const s=this.calculateBoundingBox(i),r=this.calculateBoundingBox(o);if(!this.doBoundingBoxesIntersect(s,r))return!1;const n=Math.abs((e.depth||0)-(t.depth||0));if(n>1)return!1;const l=i[0],a=o[0],c=this.isPointInContour(l,o),h=this.isPointInContour(a,i);if((c||h)&&n<=1)return!0;if(n<=1){for(let e=0;e<i.length;e++)if(this.isPointInContour(i[e],o))return!0;for(let e=0;e<o.length;e++)if(this.isPointInContour(o[e],i))return!0}return!1}handleCutOperation(e,t){console.log("=== handleCutOperation (Revolve) ===");const i=this.findIntersectingObjects(e);if(0===i.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=i.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let s=!1,r=null;i.forEach(i=>{try{console.log(`Выполняем вычитание для объекта ${i.uuid}`);const n=this.editor.booleanOps.subtract(i,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(r=n,this.replaceObjectsWithResult([i],r,"cut",{sourceRevolve:t,targetObjectData:o}),s=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),s||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){console.log("=== handleJoinOperation (Revolve) ===");const i=this.findIntersectingObjects(e);if(0===i.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=i.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),s=this.editor.projectManager.serializeObjectForHistory(e);try{const r=[...i,e],n=this.editor.booleanOps.unionMultiple(r);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(r,n,"join",{sourceObjectsData:o,revolveData:s,sourceRevolve:t})}catch(i){console.error("Ошибка соединения:",i),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],i=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(o=>{if(o===e||"sketch_plane"===o.userData.type||"work_plane"===o.userData.type||"sketch_element"===o.userData.type||"axis_helper"===o.userData.type)return;const s=(new THREE.Box3).setFromObject(o);i.intersectsBox(s)&&t.push(o)}),console.log(`Найдено ${t.length} пересекающихся объектов`),t}replaceObjectsWithResult(e,t,i,o){console.log(`Замена ${e.length} объектов результатом операции ${i}`);const s=this.editor.projectManager.serializeObjectForHistory(t),r={type:"boolean",operation:i,result:t.uuid,sourceObjects:e.map(e=>e.uuid),resultData:s,context:o?.sourceRevolve};console.log("Добавление в историю:",r),this.editor.history.addAction(r),e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectSingleObject(t)}mergeFigureGroup(e){if(0===e.length)return[];console.log(`Объединение группы из ${e.length} фигур`);const t=[];return e.forEach(e=>{const i=this.getFigurePointsForBasePlane(e);if(i.length>=3){const o=this.calculateSignedPolygonArea(i),s=o<0?i.reverse():i;t.push({points:s,figureId:e.id,originalIsHole:e.isHole,area:Math.abs(o)})}this.getAllImmediateHoles(e).forEach(i=>{const o=i.points||[];if(o.length>=3){const i=this.calculateSignedPolygonArea(o),s=i<0?o:o.reverse();t.push({points:s,figureId:e.id,originalIsHole:!0,area:Math.abs(i)})}})}),console.log(`Всего контуров в группе: ${t.length}`),this.mergeAllContours(t)}mergeAllContours(e){if(0===e.length)return[];console.log(`Начинаем объединение ${e.length} контуров`);try{const t=[],i=[];if(e.forEach(e=>{const o=e.points;if(o.length<3)return;const s=this.calculateSignedPolygonArea(o);s<0?i.push({points:o,originalIsHole:e.originalIsHole,area:Math.abs(s)}):t.push({points:o,originalIsHole:e.originalIsHole,area:Math.abs(s)})}),console.log(`Внешних контуров: ${t.length}, отверстий: ${i.length}`),0===t.length)return console.log("Нет внешних контуров для объединения"),[];if(1===t.length&&0===i.length)return console.log("Только один внешний контур, без отверстий"),[this.createFigureFromContour(t[0],[])];const o=this.mergeOuterContours(t);console.log(`Объединено внешних контуров: ${o.length}`);const s=[];return o.forEach((e,t)=>{const o=i.filter(t=>{if(0===t.points.length)return!1;const i=t.points[0];return this.isPointInContour(i,e.points)});console.log(`Внешний контур ${t}: найдено ${o.length} отверстий`);const r=this.filterNestedHoles(o);console.log(`Внешний контур ${t}: отверстий первого уровня ${r.length}`);const n=this.createFigureFromContour(e,r);s.push(n)}),s}catch(e){return console.error("Ошибка при объединении контуров:",e),[]}}mergeOuterContours(e){if(0===e.length)return[];try{const t=new ClipperLib.Clipper;e.forEach(e=>{const i=e.points;if(i.length>=3){const e=this.pointsToClipperPath(i);t.AddPath(e,ClipperLib.PolyType.ptSubject,!0)}});const i=new ClipperLib.Paths;if(!t.Execute(ClipperLib.ClipType.ctUnion,i,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)||0===i.length)return console.log("Clipper не смог объединить внешние контуры"),e;console.log(`Clipper вернул ${i.length} внешних контуров`);const o=[];return i.forEach(e=>{const t=this.clipperPathToPoints(e);if(t.length>=3){const e=this.calculateSignedPolygonArea(t);e<0?o.push({points:t.reverse(),area:Math.abs(e)}):o.push({points:t,area:Math.abs(e)})}}),o}catch(t){return console.error("Ошибка при объединении внешних контуров:",t),e}}filterNestedHoles(e){if(e.length<=1)return e;const t=[];for(let i=0;i<e.length;i++){const o=e[i];let s=!1;for(let t=0;t<e.length;t++){if(i===t)continue;const r=e[t];if(o.points.length>0&&r.points.length>0){const e=o.points[0];if(this.isPointInContour(e,r.points)){s=!0;break}}}s||t.push(o)}return t}createFigureFromContour(e,t){const i=this.basePlane;return{id:`merged_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,outer:{points:e.points,center:this.calculateContourCenter(e.points),area:e.area},holes:t.map(e=>({points:e.points,center:this.calculateContourCenter(e.points),area:e.area})),area:e.area,isHole:!1,isMerged:!0,geometricMerge:!0,plane:i,planeId:i?i.uuid:null}}getIndividualFigures(e){return e.map(e=>this.createRevolveFigure(e))}createRevolveFigure(e){const t=this.getAllImmediateHoles(e),i=this.getFigurePlane(e);return{id:e.id,outer:e.outer,holes:t,area:e.area,isHole:e.isHole,parentId:e.parentId,childrenIds:e.childrenIds,depth:e.depth,plane:i,planeId:i?i.uuid:null,element:e.element}}getAllImmediateHoles(e){const t=[];if(e.childrenIds&&e.childrenIds.length>0)for(const i of e.childrenIds){const o=this.figureManager.getFigureById(i);o&&(!e.isHole&&o.isHole||e.isHole&&!o.isHole)&&t.push(o.outer)}return t}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=this.getFigurePlane(e[0]);if(!t)return!1;for(let i=1;i<e.length;i++){const o=this.getFigurePlane(e[i]);if(!o||!this.arePlanesCompatible(t,o))return!1}return!0}createRevolveGeometryFromFigures(e,t,i,o){if(console.log("=== createRevolveGeometryFromFigures ==="),console.log(`Параметры: угол=${t}°, ось=${i}, направление=${o}`),0===e.length||!this.basePlane)return console.error("Нет фигур или базовой плоскости!"),null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;const s=[];if(e.forEach(e=>{try{console.log(`Создание формы для фигуры: ${e.id}`);const t=this.getFigurePointsForBasePlane(e);if(t.length<3)return void console.log(`  Недостаточно точек: ${t.length}`);const i=new THREE.Shape;if(t.length>0){i.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)i.lineTo(t[e].x,t[e].y);i.closePath()}e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{try{const t=this.getContourPointsForBasePlane(e);if(t.length>=3){const e=new THREE.Path;e.moveTo(t[0].x,t[0].y);for(let i=1;i<t.length;i++)e.lineTo(t[i].x,t[i].y);i.holes.push(e)}}catch(e){console.error(`  Ошибка создания отверстия ${t}:`,e)}}),s.push(i),console.log("  Форма успешно создана")}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),0===s.length)return console.error("Не удалось создать ни одной формы!"),null;console.log(`Создано ${s.length} форм`);try{let e=s[0];for(let t=1;t<s.length;t++){(s[t].holes||[]).forEach(t=>{e.holes.push(t)})}const r=e.getPoints();return!r||r.length<3?(console.error("Недостаточно точек в объединенной форме!"),null):(console.log(`Точек в форме: ${r.length}`),this.selectedAxisLine?this.createRevolveAroundLine(e,t,o):this.createRevolveAroundGlobalAxis(e,i,t,o))}catch(e){return console.error("Критическая ошибка создания геометрии вращения:",e),null}}createRevolveAroundGlobalAxis(e,t,i,o){console.log(`Создание вращения вокруг глобальной оси ${t}`);const s=e.getPoints();if(!s||s.length<3)return null;const r=s.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)}),n=new THREE.Vector3;r.forEach(e=>n.add(e)),n.divideScalar(r.length);let l,a=new THREE.Vector3(0,0,0);switch(t){case"x":l=new THREE.Vector3(1,0,0);break;case"y":default:l=new THREE.Vector3(0,1,0);break;case"z":l=new THREE.Vector3(0,0,1)}const c=r.map(e=>{const t=(new THREE.Vector3).subVectors(e,a),i=t.dot(l),o=l.clone().multiplyScalar(i),s=(new THREE.Vector3).subVectors(t,o).length(),r=i;return new THREE.Vector2(s,r)}),h="negative"===o?-THREE.MathUtils.degToRad(i):THREE.MathUtils.degToRad(i),u=new THREE.LatheGeometry(c,Math.max(16,Math.round(i/5)),0,h),d=new THREE.Matrix4,g=new THREE.Vector3(0,1,0),p=new THREE.Quaternion;return p.setFromUnitVectors(g,l),d.makeRotationFromQuaternion(p),d.setPosition(a),u.applyMatrix4(d),u}createRevolveAroundLine(e,t,i){if(console.log("Создание вращения вокруг выбранной линии"),!this.selectedAxisLine)return console.error("Нет выбранной линии!"),null;const o=e.getPoints();if(!o||o.length<3)return null;const s=this.selectedAxisLine.geometry.attributes.position.array,r=new THREE.Vector3(s[0],s[1],s[2]),n=new THREE.Vector3(s[3],s[4],s[5]),l=new THREE.Vector3,a=new THREE.Vector3;this.selectedAxisLine.localToWorld(l.copy(r)),this.selectedAxisLine.localToWorld(a.copy(n));const c=(new THREE.Vector3).subVectors(a,l).normalize(),h=o.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)}).map(e=>{const t=(new THREE.Vector3).subVectors(e,l),i=t.dot(c),o=c.clone().multiplyScalar(i),s=(new THREE.Vector3).subVectors(t,o).length(),r=i;return new THREE.Vector2(s,r)}),u="negative"===i?-THREE.MathUtils.degToRad(t):THREE.MathUtils.degToRad(t),d=new THREE.LatheGeometry(h,Math.max(16,Math.round(t/5)),0,u),g=new THREE.Matrix4,p=new THREE.Vector3(0,1,0),v=new THREE.Quaternion;return v.setFromUnitVectors(p,c),g.makeRotationFromQuaternion(v),g.setPosition(l),d.applyMatrix4(g),d}getClosestAxisToLine(e){const t=e.geometry.attributes.position.array,i=new THREE.Vector3(t[0],t[1],t[2]),o=new THREE.Vector3(t[3],t[4],t[5]);e.localToWorld(i),e.localToWorld(o);const s=(new THREE.Vector3).subVectors(o,i).normalize(),r=Math.abs(s.dot(new THREE.Vector3(1,0,0))),n=Math.abs(s.dot(new THREE.Vector3(0,1,0))),l=Math.abs(s.dot(new THREE.Vector3(0,0,1))),a=Math.max(r,n,l);return a===r?"x":a===n?"y":"z"}startAxisSelection(){this.isSelectingAxis=!0,this.editor.axesHelper?this.editor.axesHelper.visible=!0:this.createGlobalAxes(),this.editor.showStatus("Кликните на линию для выбора оси вращения","info"),this.updateAxisInfo()}createGlobalAxes(){this.editor.axesHelper||(this.editor.axesHelper=new THREE.AxesHelper(100),this.editor.axesHelper.name="globalAxes",this.editor.scene.add(this.editor.axesHelper)),this.editor.axesHelper.visible=!0}handleAxisSelection(e){if(console.log("=== handleAxisSelection ==="),this.editor.axesHelper){const t=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((e.clientX-t.left)/t.width*2-1,-(e.clientY-t.top)/t.height*2+1);this.editor.raycaster.setFromCamera(i,this.editor.camera);const o=this.editor.raycaster.intersectObject(this.editor.axesHelper,!0);if(o.length>0){const e=o[0],t=this.getAxisFromIntersection(e);if(t)return this.selectedAxis=t,this.selectedAxisLine=null,this.isSelectingAxis=!1,this.updateAxisInfo(),this.updateRevolvePreview(),this.showSelectedAxis(),this.editor.showStatus(`Выбрана глобальная ось: ${t.toUpperCase()}`,"success"),!0}}const t=this.editor.objectsManager.getAllSketchElements().filter(e=>"line"===e.userData?.elementType&&e.visible);if(t.length>0){const i=this.findLineAtPoint(e,t);if(i){this.selectedAxisLine=i,this.isSelectingAxis=!1;const e=this.getClosestAxisToLine(i);return this.selectedAxis=e,this.updateAxisInfo(),this.updateRevolvePreview(),this.showSelectedAxis(),this.editor.showStatus("Выбрана линия как ось вращения","success"),!0}}return!1}getAxisFromIntersection(e){if(e.object&&e.object.parent===this.editor.axesHelper){if("x-axis"===e.object.name||"x"===e.object.userData?.axis)return"x";if("y-axis"===e.object.name||"y"===e.object.userData?.axis)return"y";if("z-axis"===e.object.name||"z"===e.object.userData?.axis)return"z"}return null}findLineAtPoint(e,t){const i=this.editor.renderer.domElement.getBoundingClientRect(),o=new THREE.Vector2((e.clientX-i.left)/i.width*2-1,-(e.clientY-i.top)/i.height*2+1);this.editor.raycaster.setFromCamera(o,this.editor.camera);const s=this.editor.raycaster.intersectObjects(t,!0);return s.length>0?s[0].object:null}showSelectedAxis(){if(this.removeAxisVisualization(),this.selectedAxisLine){const e=new THREE.BufferGeometry,t=this.selectedAxisLine.geometry.attributes.position.array,i=new Float32Array(t);e.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),this.axisHelper=new THREE.Line(e,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.axisHelper.position.copy(this.selectedAxisLine.position),this.axisHelper.rotation.copy(this.selectedAxisLine.rotation),this.axisHelper.scale.copy(this.selectedAxisLine.scale),this.editor.scene.add(this.axisHelper)}else{const e=200;let t,i;switch(this.selectedAxis){case"x":t=new THREE.Vector3(-e/2,0,0),i=new THREE.Vector3(e/2,0,0);break;case"y":t=new THREE.Vector3(0,-e/2,0),i=new THREE.Vector3(0,e/2,0);break;case"z":t=new THREE.Vector3(0,0,-e/2),i=new THREE.Vector3(0,0,e/2)}const o=(new THREE.BufferGeometry).setFromPoints([t,i]);this.axisHelper=new THREE.Line(o,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.editor.scene.add(this.axisHelper)}}removeAxisVisualization(){this.axisHelper&&(this.editor.scene.remove(this.axisHelper),this.axisHelper.geometry&&this.axisHelper.geometry.dispose(),this.axisHelper.material&&this.axisHelper.material.dispose(),this.axisHelper=null)}updateAxisInfo(){const e=document.getElementById("axisInfo");e&&(this.selectedAxisLine?(e.textContent="Ось: выбранная линия",e.style.color="#FF0000"):(e.textContent=`Ось: глобальная ${this.selectedAxis.toUpperCase()}`,e.style.color="#666"));const t=document.getElementById("revolveAxis");t&&!this.isSelectingAxis&&(t.value=this.selectedAxis)}updateRevolvePreview(){console.log("=== updateRevolvePreview ===");const e=this.getFiguresForRevolve();if(0===e.length)return console.log("Нет фигур для предпросмотра"),void this.removeRevolvePreview();const t=parseFloat(document.getElementById("revolveAngle")?.value)||360,i=document.getElementById("revolveAxis")?.value||"y",o=document.getElementById("revolveDirection")?.value||"positive";if(console.log(`Параметры предпросмотра: угол=${t}°, ось=${i}, направление=${o}`),this.revolvePreviewGroup&&this.revolvePreviewGroup.children.length>0){console.log("Обновление существующего предпросмотра");const s=this.revolvePreviewGroup.children[0],r=this.createRevolveGeometryFromFigures(e,t,i,o);r?(s.geometry.dispose(),s.geometry=r):console.error("Не удалось создать новую геометрию для предпросмотра")}else console.log("Создание нового предпросмотра"),this.createNewRevolvePreview(e,t,i,o)}createNewRevolvePreview(e,t,i,o){console.log("=== createNewRevolvePreview ==="),this.removeRevolvePreview();const s=this.createRevolveGeometryFromFigures(e,t,i,o);if(!s)return void console.error("Не удалось создать геометрию для предпросмотра");this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:16750592,transparent:!0,opacity:.4,side:THREE.DoubleSide}));const r=new THREE.Mesh(s,this.previewMaterial);this.revolvePreviewGroup=new THREE.Group,this.revolvePreviewGroup.name="revolvePreview",this.revolvePreviewGroup.add(r),this.editor.objectsGroup.add(this.revolvePreviewGroup),console.log("Предпросмотр создан и добавлен на сцену")}removeRevolvePreview(){this.revolvePreviewGroup&&(this.editor.objectsGroup.remove(this.revolvePreviewGroup),this.revolvePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.revolvePreviewGroup=null,console.log("Предпросмотр удален"))}showRevolveUI(){console.log("=== showRevolveUI ===");const e=document.getElementById("revolveUI");e&&(console.log("Удаляем старый UI"),e.remove());const t=this.selectedFigures.size;console.log(`Выбрано фигур: ${t}`);const i=document.createElement("div");i.id="revolveUI",i.className="extrude-ui",i.innerHTML=`\n            <div class="extrude-header">\n                <h3><i class="fas fa-sync-alt"></i> Вращение фигур</h3>\n                <button id="cancelRevolve" class="btn-secondary">\n                    <i class="fas fa-times"></i> Отмена\n                </button>\n            </div>\n            <div class="extrude-controls">\n                <div class="control-group">\n                    <label>Угол вращения (°):</label>\n                    <div style="display: flex; align-items: center; gap: 8px;">\n                        <input type="range" id="revolveAngleSlider" min="1" max="360" value="360" step="1" style="flex: 1;">\n                        <input type="number" id="revolveAngle" value="360" min="1" max="360" step="1" style="width: 70px;">\n                    </div>\n                </div>\n                <div class="control-group">\n                    <label>Ось вращения:</label>\n                    <div style="display: flex; align-items: center; gap: 8px;">\n                        <select id="revolveAxis" style="flex: 1;">\n                            <option value="x">Глобальная ось X</option>\n                            <option value="y" selected>Глобальная ось Y</option>\n                            <option value="z">Глобальная ось Z</option>\n                        </select>\n                        <button id="selectAxisButton" class="btn-secondary" style="padding: 8px 12px;" title="Выбрать ось на чертеже">\n                            <i class="fas fa-mouse-pointer"></i>\n                        </button>\n                    </div>\n                    <div id="axisInfo" style="font-size: 12px; color: #666; margin-top: 4px;">\n                        ${this.selectedAxisLine?"Ось: выбранная линия":`Ось: глобальная ${this.selectedAxis.toUpperCase()}`}\n                    </div>\n                </div>\n                <div class="control-group">\n                    <label>Направление:</label>\n                    <select id="revolveDirection">\n                        <option value="positive">По часовой стрелке</option>\n                        <option value="negative">Против часовой стрелки</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>Операция:</label>\n                    <select id="revolveOperation">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>\n                        Объединять соединённые фигуры\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                        ${this.clipperAvailable?"":" (недоступно)"}\n                    </label>\n                </div>\n                <div class="extrude-info">\n                    <div id="selectedContourInfo">\n                        ${t>0?`Выбрано фигур: ${t}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" style="font-size: 12px; color: #888; margin-top: 5px;"></div>\n                    <div id="clipperStatus" style="font-size: 12px; color: #888; margin-top: 2px;"></div>\n                </div>\n                <button id="performRevolve" class="btn-primary" ${t>0?"":"disabled"}>\n                    <i class="fas fa-check"></i> Выполнить вращение\n                </button>\n            </div>\n            <div class="extrude-hint">\n                <i class="fas fa-info-circle"></i>\n                <div>• Клик по фигуре: выделить/снять выделение</div>\n                <div>• Нажмите <i class="fas fa-mouse-pointer"></i> чтобы выбрать ось на чертеже</div>\n                <div>• Глобальные оси: X, Y, Z проходят через начало координат (0,0,0)</div>\n                <div>• Торцы автоматически закрываются при угле < 360°</div>\n                <div>• Escape для отмены, Enter для подтверждения</div>\n                ${this.clipperAvailable?"<div>• Используется Clipper.js для точного объединения</div>":'<div style="color: #f44336;">• Clipper.js не найден. Объединение фигур будет недоступно.</div>'}\n            </div>\n        `;(document.querySelector(".viewport-container")||document.querySelector(".main-container")||document.body).appendChild(i),console.log("UI добавлен на страницу"),this.setupUIEventListeners(),this.updateRevolveUI()}setupUIEventListeners(){console.log("Настройка обработчиков событий UI...");const e=document.getElementById("cancelRevolve");e&&e.addEventListener("click",()=>{console.log("Нажата кнопка Отмена"),this.exitRevolveMode()});const t=document.getElementById("performRevolve");t&&t.addEventListener("click",()=>{console.log("Нажата кнопка Выполнить вращение"),this.performRevolve()});const i=document.getElementById("revolveAngleSlider"),o=document.getElementById("revolveAngle");i&&o&&(i.addEventListener("input",()=>{o.value=i.value,console.log("Изменен угол (слайдер):",i.value),this.updateRevolvePreview()}),o.addEventListener("input",()=>{i.value=o.value,console.log("Изменен угол (поле):",o.value),this.updateRevolvePreview()}));const s=document.getElementById("revolveAxis");s&&(s.value=this.selectedAxis,s.addEventListener("change",()=>{console.log("Изменена ось через селект:",s.value),this.isSelectingAxis||(this.selectedAxis=s.value,this.selectedAxisLine=null,this.updateAxisInfo(),this.showSelectedAxis(),this.updateRevolvePreview())}));const r=document.getElementById("revolveDirection");r&&r.addEventListener("change",()=>{console.log("Изменено направление:",r.value),this.updateRevolvePreview()});const n=document.getElementById("revolveOperation");n&&n.addEventListener("change",()=>{console.log("Изменена операция:",n.value),this.currentOperation=n.value});const l=document.getElementById("mergeFigures");l&&l.addEventListener("change",e=>{console.log("Изменен чекбокс объединения:",e.target.checked),this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(l.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","warning")),this.updateRevolvePreview(),this.updateRevolveUI()});const a=document.getElementById("selectAxisButton");a&&a.addEventListener("click",()=>{console.log("Нажата кнопка выбора оси"),this.startAxisSelection()})}updateRevolveUI(){const e=document.getElementById("selectedContourInfo"),t=document.getElementById("performRevolve"),i=document.getElementById("mergeFigures"),o=document.getElementById("mergeStatus"),s=document.getElementById("clipperStatus");if(!e||!t)return;const r=this.selectedFigures.size;r>0?(e.textContent=`Выбрано фигур: ${r}`,e.style.color="#28a745",t.disabled=!1,t.classList.remove("disabled"),o&&r>1&&(this.mergeConnectedFigures&&this.clipperAvailable?(o.textContent="Фигуры будут объединены",o.style.color="#28a745"):this.clipperAvailable?(o.textContent="Объединение отключено",o.style.color="#dc3545"):(o.textContent="Clipper.js не найден",o.style.color="#ffc107"))):(e.textContent="Кликните по фигуре для выбора",e.style.color="#6c757d",t.disabled=!0,t.classList.add("disabled"),o&&(o.textContent="")),i&&(i.disabled=!this.clipperAvailable),s&&(this.clipperAvailable?(s.textContent="Clipper.js доступен",s.style.color="#28a745"):(s.textContent="Clipper.js не найден - объединение недоступно",s.style.color="#f44336"))}performRevolve(){console.log("=== performRevolve (доработанная версия) ===");const e=this.getFiguresForRevolve();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вращения","error");const t=parseFloat(document.getElementById("revolveAngle")?.value)||360,i=document.getElementById("revolveAxis")?.value||"y",o=document.getElementById("revolveDirection")?.value||"positive",s=document.getElementById("revolveOperation")?.value||"new";if(isNaN(t)||t<=0)return void this.editor.showStatus("Введите корректный угол вращения","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");console.log(`Создание вращения: угол=${t}°, ось=${i}, операция=${s}`);const r=this.createRevolveGeometryFromFigures(e,t,i,o);if(!r)return void this.editor.showStatus("Не удалось создать геометрию вращения","error");const n=this.createRevolveMesh(r,t,i,o,e);if(!n)return void this.editor.showStatus("Не удалось создать объект вращения","error");const l={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),angle:t,axis:i,direction:o,operation:s,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,usedLineAxis:!!this.selectedAxisLine};switch(s){case"new":default:this.handleNewOperation(n,l);break;case"cut":this.handleCutOperation(n,l);break;case"join":this.handleJoinOperation(n,l)}this.exitRevolveMode();const a=e.filter(e=>e.isMerged).length,c=e.length;a>0&&c>a?this.editor.showStatus(`Выполнено вращение (${t}°): ${a} объединенных + ${c-a} отдельных фигур`,"success"):a>0?this.editor.showStatus(`Выполнено вращение (${t}°) с объединением ${a} фигур`,"success"):this.editor.showStatus(`Выполнено вращение (${t}°) ${c} фигур`,"success")}handleNewOperation(e,t){console.log("Создание нового объекта вращения"),this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectSingleObject(e);const i=this.editor.projectManager.serializeObjectForHistory(e);this.editor.history.addAction({type:"create",subtype:"revolve",object:e.uuid,data:{...t,objectData:i}})}createRevolveMesh(e,t,i,o,s){if(!e)return null;const r=new THREE.MeshStandardMaterial({color:16750592,metalness:.3,roughness:.6,side:THREE.DoubleSide}),n=new THREE.Mesh(e,r);n.castShadow=!0,n.receiveShadow=!0;const l=s.some(e=>e.isMerged),a=s.filter(e=>e.isMerged),c=a.length;return n.userData={type:"revolve",sourceFigureIds:s.flatMap(e=>e.sourceFigures||[e.id]),angle:t,axis:i,direction:o,operation:this.currentOperation,name:`Вращение (${t}°)${l?` [${c} объединенных]`:""}`,figureCount:s.length,holeCount:s.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:l,mergedFrom:l?a.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,closedEnds:t<360,usedLineAxis:!!this.selectedAxisLine,axisLineId:this.selectedAxisLine?this.selectedAxisLine.uuid:null},n}exitRevolveMode(){this.editor.toolManager.setCurrentTool("select")}cancelRevolveMode(){console.log("=== cancelRevolveMode ==="),this.clearSelection(),this.removeRevolvePreview(),this.removeAxisVisualization(),this.editor.axesHelper&&(this.editor.axesHelper.visible=!1);const e=document.getElementById("revolveUI");e&&e.remove();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.isSelectingAxis=!1,this.editor.showStatus("Режим вращения завершен","info"),document.body.style.cursor="default"}highlightRevolvableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,16750592):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,16750592)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вращения","warning")}getPointOnPlane(e,t=null){const i=this.editor.renderer.domElement.getBoundingClientRect(),o=new THREE.Vector2((e.clientX-i.left)/i.width*2-1,-(e.clientY-i.top)/i.height*2+1);if(this.editor.raycaster.setFromCamera(o,this.editor.camera),t){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(t.quaternion);const i=new THREE.Plane;i.setFromNormalAndCoplanarPoint(e,t.position);const o=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(i,o))return o}if(this.basePlane){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(this.basePlane.quaternion);const t=new THREE.Plane;t.setFromNormalAndCoplanarPoint(e,this.basePlane.position);const i=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(t,i))return i}const s=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];for(const e of s){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const i=new THREE.Plane;i.setFromNormalAndCoplanarPoint(t,e.position);const o=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(i,o))return o}return null}isPointInContour(e,t){if(t.length<3)return!1;let i=0;const o=t.length;for(let s=0;s<o;s++){const r=t[s],n=t[(s+1)%o];r.y<=e.y?n.y>e.y&&this.isLeft(r,n,e)>0&&i++:n.y<=e.y&&this.isLeft(r,n,e)<0&&i--}return 0!==i}isLeft(e,t,i){return(t.x-e.x)*(i.y-e.y)-(i.x-e.x)*(t.y-e.y)}getFigurePlane(e){if(e.plane)return e.plane;if(e.planeId){const t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId);if(t)return e.plane=t,t}let t=null;if(e.element?t=e.element:e.outer&&e.outer.element?t=e.outer.element:e.outer&&e.outer.elements&&e.outer.elements.length>0&&(t=e.outer.elements[0]),t){const i=this.findSketchPlaneForElement(t);return i&&(e.plane=i,e.planeId=i.uuid),i}return console.warn(`Не удалось определить плоскость для фигуры ${e.id}`),null}findSketchPlaneForElement(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}return this.editor.sketchPlanes.length>0?this.editor.sketchPlanes[0]:this.editor.workPlanes.length>0?this.editor.workPlanes[0]:null}calculateSignedPolygonArea(e){if(e.length<3)return 0;let t=0;const i=e.length;for(let o=0;o<i;o++){const s=(o+1)%i;t+=e[o].x*e[s].y,t-=e[s].x*e[o].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,i=0;return e.forEach(e=>{t+=e.x,i+=e.y}),new THREE.Vector2(t/e.length,i/e.length)}fixContourOrientation(e,t){if(e.length<3)return e;return this.calculateSignedPolygonArea(e)<0!==t?[...e].reverse():e}getFigurePointsForBasePlane(e){const t=this.getFigurePlane(e);return t?!this.basePlane||this.arePlanesCompatible(t,this.basePlane)?e.outer.points||[]:(e.outer.points||[]).map(e=>{const i=new THREE.Vector3(e.x,e.y,0),o=t.localToWorld(i.clone()),s=this.basePlane.worldToLocal(o.clone());return new THREE.Vector2(s.x,s.y)}):e.outer.points||[]}getContourPointsForBasePlane(e){return e.points||[]}arePlanesCompatible(e,t){if(!e||!t)return!1;if(e.uuid===t.uuid)return!0;const i=e.position,o=t.position,s=e.quaternion,r=t.quaternion,n=i.distanceTo(o),l=s.angleTo(r);return n<.001&&l<.001}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let i=0;i<e.length;i++)t[i]=new ClipperLib.IntPoint(Math.round(e[i].x*this.clipperScale),Math.round(e[i].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let i=0;i<e.length;i++)t.push(new THREE.Vector2(e[i].X/this.clipperScale,e[i].Y/this.clipperScale));return t}highlightFigure(e,t){e&&e.outer&&(e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,t):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,t)}))}unhighlightFigure(e){e&&e.outer&&(this.selectedFigures.has(e.id)||(e.outer.element?this.editor.objectsManager.safeRestoreElementColor(e.outer.element):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)})))}highlightFiguresOnHover(e){this.hoveredFigure&&!this.selectedFigures.has(this.hoveredFigure.id)&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null);const t=this.figureManager.getAllFigures(),i=this.findFigureAtPoint(e,t);if(i){if(this.selectedFigures.has(i.id))return this.hoveredFigure&&(this.hoveredFigure=null),void(document.body.style.cursor="default");this.hoveredFigure=i,this.highlightFigure(i,this.hoveredColor),document.body.style.cursor="pointer"}else document.body.style.cursor="default"}clearSelection(){console.log("=== clearSelection (Revolve) ===");for(const e of this.selectedFigures.values())this.unhighlightFigure(e);this.selectedFigures.clear(),this.basePlane=null,this.hoveredFigure&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),document.body.style.cursor="default"}calculateBoundingBox(e){if(0===e.length)return{min:new THREE.Vector2(0,0),max:new THREE.Vector2(0,0)};const t=new THREE.Vector2(1/0,1/0),i=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),i.x=Math.max(i.x,e.x),i.y=Math.max(i.y,e.y)}),{min:t,max:i}}doBoundingBoxesIntersect(e,t){return!(e.max.x<t.min.x||e.min.x>t.max.x||e.max.y<t.min.y||e.min.y>t.max.y)}}