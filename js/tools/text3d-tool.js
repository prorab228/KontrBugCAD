class Text3DTool extends Tool{constructor(e){super("text3dTool","fa-font",e),this.text="КонтрБагCAD",this.fontSize=25,this.depth=2,this.fontColor=63571,this.materialType="standard",this.bevelEnabled=!1,this.bevelThickness=.1,this.bevelSize=.05,this.curveSegments=12,this.conversionQuality="medium",this.currentTextMesh=null,this.tempText=null,this.isPlacing=!1,this.textMaterials={standard:new THREE.MeshStandardMaterial({color:this.fontColor,roughness:.7,metalness:.2}),basic:new THREE.MeshBasicMaterial({color:this.fontColor}),phong:new THREE.MeshPhongMaterial({color:this.fontColor,shininess:100})},this.fonts={},this.availableFonts=[{name:"Roboto",file:"fonts/Roboto_Regular.json"},{name:"Arial",file:"fonts/helvetiker_regular.typeface.json"},{name:"Bold",file:"fonts/helvetiker_bold.typeface.json"},{name:"Optima",file:"fonts/optimer_regular.typeface.json"}],this.currentFont="Roboto",this.ttfConverter=new TTFConverter,this.customFonts={},this.loadFonts(),this.loadCustomFonts()}onActivate(){this.clear(),this.createPropertiesSection(),document.body.style.cursor="crosshair",this.editor.showStatus("3D Текст: кликните для размещения текста (ESC - отмена)","info")}onDeactivate(){this.clear(),this.removePropertiesSection(),document.body.style.cursor="default",this.clearTempText()}async loadFonts(){const e=new THREE.FontLoader;this.availableFonts.forEach(t=>{e.load(t.file,e=>{this.fonts[t.name]=e,console.log(`Шрифт ${t.name} загружен`),this.propertiesElement&&this.updateFontSelector()},void 0,e=>{console.error(`Ошибка загрузки шрифта ${t.name}:`,e)})})}loadCustomFonts(){const e=this.ttfConverter.loadFontsFromLocalStorage(),t=new THREE.FontLoader;for(const[s,i]of Object.entries(e))try{const e=t.parse(i);this.customFonts[s]=e,this.fonts[s]=e,console.log(`Кастомный шрифт ${s} загружен из localStorage`)}catch(e){console.error(`Ошибка загрузки кастомного шрифта ${s}:`,e)}this.propertiesElement&&this.updateFontSelector()}async loadTTFFont(e){if(e&&e.name.toLowerCase().endsWith(".ttf"))try{this.editor.showStatus("Конвертация TTF шрифта...","info");const t={low:{curveSegments:1,resolution:100},medium:{curveSegments:2,resolution:100},high:{curveSegments:4,resolution:100},veryhigh:{curveSegments:8,resolution:100}},s=t[this.conversionQuality]||t.medium,i=await this.ttfConverter.convertTTFtoThreeJS(e,{includeCyrillic:!0,includeLatin:!0,curveSegments:s.curveSegments,resolution:s.resolution});if(i.success){const e=i.fontData;e.conversionQuality=this.conversionQuality,e.conversionSettings=s,e.conversionDate=(new Date).toISOString(),this.ttfConverter.saveFontToLocalStorage(i.fontName,e);const t=(new THREE.FontLoader).parse(e);this.customFonts[i.fontName]=t,this.fonts[i.fontName]=t,this.updateFontSelector(),this.editor.showStatus(`Шрифт "${i.fontName}" успешно загружен! (Качество: ${this.conversionQuality})`,"success")}else this.editor.showStatus(`Ошибка конвертации: ${i.error}`,"error")}catch(e){console.error("Ошибка загрузки TTF шрифта:",e),this.editor.showStatus("Ошибка загрузки шрифта","error")}else this.editor.showStatus("Пожалуйста, выберите файл .ttf","error")}onMouseDown(e){if(0!==e.button)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);let s;if(t.length>0)s=t[0].point.clone(),s.y+=.1;else{const e=new THREE.Plane(new THREE.Vector3(0,1,0),0);if(s=new THREE.Vector3,!this.editor.raycaster.ray.intersectPlane(e,s))return!1;{const e=this.editor.gridStep;s.x=Math.round(s.x/e)*e,s.z=Math.round(s.z/e)*e}}return this.createFinalText(s),!0}onMouseMove(e){if(this.isPlacing)return;let t;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera),this.clearTempText();const s=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(s.length>0)t=s[0].point.clone(),t.y+=.1;else{const e=new THREE.Plane(new THREE.Vector3(0,1,0),0);if(t=new THREE.Vector3,!this.editor.raycaster.ray.intersectPlane(e,t))return this.hideTempText(),!1;{const e=this.editor.gridStep;t.x=Math.round(t.x/e)*e,t.z=Math.round(t.z/e)*e}}return this.showTextPreview(t),!0}onKeyDown(e){return"Delete"===e.key||"Backspace"===e.key?(this.clear(),!0):!("Enter"!==e.key||!this.currentTextMesh)&&(this.finishTextEditing(),!0)}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","text3dTool"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents(),this.updateFontSelector())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="text3dTool"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <div class="property-group" data-type="text3d-settings">\n                <h4>3D ТЕКСТ</h4>\n\n                <div class="property-row">\n                    <label>Текст:</label>\n                    <input type="text" id="text3dInput" value="${this.text}" style="width: 200px;">\n                </div>\n\n                <div class="property-row">\n                    <label>Шрифт:</label>\n                    <select id="text3dFont" class = "property-select">\n                        \x3c!-- Динамически заполняется --\x3e\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label>Размер:</label>\n                    <input type="number" id="text3dSize" value="${this.fontSize}" step="0.5" min="1" max="100" style="width: 80px;">\n                    <span>мм</span>\n                </div>\n\n                <div class="property-row">\n                    <label>Глубина:</label>\n                    <input type="number" id="text3dDepth" value="${this.depth}" step="0.5" min="0.1" max="50" style="width: 80px;">\n                    <span>мм</span>\n                </div>\n\n                <div class="property-row">\n                    <label>Цвет:</label>\n                    <input type="color" id="text3dColor" value="#${this.fontColor.toString(16).padStart(6,"0")}" style="width: 60px;">\n                </div>\n\n                <div class="property-row">\n                    <label>Материал:</label>\n                    <select id="text3dMaterial" class = "property-select">\n                        <option value="standard">Standard</option>\n                        <option value="basic">Basic</option>\n                        <option value="phong">Phong</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label>Скошенные края:</label>\n                    <input type="checkbox" id="text3dBevel" ${this.bevelEnabled?"checked":""}>\n                </div>\n\n                <div class="property-subgroup" id="bevelSettings" style="${this.bevelEnabled?"":"display: none;"}">\n                    <div class="property-row">\n                        <label>Толщина скоса:</label>\n                        <input type="number" id="text3dBevelThickness" value="${this.bevelThickness}" step="0.05" min="0.05" max="1" style="width: 80px;">\n                        <span>мм</span>\n                    </div>\n\n                    <div class="property-row">\n                        <label>Размер скоса:</label>\n                        <input type="number" id="text3dBevelSize" value="${this.bevelSize}" step="0.05" min="0.05" max="1" style="width: 80px;">\n                        <span>мм</span>\n                    </div>\n\n                    <div class="property-row">\n                        <label>Детализация:</label>\n                        <select id="text3dCurveSegments" class = "property-select">\n                            <option value="4">Низкая</option>\n                            <option value="8" selected>Средняя</option>\n                            <option value="12">Высокая</option>\n                            <option value="24">Очень высокая</option>\n                        </select>\n                    </div>\n                </div>\n\n                \x3c!-- Секция загрузки TTF шрифтов --\x3e\n                <div class="property-subgroup" class = "property-select">\n                    <div class="property-row">\n                        <label>Загрузить TTF шрифт:</label>\n                    </div>\n\n                    <div class="property-row">\n                        <label>Качество конвертации:</label>\n                        <select id="ttfConversionQuality" class = "property-select">\n                            <option value="low">Низкое</option>\n                            <option value="medium" selected>Среднее</option>\n                            <option value="high">Высокое</option>\n                            <option value="veryhigh">Очень высокое</option>\n                        </select>\n                    </div>\n\n                    <div class="property-row">\n                        <input type="file" id="ttfUpload" accept=".ttf" style="display: none;">\n                        <button id="uploadTTFButton" class="btn-secondary" style="width: 100%;">\n                            <i class="fas fa-upload"></i> Загрузить TTF\n                        </button>\n                    </div>\n                    <div class="property-row" style="margin-top: 10px;">\n                        <small style="color: #666;">\n                            Поддерживаются кириллические и латинские символы<br>\n                        </small>\n                    </div>\n                </div>\n\n                <div class="property-row" style="margin-top: 20px;">\n                    <button id="text3dCreateBtn" class="btn-primary" style="width: 100%;">\n                        <i class="fas fa-plus"></i> Создать текст\n                    </button>\n                </div>\n            </div>\n        `}updateFontSelector(){const e=this.propertiesElement?.querySelector("#text3dFont");if(!e)return;const t=e.value;if(e.innerHTML="",this.availableFonts.forEach(t=>{const s=document.createElement("option");s.value=t.name,s.textContent=t.name,this.fonts[t.name]||(s.disabled=!0,s.textContent+=" (загрузка...)"),e.appendChild(s)}),Object.keys(this.customFonts).length>0){const t=document.createElement("option");t.disabled=!0,t.textContent="──────────",e.appendChild(t);for(const t in this.customFonts){const s=document.createElement("option");s.value=t,s.textContent=`★ ${t}`,e.appendChild(s)}}t&&e.querySelector(`option[value="${t}"]`)?e.value=t:e.value=this.currentFont}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#text3dInput");e&&e.addEventListener("input",e=>{this.text=e.target.value,this.updateTextPreview()});const t=this.propertiesElement.querySelector("#text3dFont");t&&t.addEventListener("change",e=>{this.currentFont=e.target.value,this.updateTextPreview()});const s=this.propertiesElement.querySelector("#text3dSize");s&&s.addEventListener("input",e=>{this.fontSize=parseFloat(e.target.value)||10,this.updateTextPreview()});const i=this.propertiesElement.querySelector("#text3dDepth");i&&i.addEventListener("input",e=>{this.depth=parseFloat(e.target.value)||2,this.updateTextPreview()});const n=this.propertiesElement.querySelector("#text3dColor");n&&n.addEventListener("input",e=>{const t=new THREE.Color(e.target.value);this.fontColor=t.getHex(),this.updateTextMaterial()});const o=this.propertiesElement.querySelector("#text3dMaterial");o&&(o.value=this.materialType,o.addEventListener("change",e=>{this.materialType=e.target.value,this.updateTextMaterial()}));const r=this.propertiesElement.querySelector("#text3dBevel");r&&r.addEventListener("change",e=>{this.bevelEnabled=e.target.checked;const t=this.propertiesElement.querySelector("#bevelSettings");t&&(t.style.display=this.bevelEnabled?"block":"none"),this.updateTextPreview()});const a=this.propertiesElement.querySelector("#text3dBevelThickness");a&&a.addEventListener("input",e=>{this.bevelThickness=parseFloat(e.target.value)||.1,this.updateTextPreview()});const l=this.propertiesElement.querySelector("#text3dBevelSize");l&&l.addEventListener("input",e=>{this.bevelSize=parseFloat(e.target.value)||.05,this.updateTextPreview()});const h=this.propertiesElement.querySelector("#text3dCurveSegments");h&&(h.value=this.curveSegments.toString(),h.addEventListener("change",e=>{this.curveSegments=parseInt(e.target.value)||12,this.updateTextPreview()}));const c=this.propertiesElement.querySelector("#ttfConversionQuality");c&&(c.value=this.conversionQuality,c.addEventListener("change",e=>{this.conversionQuality=e.target.value}));const p=this.propertiesElement.querySelector("#uploadTTFButton"),d=this.propertiesElement.querySelector("#ttfUpload");p&&d&&(p.addEventListener("click",()=>{d.click()}),d.addEventListener("change",async e=>{const t=e.target.files[0];t&&await this.loadTTFFont(t)}));const u=this.propertiesElement.querySelector("#text3dCreateBtn");u&&u.addEventListener("click",()=>{this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=new THREE.Plane(new THREE.Vector3(0,1,0),0),t=new THREE.Vector3;this.editor.raycaster.ray.intersectPlane(e,t)&&this.createFinalText(t)})}updateTextPreview(){if(this.tempText&&this.tempText.parent){const e=this.tempText.position.clone();this.clearTempText(),this.showTextPreview(e)}}updateTextMaterial(){const e=new THREE.Color(this.fontColor);Object.keys(this.textMaterials).forEach(t=>{this.textMaterials[t].color.copy(e),this.textMaterials[t].needsUpdate=!0}),this.tempText&&(this.tempText.material=this.textMaterials[this.materialType]),this.currentTextMesh&&(this.currentTextMesh.material=this.textMaterials[this.materialType])}showTextPreview(e){if(this.text&&this.fonts[this.currentFont]){this.clearTempText();try{const t=new THREE.TextGeometry(this.text,{font:this.fonts[this.currentFont],size:this.fontSize,height:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize});t.computeBoundingBox();const s=new THREE.Vector3;t.boundingBox.getCenter(s),t.translate(-s.x,-s.y,-s.z/2);const i=this.textMaterials[this.materialType];this.tempText=new THREE.Mesh(t,i),this.tempText.position.copy(e),this.tempText.material.transparent=!0,this.tempText.material.opacity=.7,this.editor.scene.add(this.tempText),this.updateCoordinates(e)}catch(e){console.error("Ошибка создания предварительного просмотра текста:",e),this.editor.showStatus("Ошибка создания текста","error")}}else this.hideTempText()}hideTempText(){this.tempText&&(this.tempText.visible=!1)}clearTempText(){this.tempText&&(this.editor.scene.remove(this.tempText),this.tempText.geometry&&this.tempText.geometry.dispose(),this.tempText=null)}createFinalText(e){if(this.text&&this.fonts[this.currentFont])try{this.clearTempText();const t=new THREE.TextGeometry(this.text,{font:this.fonts[this.currentFont],size:this.fontSize,height:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize});t.computeBoundingBox();const s=new THREE.Vector3;t.boundingBox.getCenter(s),t.translate(-s.x,-s.y,-s.z/2);const i=this.textMaterials[this.materialType].clone();i.opacity=1;const n=new THREE.Mesh(t,i);n.position.copy(e),n.userData.type="text3d",n.userData.text=this.text,n.userData.font=this.currentFont,n.userData.fontSize=this.fontSize,n.userData.depth=this.depth,n.userData.bevelEnabled=this.bevelEnabled,n.userData.bevelThickness=this.bevelThickness,n.userData.bevelSize=this.bevelSize,n.userData.curveSegments=this.curveSegments,n.userData.materialType=this.materialType,n.userData.color=this.fontColor,n.userData.isEditable=!0,this.editor.objectsGroup.add(n),this.editor.objects.push(n),this.editor.history&&this.editor.history.addAction({type:"create",object:n.uuid,data:this.editor.projectManager.serializeObjectForHistory(n)}),this.editor.showStatus(`3D текст создан: "${this.text}"`,"success"),this.currentTextMesh=n}catch(e){console.error("Ошибка создания 3D текста:",e),this.editor.showStatus("Ошибка создания 3D текста","error")}else this.editor.showStatus("Введите текст и дождитесь загрузки шрифта","error")}finishTextEditing(){this.currentTextMesh&&(this.currentTextMesh=null,this.editor.showStatus("Создание текста завершено. Кликните для нового текста","success"))}updateCoordinates(e){e&&(document.getElementById("coords").textContent=`X: ${e.x.toFixed(2)}, Y: ${e.y.toFixed(2)}, Z: ${e.z.toFixed(2)}`)}clear(){this.clearTempText(),this.currentTextMesh=null,this.isPlacing=!1}}