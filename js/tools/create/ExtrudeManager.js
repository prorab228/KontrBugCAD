import*as THREE from"three";import{ParametricOperation}from"/js/core/parametric/ParametricOperation.js";import{OperationManager}from"./OperationManager.js";export class ExtrudeManager extends OperationManager{constructor(e){super(e),this.extrudePreviewGroup=null,this.previewMaterial=null,this.extrudeArrow=null,this.isDraggingArrow=!1,this.arrowStartHeight=0,this.startMouseY=0,this.currentOperation="new",this.propertiesElement=null,console.log("ExtrudeManager создан (версия с регионами)")}createOperationFigure(e){return this.regionToOperationFigure(e)}getFiguresForOperation(){return this.getRegionsForOperation()}getPreviewColor(){switch(this.currentOperation){case"cut":return 16711680;case"join":return 16750592;default:return 5025616}}calculateSignedPolygonArea(e){if(e.length<3)return 0;let t=0;const r=e.length;for(let i=0;i<r;i++){const o=(i+1)%r;t+=e[i].x*e[o].y,t-=e[o].x*e[i].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,r=0;return e.forEach(e=>{t+=e.x,r+=e.y}),new THREE.Vector2(t/e.length,r/e.length)}pointInPolygon(e,t){let r=!1;for(let i=0,o=t.length-1;i<t.length;o=i++){const n=t[i].x,s=t[i].y,a=t[o].x,l=t[o].y;s>e.y!=l>e.y&&e.x<(a-n)*(e.y-s)/(l-s)+n&&(r=!r)}return r}createExtrusionGeometryFromFigures(e,t,r,i=!1){if(0===e.length||!this.basePlane)return null;const o=[];for(const t of e){const e=t.outer.points;if(e.length<3)continue;const r=t.outer.isClockwise?e.slice().reverse():e.slice(),i=new THREE.Shape(r.map(e=>new THREE.Vector2(e.x,e.y)));if(t.holes&&t.holes.length>0)for(const e of t.holes){const t=e.points;if(t.length<3)continue;const r=e.isClockwise?t.slice():t.slice().reverse(),o=new THREE.Path(r.map(e=>new THREE.Vector2(e.x,e.y)));i.holes.push(o)}o.push(i)}if(0===o.length)return null;let n=t;i&&(n+=.2);const s={depth:n,bevelEnabled:!1,steps:1},a=new THREE.ExtrudeGeometry(o,s);return i?"positive"===r?a.translate(0,0,-.2):"negative"===r?a.translate(0,0,-n):"both"===r&&a.translate(0,0,-n/2):"positive"===r?a.translate(0,0,-.2):"negative"===r?a.translate(0,0,-t):"both"===r&&a.translate(0,0,-t/2),a}createPreviewMesh(e,t,r,i=!1){const o=this.createExtrusionGeometryFromFigures(e,t,r,i);if(!o)return null;const n=new THREE.MeshPhongMaterial({color:this.getPreviewColor(),transparent:!0,opacity:.3,side:THREE.DoubleSide}),s=new THREE.Mesh(o,n);s.position.copy(this.basePlane.position),s.quaternion.copy(this.basePlane.quaternion);const a=new THREE.Vector3(0,0,1).applyQuaternion(this.basePlane.quaternion);return s.position.addScaledVector(a,.1),s}updateExtrudePreview(){const e=this.getFiguresForOperation();if(0===e.length)return void this.removeExtrudePreview();const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive";if(this.extrudePreviewGroup&&this.extrudePreviewGroup.children.length>0){const i=this.extrudePreviewGroup.children[0],o=this.createExtrusionGeometryFromFigures(e,t,r);o&&(i.geometry.dispose(),i.geometry=o,this.updatePreviewPosition(i,t,r),i.material.color.setHex(this.getPreviewColor()))}else this.createNewExtrudePreview(e,t,r)}createNewExtrudePreview(e,t,r){this.removeExtrudePreview();const i=this.createExtrusionGeometryFromFigures(e,t,r);if(!i)return;const o=this.getPreviewColor(),n=new THREE.MeshPhongMaterial({color:o,transparent:!0,opacity:.3,side:THREE.DoubleSide});this.previewMaterial=n;const s=new THREE.Mesh(i,n);this.updatePreviewPosition(s,t,r),this.extrudePreviewGroup=new THREE.Group,this.extrudePreviewGroup.add(s),this.editor.objectsGroup.add(this.extrudePreviewGroup)}updatePreviewPosition(e,t,r){if(!e||!this.basePlane)return;e.position.copy(this.basePlane.position),e.quaternion.copy(this.basePlane.quaternion);const i=new THREE.Vector3(0,0,1).applyQuaternion(this.basePlane.quaternion);e.position.addScaledVector(i,.1)}removeExtrudePreview(){this.extrudePreviewGroup&&(this.editor.objectsGroup.remove(this.extrudePreviewGroup),this.extrudePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.extrudePreviewGroup=null)}createExtrudeDirectionIndicator(){this.extrudeArrow&&(this.editor.scene.remove(this.extrudeArrow),this.extrudeArrow=null);if(0===this.getFiguresForOperation().length||!this.basePlane)return;if(!this.isPlaneVisible(this.basePlane))return void console.log("Базовая плоскость скрыта, стрелка не создаётся");const e=document.getElementById("extrudeDirection")?.value||"positive";let t=new THREE.Vector3(0,0,1).applyQuaternion(this.basePlane.quaternion).normalize().clone();"negative"===e&&t.negate(),this.extrudeArrow=new THREE.Group,this.extrudeArrow.userData.isExtrudeArrow=!0,this.extrudeArrow.userData.isDraggable=!0;const r=new THREE.CylinderGeometry(.5,.5,15,8),i=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.7,depthTest:!1}),o=new THREE.Mesh(r,i);o.renderOrder=999,o.position.y=7.5,o.userData.isArrowPart=!0,o.userData.isDraggable=!0,o.userData.isArrowHandle=!0,this.extrudeArrow.add(o);const n=new THREE.ConeGeometry(3,6,8),s=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.9,depthTest:!1}),a=new THREE.Mesh(n,s);a.renderOrder=999,a.position.y=18,a.userData.isArrowPart=!0,a.userData.isArrowHandle=!0,a.userData.isDraggable=!0,this.extrudeArrow.add(a);const l=new THREE.Vector3(0,1,0),u=(new THREE.Quaternion).setFromUnitVectors(l,t);this.extrudeArrow.quaternion.copy(u),this.updateArrowPosition(),this.editor.scene.add(this.extrudeArrow)}updateArrowPosition(){if(!this.extrudeArrow||!this.basePlane)return;const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10,t=document.getElementById("extrudeDirection")?.value||"positive",r=this.getFiguresForOperation();if(0===r.length)return;let i=new THREE.Vector3(0,0,1).applyQuaternion(this.basePlane.quaternion).normalize().clone();"negative"===t&&i.negate();const o=new THREE.Vector3(0,1,0),n=(new THREE.Quaternion).setFromUnitVectors(o,i);this.extrudeArrow.quaternion.copy(n);const s=new THREE.Vector3(0,0,0);let a=0;r.forEach(e=>{const t=e.outer.center,r=e.outer.area||1;s.x+=t.x*r,s.y+=t.y*r,a+=r}),a>0&&(s.x/=a,s.y/=a);const l=this.basePlane.localToWorld(s),u=this.basePlane.position.clone(),d=(new THREE.Vector3).subVectors(l,u);let h=e;"both"===t&&(h=e/2);const c=u.clone().add(d).clone().addScaledVector(i,h);this.extrudeArrow.position.copy(c),this.extrudeArrow.updateMatrixWorld(!0)}handleArrowDragStart(e){if(!this.extrudeArrow)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.extrudeArrow.traverse(e=>{(e.userData?.isDraggable||e.userData?.isArrowHandle)&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingArrow=!0,this.startMouseY=e.clientY,this.arrowStartHeight=parseFloat(document.getElementById("extrudeHeight")?.value)||10,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleArrowDrag(e){if(!this.isDraggingArrow||!this.extrudeArrow||!this.basePlane)return;const t=e.clientY-this.startMouseY,r=document.getElementById("extrudeDirection")?.value||"positive",i=new THREE.Vector3(0,0,1).applyQuaternion(this.basePlane.quaternion).normalize(),o=this.extrudeArrow.position.clone(),n=o.clone().project(this.editor.camera);let s=.4*-t;o.clone().addScaledVector(i,10).clone().project(this.editor.camera).y-n.y<0&&(s=-s),"negative"===r&&(s=-s);let a=this.arrowStartHeight+s;a=Math.max(.1,Math.round(10*a)/10);const l=document.getElementById("extrudeHeight");l&&(l.value=a,l.dispatchEvent(new Event("input",{bubbles:!0})),this.updateExtrudePreview(),this.updateArrowPosition()),e.preventDefault()}handleArrowDragEnd(){this.isDraggingArrow=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor="default",this.updateExtrudePreview(),this.updateArrowPosition();const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10;this.editor.showStatus(`Высота установлена: ${e.toFixed(1)} мм`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingArrow&&this.handleArrowDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingArrow&&0===e.button&&this.handleArrowDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}createPropertiesUI(){const e=this.selectedRegions.size;return`\n            <div class="property-group" data-tool="extrude">\n                <h4>ВЫТЯГИВАНИЕ</h4>\n\n                <div class="property-row">\n                    <label>Высота (мм):</label>\n                    <input type="number" id="extrudeHeight" class="property-input" value="10" step="0.1" min="0.1">\n                </div>\n\n                <div class="property-row">\n                    <label>Направление:</label>\n                    <select id="extrudeDirection" class="property-select">\n                        <option value="positive">Наружу</option>\n                        <option value="negative">Внутрь</option>\n                        <option value="both">В обе стороны</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label>Операция:</label>\n                    <select id="extrudeOperation" class="property-select">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n\n                <div class="property-buttons">\n                    <button id="performOperation" class="btn-primary" ${0===e?"disabled":""}>\n                        <i class="fas fa-check"></i> Выполнить\n                    </button>\n                    <button id="cancelExtrude" class="btn-secondary">\n                        <i class="fas fa-times"></i> Отмена\n                    </button>\n                </div>\n\n                <div class="property-hint">\n                    <div id="selectedContourInfo">\n                        ${e>0?`Выбрано регионов: ${e}`:"Кликните по региону для выбора"}\n                    </div>\n                </div>\n                <div class="property-row">\n                    <div class="property-hint">\n                        <i class="fas fa-info-circle"></i> Описание:\n                        <div>Этот инструмент создает объемное тело путем линейного вытягивания плоского эскиза в перпендикулярном ему направлении.</div><br>\n                        <div>• Клик по фигуре: выделить/снять выделение</div>\n                        <div>• Перетаскивайте стрелку для изменения высоты</div>\n                        <div>• Escape для отмены, Enter для подтверждения</div>\n                    </div>\n                </div>\n            </div>\n        `}showExtrudeUI(){this.removeExtrudeUI();const e=document.getElementById("propertiesContent");e&&(this.propertiesElement=document.createElement("div"),this.propertiesElement.innerHTML=this.createPropertiesUI(),e.appendChild(this.propertiesElement),this.setupPropertiesEventListeners(),this.updateExtrudeUI(),this.currentOperation="new")}setupPropertiesEventListeners(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#cancelExtrude");e&&e.addEventListener("click",()=>this.exitExtrudeMode());const t=this.propertiesElement.querySelector("#performOperation");t&&t.addEventListener("click",()=>this.performExtrude());const r=this.propertiesElement.querySelector("#extrudeHeight");r&&r.addEventListener("input",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});const i=this.propertiesElement.querySelector("#extrudeDirection");i&&i.addEventListener("change",()=>{this.updateExtrudePreview(),this.updateArrowPosition(),this.createExtrudeDirectionIndicator()});const o=this.propertiesElement.querySelector("#extrudeOperation");o&&o.addEventListener("change",e=>{this.currentOperation=e.target.value,this.updateExtrudePreview()})}updateExtrudeUI(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#selectedContourInfo"),t=this.propertiesElement.querySelector("#performOperation"),r=this.selectedRegions.size;e&&(e.textContent=r>0?`Выбрано регионов: ${r}`:"Кликните по региону для выбора",e.style.color=r>0?"#4CAF50":"#888"),t&&(t.disabled=0===r)}removeExtrudeUI(){this.propertiesElement&&(this.propertiesElement.remove(),this.propertiesElement=null)}performExtrude(){const e=this.getFiguresForOperation();if(0===e.length)return void this.editor.showStatus("Выберите регион(ы) для вытягивания","error");const t=parseFloat(this.propertiesElement?.querySelector("#extrudeHeight")?.value)||10,r=this.propertiesElement?.querySelector("#extrudeDirection")?.value||"positive",i=this.propertiesElement?.querySelector("#extrudeOperation")?.value||"new";if(isNaN(t)||t<=0)return void this.editor.showStatus("Введите корректную высоту (>0)","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const o={figures:e.map(e=>({outer:e.outer.points.flatMap(e=>[e.x,e.y]),holes:e.holes.map(e=>e.points.flatMap(e=>[e.x,e.y]))})),height:t,direction:r,operationType:i,color:5025616,planeId:this.basePlane.uuid},n=[];if("cut"===i||"join"===i){const i=this.createPreviewMesh(e,t,r,!0);if(!i)return void this.editor.showStatus("Не удалось создать временную геометрию","error");const o=this.findIntersectingObjects(i).map(e=>e.uuid);if(i.geometry.dispose(),0===o.length)return void this.editor.showStatus("Нет пересекающихся объектов для операции","warning");n.push(...o)}const s=new ParametricOperation("extrude",o,n),a=this.editor.parametricModel.addOperation(s);this.editor.clearSelection(),a.forEach(e=>{const t=this.editor.parametricModel.objectMap.get(e);t&&(this.editor.selectedObjects.push(t),this.editor.objectsManager.highlightObject(t))}),this.editor.showStatus(`Вытягивание выполнено: высота ${t} мм, ${e.length} регионов`,"success"),this.exitExtrudeMode()}findIntersectingObjects(e){const t=[],r=(new THREE.Box3).setFromObject(e);return this.editor.parametricModel.objectMap.forEach(i=>{if(!i.visible||i.userData.isHelper)return;if(i===e)return;const o=i.userData?.type;if("sketch_plane"===o||"work_plane"===o||"sketch_element"===o)return;const n=(new THREE.Box3).setFromObject(i);r.intersectsBox(n)&&t.push(i)}),t}exitExtrudeMode(){this.editor.toolManager.setCurrentTool("select")}cancelExtrudeMode(){this.clearSelection(),this.extrudeArrow&&(this.editor.scene.remove(this.extrudeArrow),this.extrudeArrow=null),this.removeExtrudePreview(),this.removeExtrudeUI(),this.editor.scene.traverse(e=>{e.userData?.regionManager&&e.userData.regionManager.clearHighlight()}),this.editor.showStatus("Режим вытягивания завершён","info"),document.body.style.cursor="default"}toggleSelection(e){super.toggleSelection(e),console.log("ExtrudeManager: toggleSelection, обновляем предпросмотр"),this.updateExtrudePreview(),this.createExtrudeDirectionIndicator(),this.updateExtrudeUI()}highlightExtrudableRegions(){this.editor.scene.traverse(e=>{e.userData?.regionManager&&e.userData.regionManager.clearHighlight()});const e=this.getAllRegions();e.forEach(e=>{this.highlightRegion(e,2201331)}),0===e.length&&this.editor.showStatus("Нет замкнутых регионов для вытягивания","warning")}highlightExtrudableFigures(){this.highlightExtrudableRegions()}}