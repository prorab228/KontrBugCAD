class ExtrudeManager extends OperationManager{constructor(e){super(e),this.extrudePreviewGroup=null,this.previewMaterial=null,this.extrudeArrow=null,this.isDraggingArrow=!1,this.arrowStartHeight=0,this.startMouseY=0,this.currentOperation="new",this.propertiesElement=null,console.log("ExtrudeManager: создан (реализация через Manifold)")}getElementPoints(e){if(!e)return[];const t=[];if("line"===e.userData?.elementType){const r=e.geometry.attributes.position.array,o=new THREE.Vector3(r[0],r[1],r[2]),i=new THREE.Vector3(r[3],r[4],r[5]);e.localToWorld(o),e.localToWorld(i),t.push(o,i)}else if("arc"===e.userData?.elementType){const r=e.userData.center||new THREE.Vector3,o=e.userData.radius||1,i=e.userData.startAngle||0,s=e.userData.endAngle||0,n=e.userData.segments||16,a=(s-i)/n;for(let s=0;s<=n;s++){const n=i+a*s,l=new THREE.Vector3(r.x+Math.cos(n)*o,r.y+Math.sin(n)*o,r.z);e.localToWorld(l),t.push(l)}}else if("rectangle"===e.userData?.elementType){const r=(new THREE.Box3).setFromObject(e);[new THREE.Vector3(r.min.x,r.min.y,r.min.z),new THREE.Vector3(r.max.x,r.min.y,r.min.z),new THREE.Vector3(r.max.x,r.max.y,r.min.z),new THREE.Vector3(r.min.x,r.max.y,r.min.z),new THREE.Vector3(r.min.x,r.min.y,r.min.z)].forEach(r=>{e.localToWorld(r),t.push(r)})}return t}getElementStart(e){if(!e)return new THREE.Vector3;if("line"===e.userData?.elementType){const t=e.geometry.attributes.position.array,r=new THREE.Vector3(t[0],t[1],t[2]);return e.localToWorld(r),r}if("arc"===e.userData?.elementType){const t=e.userData.startAngle||0,r=e.userData.radius||1,o=e.userData.center||new THREE.Vector3,i=new THREE.Vector3(o.x+Math.cos(t)*r,o.y+Math.sin(t)*r,o.z);return e.localToWorld(i),i}return new THREE.Vector3}getElementEnd(e){if(!e)return new THREE.Vector3;if("line"===e.userData?.elementType){const t=e.geometry.attributes.position.array,r=new THREE.Vector3(t[3],t[4],t[5]);return e.localToWorld(r),r}if("arc"===e.userData?.elementType){const t=e.userData.endAngle||0,r=e.userData.radius||1,o=e.userData.center||new THREE.Vector3,i=new THREE.Vector3(o.x+Math.cos(t)*r,o.y+Math.sin(t)*r,o.z);return e.localToWorld(i),i}return new THREE.Vector3}sortContourElements(e){if(e.length<=1)return e;const t=[e[0]],r=e.slice(1);for(;r.length>0;){const e=t[t.length-1],o=this.getElementEnd(e);let i=!1;for(let e=0;e<r.length;e++){const s=r[e],n=this.getElementStart(s);if(o.distanceTo(n)<.001){t.push(s),r.splice(e,1),i=!0;break}}i||t.push(r.shift())}return t}getFigurePointsForBasePlane(e){if(console.log("=== getFigurePointsForBasePlane ==="),console.log("Базовая плоскость:",this.basePlane),console.log("Фигура:",e.id),!this.basePlane)return console.error("Базовая плоскость не установлена"),[];const t=[];if(e.outer.elements&&e.outer.elements.length>0){const r=e.outer.elements;console.log(`Количество элементов контура: ${r.length}`);const o=this.sortContourElements(r);console.log(`Отсортировано элементов: ${o.length}`);for(let e=0;e<o.length;e++){const r=o[e],i=this.getElementPoints(r);if(console.log(`Элемент ${e}: ${r.userData?.elementType}, точек: ${i.length}`),i&&i.length>0)for(let e=0;e<i.length;e++){const r=i[e],o=this.basePlane.worldToLocal(r.clone());t.push(new THREE.Vector2(o.x,o.y))}}}else if(e.outer.element){const r=e.outer.element;console.log(`Один элемент: ${r.userData?.elementType}`);const o=this.getElementPoints(r);o&&o.length>0&&(console.log(`Точек в элементе: ${o.length}`),o.forEach(e=>{const r=this.basePlane.worldToLocal(e.clone());t.push(new THREE.Vector2(r.x,r.y))}))}return console.log(`Собрано точек: ${t.length}`),this.simplifyContourPoints(t)}simplifyContourPoints(e){if(e.length<3)return console.warn("Недостаточно точек для контура:",e.length),e;const t=[e[0]];for(let r=1;r<e.length;r++){const o=t[t.length-1],i=e[r];o.distanceTo(i)>.001&&t.push(i)}if(t.length>2){const e=t[0],r=t[t.length-1];e.distanceTo(r)>.001&&t.push(e.clone())}return console.log("Упрощенный контур:",{"исходных":e.length,"после_упрощения":t.length}),t}getContourPointsForBasePlane(e){if(!this.basePlane)return[];const t=[];if(e.elements&&e.elements.length>0){const r=this.sortContourElements(e.elements);for(let e=0;e<r.length;e++){const o=r[e],i=this.getElementPoints(o);i&&i.length>0&&i.forEach(e=>{const r=this.basePlane.worldToLocal(e.clone());t.push(new THREE.Vector2(r.x,r.y))})}}return this.simplifyContourPoints(t)}async createExtrusionManifold(e,t,r,o=!1){if(!this.editor.booleanOps?.isReady||!this.editor.booleanOps.manifold)return console.error("Manifold не готов для создания геометрии"),null;const i=this.editor.booleanOps.manifold;try{const s=[];for(const o of e){const e=this.getFigurePointsForBasePlane(o);if(e.length<3){console.warn("Пропускаем фигуру: недостаточно точек для контура",e.length);continue}let n=!0;for(const t of e)if(isNaN(t.x)||isNaN(t.y)||!isFinite(t.x)||!isFinite(t.y)){console.warn("Невалидная точка в контуре:",t),n=!1;break}if(!n)continue;const a=e.map(e=>[e.x,e.y]),l=i.CrossSection([a]);if(!l||l.area()<=0){console.warn("Сечение имеет нулевую площадь, пропускаем фигуру");continue}let c=l.extrude(t);if(c&&0!==c.numVert()){if("negative"===r)c=c.transform([1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1]);else if("both"===r){const e=t/2,r=i.CrossSection([a]).extrude(e),o=i.CrossSection([a]).extrude(e).transform([1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1]);c=i.Manifold.union([r,o])}s.push(c)}else console.warn("Выдавливание создало пустой манифолд")}if(0===s.length)return console.error("Не удалось создать ни одного валидного манифолда"),null;let n=s[0];for(let e=1;e<s.length;e++)n=i.Manifold.union([n,s[e]]);if(o&&n){const e=.1;"positive"===r?n=n.transform([1,0,0,0,0,1,0,0,0,0,1,0,0,0,e,1]):"negative"===r&&(n=n.transform([1,0,0,0,0,1,0,0,0,0,1,0,0,0,-e,1]))}return console.log("✅ Манифолд создан успешно:",{"вершин":n.numVert(),"треугольников":n.numTri(),"объём":n.volume().toFixed(2)}),n}catch(e){return console.error("❌ Ошибка создания манифолда для выдавливания:",e),console.error("Stack trace:",e.stack),null}}async createExtrusionMeshFromManifold(e,t,r,o=!1){const i=await this.createExtrusionManifold(e,t,r,o);if(!i)return console.error("❌ Манифолд не создан"),null;const s=this.editor.booleanOps._manifoldToThreeGeometry(i);if(!s||!s.attributes?.position||0===s.attributes.position.count)return console.error("❌ Геометрия пустая после преобразования из манифолда"),console.log("Geometry details:",{attributes:Object.keys(s.attributes||{}),positionCount:s.attributes?.position?.count,indexCount:s.index?.count}),null;console.log("✅ Создана геометрия:",{vertices:s.attributes.position.count,faces:s.index?Math.floor(s.index.count/3):Math.floor(s.attributes.position.count/3)});const n=new THREE.MeshStandardMaterial({color:5025616,metalness:.3,roughness:.6,side:THREE.DoubleSide}),a=new THREE.Mesh(s,n);if(a.castShadow=!0,a.receiveShadow=!0,this.basePlane){const e=new THREE.Vector3;if(this.basePlane.getWorldPosition(e),a.position.copy(e),a.quaternion.copy(this.basePlane.quaternion),"negative"===r){const e=new THREE.Vector3(0,0,-t);e.applyQuaternion(this.basePlane.quaternion),a.position.add(e)}else if("both"===r){const e=new THREE.Vector3(0,0,-t/2);e.applyQuaternion(this.basePlane.quaternion),a.position.add(e)}}return a}async updateExtrudePreview(){const e=this.getFiguresForOperation();if(0===e.length)return void this.removeExtrudePreview();const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive";if(this.extrudePreviewGroup&&this.extrudePreviewGroup.children.length>0){const o=this.extrudePreviewGroup.children[0],i=await this.createExtrusionMeshFromManifold(e,t,r,!1);i&&i.geometry&&(o.geometry.dispose(),o.geometry=i.geometry,this.updatePreviewPosition(o,t,r))}else await this.createNewExtrudePreview(e,t,r)}async createNewExtrudePreview(e,t,r){this.removeExtrudePreview();const o=await this.createExtrusionMeshFromManifold(e,t,r,!1);o&&(this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.3,side:THREE.DoubleSide})),o.material=this.previewMaterial,this.updatePreviewPosition(o,t,r),this.extrudePreviewGroup=new THREE.Group,this.extrudePreviewGroup.add(o),this.editor.objectsGroup.add(this.extrudePreviewGroup))}updatePreviewPosition(e,t,r){if(!e||!this.basePlane)return;const o=new THREE.Vector3;this.basePlane.getWorldPosition(o),e.position.copy(o),e.quaternion.copy(this.basePlane.quaternion);const i=new THREE.Vector3(0,0,1);i.applyQuaternion(this.basePlane.quaternion),i.normalize();e.position.add(i.clone().multiplyScalar(.1))}removeExtrudePreview(){this.extrudePreviewGroup&&(this.editor.objectsGroup.remove(this.extrudePreviewGroup),this.extrudePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.extrudePreviewGroup=null)}createPropertiesUI(){const e=this.selectedFigures.size;return`\n            <div class="property-group" data-tool="extrude">\n                <h4>ВЫТЯГИВАНИЕ</h4>\n\n                <div class="property-row">\n                    <label>Высота (мм):</label>\n                    <input type="number" id="extrudeHeight" class="property-input" value="10" step="1" min="1">\n                </div>\n\n                <div class="property-row">\n                    <label>Направление:</label>\n                    <select id="extrudeDirection" class="property-select">\n                        <option value="positive">Наружу</option>\n                        <option value="negative">Внутрь</option>\n                        <option value="both">В обе стороны</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label>Операция:</label>\n                    <select id="extrudeOperation" class="property-select">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label class="property-checkbox">\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                        Объединять фигуры\n                        ${this.clipperAvailable?"":' <span style="color: #f00;">(Clipper.js не найден)</span>'}\n                    </label>\n                </div>\n\n                <div class="property-buttons">\n                    <button id="performOperation" class="btn-primary">\n                        <i class="fas fa-check"></i> Выполнить\n                    </button>\n                    <button id="cancelExtrude" class="btn-secondary">\n                        <i class="fas fa-times"></i> Отмена\n                    </button>\n                </div>\n\n                <div class="property-hint">\n                    <div id="selectedContourInfo">\n                        ${e>0?`Выбрано фигур: ${e}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" class="property-status"></div>\n                    <div id="clipperStatus" class="property-status"></div>\n                </div>\n                <div class="property-row">\n                    <div class="property-hint">\n                        <i class="fas fa-info-circle"></i> Описание:\n                        <div>Этот инструмент создает объемное тело путем линейного вытягивания плоского эскиза в перпендикулярном ему направлении через библиотеку Manifold.</div><br>\n                        <div>• Клик по фигуре: выделить/снять выделение</div>\n                        <div>• Перетаскивайте стрелку для изменения высоты</div>\n                        <div>• Escape для отмены, Enter для подтверждения</div>\n                    </div>\n                </div>\n            </div>\n        `}showExtrudeUI(){this.removeExtrudeUI();const e=document.getElementById("propertiesContent");e&&(this.propertiesElement=document.createElement("div"),this.propertiesElement.innerHTML=this.createPropertiesUI(),e.appendChild(this.propertiesElement),this.setupPropertiesEventListeners(),this.updateExtrudeUI())}setupPropertiesEventListeners(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#cancelExtrude");e&&e.addEventListener("click",()=>{this.exitExtrudeMode()});const t=this.propertiesElement.querySelector("#performOperation");t&&t.addEventListener("click",()=>{this.performExtrude()});const r=this.propertiesElement.querySelector("#extrudeHeight");r&&r.addEventListener("input",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});const o=this.propertiesElement.querySelector("#extrudeDirection");o&&o.addEventListener("change",()=>{this.updateExtrudePreview(),this.updateArrowPosition(),this.createExtrudeDirectionIndicator()});const i=this.propertiesElement.querySelector("#extrudeOperation");i&&i.addEventListener("change",()=>{this.currentOperation=i.value});const s=this.propertiesElement.querySelector("#mergeFigures");s&&s.addEventListener("change",e=>{this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(s.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","error")),this.updateExtrudePreview(),this.updateExtrudeUI()})}updateExtrudeUI(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#selectedContourInfo"),t=this.propertiesElement.querySelector("#mergeStatus"),r=this.propertiesElement.querySelector("#clipperStatus"),o=this.propertiesElement.querySelector("#performOperation"),i=this.propertiesElement.querySelector("#mergeFigures");if(i&&(i.disabled=!this.clipperAvailable),e){const o=this.selectedFigures.size;if(o>0){if(e.textContent=`Выбрано фигур: ${o}`,e.style.color="#4CAF50",t)if(o>1&&this.mergeConnectedFigures&&this.clipperAvailable){const e=Array.from(this.selectedFigures.values());this.areAllFiguresOnSamePlane(e)?(t.textContent="✓ Фигуры будут объединены",t.style.color="#4CAF50"):(t.textContent="✗ Фигуры на разных плоскостях",t.style.color="#f44336")}else!this.clipperAvailable&&o>1?(t.textContent="⚠ Clipper.js не найден, объединение недоступно",t.style.color="#FF9800"):t.textContent="";r&&(this.clipperAvailable?(r.textContent="✓ Clipper.js доступен",r.style.color="#4CAF50"):(r.textContent="✗ Clipper.js не найден",r.style.color="#f44336"))}else e.textContent="Кликните по фигуре для выбора",e.style.color="#888",t&&(t.textContent=""),r&&(r.textContent="")}o&&(o.disabled=0===this.selectedFigures.size)}removeExtrudeUI(){this.propertiesElement&&(this.propertiesElement.remove(),this.propertiesElement=null)}createExtrudeDirectionIndicator(){console.log("=== createExtrudeDirectionIndicator ==="),this.extrudeArrow&&(this.extrudeArrow.parent&&this.extrudeArrow.parent.remove(this.extrudeArrow),this.extrudeArrow=null);const e=this.getFiguresForOperation();if(console.log("Фигуры:",e),!e||0===e.length||!this.basePlane)return void console.warn("Нет фигур или базовой плоскости для стрелки");if(!this.isPlaneVisible(this.basePlane))return void console.log("Базовая плоскость скрыта, не создаем стрелку");const t=document.getElementById("extrudeDirection")?.value||"positive",r=new THREE.Vector3(0,0,1);r.applyQuaternion(this.basePlane.quaternion),r.normalize(),"negative"===t&&r.negate(),this.extrudeArrow=new THREE.Group,this.extrudeArrow.userData.isExtrudeArrow=!0,this.extrudeArrow.userData.isDraggable=!0,this.extrudeArrow.raycast=()=>{};const o=new THREE.CylinderGeometry(.5,.5,15,8),i=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.7,depthTest:!1}),s=new THREE.Mesh(o,i);s.renderOrder=999,s.position.y=7.5,s.userData.isArrowPart=!0,s.userData.isDraggable=!0,s.userData.isArrowHandle=!0,this.extrudeArrow.add(s);const n=new THREE.ConeGeometry(3,6,8),a=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.9,depthTest:!1}),l=new THREE.Mesh(n,a);l.renderOrder=999,l.position.y=18,l.userData.isArrowPart=!0,l.userData.isArrowHandle=!0,l.userData.isDraggable=!0,this.extrudeArrow.add(l);const c=new THREE.Vector3(0,1,0),u=(new THREE.Quaternion).setFromUnitVectors(c,r.clone().normalize());this.extrudeArrow.quaternion.copy(u),this.updateArrowPosition(),this.editor.scene.add(this.extrudeArrow),console.log("✅ Стрелка создана и добавлена в сцену")}updateArrowPosition(){if(console.log("=== updateArrowPosition ==="),!this.extrudeArrow||!this.basePlane)return void console.warn("Стрелка или базовая плоскость не установлены");const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10,t=document.getElementById("extrudeDirection")?.value||"positive",r=this.getFiguresForOperation();if(0===r.length)return void console.warn("Нет фигур для позиционирования стрелки");const o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();let i=o.clone();"negative"===t&&i.negate();const s=new THREE.Vector3(0,1,0),n=(new THREE.Quaternion).setFromUnitVectors(s,i.clone().normalize());this.extrudeArrow.quaternion.copy(n);const a=new THREE.Vector3(0,0,0);let l=0;r.forEach(e=>{if(e.outer&&e.outer.center){const t=e.outer.area||1;a.x+=e.outer.center.x*t,a.y+=e.outer.center.y*t,l+=t}}),l>0&&(a.x/=l,a.y/=l);const c=this.basePlane.localToWorld(a.clone()),u=new THREE.Vector3;this.basePlane.getWorldPosition(u);const d=(new THREE.Vector3).subVectors(c,u);let h=e;"both"===t&&(h=e/2);const p=u.clone().add(d).clone().clone().add(i.clone().multiplyScalar(h));this.extrudeArrow.position.copy(p),this.extrudeArrow.updateMatrixWorld(!0),console.log("Стрелка позиционирована:",{"позиция":this.extrudeArrow.position,"направление":t,"высота":e})}handleArrowDragStart(e){if(!this.extrudeArrow)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.extrudeArrow&&this.extrudeArrow.traverse(e=>{e.userData&&(e.userData.isDraggable||e.userData.isArrowHandle)&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingArrow=!0,this.startMouseY=e.clientY,this.arrowStartHeight=parseFloat(document.getElementById("extrudeHeight")?.value)||10,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleArrowDrag(e){if(!this.isDraggingArrow||!this.extrudeArrow||!this.basePlane)return;const t=e.clientY-this.startMouseY,r=document.getElementById("extrudeDirection")?.value||"positive",o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();const i=this.extrudeArrow.position.clone(),s=i.clone().project(this.editor.camera);let n=.4*-t;i.clone().add(o.clone().multiplyScalar(10)).clone().project(this.editor.camera).y-s.y<0&&(n=-n),"negative"===r&&(n=-n);let a=this.arrowStartHeight+n;a=Math.max(.1,a),a=Math.round(a);const l=document.getElementById("extrudeHeight");if(l){l.value=a;const e=new Event("input",{bubbles:!0});l.dispatchEvent(e),this.updateExtrudePreview(),this.updateArrowPosition()}e.preventDefault()}handleArrowDragEnd(){this.isDraggingArrow=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor="default",this.updateExtrudePreview(),this.updateArrowPosition();const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10;this.editor.showStatus(`Высота установлена: ${e.toFixed(0)} мм`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingArrow&&this.handleArrowDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingArrow&&0===e.button&&this.handleArrowDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}async performExtrude(){const e=this.getFiguresForOperation();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вытягивания","error");const t=parseFloat(this.propertiesElement?.querySelector("#extrudeHeight")?.value)||10,r=this.propertiesElement?.querySelector("#extrudeDirection")?.value||"positive",o=this.propertiesElement?.querySelector("#extrudeOperation")?.value||"new";if(isNaN(t))return void this.editor.showStatus("Введите корректную высоту","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const i="cut"===o||"join"===o,s=await this.createExtrusionMeshFromManifold(e,t,r,i);if(!s)return void this.editor.showStatus("Не удалось создать геометрию выдавливания через Manifold","error");const n=new THREE.Vector3;this.basePlane.getWorldPosition(n),s.position.copy(n),s.quaternion.copy(this.basePlane.quaternion);const a={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),height:t,direction:r,operation:o,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,forBoolean:i};switch(o){case"new":this.handleNewOperation(s,a);break;case"cut":this.handleCutOperation(s,a);break;case"join":this.handleJoinOperation(s,a)}this.exitExtrudeMode();const l=e.filter(e=>e.isMerged).length,c=e.length;l>0&&c>l?this.editor.showStatus(`Выполнено выдавливание (${t} мм): ${l} объединенных + ${c-l} отдельных фигур`,"success"):l>0?this.editor.showStatus(`Выполнено выдавливание (${t} мм) с объединением ${l} фигур`,"success"):this.editor.showStatus(`Выполнено выдавливание (${t} мм) ${c} фигур`,"success")}createExtrusionMeshMetadata(e,t,r,o){if(!e)return null;const i=o.some(e=>e.isMerged),s=o.filter(e=>e.isMerged),n=s.length;return e.userData={type:"extrusion",sourceFigureIds:o.flatMap(e=>e.sourceFigures||[e.id]),height:t,direction:r,operation:this.currentOperation,name:`Вытягивание (${t} мм)${i?` [${n} объединенных]`:""}`,figureCount:o.length,holeCount:o.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:i,mergedFrom:i?s.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures},e}handleNewOperation(e,t){const r=e.position.clone(),o=e.scale.clone();this.createExtrusionMeshMetadata(e,t.height,t.direction,t.sourceFigures),this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectSingleObject(e);const i=this.editor.projectManager.serializeObjectForHistory(e);i.userData.finalPosition=r.toArray(),i.userData.finalScale=o.toArray(),this.editor.history.addAction({type:"create",subtype:"extrude",object:e.uuid,data:{...t,objectData:i,finalPosition:r.toArray(),finalScale:o.toArray()}})}handleCutOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let i=!1,s=null;r.forEach(r=>{try{const n=this.editor.booleanOps.subtract(r,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(s=n,this.replaceObjectsWithResult([r],s,"cut",{sourceExtrude:t,targetObjectData:o}),i=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),i||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),i=this.editor.projectManager.serializeObjectForHistory(e);try{const s=[...r,e],n=this.editor.booleanOps.unionMultiple(s);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(s,n,"join",{sourceObjectsData:o,extrudeData:i,sourceExtrude:t})}catch(r){console.error("Ошибка соединения:",r),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],r=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(o=>{if(!o.visible||!0===o.userData.hidden)return;if(o===e||"sketch_plane"===o.userData.type||"work_plane"===o.userData.type||"sketch_element"===o.userData.type)return;const i=(new THREE.Box3).setFromObject(o);r.intersectsBox(i)&&t.push(o)}),t}replaceObjectsWithResult(e,t,r,o){const i=this.editor.projectManager.serializeObjectForHistory(t);this.editor.history.addAction({type:"boolean",operation:r,result:t.uuid,sourceObjects:e.map(e=>e.uuid),resultData:i,context:o?.sourceExtrude}),e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectSingleObject(t)}exitExtrudeMode(){this.editor.toolManager.setCurrentTool("select")}cancelExtrudeMode(){this.clearSelection(),this.extrudeArrow&&(this.editor.scene.remove(this.extrudeArrow),this.extrudeArrow=null),this.removeExtrudePreview(),this.removeExtrudeUI();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.editor.showStatus("Режим вытягивания завершен","info"),document.body.style.cursor="default"}highlightExtrudableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,2201331):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,2201331)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вытягивания","warning")}}