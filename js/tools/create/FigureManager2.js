class FigureManager{constructor(e){this.editor=e,this.figureTree=new Map,this.rootNodes=[],this.elementToNodes=new Map,this.figureCacheTimestamp=0,this.autoContours=[],this.brokenElements=new Set,this.clipperScale=1e5,this.clipperAvailable=!1,this.useClipperForContourSeparation=!0,this.initializeClipper(),console.log("FigureManager: создан (универсальный алгоритм, исправлена вложенность)"),THREE.Vector2.prototype.distanceTo||(THREE.Vector2.prototype.distanceTo=function(e){return Math.sqrt(Math.pow(e.x-this.x,2)+Math.pow(e.y-this.y,2))})}initializeClipper(){"undefined"!=typeof ClipperLib?(this.clipperAvailable=!0,console.log("Clipper.js доступен в FigureManager"),ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale):(console.warn("Clipper.js не найден! Разделение контуров будет недоступно."),this.clipperAvailable=!1,this.useClipperForContourSeparation=!1)}getLineIntersection(e,t,n,o){const r=(o.y-n.y)*(t.x-e.x)-(o.x-n.x)*(t.y-e.y);if(Math.abs(r)<1e-4)return null;const s=((o.x-n.x)*(e.y-n.y)-(o.y-n.y)*(e.x-n.x))/r,l=((t.x-e.x)*(e.y-n.y)-(t.y-e.y)*(e.x-n.x))/r;return s>=0&&s<=1&&l>=0&&l<=1?new THREE.Vector2(e.x+s*(t.x-e.x),e.y+s*(t.y-e.y)):null}getIntersectionParameter(e,t,n){const o=t.x-e.x,r=t.y-e.y;return Math.abs(o)>Math.abs(r)?(n.x-e.x)/o:(n.y-e.y)/r}getDistance(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}calculatePolygonArea(e){if(e.length<3)return 0;let t=0;const n=e.length;for(let o=0;o<n;o++){const r=(o+1)%n;t+=e[o].x*e[r].y,t-=e[r].x*e[o].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);const t=new THREE.Vector2(0,0);return e.forEach(e=>{t.x+=e.x,t.y+=e.y}),t.x/=e.length,t.y/=e.length,t}calculateBoundingBox(e){if(0===e.length)return{min:new THREE.Vector2(0,0),max:new THREE.Vector2(0,0)};const t=new THREE.Vector2(1/0,1/0),n=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),n.x=Math.max(n.x,e.x),n.y=Math.max(n.y,e.y)}),{min:t,max:n}}collectAllFigures(){console.log("=== FigureManager: начинаем сбор фигур (универсальный алгоритм) ===");const e=Date.now();if(this.figureTree.size>0&&e-this.figureCacheTimestamp<200)return console.log("FigureManager: используем кэш, узлов:",this.figureTree.size),this.getAllFiguresFlat();const t=this.getAllSketchElements();console.log("Всего элементов:",t.length);const n=this.collectSimpleContours(t);console.log("Простых контуров:",n.length);const o=this.getAutoContours();this.updateBrokenElements(o);const r=this.filterBrokenContours(n);console.log("Простых контуров после фильтрации:",r.length);const s=new Set;r.forEach(e=>{e.element&&s.add(e.element.uuid),e.elements&&e.elements.forEach(e=>s.add(e.uuid))});const l=t.filter(e=>"line"===e.userData?.elementType&&!s.has(e.uuid));console.log("Свободных линий:",l.length);const i=[];r.forEach(e=>{const t=e.points;for(let n=0;n<t.length-1;n++)i.push({start:t[n].clone(),end:t[n+1].clone(),plane:e.plane,originalContour:e})}),l.forEach(e=>{const t=this.getElementPoints(e);t.length>=2&&i.push({start:t[0].clone(),end:t[1].clone(),plane:this.getElementPlane(e),originalLine:e})}),o.forEach(e=>{const t=e.points;for(let n=0;n<t.length-1;n++)i.push({start:t[n].clone(),end:t[n+1].clone(),plane:e.plane,originalContour:e})});const a=this.buildContoursFromSegments(i);console.log("Сгенерировано контуров из отрезков:",a.length);const u=this.mergeContourSets(r,a);console.log("Итоговое количество контуров:",u.length);const c=u.map(e=>new FigureNode(e));return console.log("Создано узлов:",c.length),c.length>0?(this.buildEnhancedNestingTree(c),this.determineContourTypes()):this.rootNodes=[],this.updateDataStructures(c),this.figureCacheTimestamp=e,this.getAllFiguresFlat()}buildContoursFromSegments(e){if(e.length<3)return[];const t=this.findAllIntersections(e),n=this.splitAllSegments(e,t),o=this.buildGraphFromSplitSegments(n);if(0===o.size)return[];const r=this.findElementaryCycles(o),s=[],l=new Set;return r.forEach(t=>{if(t.length<3)return;const n=this.calculatePolygonArea(t),o=Math.abs(n);if(o<.01)return;const r=this.getContourKey(t);if(l.has(r))return;l.add(r);const i=n<0,a=i?t:t.reverse();let u=null;e.length>0&&e[0].plane&&(u=e[0].plane),s.push({points:a,area:o,center:this.calculateContourCenter(a),boundingBox:this.calculateBoundingBox(a),type:"auto_contour",isClosed:!0,isClockwise:i,planeId:u?u.uuid:null,plane:u,isFromSegments:!0})}),console.log(`buildContoursFromSegments: сгенерировано ${s.length} контуров`),s}findAllIntersections(e){const t=new Map;for(let n=0;n<e.length;n++)t.set(n,[]);for(let n=0;n<e.length;n++){const o=e[n];for(let r=n+1;r<e.length;r++){const s=e[r],l=this.getLineIntersection(o.start,o.end,s.start,s.end);if(l){const e=this.getIntersectionParameter(o.start,o.end,l),i=this.getIntersectionParameter(s.start,s.end,l);t.get(n).push({point:l.clone(),t:e,otherIndex:r}),t.get(r).push({point:l.clone(),t:i,otherIndex:n})}}}return t}splitAllSegments(e,t){const n=[];return e.forEach((e,o)=>{const r=t.get(o)||[];if(0===r.length)return void n.push({...e});r.sort((e,t)=>e.t-t.t);let s=e.start;for(let t=0;t<r.length;t++){const o=r[t].point;s.equals(o)||n.push({start:s.clone(),end:o.clone(),plane:e.plane,original:e.original||e}),s=o}s.equals(e.end)||n.push({start:s.clone(),end:e.end.clone(),plane:e.plane,original:e.original||e})}),n}buildGraphFromSplitSegments(e){const t=new Map,n=e=>`${e.x.toFixed(9)},${e.y.toFixed(9)}`;return e.forEach(e=>{const o=n(e.start),r=n(e.end);if(o===r)return;t.has(o)||t.set(o,{point:e.start.clone(),edges:[]}),t.has(r)||t.set(r,{point:e.end.clone(),edges:[]});const s=(new THREE.Vector2).subVectors(e.end,e.start).normalize(),l=Math.atan2(s.y,s.x);t.get(o).edges.push({to:r,angle:l,length:e.start.distanceTo(e.end)}),t.get(r).edges.push({to:o,angle:l+Math.PI,length:e.start.distanceTo(e.end)})}),t.forEach(e=>{e.edges.sort((e,t)=>e.angle-t.angle)}),t}findElementaryCycles(e){const t=[],n=new Set,o=2*e.size;return e.forEach((r,s)=>{r.edges.forEach(r=>{const l=`${s}->${r.to}`;if(n.has(l))return;const i=[];let a=s,u=null,c=0;for(;c++<o&&!(c>1&&a===s);){const t=e.get(a);if(!t)break;let o=null;if(null===u)o=r;else{const n=(new THREE.Vector2).subVectors(t.point,e.get(u).point).normalize(),r=Math.atan2(n.y,n.x);let s=1/0;t.edges.forEach(e=>{if(e.to===u)return;let t=e.angle-r;t<0&&(t+=2*Math.PI),t<s&&(s=t,o=e)})}if(!o)break;const s=o.to;n.add(`${a}->${s}`),0===i.length&&i.push(t.point.clone()),i.push(e.get(s).point.clone()),u=a,a=s}if(a===s&&i.length>=3){const e=[];for(let t=0;t<i.length;t++)0!==t&&i[t].equals(i[t-1])||e.push(i[t].clone());e.length>2&&!e[0].equals(e[e.length-1])&&e.push(e[0].clone()),e.length>=3&&t.push(e)}})}),t}mergeContourSets(e,t){const n=[...e],o=new Set;return e.forEach(e=>{const t=this.getContourKey(e.points);o.add(t)}),t.forEach(t=>{const r=this.getContourKey(t.points);if(o.has(r))return;let s=!1;for(const n of e)if(Math.abs(n.area-t.area)<.1&&this.areBoundingBoxesEqual(n.boundingBox,t.boundingBox,.01)){s=!0;break}s||(n.push(t),o.add(r))}),n}getContourKey(e){return e.map(e=>`${e.x.toFixed(6)},${e.y.toFixed(6)}`).join("|")}areBoundingBoxesEqual(e,t,n=.01){return!(!e||!t)&&(Math.abs(e.min.x-t.min.x)<n&&Math.abs(e.min.y-t.min.y)<n&&Math.abs(e.max.x-t.max.x)<n&&Math.abs(e.max.y-t.max.y)<n)}advancedSeparateContours(e){if(console.log("=== FigureManager: улучшенное разделение контуров ==="),!this.clipperAvailable||0===e.length)return e;try{const t=this.groupContoursByPlane(e);let n=[];for(const[e,o]of Object.entries(t)){if(console.log(`Обрабатываем плоскость ${e}: ${o.length} контуров`),0===o.length)continue;const t=this.getPlaneById(e);if(!t){n=n.concat(o);continue}const{holes:r,solids:s}=this.separateHolesAndSolids(o),l=this.separateSolidContours(s,t);n=n.concat(l,r)}return console.log(`Всего получено ${n.length} контуров`),n}catch(t){return console.error("Ошибка при улучшенном разделении контуров:",t),e}}separateHolesAndSolids(e){const t=[],n=[],o=[...e.map(e=>new FigureNode(e))].sort((e,t)=>t.area-e.area);for(let e=0;e<o.length;e++){const t=o[e];for(let n=0;n<e;n++){const e=o[n];if(this.isContourInside(t.contour,e.contour)){e.addChild(t);break}}}const r=o.filter(e=>null===e.parent),s=(e,o)=>{e.depth=o,e.isHole=o%2==1,e.isHole?t.push(e.contour):n.push(e.contour),e.children.forEach(e=>s(e,o+1))};return r.forEach(e=>s(e,0)),console.log(`Найдено: ${n.length} твердых тел, ${t.length} отверстий`),{holes:t,solids:n}}separateSolidContours(e,t){return 0===e.length?[]:1===e.length?[e[0]]:2===e.length?this.separateTwoSolids(e[0],e[1],t):this.separateMultipleSolids(e,t)}separateTwoSolids(e,t,n){try{const o=e.points||[],r=t.points||[];if(o.length<3||r.length<3)return[e,t];const s=[];this.clipperDifference(o,r,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&s.push(this.createSeparatedContour(e,"solid1_minus_2",n))});this.clipperDifference(r,o,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&s.push(this.createSeparatedContour(e,"solid2_minus_1",n))});return this.clipperIntersection(o,r,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&s.push(this.createSeparatedContour(e,"intersection",n))}),console.log(`Разделение двух тел: было 2, стало ${s.length}`),s.length>0?s:[e,t]}catch(n){return console.error("Ошибка при разделении двух тел:",n),[e,t]}}separateMultipleSolids(e,t){try{console.log(`Разделение ${e.length} твердых тел`);let n=[];for(let o=1;o<1<<e.length;o++){const r=[];for(let t=0;t<e.length;t++)o&1<<t&&r.push(e[t]);if(0===r.length)continue;let s=r[0].points||[];for(let e=1;e<r.length&&0!==s.length;e++)s=this.clipperIntersection(s,r[e].points||[],t)[0]||[];if(s.length<3)continue;let l=s;for(let n=0;n<e.length;n++)if(!(o&1<<n)){if(l=this.clipperDifference(l,e[n].points||[],t)[0]||[],0===l.length)break}if(l.length>=3){const e=this.calculatePolygonArea(l);Math.abs(e)>.01&&n.push({points:l,mask:o,area:Math.abs(e)})}}const o=n.map((e,n)=>this.createSeparatedContour(e.points,`area_${n}`,t));return console.log(`Разделение ${e.length} тел: было ${e.length}, стало ${o.length}`),o.length>0?o:e}catch(t){return console.error("Ошибка при разделении нескольких тел:",t),e}}clipperDifference(e,t,n){try{const n=new ClipperLib.Clipper,o=this.pointsToClipperPath(e);n.AddPath(o,ClipperLib.PolyType.ptSubject,!0);const r=this.pointsToClipperPath(t);n.AddPath(r,ClipperLib.PolyType.ptClip,!0);const s=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctDifference,s,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?s.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Difference:",e),[]}}clipperIntersection(e,t,n){try{const n=new ClipperLib.Clipper,o=this.pointsToClipperPath(e);n.AddPath(o,ClipperLib.PolyType.ptSubject,!0);const r=this.pointsToClipperPath(t);n.AddPath(r,ClipperLib.PolyType.ptClip,!0);const s=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctIntersection,s,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?s.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Intersection:",e),[]}}createSeparatedContour(e,t,n){const o=this.calculatePolygonArea(e),r=Math.abs(o),s=o<0,l=s?e:e.reverse();return{points:l,area:r,center:this.calculateContourCenter(l),boundingBox:this.calculateBoundingBox(l),type:t,isClosed:!0,isClockwise:s,planeId:n.uuid,plane:n,isSeparated:!0}}groupContoursByPlane(e){const t={};return e.forEach(e=>{const n=e.planeId||this.getContourPlaneId(e);n&&(t[n]||(t[n]=[]),t[n].push(e))}),t}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let n=0;n<e.length;n++)t[n]=new ClipperLib.IntPoint(Math.round(e[n].x*this.clipperScale),Math.round(e[n].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let n=0;n<e.length;n++)t.push(new THREE.Vector2(e[n].X/this.clipperScale,e[n].Y/this.clipperScale));return t}getContourPlaneId(e){if(e.planeId)return e.planeId;if(e.plane)return e.plane.uuid;if(e.element){const t=this.getElementPlane(e.element);return t?t.uuid:null}return null}getPlaneById(e){return[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e)||null}collectSimpleContours(e){const t=[];return e.forEach(e=>{if(!e.userData)return;const n=e.userData.elementType,o=this.getElementPoints(e);if("line"===n||"polyline"===n){if(o.length<2)return;const r=this.isSketchElementClosed(e);if(this.brokenElements.has(e))return;if(!r)return;const s=this.calculatePolygonArea(o);if(Math.abs(s)<.001)return;const l=this.calculateContourCenter(o),i=this.calculateBoundingBox(o),a=s<0,u=this.getElementPlane(e);if(!u)return;return void t.push({element:e,points:o,area:Math.abs(s),center:l,boundingBox:i,type:n,isClosed:!0,isClockwise:a,originalArea:s,planeId:u.uuid,plane:u})}if(o.length<3)return;if(!this.isSketchElementClosed(e))return;if(this.brokenElements.has(e))return;const r=this.calculatePolygonArea(o);if(Math.abs(r)<.001)return;const s=this.calculateContourCenter(o),l=this.calculateBoundingBox(o),i=r<0,a=this.getElementPlane(e);a&&t.push({element:e,points:o,area:Math.abs(r),center:s,boundingBox:l,type:n,isClosed:!0,isClockwise:i,originalArea:r,planeId:a.uuid,plane:a})}),t}getAutoContours(){return this.autoContours||[]}updateWithAutoContours(e,t=null){t&&e.forEach(e=>{e.planeId=t}),this.autoContours=e.filter(e=>e&&e.points&&e.points.length>=3&&e.area>.01),this.figureCacheTimestamp=0,this.collectAllFigures()}updateBrokenElements(e){this.brokenElements.clear(),e.forEach(e=>{e.elements&&e.elements.forEach(e=>{this.isSketchElementClosed(e)&&this.brokenElements.add(e)})}),console.log("Разбитых элементов:",this.brokenElements.size)}filterBrokenContours(e){return 0===this.brokenElements.size?e:e.filter(e=>{if(e.element&&this.brokenElements.has(e.element))return!1;if(e.elements&&e.elements.length>0){if(e.elements.every(e=>this.brokenElements.has(e)))return!1}return!0})}getElementPoints(e){if(!e.userData)return[];if(e.userData.localPoints&&e.userData.localPoints.length>0)return e.userData.localPoints.map(e=>e instanceof THREE.Vector3||void 0!==e.x&&void 0!==e.y?new THREE.Vector2(e.x,e.y):new THREE.Vector2(0,0));if(e.geometry&&e.geometry.attributes.position){const t=e.geometry.attributes.position.array,n=[];for(let e=0;e<t.length;e+=3)n.push(new THREE.Vector2(t[e],t[e+1]));return n}return e.userData.elementType,[]}isSketchElementClosed(e){if(!e.userData)return!1;const t=e.userData.elementType;return["rectangle","circle","polygon","oval","stadium","arc","polyline"].includes(t)}buildEnhancedNestingTree(e){e.forEach(e=>{e.parent=null,e.children=[],e.depth=0});const t=[...e].sort((e,t)=>t.area-e.area);for(let e=0;e<t.length;e++){const n=t[e];let o=null,r=1/0;for(let s=0;s<e;s++){const e=t[s];this.isContourInside(n.contour,e.contour)&&e.area<r&&(o=e,r=e.area)}o&&o.addChild(n)}this.rootNodes=t.filter(e=>null===e.parent),this.updateDepthsRecursively()}getContourPlane(e){if(e.planeId){return[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId)||null}return e.element?this.getElementPlane(e.element):null}getElementPlane(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}const n=this.editor.sketchPlanes||[],o=this.editor.workPlanes||[];return n.length>0?n[0]:o.length>0?o[0]:null}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=e[0],n=this.getFigurePlane(t);if(!n)return!1;for(let t=1;t<e.length;t++){const o=e[t],r=this.getFigurePlane(o);if(!r)return!1;if(r.uuid!==n.uuid)return!1}return!0}isContourInside(e,t){const n=e.points||[],o=t.points||[];if(0===n.length||0===o.length)return!1;const r=this.getContourPlane(e),s=this.getContourPlane(t);if(!r||!s||r.uuid!==s.uuid)return!1;for(const e of n)if(!this.isPointInsidePolygon(e,o))return!1;return!0}isPointInsidePolygon(e,t){if(t.length<3)return!1;let n=!1;const o=e.x,r=e.y;for(let e=0,s=t.length-1;e<t.length;s=e++){const l=t[e].x,i=t[e].y,a=t[s].x,u=t[s].y;i>r!=u>r&&o<(a-l)*(r-i)/(u-i)+l&&(n=!n)}return n}updateDepthsRecursively(){const e=(t,n)=>{t.depth=n,t.children.forEach(t=>e(t,n+1))};this.rootNodes.forEach(t=>e(t,0))}determineContourTypes(){const e=t=>{t.isHole=t.depth%2==1,t.isOuter=!t.isHole,t.children.forEach(e)};this.rootNodes.forEach(e)}updateDataStructures(e){this.figureTree.clear(),this.elementToNodes.clear(),e.forEach(e=>{this.figureTree.set(e.id,e),e.elementIds.forEach(t=>{this.elementToNodes.has(t)||this.elementToNodes.set(t,[]),this.elementToNodes.get(t).push(e)})})}getFigurePlane(e){if(e.plane)return e.plane;if(e.planeId){const t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId);if(t)return e.plane=t,t}if(e.element){const t=this.getElementPlane(e.element);return t&&(e.plane=t,e.planeId=t.uuid),t}return null}getImmediateHolesForFigure(e){const t=this.getNodeById(e);return t?t.getImmediateHoles().map(e=>e.contour):[]}getAllFiguresFlat(){const e=[],t=n=>{const o={id:n.id,outer:n.contour,holes:n.getImmediateHoles().map(e=>e.contour),area:n.area,selected:!1,parentId:n.parent?n.parent.id:null,childrenIds:n.children.map(e=>e.id),isStandalone:null===n.parent,canBeSelected:!0,isHole:n.isHole,isOuter:n.isOuter,depth:n.depth,elementIds:Array.from(n.elementIds),element:n.element,boundingBox:n.boundingBox,center:n.center,type:n.type,holeDepth:n.isHole?n.depth:null,hasDeepHoles:n.getHoleDescendants().length>0,plane:n.contour.plane,planeId:n.contour.planeId,isSeparated:n.contour.isSeparated||!1,isCut:n.contour.isCut||!1};e.push(o),n.children.forEach(e=>t(e))};return this.rootNodes.forEach(e=>t(e)),e.sort((e,t)=>e.depth-t.depth),e}getNodeById(e){return this.figureTree.get(e)}getFigureById(e){for(const t of this.figureTree.values())if(t.id===e)return this.nodeToFigure(t);return this.getAllFiguresFlat().find(t=>t.id===e)||null}getFiguresByElement(e){const t=e.uuid;return(this.elementToNodes.get(t)||[]).filter(e=>{if(e.element&&this.brokenElements.has(e.element))return!1;if(e.elementIds&&e.elementIds.size>0){if(Array.from(e.elementIds).every(e=>{const t=this.findElementById(e);return t&&this.brokenElements.has(t)}))return!1}return!0}).map(e=>this.nodeToFigure(e))}findElementById(e){let t=null;const n=o=>{if(o.uuid===e)return t=o,!0;if(o.children&&o.children.length>0)for(const e of o.children)if(n(e))return!0;return!1};return n(this.editor.scene),t}findNodeByContour(e){for(const t of this.figureTree.values())if(t.contour===e)return t;return null}nodeToFigure(e){const t=e.getImmediateHoles().map(e=>({points:e.contour.points,center:e.contour.center,area:e.contour.area,element:e.element,elements:e.contour.elements}));return{id:e.id,outer:{points:e.contour.points,center:e.contour.center,area:e.contour.area,element:e.element,elements:e.contour.elements},holes:t,area:e.area,isHole:e.isHole,isOuter:e.isOuter,depth:e.depth,parentId:e.parent?e.parent.id:null,childrenIds:e.children.map(e=>e.id),elementIds:Array.from(e.elementIds),element:e.element,boundingBox:e.boundingBox,center:e.center,type:e.type,plane:e.contour.plane,planeId:e.contour.planeId,isSeparated:e.contour.isSeparated||!1,isCut:e.contour.isCut||!1}}setUseClipperForContourSeparation(e){this.useClipperForContourSeparation=e&&this.clipperAvailable,e&&!this.clipperAvailable&&console.warn("Clipper.js недоступен, разделение контуров отключено"),this.figureCacheTimestamp=0}isClipperAvailable(){return this.clipperAvailable}findFigureByHoleContour(e){const t=this.findNodeByContour(e);return t?this.nodeToFigure(t):null}getAllFigures(){return this.getAllFiguresFlat()}findNodeByHoleContour(e){return this.findNodeByContour(e)}debugPrintTree(){if(console.log("\n=== ДЕРЕВО ФИГУР ==="),0===this.rootNodes.length)return void console.log("  Дерево пустое");const e=(t,n="")=>{const o=t.isHole?"○ ОТВЕРСТИЕ":"● ВНЕШНИЙ",r=t.area.toFixed(2),s=t.elementIds.size,l=t.children.length,i=t.depth,a=t.contour.isSeparated?" [РАЗДЕЛЕН]":"",u=t.contour.isCut?" [РАЗРЕЗАН]":"";console.log(`${n}${o}${a}${u} [ID: ${t.id.substring(0,8)}...]`),console.log(`${n}  Глубина: ${i}, Площадь: ${r}, Элементов: ${s}, Детей: ${l}`),t.children.forEach(t=>e(t,n+"  "))};this.rootNodes.forEach((t,n)=>{console.log(`\nКорень ${n+1}:`),e(t)})}collectLineContours(e,t){const n=new Set;t.forEach(e=>{e.element&&n.add(e.element.uuid)});const o=e.filter(e=>{const t=e.userData?.elementType;return"line"===t&&!n.has(e.uuid)});if(o.length<3)return[];const r=o.map(e=>{const t=this.getElementPoints(e);return{element:e,start:t[0],end:t[1],points:t}});return this.findClosedContoursFromLines(r)}findClosedContoursFromLines(e){if(e.length<3)return[];const t=[],n=new Set;for(let o=0;o<e.length;o++){if(n.has(o))continue;const r=this.buildContourFromLine(o,e,n);if(r&&r.points.length>=3){const e=this.calculatePolygonArea(r.points);if(Math.abs(e)>.01){const n=this.calculateContourCenter(r.points),o=this.calculateBoundingBox(r.points),s=r.elements[0],l=this.getElementPlane(s);t.push({elements:r.elements,points:r.points,area:Math.abs(e),center:n,boundingBox:o,type:"line_contour",isClosed:!0,isClockwise:e<0,planeId:l?l.uuid:null,plane:l})}}}return t}buildContourFromLine(e,t,n){const o=t[e],r=[o.element],s=[];let l=o.start,i=o.end;s.push(l.clone()),s.push(i.clone()),n.add(e);let a=!0,u=0;for(;a&&u<100;){a=!1,u++;for(let e=0;e<t.length;e++){if(n.has(e))continue;const o=t[e],l=this.getDistance(i,o.start),u=this.getDistance(i,o.end);if(l<.5){i=o.end,s.push(i.clone()),r.push(o.element),n.add(e),a=!0;break}if(u<.5){i=o.start,s.push(i.clone()),r.push(o.element),n.add(e),a=!0;break}}if(this.getDistance(i,o.start)<.5)return{elements:r,points:s}}return null}getAllSketchElements(){const e=[],t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];return 0===t.length?this.editor.scene.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)}):t.forEach(t=>{t.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)})}),e}getCuttingLines(e,t){const n=[],o=new Set;return t.forEach(e=>{e.element&&"line"===e.element.userData?.elementType&&o.add(e.element.uuid),e.elements&&e.elements.forEach(e=>{"line"===e.userData?.elementType&&o.add(e.uuid)})}),e.forEach(e=>{"line"!==e.userData?.elementType||o.has(e.uuid)||n.push(e)}),n}cutContoursWithLines(e,t){return console.log("=== FigureManager: разрезание контуров линиями (устаревший метод) ==="),e}}