class ExtrudeManager extends OperationManager{constructor(e){super(e),this.extrudePreviewGroup=null,this.previewMaterial=null,this.extrudeArrow=null,this.isDraggingArrow=!1,this.arrowStartHeight=0,this.startMouseY=0,this.currentOperation="new",console.log("ExtrudeManager: создан (наследник OperationManager)")}createOperationFigure(e){const t=this.getAllImmediateHoles(e),r=this.getFigurePlane(e);return{id:e.id,outer:e.outer,holes:t,area:e.area,isHole:e.isHole,parentId:e.parentId,childrenIds:e.childrenIds,depth:e.depth,plane:r,planeId:r?r.uuid:null,element:e.element}}handleFigureClick(e){const t=super.handleFigureClick(e);return t&&(this.updateExtrudePreview(),this.updateExtrudeUI(),this.createExtrudeDirectionIndicator()),t}createExtrusionGeometryFromFigures(e,t,r){if(0===e.length||!this.basePlane)return null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;const o=[];if(e.forEach(e=>{console.log(`Создание фигуры: ${e.id}, isHole: ${e.isHole}, отверстий: ${e.holes?e.holes.length:0}`);const t=this.getFigurePointsForBasePlane(e);if(t.length<3)return void console.log(`  Недостаточно точек: ${t.length}`);let r=!1;e.isHole&&(r=!1);const i=this.fixContourOrientation(t,r);try{const t=new THREE.Shape(i.map(e=>new THREE.Vector2(e.x,e.y)));e.holes&&e.holes.length>0&&e.holes.forEach((e,r)=>{const o=this.getContourPointsForBasePlane(e);if(o.length>=3){const e=this.fixContourOrientation(o,!0);try{const o=new THREE.Path(e.map(e=>new THREE.Vector2(e.x,e.y)));t.holes.push(o),console.log(`    Добавлено отверстие ${r}`)}catch(e){console.error(`    Ошибка создания отверстия ${r}:`,e)}}}),o.push(t),console.log("  Форма успешно создана")}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),0===o.length)return console.log("Нет фигур для создания геометрии"),null;console.log(`Создано ${o.length} форм для выдавливания`);const i={depth:t,bevelEnabled:!1,steps:1};try{console.log("Создание ExtrudeGeometry...");const e=new THREE.ExtrudeGeometry(o,i);return"negative"===r?e.translate(0,0,-t):"both"===r&&e.translate(0,0,-t/2),console.log("Геометрия успешно создана, вершин:",e.attributes.position.count),e}catch(e){return console.error("Ошибка создания геометрии выдавливания:",e),null}}createExtrudeDirectionIndicator(){this.extrudeArrow&&(this.extrudeArrow.parent&&this.extrudeArrow.parent.remove(this.extrudeArrow),this.extrudeArrow=null);const e=this.getFiguresForOperation();if(!e||0===e.length||!this.basePlane)return;if(!this.isPlaneVisible(this.basePlane))return void console.log("Базовая плоскость скрыта, не создаем стрелку");const t=document.getElementById("extrudeDirection")?.value||"positive",r=new THREE.Vector3(0,0,1);r.applyQuaternion(this.basePlane.quaternion),r.normalize(),"negative"===t&&r.negate(),this.extrudeArrow=new THREE.Group,this.extrudeArrow.userData.isExtrudeArrow=!0,this.extrudeArrow.userData.isDraggable=!0,this.extrudeArrow.raycast=()=>{};const o=new THREE.CylinderGeometry(.5,.5,15,8),i=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.7,depthTest:!1}),s=new THREE.Mesh(o,i);s.renderOrder=999,s.position.y=7.5,s.userData.isArrowPart=!0,s.userData.isDraggable=!0,s.userData.isArrowHandle=!0,this.extrudeArrow.add(s);const n=new THREE.ConeGeometry(3,6,8),a=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.9,depthTest:!1}),l=new THREE.Mesh(n,a);l.renderOrder=999,l.position.y=18,l.userData.isArrowPart=!0,l.userData.isArrowHandle=!0,l.userData.isDraggable=!0,this.extrudeArrow.add(l);const d=new THREE.Vector3(0,1,0),u=(new THREE.Quaternion).setFromUnitVectors(d,r.clone().normalize());this.extrudeArrow.quaternion.copy(u),this.updateArrowPosition(),this.editor.scene.add(this.extrudeArrow)}updateArrowPosition(){if(!this.extrudeArrow||!this.basePlane)return;const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10,t=document.getElementById("extrudeDirection")?.value||"positive",r=this.getFiguresForOperation();if(0===r.length)return;const o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();let i=o.clone();"negative"===t&&i.negate();const s=new THREE.Vector3(0,1,0),n=(new THREE.Quaternion).setFromUnitVectors(s,i.clone().normalize());this.extrudeArrow.quaternion.copy(n);const a=new THREE.Vector3(0,0,0);let l=0;r.forEach(e=>{if(e.outer&&e.outer.center){const t=e.outer.area||1;a.x+=e.outer.center.x*t,a.y+=e.outer.center.y*t,l+=t}}),l>0&&(a.x/=l,a.y/=l);const d=this.basePlane.localToWorld(a.clone()),u=new THREE.Vector3;this.basePlane.getWorldPosition(u);const c=(new THREE.Vector3).subVectors(d,u);let h=e;"both"===t&&(h=e/2);const p=u.clone().add(c).clone().clone().add(i.clone().multiplyScalar(h));this.extrudeArrow.position.copy(p),this.extrudeArrow.updateMatrixWorld(!0)}handleArrowDragStart(e){if(!this.extrudeArrow)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.extrudeArrow&&this.extrudeArrow.traverse(e=>{e.userData&&(e.userData.isDraggable||e.userData.isArrowHandle)&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingArrow=!0,this.startMouseY=e.clientY,this.arrowStartHeight=parseFloat(document.getElementById("extrudeHeight")?.value)||10,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleArrowDrag(e){if(!this.isDraggingArrow||!this.extrudeArrow||!this.basePlane)return;const t=e.clientY-this.startMouseY,r=document.getElementById("extrudeDirection")?.value||"positive",o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();const i=this.extrudeArrow.position.clone(),s=i.clone().project(this.editor.camera);let n=.4*-t;i.clone().add(o.clone().multiplyScalar(10)).clone().project(this.editor.camera).y-s.y<0&&(n=-n),"negative"===r&&(n=-n);let a=this.arrowStartHeight+n;a=Math.max(.1,a),a=Math.round(a);const l=document.getElementById("extrudeHeight");if(l){l.value=a;const e=new Event("input",{bubbles:!0});l.dispatchEvent(e),this.updateExtrudePreview(),this.updateArrowPosition()}e.preventDefault()}handleArrowDragEnd(){this.isDraggingArrow=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor="default",this.updateExtrudePreview(),this.updateArrowPosition();const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10;this.editor.showStatus(`Высота установлена: ${e.toFixed(0)} мм`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingArrow&&this.handleArrowDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingArrow&&0===e.button&&this.handleArrowDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}updateExtrudePreview(){const e=this.getFiguresForOperation();if(0===e.length)return void this.removeExtrudePreview();const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive";if(this.extrudePreviewGroup&&this.extrudePreviewGroup.children.length>0){const o=this.extrudePreviewGroup.children[0],i=this.createExtrusionGeometryFromFigures(e,t,r);i&&(o.geometry.dispose(),o.geometry=i,this.updatePreviewPosition(o,t,r))}else this.createNewExtrudePreview(e,t,r)}createNewExtrudePreview(e,t,r){this.removeExtrudePreview();const o=this.createExtrusionGeometryFromFigures(e,t,r);if(!o)return;this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.3,side:THREE.DoubleSide}));const i=new THREE.Mesh(o,this.previewMaterial);this.updatePreviewPosition(i,t,r),this.extrudePreviewGroup=new THREE.Group,this.extrudePreviewGroup.add(i),this.editor.objectsGroup.add(this.extrudePreviewGroup)}updatePreviewPosition(e,t,r){if(!e||!this.basePlane)return;const o=new THREE.Vector3;this.basePlane.getWorldPosition(o),e.position.copy(o),e.quaternion.copy(this.basePlane.quaternion);const i=new THREE.Vector3(0,0,1);i.applyQuaternion(this.basePlane.quaternion),i.normalize();e.position.add(i.clone().multiplyScalar(.1))}removeExtrudePreview(){this.extrudePreviewGroup&&(this.editor.objectsGroup.remove(this.extrudePreviewGroup),this.extrudePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.extrudePreviewGroup=null)}showExtrudeUI(){const e=document.getElementById("extrudeUI");e&&e.remove();const t=this.selectedFigures.size,r=document.createElement("div");r.id="extrudeUI",r.className="extrude-ui",r.innerHTML=`\n            <div class="extrude-header">\n                <h3><i class="fas fa-arrows-alt-v"></i> Вытягивание фигур</h3>\n                <button id="cancelExtrude" class="btn-secondary">\n                    <i class="fas fa-times"></i> Отмена\n                </button>\n            </div>\n            <div class="extrude-controls">\n                <div class="control-group">\n                    <label>Высота (мм):</label>\n                    <input type="number" id="extrudeHeight" value="10" step="1" min="1" style="width: 100px;">\n                </div>\n                <div class="control-group">\n                    <label>Направление:</label>\n                    <select id="extrudeDirection">\n                        <option value="positive">Наружу</option>\n                        <option value="negative">Внутрь</option>\n                        <option value="both">В обе стороны</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>Операция:</label>\n                    <select id="extrudeOperation">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>\n                        Автоматически объединять соединённые фигуры\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                        ${this.clipperAvailable?"":" (Clipper.js не найден)"}\n                    </label>\n                </div>\n                <div class="extrude-info">\n                    <div id="selectedContourInfo">\n                        ${t>0?`Выбрано фигур: ${t}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" style="font-size: 12px; color: #888; margin-top: 5px;"></div>\n                    <div id="clipperStatus" style="font-size: 12px; color: #888; margin-top: 2px;"></div>\n                </div>\n                <button id="performExtrude" class="btn-primary" ${t>0?"":"disabled"}>\n                    <i class="fas fa-check"></i> Выполнить вытягивание\n                </button>\n            </div>\n            <div class="extrude-hint">\n                <i class="fas fa-info-circle"></i>\n                <div>• Клик по фигуре: выделить/снять выделение</div>\n                <div>• Соединённые фигуры будут объединены при вытягивании (только если включена галка)</div>\n                <div>• Перетаскивайте стрелку для изменения высоты (шаг 1 мм)</div>\n                <div>• Escape для отмены, Enter для подтверждения</div>\n                ${this.clipperAvailable?"<div>• Используется Clipper.js для точного объединения</div>":'<div style="color: #f44336;">• Clipper.js не найден. Объединение фигур будет недоступно.</div>'}\n            </div>\n        `,document.querySelector(".viewport-container").appendChild(r),this.setupExtrudeUIEventListeners(),this.updateExtrudeUI()}setupExtrudeUIEventListeners(){const e=document.getElementById("cancelExtrude");e&&e.addEventListener("click",()=>{this.exitExtrudeMode()});const t=document.getElementById("performExtrude");t&&t.addEventListener("click",()=>{this.performExtrude()});const r=document.getElementById("extrudeHeight");r&&r.addEventListener("input",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});const o=document.getElementById("extrudeDirection");o&&o.addEventListener("change",()=>{this.updateExtrudePreview(),this.updateArrowPosition(),this.createExtrudeDirectionIndicator()});const i=document.getElementById("extrudeOperation");i&&i.addEventListener("change",()=>{this.currentOperation=i.value});const s=document.getElementById("mergeFigures");s&&s.addEventListener("change",e=>{this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(s.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","error")),this.updateExtrudePreview(),this.updateExtrudeUI()})}updateExtrudeUI(){const e=document.getElementById("selectedContourInfo"),t=document.getElementById("mergeStatus"),r=document.getElementById("clipperStatus"),o=document.getElementById("performExtrude"),i=document.getElementById("mergeFigures");if(i&&(i.disabled=!this.clipperAvailable),e){const o=this.selectedFigures.size;if(o>0){if(e.textContent=`Выбрано фигур: ${o}`,e.style.color="#4CAF50",t)if(o>1&&this.mergeConnectedFigures&&this.clipperAvailable){const e=Array.from(this.selectedFigures.values());this.areAllFiguresOnSamePlane(e)?(t.textContent="✓ Фигуры будут объединены",t.style.color="#4CAF50"):(t.textContent="✗ Фигуры на разных плоскостях",t.style.color="#f44336")}else!this.clipperAvailable&&o>1?(t.textContent="⚠ Clipper.js не найден, объединение недоступно",t.style.color="#FF9800"):t.textContent="";r&&(this.clipperAvailable?(r.textContent="✓ Clipper.js доступен",r.style.color="#4CAF50"):(r.textContent="✗ Clipper.js не найден",r.style.color="#f44336"))}else e.textContent="Кликните по фигуре для выбора",e.style.color="#888",t&&(t.textContent=""),r&&(r.textContent="")}o&&(o.disabled=0===this.selectedFigures.size)}performExtrude(){const e=this.getFiguresForOperation();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вытягивания","error");const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive",o=document.getElementById("extrudeOperation")?.value||"new";if(isNaN(t))return void this.editor.showStatus("Введите корректную высоту","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const i=this.createExtrusionGeometryFromFigures(e,t,r);if(!i)return void this.editor.showStatus("Не удалось создать геометрию выдавливания","error");const s=this.createExtrusionMesh(i,t,r,e);if(!s)return void this.editor.showStatus("Не удалось создать объект выдавливания","error");const n=new THREE.Vector3;this.basePlane.getWorldPosition(n),s.position.copy(n),s.quaternion.copy(this.basePlane.quaternion);const a={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),height:t,direction:r,operation:o,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures};switch(o){case"new":this.handleNewOperation(s,a);break;case"cut":this.handleCutOperation(s,a);break;case"join":this.handleJoinOperation(s,a)}this.exitExtrudeMode();const l=e.filter(e=>e.isMerged).length,d=e.length;l>0&&d>l?this.editor.showStatus(`Выполнено выдавливание (${t} мм): ${l} объединенных + ${d-l} отдельных фигур`,"success"):l>0?this.editor.showStatus(`Выполнено выдавливание (${t} мм) с объединением ${l} фигур`,"success"):this.editor.showStatus(`Выполнено выдавливание (${t} мм) ${d} фигур`,"success")}createExtrusionMesh(e,t,r,o){if(!e)return null;const i=new THREE.MeshStandardMaterial({color:5025616,transparent:!0,opacity:1,side:THREE.DoubleSide}),s=new THREE.Mesh(e,i);s.castShadow=!0,s.receiveShadow=!0;const n=o.some(e=>e.isMerged),a=o.filter(e=>e.isMerged),l=a.length;return s.userData={type:"extrusion",sourceFigureIds:o.flatMap(e=>e.sourceFigures||[e.id]),height:t,direction:r,operation:this.currentOperation,name:`Вытягивание (${t} мм)${n?` [${l} объединенных]`:""}`,figureCount:o.length,holeCount:o.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:n,mergedFrom:n?a.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures},s}handleNewOperation(e,t){const r=e.position.clone(),o=e.scale.clone();this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectSingleObject(e);const i=this.editor.projectManager.serializeObjectForHistory(e);i.userData.finalPosition=r.toArray(),i.userData.finalScale=o.toArray(),this.editor.history.addAction({type:"create",subtype:"extrude",object:e.uuid,data:{...t,objectData:i,finalPosition:r.toArray(),finalScale:o.toArray()}})}handleCutOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let i=!1,s=null;r.forEach(r=>{try{const n=this.editor.booleanOps.subtract(r,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(s=n,this.replaceObjectsWithResult([r],s,"cut",{sourceExtrude:t,targetObjectData:o}),i=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),i||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),i=this.editor.projectManager.serializeObjectForHistory(e);try{const s=[...r,e],n=this.editor.booleanOps.unionMultiple(s);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(s,n,"join",{sourceObjectsData:o,extrudeData:i,sourceExtrude:t})}catch(r){console.error("Ошибка соединения:",r),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],r=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(o=>{if(o===e||"sketch_plane"===o.userData.type||"work_plane"===o.userData.type||"sketch_element"===o.userData.type)return;const i=(new THREE.Box3).setFromObject(o);r.intersectsBox(i)&&t.push(o)}),t}replaceObjectsWithResult(e,t,r,o){const i=this.editor.projectManager.serializeObjectForHistory(t);console.log("Result data:",i);const s={type:"boolean",operation:r,result:t.uuid,sourceObjects:e.map(e=>e.uuid),resultData:i,context:o?.sourceExtrude};console.log("Adding to history:",s),this.editor.history.addAction(s),e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectSingleObject(t)}exitExtrudeMode(){this.editor.toolManager.setCurrentTool("select")}cancelExtrudeMode(){this.clearSelection(),this.extrudeArrow&&(this.editor.scene.remove(this.extrudeArrow),this.extrudeArrow=null),this.removeExtrudePreview();const e=document.getElementById("extrudeUI");e&&e.remove();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.editor.showStatus("Режим вытягивания завершен","info"),document.body.style.cursor="default"}highlightExtrudableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,2201331):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,2201331)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вытягивания","warning")}}