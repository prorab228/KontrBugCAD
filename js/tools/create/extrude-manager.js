class ExtrudeManager extends OperationManager{constructor(e){super(e),this.extrudePreviewGroup=null,this.previewMaterial=null,this.extrudeArrow=null,this.isDraggingArrow=!1,this.arrowStartHeight=0,this.startMouseY=0,this.currentOperation="new",this.propertiesElement=null,console.log("ExtrudeManager: создан (наследник OperationManager)")}createOperationFigure(e){const t=this.getAllImmediateHoles(e),r=this.getFigurePlane(e);return{id:e.id,outer:e.outer,holes:t,area:e.area,isHole:e.isHole,parentId:e.parentId,childrenIds:e.childrenIds,depth:e.depth,plane:r,planeId:r?r.uuid:null,element:e.element}}handleFigureClick(e){const t=super.handleFigureClick(e);return t&&(this.updateExtrudePreview(),this.updateExtrudeUI(),this.createExtrudeDirectionIndicator()),t}createExtrusionGeometryFromFigures(e,t,r,o=!1){if(0===e.length||!this.basePlane)return null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;const i=[];if(e.forEach(e=>{console.log(`Создание фигуры: ${e.id}, isHole: ${e.isHole}`);let t=this.getFigurePointsForBasePlane(e);if(t.length<3)return void console.log(`  Недостаточно точек: ${t.length}`);if(o&&this.clipperAvailable){const e=this.expandContourWithClipper(t,1e-4);e&&e.length>=3&&(t=e,console.log("  Контур расширен с помощью Clipper.js"))}let r=!1;e.isHole&&(r=!1);const s=this.fixContourOrientation(t,r);try{const t=new THREE.Shape(s.map(e=>new THREE.Vector2(e.x,e.y)));e.holes&&e.holes.length>0&&e.holes.forEach((e,r)=>{let i=this.getContourPointsForBasePlane(e);if(o&&i.length>=3){const e=this.expandContourWithClipper(i,-1e-4);e&&e.length>=3&&(i=e)}if(i.length>=3){const e=this.fixContourOrientation(i,!0);try{const o=new THREE.Path(e.map(e=>new THREE.Vector2(e.x,e.y)));t.holes.push(o),console.log(`    Добавлено отверстие ${r}`)}catch(e){console.error(`    Ошибка создания отверстия ${r}:`,e)}}}),i.push(t),console.log("  Форма успешно создана")}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),0===i.length)return console.log("Нет фигур для создания геометрии"),null;console.log(`Создано ${i.length} форм для выдавливания`);let s=t;o&&(s+=.01);const n={depth:s,bevelEnabled:!1,steps:1};try{console.log("Создание ExtrudeGeometry...");const e=new THREE.ExtrudeGeometry(i,n);return o&&"positive"===r?e.translate(0,0,-.01):"negative"===r?e.translate(0,0,-t):"both"===r&&e.translate(0,0,-t/2),console.log("Геометрия успешно создана, вершин:",e.attributes.position.count),e}catch(e){return console.error("Ошибка создания геометрии выдавливания:",e),null}}expandContourWithClipper(e,t){if(!this.clipperAvailable||!e||e.length<3)return e;try{const r=new ClipperLib.Path;for(const t of e)r.push(new ClipperLib.IntPoint(Math.round(1e5*t.x),Math.round(1e5*t.y)));const o=new ClipperLib.Paths,i=new ClipperLib.ClipperOffset;if(i.AddPath(r,ClipperLib.JoinType.jtMiter,ClipperLib.EndType.etClosedPolygon),i.Execute(o,1e5*t),0===o.length||o[0].length<3)return console.warn("Clipper не смог обработать контур"),e;const s=[];for(const e of o[0])s.push(new THREE.Vector2(e.X/1e5,e.Y/1e5));return s}catch(t){return console.error("Ошибка в Clipper.js расширении:",t),e}}createExtrudeDirectionIndicator(){this.extrudeArrow&&(this.extrudeArrow.parent&&this.extrudeArrow.parent.remove(this.extrudeArrow),this.extrudeArrow=null);const e=this.getFiguresForOperation();if(!e||0===e.length||!this.basePlane)return;if(!this.isPlaneVisible(this.basePlane))return void console.log("Базовая плоскость скрыта, не создаем стрелку");const t=document.getElementById("extrudeDirection")?.value||"positive",r=new THREE.Vector3(0,0,1);r.applyQuaternion(this.basePlane.quaternion),r.normalize(),"negative"===t&&r.negate(),this.extrudeArrow=new THREE.Group,this.extrudeArrow.userData.isExtrudeArrow=!0,this.extrudeArrow.userData.isDraggable=!0,this.extrudeArrow.raycast=()=>{};const o=new THREE.CylinderGeometry(.5,.5,15,8),i=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.7,depthTest:!1}),s=new THREE.Mesh(o,i);s.renderOrder=999,s.position.y=7.5,s.userData.isArrowPart=!0,s.userData.isDraggable=!0,s.userData.isArrowHandle=!0,this.extrudeArrow.add(s);const n=new THREE.ConeGeometry(3,6,8),a=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.9,depthTest:!1}),l=new THREE.Mesh(n,a);l.renderOrder=999,l.position.y=18,l.userData.isArrowPart=!0,l.userData.isArrowHandle=!0,l.userData.isDraggable=!0,this.extrudeArrow.add(l);const u=new THREE.Vector3(0,1,0),c=(new THREE.Quaternion).setFromUnitVectors(u,r.clone().normalize());this.extrudeArrow.quaternion.copy(c),this.updateArrowPosition(),this.editor.scene.add(this.extrudeArrow)}updateArrowPosition(){if(!this.extrudeArrow||!this.basePlane)return;const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10,t=document.getElementById("extrudeDirection")?.value||"positive",r=this.getFiguresForOperation();if(0===r.length)return;const o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();let i=o.clone();"negative"===t&&i.negate();const s=new THREE.Vector3(0,1,0),n=(new THREE.Quaternion).setFromUnitVectors(s,i.clone().normalize());this.extrudeArrow.quaternion.copy(n);const a=new THREE.Vector3(0,0,0);let l=0;r.forEach(e=>{if(e.outer&&e.outer.center){const t=e.outer.area||1;a.x+=e.outer.center.x*t,a.y+=e.outer.center.y*t,l+=t}}),l>0&&(a.x/=l,a.y/=l);const u=this.basePlane.localToWorld(a.clone()),c=new THREE.Vector3;this.basePlane.getWorldPosition(c);const d=(new THREE.Vector3).subVectors(u,c);let h=e;"both"===t&&(h=e/2);const p=c.clone().add(d).clone().clone().add(i.clone().multiplyScalar(h));this.extrudeArrow.position.copy(p),this.extrudeArrow.updateMatrixWorld(!0)}handleArrowDragStart(e){if(!this.extrudeArrow)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.extrudeArrow&&this.extrudeArrow.traverse(e=>{e.userData&&(e.userData.isDraggable||e.userData.isArrowHandle)&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingArrow=!0,this.startMouseY=e.clientY,this.arrowStartHeight=parseFloat(document.getElementById("extrudeHeight")?.value)||10,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleArrowDrag(e){if(!this.isDraggingArrow||!this.extrudeArrow||!this.basePlane)return;const t=e.clientY-this.startMouseY,r=document.getElementById("extrudeDirection")?.value||"positive",o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();const i=this.extrudeArrow.position.clone(),s=i.clone().project(this.editor.camera);let n=.4*-t;i.clone().add(o.clone().multiplyScalar(10)).clone().project(this.editor.camera).y-s.y<0&&(n=-n),"negative"===r&&(n=-n);let a=this.arrowStartHeight+n;a=Math.max(.1,a),a=Math.round(a);const l=document.getElementById("extrudeHeight");if(l){l.value=a;const e=new Event("input",{bubbles:!0});l.dispatchEvent(e),this.updateExtrudePreview(),this.updateArrowPosition()}e.preventDefault()}handleArrowDragEnd(){this.isDraggingArrow=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor="default",this.updateExtrudePreview(),this.updateArrowPosition();const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10;this.editor.showStatus(`Высота установлена: ${e.toFixed(0)} мм`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingArrow&&this.handleArrowDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingArrow&&0===e.button&&this.handleArrowDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}updateExtrudePreview(){const e=this.getFiguresForOperation();if(0===e.length)return void this.removeExtrudePreview();const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive";if(this.extrudePreviewGroup&&this.extrudePreviewGroup.children.length>0){const o=this.extrudePreviewGroup.children[0],i=this.createExtrusionGeometryFromFigures(e,t,r);i&&(o.geometry.dispose(),o.geometry=i,this.updatePreviewPosition(o,t,r))}else this.createNewExtrudePreview(e,t,r)}createNewExtrudePreview(e,t,r){this.removeExtrudePreview();const o=this.createExtrusionGeometryFromFigures(e,t,r);if(!o)return;this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.3,side:THREE.DoubleSide}));const i=new THREE.Mesh(o,this.previewMaterial);this.updatePreviewPosition(i,t,r),this.extrudePreviewGroup=new THREE.Group,this.extrudePreviewGroup.add(i),this.editor.objectsGroup.add(this.extrudePreviewGroup)}updatePreviewPosition(e,t,r){if(!e||!this.basePlane)return;const o=new THREE.Vector3;this.basePlane.getWorldPosition(o),e.position.copy(o),e.quaternion.copy(this.basePlane.quaternion);const i=new THREE.Vector3(0,0,1);i.applyQuaternion(this.basePlane.quaternion),i.normalize();e.position.add(i.clone().multiplyScalar(.1))}removeExtrudePreview(){this.extrudePreviewGroup&&(this.editor.objectsGroup.remove(this.extrudePreviewGroup),this.extrudePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.extrudePreviewGroup=null)}createPropertiesUI(){const e=this.selectedFigures.size;return`\n            <div class="property-group" data-tool="extrude">\n                <h4>ВЫТЯГИВАНИЕ</h4>\n\n                <div class="property-row">\n                    <label>Высота (мм):</label>\n                    <input type="number" id="extrudeHeight" class="property-input" value="10" step="1" min="1">\n                </div>\n\n                <div class="property-row">\n                    <label>Направление:</label>\n                    <select id="extrudeDirection" class="property-select">\n                        <option value="positive">Наружу</option>\n                        <option value="negative">Внутрь</option>\n                        <option value="both">В обе стороны</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label>Операция:</label>\n                    <select id="extrudeOperation" class="property-select">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label class="property-checkbox">\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                        Объединять фигуры\n                        ${this.clipperAvailable?"":'<span style="color: #f00;"> (Clipper.js не найден)</span>'}\n                    </label>\n                </div>\n\n\n\n                <div class="property-buttons">\n                    <button id="performOperation" class="btn-primary" >\n                        <i class="fas fa-check"></i> Выполнить\n                    </button>\n                    <button id="cancelExtrude" class="btn-secondary">\n                        <i class="fas fa-times"></i> Отмена\n                    </button>\n                </div>\n\n                <div class="property-hint">\n                    <div id="selectedContourInfo">\n                        ${e>0?`Выбрано фигур: ${e}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" class="property-status"></div>\n                    <div id="clipperStatus" class="property-status"></div>\n                </div>\n                <div class="property-row">\n                    <div class="property-hint">\n                        <i class="fas fa-info-circle"></i> Описание:\n                        <div>Этот инструмент создает объемное тело путем линейного вытягивания плоского эскиза в перпендикулярном ему направлении.</div><br>\n                        <div>• Клик по фигуре: выделить/снять выделение</div>\n                        <div>• Перетаскивайте стрелку для изменения высоты</div>\n                        <div>• Escape для отмены, Enter для подтверждения</div>\n                    </div>\n                </div>\n            </div>\n        `}showExtrudeUI(){this.removeExtrudeUI();const e=document.getElementById("propertiesContent");e&&(this.propertiesElement=document.createElement("div"),this.propertiesElement.innerHTML=this.createPropertiesUI(),e.appendChild(this.propertiesElement),this.setupPropertiesEventListeners(),this.updateExtrudeUI())}setupPropertiesEventListeners(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#cancelExtrude");e&&e.addEventListener("click",()=>{this.exitExtrudeMode()});const t=this.propertiesElement.querySelector("#performOperation");t&&t.addEventListener("click",()=>{this.performExtrude()});const r=this.propertiesElement.querySelector("#extrudeHeight");r&&r.addEventListener("input",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});const o=this.propertiesElement.querySelector("#extrudeDirection");o&&o.addEventListener("change",()=>{this.updateExtrudePreview(),this.updateArrowPosition(),this.createExtrudeDirectionIndicator()});const i=this.propertiesElement.querySelector("#extrudeOperation");i&&i.addEventListener("change",()=>{this.currentOperation=i.value});const s=this.propertiesElement.querySelector("#mergeFigures");s&&s.addEventListener("change",e=>{this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(s.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","error")),this.updateExtrudePreview(),this.updateExtrudeUI()})}updateExtrudeUI(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#selectedContourInfo"),t=this.propertiesElement.querySelector("#mergeStatus"),r=this.propertiesElement.querySelector("#clipperStatus"),o=this.propertiesElement.querySelector("#performOperation"),i=this.propertiesElement.querySelector("#mergeFigures");if(i&&(i.disabled=!this.clipperAvailable),e){const o=this.selectedFigures.size;if(o>0){if(e.textContent=`Выбрано фигур: ${o}`,e.style.color="#4CAF50",t)if(o>1&&this.mergeConnectedFigures&&this.clipperAvailable){const e=Array.from(this.selectedFigures.values());this.areAllFiguresOnSamePlane(e)?(t.textContent="✓ Фигуры будут объединены",t.style.color="#4CAF50"):(t.textContent="✗ Фигуры на разных плоскостях",t.style.color="#f44336")}else!this.clipperAvailable&&o>1?(t.textContent="⚠ Clipper.js не найден, объединение недоступно",t.style.color="#FF9800"):t.textContent="";r&&(this.clipperAvailable?(r.textContent="✓ Clipper.js доступен",r.style.color="#4CAF50"):(r.textContent="✗ Clipper.js не найден",r.style.color="#f44336"))}else e.textContent="Кликните по фигуре для выбора",e.style.color="#888",t&&(t.textContent=""),r&&(r.textContent="")}o&&(o.disabled=0===this.selectedFigures.size)}removeExtrudeUI(){this.propertiesElement&&(this.propertiesElement.remove(),this.propertiesElement=null)}performExtrude(){const e=this.getFiguresForOperation();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вытягивания","error");const t=parseFloat(this.propertiesElement?.querySelector("#extrudeHeight")?.value)||10,r=this.propertiesElement?.querySelector("#extrudeDirection")?.value||"positive",o=this.propertiesElement?.querySelector("#extrudeOperation")?.value||"new";if(isNaN(t))return void this.editor.showStatus("Введите корректную высоту","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const i="cut"===o||"join"===o,s=this.createExtrusionGeometryFromFigures(e,t,r,i);if(!s)return void this.editor.showStatus("Не удалось создать геометрию выдавливания","error");const n=this.createExtrusionMesh(s,t,r,e);if(!n)return void this.editor.showStatus("Не удалось создать объект выдавливания","error");const a=new THREE.Vector3;if(this.basePlane.getWorldPosition(a),n.position.copy(a),n.quaternion.copy(this.basePlane.quaternion),i){new THREE.Vector3(0,0,1).applyQuaternion(this.basePlane.quaternion),console.log("Применено смещение для булевой операции")}const l={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),height:t,direction:r,operation:o,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,forBoolean:i};switch(o){case"new":this.handleNewOperation(n,l);break;case"cut":this.handleCutOperation(n,l);break;case"join":this.handleJoinOperation(n,l)}this.exitExtrudeMode();const u=e.filter(e=>e.isMerged).length,c=e.length;u>0&&c>u?this.editor.showStatus(`Выполнено выдавливание (${t} мм): ${u} объединенных + ${c-u} отдельных фигур`,"success"):u>0?this.editor.showStatus(`Выполнено выдавливание (${t} мм) с объединением ${u} фигур`,"success"):this.editor.showStatus(`Выполнено выдавливание (${t} мм) ${c} фигур`,"success")}createExtrusionMesh(e,t,r,o){if(!e)return null;const i=new THREE.MeshStandardMaterial({color:5025616,transparent:!0,opacity:1,side:THREE.DoubleSide}),s=new THREE.Mesh(e,i);s.castShadow=!0,s.receiveShadow=!0;const n=o.some(e=>e.isMerged),a=o.filter(e=>e.isMerged),l=a.length;return s.userData={type:"extrusion",sourceFigureIds:o.flatMap(e=>e.sourceFigures||[e.id]),height:t,direction:r,operation:this.currentOperation,name:`Вытягивание (${t} мм)${n?` [${l} объединенных]`:""}`,figureCount:o.length,holeCount:o.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:n,mergedFrom:n?a.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures},s}handleNewOperation(e,t){const r=e.position.clone(),o=e.scale.clone();this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectSingleObject(e);const i=this.editor.projectManager.serializeObjectForHistory(e);i.userData.finalPosition=r.toArray(),i.userData.finalScale=o.toArray(),this.editor.history.addAction({type:"create",subtype:"extrude",object:e.uuid,data:{...t,objectData:i,finalPosition:r.toArray(),finalScale:o.toArray()}})}removeThinWalls(e,t=.05){if(!e||!e.geometry)return e;const r=e.geometry;if(!r.isBufferGeometry)return e;console.log("Очистка тонких стенок...");const o=r.attributes.position,i=r.index;if(!o||!i)return e;const s=i.count/3,n=new Set;for(let e=0;e<s;e++){const r=[i.array[3*e],i.array[3*e+1],i.array[3*e+2]].map(e=>new THREE.Vector3(o.array[3*e],o.array[3*e+1],o.array[3*e+2])),s=(new THREE.Vector3).subVectors(r[1],r[0]),a=(new THREE.Vector3).subVectors(r[2],r[0]),l=s.cross(a).length()/2,u=[r[0].distanceTo(r[1]),r[1].distanceTo(r[2]),r[2].distanceTo(r[0])],c=Math.min(...u);(l<.001||c<t)&&n.add(e)}if(console.log(`Найдено тонких граней для удаления: ${n.size} из ${s}`),0===n.size)return e;const a=[];for(let e=0;e<s;e++)n.has(e)||a.push(i.array[3*e],i.array[3*e+1],i.array[3*e+2]);const l=new THREE.BufferGeometry;return l.setAttribute("position",o.clone()),r.attributes.normal&&l.setAttribute("normal",r.attributes.normal.clone()),r.attributes.uv&&l.setAttribute("uv",r.attributes.uv.clone()),l.setIndex(a),e.geometry.dispose(),e.geometry=l,e}handleCutOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let i=!1,s=null;r.forEach(r=>{try{const n=this.editor.booleanOps.subtract(r,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(s=n,this.replaceObjectsWithResult([r],s,"cut",{sourceExtrude:t,targetObjectData:o}),i=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),i||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),i=this.editor.projectManager.serializeObjectForHistory(e);try{const s=[...r,e],n=this.editor.booleanOps.unionMultiple(s);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(s,n,"join",{sourceObjectsData:o,extrudeData:i,sourceExtrude:t})}catch(r){console.error("Ошибка соединения:",r),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],r=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(o=>{if(!o.visible||!0===o.userData.hidden)return;if(o===e||"sketch_plane"===o.userData.type||"work_plane"===o.userData.type||"sketch_element"===o.userData.type)return;const i=(new THREE.Box3).setFromObject(o);r.intersectsBox(i)&&t.push(o)}),t}replaceObjectsWithResult(e,t,r,o){const i=this.editor.projectManager.serializeObjectForHistory(t);console.log("Result data:",i);const s={type:"boolean",operation:r,result:t.uuid,sourceObjects:e.map(e=>e.uuid),resultData:i,context:o?.sourceExtrude};console.log("Adding to history:",s),this.editor.history.addAction(s),e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectSingleObject(t)}exitExtrudeMode(){this.editor.toolManager.setCurrentTool("select")}cancelExtrudeMode(){this.clearSelection(),this.extrudeArrow&&(this.editor.scene.remove(this.extrudeArrow),this.extrudeArrow=null),this.removeExtrudePreview(),this.removeExtrudeUI();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.editor.showStatus("Режим вытягивания завершен","info"),document.body.style.cursor="default"}highlightExtrudableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,2201331):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,2201331)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вытягивания","warning")}}