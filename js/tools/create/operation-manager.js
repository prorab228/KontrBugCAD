class OperationManager{constructor(e){this.editor=e,this.figureManager=e.objectsManager.figureManager,this.selectedFigures=new Map,this.basePlane=null,this.hoveredFigure=null,this.hoveredColor=16776960,this.selectedColor=26367,this.isProcessingClick=!1,this.mergeConnectedFigures=!0,this.mergeThreshold=.1,this.clipperScale=1e5,this.clipperAvailable=!1,this.initializeClipper(),console.log("OperationManager: создан (базовый класс)")}initializeClipper(){"undefined"!=typeof ClipperLib?(this.clipperAvailable=!0,console.log("Clipper.js доступен"),ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale):(console.error("Clipper.js не найден! Объединение фигур будет недоступно."),this.clipperAvailable=!1)}initialize(){console.log("OperationManager: инициализация"),this.figureManager?this.figureManager.collectAllFigures():console.error("OperationManager: FigureManager не найден!")}handleFigureClick(e){if(console.log("=== handleFigureClick (OperationManager) ==="),this.isProcessingClick)return!1;this.isProcessingClick=!0;try{const t=this.figureManager.getAllFigures();if(0===t.length)return console.log("Нет фигур для выбора"),!1;const r=this.findFigureAtPoint(e,t);return r?(console.log("Найдена фигура:",r.id,"плоскость:",this.getFigurePlane(r)?.uuid),this.toggleSelection(r),!0):(console.log("Не найдена фигура под курсором"),!1)}finally{setTimeout(()=>{this.isProcessingClick=!1},50)}}findFigureAtPoint(e,t){const r=[...t].sort((e,t)=>e.depth!==t.depth?t.depth-e.depth:e.area-t.area);for(const t of r){if(!t.outer||!t.outer.points)continue;const r=this.getFigurePlane(t);if(!r)continue;if(!this.isPlaneVisible(r))continue;const i=this.getPointOnPlane(e,r);if(!i)continue;const n=r.worldToLocal(i.clone()),o=new THREE.Vector2(n.x,n.y);if(this.isPointInContour(o,t.outer.points))return t}return null}isPlaneVisible(e){if(!e)return!1;if(!e.visible)return!1;if(e.userData&&!1===e.userData.visible)return!1;let t=e.parent;for(;t;){if(!t.visible)return!1;t=t.parent}return!0}recalculateBasePlane(){if(0===this.selectedFigures.size)return void(this.basePlane=null);const e=this.selectedFigures.values().next().value;this.basePlane=this.getFigurePlane(e),console.log("Пересчитана базовая плоскость:",this.basePlane?.uuid)}toggleSelection(e){const t=e.id;if(this.selectedFigures.has(t))this.selectedFigures.delete(t),this.unhighlightFigure(e),0===this.selectedFigures.size?this.basePlane=null:this.recalculateBasePlane();else{this.selectedFigures.set(t,e);const r=this.getFigurePlane(e);if(this.basePlane){if(!this.arePlanesCompatible(this.basePlane,r))return this.editor.showStatus("Выбраны фигуры на разных плоскостях!","error"),void this.selectedFigures.delete(t)}else this.basePlane=r;this.highlightFigure(e,this.selectedColor)}console.log("Выделено фигур:",this.selectedFigures.size,"Базовая плоскость:",this.basePlane?.uuid)}getFiguresForOperation(){if(console.log("=== getFiguresForOperation (улучшенная логика) ==="),0===this.selectedFigures.size)return[];if(1===this.selectedFigures.size){const e=this.selectedFigures.values().next().value;return console.log(`Одна фигура: ${e.id}, isHole: ${e.isHole}`),[this.createOperationFigure(e)]}if(!this.mergeConnectedFigures||!this.clipperAvailable)return console.log("Объединение отключено или Clipper недоступен"),this.getIndividualFigures(Array.from(this.selectedFigures.values()));const e=Array.from(this.selectedFigures.values());if(!this.areAllFiguresOnSamePlane(e))return console.log("Фигуры на разных плоскостях, не объединяем"),this.getIndividualFigures(e);!this.basePlane&&e.length>0&&(this.basePlane=this.getFigurePlane(e[0])),console.log(`Выбрано фигур: ${e.length}`);const t=this.getIndependentFigures(e);console.log(`Независимых фигур: ${t.length}`);const r=[];return t.forEach(e=>{if(1===e.length){const t=e[0],i=this.createOperationFigure(t);r.push(i)}else{const t=this.mergeFigureGroup(e);t.length>0?r.push(...t):e.forEach(e=>{r.push(this.createOperationFigure(e))})}}),console.log(`Итоговое количество фигур для операции: ${r.length}`),r}getIndependentFigures(e){console.log("=== getIndependentFigures ==="),console.log(`Обработка ${e.length} выбранных фигур`);const t=[...e].sort((e,t)=>e.depth!==t.depth?e.depth-t.depth:t.area-e.area);console.log("Отсортированные фигуры:",t.map(e=>`ID: ${e.id}, depth: ${e.depth}, area: ${e.area?.toFixed(2)}`));const r=[],i=new Set,n=new Map;return t.forEach(e=>n.set(e.id,e)),t.forEach(e=>{if(i.has(e.id))return;const o=this.buildRelatedGroup(e,t,i,n);o.length>0&&(r.push(o),console.log(`Создана группа: ${o.map(e=>e.id).join(", ")}`))}),console.log(`Итого создано ${r.length} групп`),r}buildRelatedGroup(e,t,r,i){const n=[],o=[e];for(;o.length>0;){const e=o.pop();if(!r.has(e.id)){n.push(e),r.add(e.id);for(const i of t){if(r.has(i.id))continue;if(e.id===i.id)continue;let t=!1;(e.childrenIds&&e.childrenIds.includes(i.id)||i.childrenIds&&i.childrenIds.includes(e.id)||this.areFiguresRelated(e,i))&&(t=!0),t&&o.push(i)}}}return n}areFiguresRelated(e,t){if(e.childrenIds&&e.childrenIds.includes(t.id))return!0;if(t.childrenIds&&t.childrenIds.includes(e.id))return!0;const r=this.getFigurePointsForBasePlane(e),i=this.getFigurePointsForBasePlane(t);if(0===r.length||0===i.length)return!1;const n=this.calculateBoundingBox(r),o=this.calculateBoundingBox(i);if(!this.doBoundingBoxesIntersect(n,o))return!1;const s=Math.abs((e.depth||0)-(t.depth||0));if(s>1)return!1;const l=r[0],a=i[0],h=this.isPointInContour(l,i),u=this.isPointInContour(a,r);if((h||u)&&s<=1)return!0;if(s<=1){for(let e=0;e<r.length;e++)if(this.isPointInContour(r[e],i))return!0;for(let e=0;e<i.length;e++)if(this.isPointInContour(i[e],r))return!0}return!1}mergeFigureGroup(e){if(0===e.length)return[];console.log(`Объединение группы из ${e.length} фигур`);const t=[];return e.forEach(e=>{const r=this.getFigurePointsForBasePlane(e);if(r.length>=3){const i=this.calculateSignedPolygonArea(r),n=i<0?r.reverse():r;t.push({points:n,figureId:e.id,originalIsHole:e.isHole,area:Math.abs(i)})}this.getAllImmediateHoles(e).forEach(r=>{const i=r.points||[];if(i.length>=3){const r=this.calculateSignedPolygonArea(i),n=r<0?i:i.reverse();t.push({points:n,figureId:e.id,originalIsHole:!0,area:Math.abs(r)})}})}),console.log(`Всего контуров в группе: ${t.length}`),this.mergeAllContours(t)}mergeAllContours(e){if(0===e.length)return[];console.log(`Начинаем объединение ${e.length} контуров`);try{const t=[],r=[];if(e.forEach(e=>{const i=e.points;if(i.length<3)return;const n=this.calculateSignedPolygonArea(i);n<0?r.push({points:i,originalIsHole:e.originalIsHole,area:Math.abs(n)}):t.push({points:i,originalIsHole:e.originalIsHole,area:Math.abs(n)})}),console.log(`Внешних контуров: ${t.length}, отверстий: ${r.length}`),0===t.length)return console.log("Нет внешних контуров для объединения"),[];if(1===t.length&&0===r.length)return console.log("Только один внешний контур, без отверстий"),[this.createFigureFromContour(t[0],[])];const i=this.mergeOuterContours(t);console.log(`Объединено внешних контуров: ${i.length}`);const n=[];return i.forEach((e,t)=>{const i=r.filter(t=>{if(0===t.points.length)return!1;const r=t.points[0];return this.isPointInContour(r,e.points)});console.log(`Внешний контур ${t}: найдено ${i.length} отверстий`);const o=this.filterNestedHoles(i);console.log(`Внешний контур ${t}: отверстий первого уровня ${o.length}`);const s=this.createFigureFromContour(e,o);n.push(s)}),n}catch(e){return console.error("Ошибка при объединении контуров:",e),[]}}mergeOuterContours(e){if(0===e.length)return[];try{const t=new ClipperLib.Clipper;e.forEach(e=>{const r=e.points;if(r.length>=3){const e=this.pointsToClipperPath(r);t.AddPath(e,ClipperLib.PolyType.ptSubject,!0)}});const r=new ClipperLib.Paths;if(!t.Execute(ClipperLib.ClipType.ctUnion,r,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)||0===r.length)return console.log("Clipper не смог объединить внешние контуры"),e;console.log(`Clipper вернул ${r.length} внешних контуров`);const i=[];return r.forEach(e=>{const t=this.clipperPathToPoints(e);if(t.length>=3){const e=this.calculateSignedPolygonArea(t);e<0?i.push({points:t.reverse(),area:Math.abs(e)}):i.push({points:t,area:Math.abs(e)})}}),i}catch(t){return console.error("Ошибка при объединении внешних контуров:",t),e}}filterNestedHoles(e){if(e.length<=1)return e;const t=[];for(let r=0;r<e.length;r++){const i=e[r];let n=!1;for(let t=0;t<e.length;t++){if(r===t)continue;const o=e[t];if(i.points.length>0&&o.points.length>0){const e=i.points[0];if(this.isPointInContour(e,o.points)){n=!0;break}}}n||t.push(i)}return t}createFigureFromContour(e,t){const r=this.basePlane;return{id:`merged_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,outer:{points:e.points,center:this.calculateContourCenter(e.points),area:e.area},holes:t.map(e=>({points:e.points,center:this.calculateContourCenter(e.points),area:e.area})),area:e.area,isHole:!1,isMerged:!0,geometricMerge:!0,plane:r,planeId:r?r.uuid:null}}getIndividualFigures(e){return e.map(e=>this.createOperationFigure(e))}createOperationFigure(e){throw new Error("Метод createOperationFigure должен быть реализован в дочернем классе")}getAllImmediateHoles(e){const t=[];if(e.childrenIds&&e.childrenIds.length>0)for(const r of e.childrenIds){const i=this.figureManager.getFigureById(r);i&&(!e.isHole&&i.isHole||e.isHole&&!i.isHole)&&t.push(i.outer)}return t}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=this.getFigurePlane(e[0]);if(!t)return!1;for(let r=1;r<e.length;r++){const i=this.getFigurePlane(e[r]);if(!i||!this.arePlanesCompatible(t,i))return!1}return!0}getPointOnPlane(e,t=null){const r=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((e.clientX-r.left)/r.width*2-1,-(e.clientY-r.top)/r.height*2+1);if(this.editor.raycaster.setFromCamera(i,this.editor.camera),t){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(t.quaternion);const r=new THREE.Plane;r.setFromNormalAndCoplanarPoint(e,t.position);const i=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(r,i))return i}if(this.basePlane){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(this.basePlane.quaternion);const t=new THREE.Plane;t.setFromNormalAndCoplanarPoint(e,this.basePlane.position);const r=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(t,r))return r}const n=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];for(const e of n){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const r=new THREE.Plane;r.setFromNormalAndCoplanarPoint(t,e.position);const i=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(r,i))return i}return null}isPointInContour(e,t){if(t.length<3)return!1;let r=0;const i=t.length;for(let n=0;n<i;n++){const o=t[n],s=t[(n+1)%i];o.y<=e.y?s.y>e.y&&this.isLeft(o,s,e)>0&&r++:s.y<=e.y&&this.isLeft(o,s,e)<0&&r--}return 0!==r}isLeft(e,t,r){return(t.x-e.x)*(r.y-e.y)-(r.x-e.x)*(t.y-e.y)}getFigurePlane(e){if(e.plane)return e.plane;if(e.planeId){const t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId);if(t)return e.plane=t,t}let t=null;if(e.element?t=e.element:e.outer&&e.outer.element?t=e.outer.element:e.outer&&e.outer.elements&&e.outer.elements.length>0&&(t=e.outer.elements[0]),t){const r=this.findSketchPlaneForElement(t);return r&&(e.plane=r,e.planeId=r.uuid),r}return console.warn(`Не удалось определить плоскость для фигуры ${e.id}`),null}findSketchPlaneForElement(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}return this.editor.sketchPlanes.length>0?this.editor.sketchPlanes[0]:this.editor.workPlanes.length>0?this.editor.workPlanes[0]:null}calculateSignedPolygonArea(e){if(e.length<3)return 0;let t=0;const r=e.length;for(let i=0;i<r;i++){const n=(i+1)%r;t+=e[i].x*e[n].y,t-=e[n].x*e[i].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,r=0;return e.forEach(e=>{t+=e.x,r+=e.y}),new THREE.Vector2(t/e.length,r/e.length)}fixContourOrientation(e,t){if(e.length<3)return e;return this.calculateSignedPolygonArea(e)<0!==t?[...e].reverse():e}getFigurePointsForBasePlane(e){const t=this.getFigurePlane(e);return t?!this.basePlane||this.arePlanesCompatible(t,this.basePlane)?e.outer.points||[]:(e.outer.points||[]).map(e=>{const r=new THREE.Vector3(e.x,e.y,0),i=t.localToWorld(r.clone()),n=this.basePlane.worldToLocal(i.clone());return new THREE.Vector2(n.x,n.y)}):e.outer.points||[]}getContourPointsForBasePlane(e){return e.points||[]}arePlanesCompatible(e,t){if(!e||!t)return!1;if(e.uuid===t.uuid)return!0;const r=e.position,i=t.position,n=e.quaternion,o=t.quaternion,s=r.distanceTo(i),l=n.angleTo(o);return s<.001&&l<.001}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let r=0;r<e.length;r++)t[r]=new ClipperLib.IntPoint(Math.round(e[r].x*this.clipperScale),Math.round(e[r].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let r=0;r<e.length;r++)t.push(new THREE.Vector2(e[r].X/this.clipperScale,e[r].Y/this.clipperScale));return t}highlightFigure(e,t){e&&e.outer&&(e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,t):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,t)}))}unhighlightFigure(e){e&&e.outer&&(this.selectedFigures.has(e.id)||(e.outer.element?this.editor.objectsManager.safeRestoreElementColor(e.outer.element):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)})))}highlightFiguresOnHover(e){this.hoveredFigure&&!this.selectedFigures.has(this.hoveredFigure.id)&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null);const t=this.figureManager.getAllFigures(),r=this.findFigureAtPoint(e,t);if(r){if(this.selectedFigures.has(r.id))return this.hoveredFigure&&(this.hoveredFigure=null),void(document.body.style.cursor="default");this.hoveredFigure=r,this.highlightFigure(r,this.hoveredColor),document.body.style.cursor="pointer"}else document.body.style.cursor="default"}clearSelection(){console.log("=== clearSelection (OperationManager) ===");for(const e of this.selectedFigures.values())this.unhighlightFigure(e);this.selectedFigures.clear(),this.basePlane=null,this.hoveredFigure&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),document.body.style.cursor="default"}calculateBoundingBox(e){if(0===e.length)return{min:new THREE.Vector2(0,0),max:new THREE.Vector2(0,0)};const t=new THREE.Vector2(1/0,1/0),r=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),r.x=Math.max(r.x,e.x),r.y=Math.max(r.y,e.y)}),{min:t,max:r}}doBoundingBoxesIntersect(e,t){return!(e.max.x<t.min.x||e.min.x>t.max.x||e.max.y<t.min.y||e.min.y>t.max.y)}createOperationFigure(e){throw new Error("Метод createOperationFigure должен быть реализован в дочернем классе")}updateOperationPreview(){throw new Error("Метод updateOperationPreview должен быть реализован в дочернем классе")}performOperation(){throw new Error("Метод performOperation должен быть реализован в дочернем классе")}exitOperationMode(){throw new Error("Метод exitOperationMode должен быть реализован в дочернем классе")}}