class OperationManager{constructor(e){this.editor=e,this.selectedRegions=new Map,this.basePlane=null,this.hoveredRegion=null,this.hoveredColor=16776960,this.selectedColor=26367,this.isProcessingClick=!1,this.mergeConnectedRegions=!0,this.mergeThreshold=.1,this.clipperScale=1e7,this.clipperAvailable="undefined"!=typeof ClipperLib,this.clipperAvailable?(ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale,console.log("OperationManager: Clipper.js доступен, масштаб:",this.clipperScale)):console.warn("OperationManager: Clipper.js не найден!"),console.log("OperationManager создан")}initialize(){console.log("OperationManager: инициализация")}logSelectedAreas(){if(0===this.selectedRegions.size)return void console.log("Нет выделенных регионов");console.log("=== Выделенные регионы ===");let e=0;for(const t of this.selectedRegions.values()){const n=t.outer?.area||0,i=t.outer?.points?.length||0,o=t.holes?.length||0;console.log(`Регион ${t.id.substring(0,8)}: площадь = ${n.toFixed(2)}, точек = ${i}, отверстий = ${o}`),e+=n}console.log(`Общая площадь: ${e.toFixed(2)}`)}logOperationFigures(e){console.log("=== Фигуры для операции ==="),e.forEach((e,t)=>{const n=e.outer?.points?.length||0,i=e.outer?.area||0,o=e.holes?.length||0;console.log(`Фигура ${t}: внешних точек = ${n}, площадь = ${i.toFixed(2)}, отверстий = ${o}`),e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{const n=e.points?.length||0,i=e.area||0;console.log(`  Отверстие ${t}: точек = ${n}, площадь = ${i.toFixed(2)}`)})}),console.log(`Всего фигур: ${e.length}`)}getAllRegions(){const e=[];return this.editor.scene.traverse(t=>{if(t.userData?.regionManager&&t.userData.regionManager instanceof SketchRegionManager){const n=t.userData.regionManager.getAllRegions();n.forEach(e=>{e.plane=t,e.planeId=t.uuid}),e.push(...n)}}),e}isPlaneVisible(e){if(!e)return!1;if(!e.visible)return!1;if(!1===e.userData?.visible)return!1;let t=e.parent;for(;t;){if(!t.visible)return!1;t=t.parent}return!0}findRegionAtPoint(e){const t=this.editor.renderer.domElement.getBoundingClientRect(),n=new THREE.Vector2((e.clientX-t.left)/t.width*2-1,-(e.clientY-t.top)/t.height*2+1);this.editor.raycaster.setFromCamera(n,this.editor.camera);const i=[];this.editor.scene.traverse(e=>{e.userData?.type?.includes("plane")&&e.visible&&i.push(e)});let o=null,r=1/0;for(const e of i){const t=new THREE.Vector3(0,0,1).applyQuaternion(e.quaternion),n=(new THREE.Plane).setFromNormalAndCoplanarPoint(t,e.position),i=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(n,i)){const t=this.editor.camera.position.distanceTo(i),n=e.userData?.regionManager;if(n){const s=e.worldToLocal(i.clone()),l=n.getRegionAtPoint(s);l&&(l.plane=e,l.planeId=e.uuid,t<r&&(r=t,o=l))}}}return o}handleFigureClick(e){if(this.isProcessingClick)return!1;this.isProcessingClick=!0;try{const t=this.findRegionAtPoint(e);return!!t&&(this.toggleSelection(t),!0)}finally{setTimeout(()=>{this.isProcessingClick=!1},50)}}toggleSelection(e){const t=e.id;if(this.selectedRegions.has(t))this.selectedRegions.delete(t),this.unhighlightRegion(e),0===this.selectedRegions.size?this.basePlane=null:this.recalculateBasePlane();else{if(this.basePlane){if(!this.arePlanesCompatible(this.basePlane,e.plane))return void this.editor.showStatus("Регионы на разных плоскостях!","error")}else this.basePlane=e.plane;this.selectedRegions.set(t,e),this.highlightRegion(e,this.selectedColor)}this.logSelectedAreas()}recalculateBasePlane(){0===this.selectedRegions.size?this.basePlane=null:this.basePlane=this.selectedRegions.values().next().value.plane}clearSelection(){for(const e of this.selectedRegions.values())this.unhighlightRegion(e);this.selectedRegions.clear(),this.basePlane=null,this.hoveredRegion&&(this.unhighlightRegion(this.hoveredRegion),this.hoveredRegion=null),document.body.style.cursor="default"}highlightFiguresOnHover(e){if(this.hoveredRegion&&!this.selectedRegions.has(this.hoveredRegion.id)){const e=this.hoveredRegion.plane?.userData?.regionManager;e&&e.unhighlightRegionHover(),this.hoveredRegion=null}const t=this.findRegionAtPoint(e);if(t){if(this.selectedRegions.has(t.id))return void(document.body.style.cursor="default");this.hoveredRegion=t;const e=t.plane?.userData?.regionManager;e&&e.highlightRegionHover(t,this.hoveredColor),document.body.style.cursor="pointer"}else document.body.style.cursor="default"}highlightRegion(e,t){const n=e.plane?.userData?.regionManager;n?n.highlightRegion(e,t):console.warn("RegionManager не найден для плоскости",e.plane)}unhighlightRegion(e){const t=e.plane?.userData?.regionManager;t&&t.unhighlightRegion(e)}unionOuterRegions(e){if(!this.clipperAvailable||0===e.length)return e;if(1===e.length)return e;console.log(`unionOuterRegions: объединяем ${e.length} регионов`);const t=[];for(const n of e){let e=n.outer.points;if(e.length<3)continue;this.calculateSignedPolygonArea(e)<0&&(e=e.slice().reverse());const i=this.pointsToClipperPath(e);i&&i.length>=3&&t.push(i)}if(0===t.length)return e;const n=new ClipperLib.ClipperOffset;t.forEach(e=>n.AddPath(e,ClipperLib.JoinType.jtMiter,ClipperLib.EndType.etClosedPolygon));const i=new ClipperLib.Paths;if(n.Execute(i,.2*this.clipperScale),console.log(`expanded: ${i.length} контуров`),0===i.length)return e;const o=new ClipperLib.ClipperOffset;i.forEach(e=>o.AddPath(e,ClipperLib.JoinType.jtMiter,ClipperLib.EndType.etClosedPolygon));const r=new ClipperLib.Paths;if(o.Execute(r,-.2*this.clipperScale),console.log(`shrunk: ${r.length} контуров`),0===r.length)return e;const s=[],l=[];r.forEach(e=>{const t=this.clipperPathToPoints(e);if(t.length<3)return;const n=this.calculateSignedPolygonArea(t);n>0?s.push({points:t,area:n,center:this.calculateContourCenter(t)}):l.push({points:t,area:-n,center:this.calculateContourCenter(t)})});const a=[];return s.forEach(t=>{const n=l.filter(e=>this.pointInPolygon(e.center,t.points));a.push({outer:{points:t.points,center:t.center,area:t.area,isClockwise:!1},holes:n.map(e=>({points:e.points,center:e.center,area:e.area,isClockwise:!0})),plane:e[0].plane,planeId:e[0].planeId,id:`merged_${Date.now()}_${Math.random().toString(36).substr(2,9)}`})}),console.log(`unionOuterRegions: получено ${a.length} внешних контуров с учётом отверстий`),a}extractOuterContours(e,t,n){const i=[],o=(e,r)=>{if(e.Contour&&r%2==0){const o=this.clipperPathToPoints(e.Contour);o.length>=3&&i.push({outer:{points:o,center:this.calculateContourCenter(o),area:Math.abs(this.calculateSignedPolygonArea(o)),isClockwise:this.calculateSignedPolygonArea(o)<0},plane:t,planeId:n,id:`merged_${Date.now()}_${Math.random().toString(36).substr(2,9)}`})}this.getChildrenArray(e).forEach(e=>o(e,r+1))};return o(e,0),i}filterFirstLevelRegions(e){if(e.length<=1)return e;const t=e.map(e=>({region:e,children:[],parent:null,depth:0}));t.sort((e,t)=>(t.region.area||0)-(e.region.area||0));for(let e=0;e<t.length;e++){const n=t[e];for(let i=0;i<e;i++){const e=t[i];if(this.isRegionInside(n.region,e.region)){e.children.push(n),n.parent=e;break}}}return t.filter(e=>null===e.parent).map(e=>e.region)}isRegionInside(e,t){if(!e.outer?.points||0===e.outer.points.length||!t.outer?.points||0===t.outer.points.length)return!1;const n=e.outer.center;return!!n&&(!!this.pointInPolygon(n,t.outer.points)&&(this.isPointOnPolygonBoundary,!0))}getChildrenArray(e){if(Array.isArray(e.Childs))return e.Childs;if(e.Childs&&"number"==typeof e.Childs.length)return Array.from(e.Childs);const t=[];let n=e.GetFirst?e.GetFirst():null;for(;n;)t.push(n),n=n.GetNext?n.GetNext():null;return t}getRegionsForOperation(){if(0===this.selectedRegions.size)return[];const e=Array.from(this.selectedRegions.values());if(console.log(`getRegionsForOperation: selected ${e.length} regions`),!this.mergeConnectedRegions||!this.clipperAvailable){const t=e.map(e=>this.regionToOperationFigure(e));return this.logOperationFigures(t),t}if(!this.areAllRegionsOnSamePlane(e)){const t=e.map(e=>this.regionToOperationFigure(e));return this.logOperationFigures(t),t}let t=this.unionOuterRegions(e);0===t.length&&(t=e);const n=this.getAllRegions(),i=new Set(e.map(e=>e.id)),o=[];return t.forEach(e=>{const t=n.filter(t=>{if(i.has(t.id))return!1;if(!t.outer?.points||0===t.outer.points.length)return!1;const n=t.outer.center;if(!n)return!1;if(!this.pointInPolygon(n,e.outer.points))return!1;const o=void 0!==e.depth?e.depth:0;return!(t.depth<=o)}),r=this.filterFirstLevelRegions(t),s={id:e.id||`merged_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,outer:{points:e.outer.points,center:e.outer.center||this.calculateContourCenter(e.outer.points),area:e.outer.area||Math.abs(this.calculateSignedPolygonArea(e.outer.points)),isClockwise:void 0!==e.outer.isClockwise?e.outer.isClockwise:this.calculateSignedPolygonArea(e.outer.points)<0},holes:r.map(e=>({points:e.outer.points,center:e.outer.center,area:e.outer.area,isClockwise:e.outer.isClockwise})),plane:e.plane,planeId:e.planeId};o.push(s)}),console.log(`  итого фигур для операции: ${o.length}`),this.logOperationFigures(o),o}regionToOperationFigure(e){return{id:e.id,outer:{points:e.outer.points,center:e.outer.center,area:e.outer.area,elementIds:e.outer.elementIds,isClockwise:e.outer.isClockwise},holes:e.holes.map(e=>({points:e.points,center:e.center,area:e.area,isClockwise:e.isClockwise})),area:e.area,isHole:e.isHole,isOuter:e.isOuter,depth:e.depth,plane:e.plane,planeId:e.planeId}}getPointOnPlane(e,t=null){const n=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((e.clientX-n.left)/n.width*2-1,-(e.clientY-n.top)/n.height*2+1);this.editor.raycaster.setFromCamera(i,this.editor.camera);const o=t||this.basePlane;if(!o)return null;const r=new THREE.Vector3(0,0,1).applyQuaternion(o.quaternion),s=(new THREE.Plane).setFromNormalAndCoplanarPoint(r,o.position),l=new THREE.Vector3;return this.editor.raycaster.ray.intersectPlane(s,l)?l:null}arePlanesCompatible(e,t){return!(!e||!t)&&(e.uuid===t.uuid||e.position.distanceTo(t.position)<.001&&e.quaternion.angleTo(t.quaternion)<.001)}areAllRegionsOnSamePlane(e){if(e.length<2)return!0;const t=e[0].plane;return!!t&&e.every(e=>this.arePlanesCompatible(t,e.plane))}pointInPolygon(e,t){if(!t||t.length<3)return!1;let n=!1;for(let i=0,o=t.length-1;i<t.length;o=i++){const r=t[i].x,s=t[i].y,l=t[o].x,a=t[o].y;s>e.y!=a>e.y&&e.x<(l-r)*(e.y-s)/(a-s)+r&&(n=!n)}return n}calculateSignedPolygonArea(e){if(e.length<3)return 0;let t=0;const n=e.length;for(let i=0;i<n;i++){const o=(i+1)%n;t+=e[i].x*e[o].y,t-=e[o].x*e[i].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,n=0;return e.forEach(e=>{t+=e.x,n+=e.y}),new THREE.Vector2(t/e.length,n/e.length)}calculateBoundingBox(e){const t=new THREE.Vector2(1/0,1/0),n=new THREE.Vector2(-1/0,-1/0);return e.forEach(e=>{t.x=Math.min(t.x,e.x),t.y=Math.min(t.y,e.y),n.x=Math.max(n.x,e.x),n.y=Math.max(n.y,e.y)}),{min:t,max:n}}pointsToClipperPath(e){let t=e;e.length>1&&Math.abs(e[0].x-e[e.length-1].x)<.001&&Math.abs(e[0].y-e[e.length-1].y)<.001&&(t=e.slice(0,-1));const n=new ClipperLib.Path(t.length);for(let e=0;e<t.length;e++)n[e]=new ClipperLib.IntPoint(Math.round(t[e].x*this.clipperScale),Math.round(t[e].y*this.clipperScale));return n}clipperPathToPoints(e){const t=[];for(let n=0;n<e.length;n++)t.push(new THREE.Vector2(e[n].X/this.clipperScale,e[n].Y/this.clipperScale));return t}createOperationFigure(e){throw new Error("Метод createOperationFigure должен быть реализован в дочернем классе")}updateOperationPreview(){throw new Error("Метод updateOperationPreview должен быть реализован в дочернем классе")}performOperation(){throw new Error("Метод performOperation должен быть реализован в дочернем классе")}exitOperationMode(){throw new Error("Метод exitOperationMode должен быть реализован в дочернем классе")}}