class RevolveManager extends OperationManager{constructor(e){super(e),this.revolvePreviewGroup=null,this.previewMaterial=null,this.currentOperation="new",this.selectedAxis="y",this.selectedAxisLine=null,this.isSelectingAxis=!1,this.axisHelper=null,this.axisStartPoint=null,this.axisDirection=new THREE.Vector3(0,1,0),this.axisPoint=new THREE.Vector3(0,0,0),this.addCaps=!0,this.capThickness=.1,console.log("RevolveManager: создан (доработанная версия с закрытием торцов, наследник OperationManager)")}createOperationFigure(e){const t=this.getAllImmediateHoles(e),o=this.getFigurePlane(e);return{id:e.id,outer:e.outer,holes:t,area:e.area,isHole:e.isHole,parentId:e.parentId,childrenIds:e.childrenIds,depth:e.depth,plane:o,planeId:o?o.uuid:null,element:e.element}}handleFigureClick(e){if(this.isSelectingAxis)return this.handleAxisSelection(e);const t=super.handleFigureClick(e);return t&&(this.updateRevolvePreview(),this.updateRevolveUI()),t}createRevolveGeometryWithCaps(e,t,o,s){console.log("=== createRevolveGeometryWithCaps (обновленный) ==="),console.log(`Параметры: угол=${t}°, ось=${o}, направление=${s}, addCaps=${this.addCaps}`);const i=this.createRevolveGeometryFromFigures(e,t,o,s);if(!i)return console.error("Не удалось создать основную геометрию вращения"),null;if(t>=360||!this.addCaps)return console.log("Угол 360° или закрытие торцов отключено - не создаем крышки"),i;console.log(`Создаем крышки для ${e.length} фигур...`);try{const n=this.createCapsGeometryImproved(e,t,o,s);if(!n||0===n.length)return console.log("Не удалось создать крышки, возвращаем основную геометрию"),i;const r=this.mergeGeometries([i,...n]);return r?(console.log("Геометрия с крышками успешно создана"),r):(console.error("Не удалось объединить геометрии"),i)}catch(e){return console.error("Ошибка при создании крышек:",e),i}}createCapsGeometryImproved(e,t,o,s){console.log("=== createCapsGeometryImproved (исправленный) ===");const i=[];return e.forEach((n,r)=>{console.log(`Создание крышек для фигуры ${r+1}/${e.length}`);const l=this.createShapeFromFigure(n);if(!l)return void console.log(`  Не удалось создать форму для фигуры ${n.id}`);const a=[l];if(this.selectedAxisLine){const e=this.calculateStartAngleForLineAxis(),o=this.createLineAxisCapImproved(a,e);o&&i.push(o);const n="positive"===s?e+t:e-t,r=this.createLineAxisCapImproved(a,n);r&&i.push(r)}else{const e=this.calculateStartAngleForGlobalAxis(o),n=this.createGlobalAxisCapImproved(a,o,s,e);n&&i.push(n);const r="positive"===s?e+t:e-t,l=this.createGlobalAxisCapImproved(a,o,s,r);l&&i.push(l)}}),console.log(`Создано ${i.length} крышек для ${e.length} фигур`),i}calculateStartAngleForGlobalAxis(e){if(!this.basePlane)return 0;const t=new THREE.Vector3(0,0,1);t.applyQuaternion(this.basePlane.quaternion);let o=new THREE.Vector3;switch(e){case"x":o.set(1,0,0);break;case"y":o.set(0,1,0);break;case"z":o.set(0,0,1)}const s=t.clone().projectOnPlane(o);let i=new THREE.Vector3;s.length()<.001?"x"===e?i.set(0,1,0):i.set(1,0,0):i=s.normalize();let n=new THREE.Vector3;switch(e){case"x":n.set(0,0,1);break;case"y":n.set(1,0,0);break;case"z":n.set(0,1,0)}const r=n.dot(i),l=(new THREE.Vector3).crossVectors(n,i),a=Math.atan2(l.dot(o),r);let c=THREE.MathUtils.radToDeg(a);return Math.abs(t.z)>.9?"x"!==e&&"z"!==e||(c+=90):Math.abs(t.y)>.9?"z"===e&&(c+=180):Math.abs(t.x)>.9&&"x"===e&&(c+=90),c=(c%360+360)%360,console.log(`Начальный угол для оси ${e}: ${c}°`),c}calculateStartAngleForLineAxis(){if(!this.selectedAxisLine||!this.basePlane)return 0;const e=new THREE.Vector3(0,0,1);e.applyQuaternion(this.basePlane.quaternion);const t=this.selectedAxisLine.geometry.attributes.position.array,o=new THREE.Vector3(t[0],t[1],t[2]),s=new THREE.Vector3(t[3],t[4],t[5]),i=new THREE.Vector3,n=new THREE.Vector3;this.selectedAxisLine.localToWorld(i.copy(o)),this.selectedAxisLine.localToWorld(n.copy(s));const r=(new THREE.Vector3).subVectors(n,i).normalize(),l=e.clone().projectOnPlane(r);let a=new THREE.Vector3;l.length()<.001?(a=Math.abs(r.dot(new THREE.Vector3(1,0,0)))<.9?new THREE.Vector3(1,0,0):new THREE.Vector3(0,1,0),a=a.projectOnPlane(r).normalize()):a=l.normalize();let c=new THREE.Vector3;c=Math.abs(r.dot(new THREE.Vector3(1,0,0)))<.9?new THREE.Vector3(1,0,0):new THREE.Vector3(0,1,0),c=c.projectOnPlane(r).normalize();const d=c.dot(a),h=(new THREE.Vector3).crossVectors(c,a),u=Math.atan2(h.dot(r),d);let p=THREE.MathUtils.radToDeg(u);return p<0&&(p+=360),console.log(`Начальный угол для линии: ${p}°`),p}createGlobalAxisCapImproved(e,t,o,s){if(console.log(`Создание крышки для глобальной оси ${t}, угол: ${s}°`),0===e.length)return null;try{let i=e[0];for(let t=1;t<e.length;t++){(e[t].holes||[]).forEach(e=>{i.holes.push(e)})}const n={depth:this.capThickness,bevelEnabled:!1,steps:1},r=new THREE.ExtrudeGeometry(i,n),l=new THREE.Vector2(0,0),a=new THREE.Vector3(l.x,l.y,0),c=this.basePlane.localToWorld(a.clone());let d=new THREE.Vector3;switch(t){case"x":d.set(1,0,0);break;case"y":d.set(0,1,0);break;case"z":d.set(0,0,1)}const h="positive"===o?1:-1,u=THREE.MathUtils.degToRad(s),p=new THREE.Quaternion;p.setFromAxisAngle(d,u*h);const v=new THREE.Vector3(0,0,1);v.applyQuaternion(this.basePlane.quaternion);const g=v.clone().applyQuaternion(p),E=new THREE.Vector3(0,0,0),m=c.clone().sub(E).clone().applyQuaternion(p),x=E.clone().add(m),y=g.clone().multiplyScalar(this.capThickness/2),w=x.clone().add(y),R=this.basePlane.quaternion.clone(),b=new THREE.Quaternion;b.multiplyQuaternions(p,R);const T=new THREE.Matrix4;return T.compose(w,b,new THREE.Vector3(1,1,1)),r.applyMatrix4(T),r}catch(e){return console.error("Ошибка создания крышки для глобальной оси:",e),null}}createLineAxisCapImproved(e,t){if(console.log(`Создание крышки для линии, угол: ${t}°`),!this.selectedAxisLine||0===e.length)return null;try{let o=e[0];for(let t=1;t<e.length;t++){(e[t].holes||[]).forEach(e=>{o.holes.push(e)})}const s={depth:this.capThickness,bevelEnabled:!1,steps:1},i=new THREE.ExtrudeGeometry(o,s),n=this.selectedAxisLine.geometry.attributes.position.array,r=new THREE.Vector3(n[0],n[1],n[2]),l=new THREE.Vector3(n[3],n[4],n[5]),a=new THREE.Vector3,c=new THREE.Vector3;this.selectedAxisLine.localToWorld(a.copy(r)),this.selectedAxisLine.localToWorld(c.copy(l));const d=(new THREE.Vector3).subVectors(c,a).normalize(),h=new THREE.Vector2(0,0),u=new THREE.Vector3(h.x,h.y,0),p=this.basePlane.localToWorld(u.clone()),v=p.clone().sub(a).dot(d),g=a.clone().add(d.clone().multiplyScalar(v)),E=p.clone().sub(g),m=THREE.MathUtils.degToRad(t),x=new THREE.Quaternion;x.setFromAxisAngle(d,m);const y=E.clone().applyQuaternion(x),w=g.clone().add(y),R=new THREE.Vector3(0,0,1);R.applyQuaternion(this.basePlane.quaternion);const b=R.clone().applyQuaternion(x).clone().multiplyScalar(this.capThickness/2),T=w.clone().add(b),f=this.basePlane.quaternion.clone(),H=new THREE.Quaternion;H.multiplyQuaternions(x,f);const A=new THREE.Matrix4;return A.compose(T,H,new THREE.Vector3(1,1,1)),i.applyMatrix4(A),i}catch(e){return console.error("Ошибка создания крышки для линии:",e),null}}createShapesFromFigures(e){const t=[];return e.forEach(e=>{try{const o=this.getFigurePointsForBasePlane(e);if(o.length<3)return void console.log(`  Недостаточно точек: ${o.length}`);const s=new THREE.Shape;if(o.length>0){s.moveTo(o[0].x,o[0].y);for(let e=1;e<o.length;e++)s.lineTo(o[e].x,o[e].y);s.closePath()}e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{try{const t=this.getContourPointsForBasePlane(e);if(t.length>=3){const e=new THREE.Path;e.moveTo(t[0].x,t[0].y);for(let o=1;o<t.length;o++)e.lineTo(t[o].x,t[o].y);s.holes.push(e)}}catch(e){console.error(`  Ошибка создания отверстия ${t}:`,e)}}),t.push(s),console.log("  Форма успешно создана")}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),t}mergeGeometries(e){if(0===e.length)return null;if(1===e.length)return e[0];try{const t=new THREE.BufferGeometry,o=[],s=[];let i=0;return e.forEach((e,t)=>{if(!e||!e.attributes.position)return void console.warn(`Геометрия ${t} не имеет атрибутов позиции`);const n=e.attributes.position.array;for(let e=0;e<n.length;e+=3)o.push(n[e],n[e+1],n[e+2]);if(e.index){const t=e.index.array;for(let e=0;e<t.length;e++)s.push(t[e]+i)}else{const e=n.length/3;for(let t=0;t<e;t++)s.push(t+i)}i+=n.length/3}),t.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),t.setIndex(s),t.computeVertexNormals(),console.log(`Объединено ${e.length} геометрий, вершин: ${o.length/3}`),t}catch(t){return console.error("Ошибка объединения геометрий:",t),e[0]}}createRevolveGeometryFromFigures(e,t,o,s){if(console.log("=== createRevolveGeometryFromFigures (исправленный) ==="),console.log(`Параметры: угол=${t}°, ось=${o}, направление=${s}`),console.log(`Фигур для вращения: ${e.length}`),0===e.length||!this.basePlane)return console.error("Нет фигур или базовой плоскости!"),null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;if(1===e.length)return console.log("Одна фигура - стандартная обработка"),this.createRevolveGeometryForSingleFigure(e[0],t,o,s);console.log(`Создаем вращение для ${e.length} фигур`);const i=[];return e.forEach((n,r)=>{try{console.log(`Создание геометрии для фигуры ${r+1}/${e.length}: ${n.id}`);const l=this.createRevolveGeometryForSingleFigure(n,t,o,s);l?(i.push(l),console.log("  Геометрия создана успешно")):console.log(`  Не удалось создать геометрию для фигуры ${n.id}`)}catch(e){console.error(`  Ошибка создания геометрии для фигуры ${n.id}:`,e)}}),0===i.length?(console.error("Не удалось создать ни одну геометрию!"),null):(console.log(`Создано ${i.length} геометрий`),1===i.length?i[0]:(console.log("Объединяем геометрии..."),this.mergeGeometries(i)))}createRevolveGeometryForSingleFigure(e,t,o,s){console.log(`Создание геометрии для фигуры: ${e.id}`);const i=this.createShapeFromFigure(e);return i?this.selectedAxisLine?this.createRevolveAroundLine(i,t,s):this.createRevolveAroundGlobalAxis(i,o,t,s):(console.error(`Не удалось создать форму для фигуры ${e.id}`),null)}createShapeFromFigure(e){try{const t=this.getFigurePointsForBasePlane(e);if(t.length<3)return console.log(`  Недостаточно точек: ${t.length}`),null;const o=new THREE.Shape;if(t.length>0){o.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)o.lineTo(t[e].x,t[e].y);o.closePath()}return e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{try{const t=this.getContourPointsForBasePlane(e);if(t.length>=3){const e=new THREE.Path;e.moveTo(t[0].x,t[0].y);for(let o=1;o<t.length;o++)e.lineTo(t[o].x,t[o].y);o.holes.push(e)}}catch(e){console.error(`  Ошибка создания отверстия ${t}:`,e)}}),console.log("  Форма успешно создана"),o}catch(t){return console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t),null}}createRevolveAroundGlobalAxis(e,t,o,s){console.log(`Создание вращения вокруг глобальной оси ${t}`);const i=e.getPoints();if(!i||i.length<3)return null;const n=i.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)}),r=new THREE.Vector3;n.forEach(e=>r.add(e)),r.divideScalar(n.length);let l,a=new THREE.Vector3(0,0,0);switch(t){case"x":l=new THREE.Vector3(1,0,0);break;case"y":default:l=new THREE.Vector3(0,1,0);break;case"z":l=new THREE.Vector3(0,0,1)}const c=n.map(e=>{const t=(new THREE.Vector3).subVectors(e,a),o=t.dot(l),s=l.clone().multiplyScalar(o),i=(new THREE.Vector3).subVectors(t,s).length(),n=o;return new THREE.Vector2(i,n)}),d="negative"===s?-THREE.MathUtils.degToRad(o):THREE.MathUtils.degToRad(o),h=new THREE.LatheGeometry(c,Math.max(16,Math.round(o/5)),0,d),u=new THREE.Matrix4,p=new THREE.Vector3(0,1,0),v=new THREE.Quaternion;return v.setFromUnitVectors(p,l),u.makeRotationFromQuaternion(v),u.setPosition(a),h.applyMatrix4(u),h}createRevolveAroundLine(e,t,o){if(console.log("Создание вращения вокруг выбранной линии"),!this.selectedAxisLine)return console.error("Нет выбранной линии!"),null;const s=e.getPoints();if(!s||s.length<3)return null;const i=this.selectedAxisLine.geometry.attributes.position.array,n=new THREE.Vector3(i[0],i[1],i[2]),r=new THREE.Vector3(i[3],i[4],i[5]),l=new THREE.Vector3,a=new THREE.Vector3;this.selectedAxisLine.localToWorld(l.copy(n)),this.selectedAxisLine.localToWorld(a.copy(r));const c=(new THREE.Vector3).subVectors(a,l).normalize(),d=s.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)}).map(e=>{const t=(new THREE.Vector3).subVectors(e,l),o=t.dot(c),s=c.clone().multiplyScalar(o),i=(new THREE.Vector3).subVectors(t,s).length(),n=o;return new THREE.Vector2(i,n)}),h="negative"===o?-THREE.MathUtils.degToRad(t):THREE.MathUtils.degToRad(t),u=new THREE.LatheGeometry(d,Math.max(16,Math.round(t/5)),0,h),p=new THREE.Matrix4,v=new THREE.Vector3(0,1,0),g=new THREE.Quaternion;return g.setFromUnitVectors(v,c),p.makeRotationFromQuaternion(g),p.setPosition(l),u.applyMatrix4(p),u}updateRevolvePreview(){console.log("=== updateRevolvePreview ===");const e=this.getFiguresForOperation();if(0===e.length)return console.log("Нет фигур для предпросмотра"),void this.removeRevolvePreview();const t=parseFloat(document.getElementById("revolveAngle")?.value)||360,o=document.getElementById("revolveAxis")?.value||"y",s=document.getElementById("revolveDirection")?.value||"positive";if(console.log(`Параметры предпросмотра: угол=${t}°, ось=${o}, направление=${s}`),this.revolvePreviewGroup&&this.revolvePreviewGroup.children.length>0){console.log("Обновление существующего предпросмотра");const i=this.revolvePreviewGroup.children[0],n=this.createRevolveGeometryWithCaps(e,t,o,s);n?(i.geometry.dispose(),i.geometry=n):console.error("Не удалось создать новую геометрию для предпросмотра")}else console.log("Создание нового предпросмотра"),this.createNewRevolvePreview(e,t,o,s)}createNewRevolvePreview(e,t,o,s){console.log("=== createNewRevolvePreview ==="),this.removeRevolvePreview();const i=this.createRevolveGeometryWithCaps(e,t,o,s);if(!i)return void console.error("Не удалось создать геометрию для предпросмотра");this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:16750592,transparent:!0,opacity:.4,side:THREE.DoubleSide}));const n=new THREE.Mesh(i,this.previewMaterial);this.revolvePreviewGroup=new THREE.Group,this.revolvePreviewGroup.name="revolvePreview",this.revolvePreviewGroup.add(n),this.editor.objectsGroup.add(this.revolvePreviewGroup),console.log("Предпросмотр создан и добавлен на сцену")}removeRevolvePreview(){this.revolvePreviewGroup&&(this.editor.objectsGroup.remove(this.revolvePreviewGroup),this.revolvePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.revolvePreviewGroup=null,console.log("Предпросмотр удален"))}showRevolveUI(){console.log("=== showRevolveUI ===");const e=document.getElementById("revolveUI");e&&(console.log("Удаляем старый UI"),e.remove());const t=this.selectedFigures.size;console.log(`Выбрано фигур: ${t}`);const o=document.createElement("div");o.id="revolveUI",o.className="extrude-ui",o.innerHTML=`\n            <div class="extrude-header">\n                <h3><i class="fas fa-sync-alt"></i> Вращение фигур</h3>\n                <button id="cancelRevolve" class="btn-secondary">\n                    <i class="fas fa-times"></i> Отмена\n                </button>\n            </div>\n            <div class="extrude-controls">\n                <div class="control-group">\n                    <label>Угол вращения (°):</label>\n                    <div style="display: flex; align-items: center; gap: 8px;">\n                        <input type="range" id="revolveAngleSlider" min="1" max="360" value="360" step="1" style="flex: 1;">\n                        <input type="number" id="revolveAngle" value="360" min="1" max="360" step="1" style="width: 70px;">\n                    </div>\n                    <div id="angleHint" style="font-size: 12px; color: #666; margin-top: 4px;">\n                        При угле 360° торцы не закрываются\n                    </div>\n                </div>\n                <div class="control-group">\n                    <label>Ось вращения:</label>\n                    <div style="display: flex; align-items: center; gap: 8px;">\n                        <select id="revolveAxis" style="flex: 1;">\n                            <option value="x">Глобальная ось X</option>\n                            <option value="y" selected>Глобальная ось Y</option>\n                            <option value="z">Глобальная ось Z</option>\n                        </select>\n                        <button id="selectAxisButton" class="btn-secondary" style="padding: 8px 12px;" title="Выбрать ось на чертеже">\n                            <i class="fas fa-mouse-pointer"></i>\n                        </button>\n                    </div>\n                    <div id="axisInfo" style="font-size: 12px; color: #666; margin-top: 4px;">\n                        ${this.selectedAxisLine?"Ось: выбранная линия":`Ось: глобальная ${this.selectedAxis.toUpperCase()}`}\n                    </div>\n                </div>\n                <div class="control-group">\n                    <label>Направление:</label>\n                    <select id="revolveDirection">\n                        <option value="positive">По часовой стрелке</option>\n                        <option value="negative">Против часовой стрелки</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>Операция:</label>\n                    <select id="revolveOperation">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>\n                        Объединять соединённые фигуры\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                        ${this.clipperAvailable?"":" (недоступно)"}\n                    </label>\n                </div>\n                <div class="control-group">\n                    <label>\n                        Закрывать торцы при угле < 360°\n                        <input type="checkbox" id="addCaps" ${this.addCaps?"checked":""}>\n                    </label>\n                    <div style="font-size: 12px; color: #666; margin-top: 4px;">\n                        Торцы создаются толщиной ${this.capThickness} мм\n                    </div>\n                </div>\n                <div class="extrude-info">\n                    <div id="selectedContourInfo">\n                        ${t>0?`Выбрано фигур: ${t}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" style="font-size: 12px; color: #888; margin-top: 5px;"></div>\n                    <div id="clipperStatus" style="font-size: 12px; color: #888; margin-top: 2px;"></div>\n                    <div id="capsStatus" style="font-size: 12px; color: #888; margin-top: 2px;"></div>\n                </div>\n                <button id="performRevolve" class="btn-primary" ${t>0?"":"disabled"}>\n                    <i class="fas fa-check"></i> Выполнить вращение\n                </button>\n            </div>\n            <div class="extrude-hint">\n                <i class="fas fa-info-circle"></i>\n                <div>• Клик по фигуре: выделить/снять выделение</div>\n                <div>• Нажмите <i class="fas fa-mouse-pointer"></i> чтобы выбрать ось на чертеже</div>\n                <div>• Глобальные оси: X, Y, Z проходят через начало координат (0,0,0)</div>\n                <div>• При угле < 360° торцы автоматически закрываются (опционально)</div>\n                <div>• Escape для отмены, Enter для подтверждения</div>\n                ${this.clipperAvailable?"<div>• Используется Clipper.js для точного объединения</div>":'<div style="color: #f44336;">• Clipper.js не найден. Объединение фигур будет недоступно.</div>'}\n            </div>\n        `;(document.querySelector(".viewport-container")||document.querySelector(".main-container")||document.body).appendChild(o),console.log("UI добавлен на страницу"),this.setupRevolveUIEventListeners(),this.updateRevolveUI()}setupRevolveUIEventListeners(){console.log("Настройка обработчиков событий UI...");const e=document.getElementById("cancelRevolve");e&&e.addEventListener("click",()=>{console.log("Нажата кнопка Отмена"),this.exitRevolveMode()});const t=document.getElementById("performRevolve");t&&t.addEventListener("click",()=>{console.log("Нажата кнопка Выполнить вращение"),this.performRevolve()});const o=document.getElementById("revolveAngleSlider"),s=document.getElementById("revolveAngle"),i=document.getElementById("angleHint");o&&s&&(o.addEventListener("input",()=>{s.value=o.value,i&&(i.textContent=o.value<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются"),console.log("Изменен угол (слайдер):",o.value),this.updateRevolvePreview()}),s.addEventListener("input",()=>{o.value=s.value,i&&(i.textContent=s.value<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются"),console.log("Изменен угол (поле):",s.value),this.updateRevolvePreview()}));const n=document.getElementById("revolveAxis");n&&(n.value=this.selectedAxis,n.addEventListener("change",()=>{console.log("Изменена ось через селект:",n.value),this.isSelectingAxis||(this.selectedAxis=n.value,this.selectedAxisLine=null,this.updateAxisInfo(),this.showSelectedAxis(),this.updateRevolvePreview())}));const r=document.getElementById("revolveDirection");r&&r.addEventListener("change",()=>{console.log("Изменено направление:",r.value),this.updateRevolvePreview()});const l=document.getElementById("revolveOperation");l&&l.addEventListener("change",()=>{console.log("Изменена операция:",l.value),this.currentOperation=l.value});const a=document.getElementById("mergeFigures");a&&a.addEventListener("change",e=>{console.log("Изменен чекбокс объединения:",e.target.checked),this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(a.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","warning")),this.updateRevolvePreview(),this.updateRevolveUI()});const c=document.getElementById("addCaps");c&&(c.checked=this.addCaps,c.addEventListener("change",e=>{console.log("Изменен чекбокс закрытия торцов:",e.target.checked),this.addCaps=e.target.checked,this.updateRevolvePreview(),this.updateRevolveUI()}));const d=document.getElementById("selectAxisButton");d&&d.addEventListener("click",()=>{console.log("Нажата кнопка выбора оси"),this.startAxisSelection()})}updateRevolveUI(){const e=document.getElementById("selectedContourInfo"),t=document.getElementById("performRevolve"),o=document.getElementById("mergeFigures"),s=document.getElementById("mergeStatus"),i=document.getElementById("clipperStatus"),n=document.getElementById("capsStatus"),r=document.getElementById("revolveAngle"),l=document.getElementById("addCaps"),a=document.getElementById("angleHint");if(!e||!t)return;const c=this.selectedFigures.size,d=r?parseFloat(r.value):360;c>0?(e.textContent=`Выбрано фигур: ${c}`,e.style.color="#28a745",t.disabled=!1,t.classList.remove("disabled"),s&&c>1&&(this.mergeConnectedFigures&&this.clipperAvailable?(s.textContent="Фигуры будут объединены",s.style.color="#28a745"):this.clipperAvailable?(s.textContent="Объединение отключено",s.style.color="#dc3545"):(s.textContent="Clipper.js не найден",s.style.color="#ffc107")),n&&(d<360&&this.addCaps?(n.textContent=`Торцы будут закрыты (толщина ${this.capThickness} мм)`,n.style.color="#28a745"):d<360&&!this.addCaps?(n.textContent="Торцы не будут закрыты (опция отключена)",n.style.color="#ffc107"):(n.textContent="При угле 360° торцы не закрываются",n.style.color="#6c757d")),a&&(a.textContent=d<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются")):(e.textContent="Кликните по фигуре для выбора",e.style.color="#6c757d",t.disabled=!0,t.classList.add("disabled"),s&&(s.textContent=""),n&&(n.textContent=""),a&&(a.textContent="При угле < 360° торцы будут закрыты")),o&&(o.disabled=!this.clipperAvailable),i&&(this.clipperAvailable?(i.textContent="Clipper.js доступен",i.style.color="#28a745"):(i.textContent="Clipper.js не найден - объединение недоступно",i.style.color="#f44336")),l&&(l.checked=this.addCaps)}startAxisSelection(){this.isSelectingAxis=!0,this.editor.axesHelper?this.editor.axesHelper.visible=!0:this.createGlobalAxes(),this.editor.showStatus("Кликните на ось координат или линию для выбора оси вращения","info"),this.updateAxisInfo()}createGlobalAxes(){this.editor.axesHelper||(this.editor.axesHelper=new THREE.AxesHelper(100),this.editor.axesHelper.name="globalAxes",this.editor.scene.add(this.editor.axesHelper)),this.editor.axesHelper.visible=!0}handleAxisSelection(e){if(console.log("=== handleAxisSelection ==="),this.editor.axesHelper){const t=this.editor.renderer.domElement.getBoundingClientRect(),o=new THREE.Vector2((e.clientX-t.left)/t.width*2-1,-(e.clientY-t.top)/t.height*2+1);this.editor.raycaster.setFromCamera(o,this.editor.camera);const s=this.editor.raycaster.intersectObject(this.editor.axesHelper,!0);if(s.length>0){const e=s[0],t=this.getAxisFromIntersection(e);if(t)return this.selectedAxis=t,this.selectedAxisLine=null,this.isSelectingAxis=!1,this.updateAxisInfo(),this.updateRevolvePreview(),this.showSelectedAxis(),this.editor.showStatus(`Выбрана глобальная ось: ${t.toUpperCase()}`,"success"),!0}}const t=this.editor.objectsManager.getAllSketchElements().filter(e=>"line"===e.userData?.elementType&&e.visible);if(t.length>0){const o=this.findLineAtPoint(e,t);if(o){this.selectedAxisLine=o,this.isSelectingAxis=!1;const e=this.getClosestAxisToLine(o);return this.selectedAxis=e,this.updateAxisInfo(),this.updateRevolvePreview(),this.showSelectedAxis(),this.editor.showStatus("Выбрана линия как ось вращения","success"),!0}}return!1}getAxisFromIntersection(e){if(e.object&&e.object.parent===this.editor.axesHelper){if("x-axis"===e.object.name||"x"===e.object.userData?.axis)return"x";if("y-axis"===e.object.name||"y"===e.object.userData?.axis)return"y";if("z-axis"===e.object.name||"z"===e.object.userData?.axis)return"z"}return null}findLineAtPoint(e,t){const o=this.editor.renderer.domElement.getBoundingClientRect(),s=new THREE.Vector2((e.clientX-o.left)/o.width*2-1,-(e.clientY-o.top)/o.height*2+1);this.editor.raycaster.setFromCamera(s,this.editor.camera);const i=this.editor.raycaster.intersectObjects(t,!0);return i.length>0?i[0].object:null}showSelectedAxis(){if(this.removeAxisVisualization(),this.selectedAxisLine){const e=new THREE.BufferGeometry,t=this.selectedAxisLine.geometry.attributes.position.array,o=new Float32Array(t);e.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),this.axisHelper=new THREE.Line(e,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.axisHelper.position.copy(this.selectedAxisLine.position),this.axisHelper.rotation.copy(this.selectedAxisLine.rotation),this.axisHelper.scale.copy(this.selectedAxisLine.scale),this.editor.scene.add(this.axisHelper)}else{const e=200;let t,o;switch(this.selectedAxis){case"x":t=new THREE.Vector3(-e/2,0,0),o=new THREE.Vector3(e/2,0,0);break;case"y":t=new THREE.Vector3(0,-e/2,0),o=new THREE.Vector3(0,e/2,0);break;case"z":t=new THREE.Vector3(0,0,-e/2),o=new THREE.Vector3(0,0,e/2)}const s=(new THREE.BufferGeometry).setFromPoints([t,o]);this.axisHelper=new THREE.Line(s,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.editor.scene.add(this.axisHelper)}}removeAxisVisualization(){this.axisHelper&&(this.editor.scene.remove(this.axisHelper),this.axisHelper.geometry&&this.axisHelper.geometry.dispose(),this.axisHelper.material&&this.axisHelper.material.dispose(),this.axisHelper=null)}updateAxisInfo(){const e=document.getElementById("axisInfo");e&&(this.selectedAxisLine?(e.textContent="Ось: выбранная линия",e.style.color="#FF0000"):(e.textContent=`Ось: глобальная ${this.selectedAxis.toUpperCase()}`,e.style.color="#666"));const t=document.getElementById("revolveAxis");t&&!this.isSelectingAxis&&(t.value=this.selectedAxis)}getClosestAxisToLine(e){const t=e.geometry.attributes.position.array,o=new THREE.Vector3(t[0],t[1],t[2]),s=new THREE.Vector3(t[3],t[4],t[5]);e.localToWorld(o),e.localToWorld(s);const i=(new THREE.Vector3).subVectors(s,o).normalize(),n=Math.abs(i.dot(new THREE.Vector3(1,0,0))),r=Math.abs(i.dot(new THREE.Vector3(0,1,0))),l=Math.abs(i.dot(new THREE.Vector3(0,0,1))),a=Math.max(n,r,l);return a===n?"x":a===r?"y":"z"}performRevolve(){console.log("=== performRevolve (с крышками) ===");const e=this.getFiguresForOperation();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вращения","error");const t=parseFloat(document.getElementById("revolveAngle")?.value)||360,o=document.getElementById("revolveAxis")?.value||"y",s=document.getElementById("revolveDirection")?.value||"positive",i=document.getElementById("revolveOperation")?.value||"new";if(isNaN(t)||t<=0)return void this.editor.showStatus("Введите корректный угол вращения","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");console.log(`Создание вращения: угол=${t}°, ось=${o}, операция=${i}`);const n=this.createRevolveGeometryWithCaps(e,t,o,s);if(!n)return void this.editor.showStatus("Не удалось создать геометрию вращения","error");const r=this.createRevolveMesh(n,t,o,s,e);if(!r)return void this.editor.showStatus("Не удалось создать объект вращения","error");const l={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),angle:t,axis:o,direction:s,operation:i,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,usedLineAxis:!!this.selectedAxisLine,hasCaps:t<360&&this.addCaps,capThickness:this.capThickness};switch(i){case"new":default:this.handleNewOperation(r,l);break;case"cut":this.handleCutOperation(r,l);break;case"join":this.handleJoinOperation(r,l)}this.exitRevolveMode();const a=e.filter(e=>e.isMerged).length,c=e.length;let d=`Выполнено вращение (${t}°)`;d+=a>0&&c>a?`: ${a} объединенных + ${c-a} отдельных фигур`:a>0?` с объединением ${a} фигур`:` ${c} фигур`,t<360&&this.addCaps&&(d+=" (торцы закрыты)"),this.editor.showStatus(d,"success")}createRevolveMesh(e,t,o,s,i){if(!e)return null;const n=new THREE.MeshStandardMaterial({color:16750592,metalness:.3,roughness:.6,side:THREE.DoubleSide}),r=new THREE.Mesh(e,n);r.castShadow=!0,r.receiveShadow=!0;const l=i.some(e=>e.isMerged),a=i.filter(e=>e.isMerged),c=a.length,d=t<360&&this.addCaps,h=i.length,u=h>1;let p=`Вращение (${t}°)`;return l&&(p+=` [${c} объединенных]`),u&&(p+=` [${h} фигур]`),d&&(p+=" [с крышками]"),r.userData={type:"revolve",sourceFigureIds:i.flatMap(e=>e.sourceFigures||[e.id]),angle:t,axis:o,direction:s,operation:this.currentOperation,name:p,figureCount:h,holeCount:i.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:l,mergedFrom:l?a.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,closedEnds:d,hasCaps:d,capThickness:this.capThickness,usedLineAxis:!!this.selectedAxisLine,axisLineId:this.selectedAxisLine?this.selectedAxisLine.uuid:null,isMultipleFigures:u},r}handleNewOperation(e,t){console.log("Создание нового объекта вращения"),this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectSingleObject(e);const o=this.editor.projectManager.serializeObjectForHistory(e);this.editor.history.addAction({type:"create",subtype:"revolve",object:e.uuid,data:{...t,objectData:o}})}handleCutOperation(e,t){console.log("=== handleCutOperation (Revolve) ===");const o=this.findIntersectingObjects(e);if(0===o.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const s=o.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let i=!1,n=null;o.forEach(o=>{try{console.log(`Выполняем вычитание для объекта ${o.uuid}`);const r=this.editor.booleanOps.subtract(o,e);r&&r.geometry&&r.geometry.attributes.position.count>0&&(n=r,this.replaceObjectsWithResult([o],n,"cut",{sourceRevolve:t,targetObjectData:s}),i=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),i||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){console.log("=== handleJoinOperation (Revolve) ===");const o=this.findIntersectingObjects(e);if(0===o.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const s=o.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),i=this.editor.projectManager.serializeObjectForHistory(e);try{const n=[...o,e],r=this.editor.booleanOps.unionMultiple(n);if(!(r&&r.geometry&&r.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(n,r,"join",{sourceObjectsData:s,revolveData:i,sourceRevolve:t})}catch(o){console.error("Ошибка соединения:",o),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],o=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(s=>{if(s===e||"sketch_plane"===s.userData.type||"work_plane"===s.userData.type||"sketch_element"===s.userData.type||"axis_helper"===s.userData.type)return;const i=(new THREE.Box3).setFromObject(s);o.intersectsBox(i)&&t.push(s)}),console.log(`Найдено ${t.length} пересекающихся объектов`),t}replaceObjectsWithResult(e,t,o,s){console.log(`Замена ${e.length} объектов результатом операции ${o}`);const i=this.editor.projectManager.serializeObjectForHistory(t),n={type:"boolean",operation:o,result:t.uuid,sourceObjects:e.map(e=>e.uuid),resultData:i,context:s?.sourceRevolve};console.log("Добавление в историю:",n),this.editor.history.addAction(n),e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectSingleObject(t)}exitRevolveMode(){this.editor.toolManager.setCurrentTool("select")}cancelRevolveMode(){console.log("=== cancelRevolveMode ==="),this.clearSelection(),this.removeRevolvePreview(),this.removeAxisVisualization();const e=document.getElementById("revolveUI");e&&e.remove();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.isSelectingAxis=!1,this.editor.showStatus("Режим вращения завершен","info"),document.body.style.cursor="default"}highlightRevolvableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,16750592):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,16750592)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вращения","warning")}}