class RevolveManager extends OperationManager{constructor(e){super(e),this.revolvePreviewGroup=null,this.previewMaterial=null,this.currentOperation="new",this.selectedAxis="y",this.selectedAxisLine=null,this.isSelectingAxis=!1,this.axisHelper=null,this.axisStartPoint=null,this.axisDirection=new THREE.Vector3(0,1,0),this.axisPoint=new THREE.Vector3(0,0,0),this.addCaps=!0,this.capThickness=.1,this.propertiesElement=null,console.log("RevolveManager: создан (доработанная версия с закрытием торцов, наследник OperationManager)")}createOperationFigure(e){const t=this.getAllImmediateHoles(e),o=this.getFigurePlane(e);return{id:e.id,outer:e.outer,holes:t,area:e.area,isHole:e.isHole,parentId:e.parentId,childrenIds:e.childrenIds,depth:e.depth,plane:o,planeId:o?o.uuid:null,element:e.element}}handleFigureClick(e){if(this.isSelectingAxis)return this.handleAxisSelection(e);const t=super.handleFigureClick(e);return t&&(this.updateRevolvePreview(),this.updateRevolveUI()),t}createRevolveGeometryWithCaps(e,t,o,s){console.log("=== createRevolveGeometryWithCaps (обновленный) ==="),console.log(`Параметры: угол=${t}°, ось=${o}, направление=${s}, addCaps=${this.addCaps}`);const r=this.createRevolveGeometryFromFigures(e,t,o,s);if(!r)return console.error("Не удалось создать основную геометрию вращения"),null;if(t>=360||!this.addCaps)return console.log("Угол 360° или закрытие торцов отключено - не создаем крышки"),r;console.log(`Создаем крышки для ${e.length} фигур...`);try{const i=this.createCapsGeometryImproved(e,t,o,s);if(!i||0===i.length)return console.log("Не удалось создать крышки, возвращаем основную геометрию"),r;const n=this.mergeGeometries([r,...i]);return n?(console.log("Геометрия с крышками успешно создана"),n):(console.error("Не удалось объединить геометрии"),r)}catch(e){return console.error("Ошибка при создании крышек:",e),r}}createCapsGeometryImproved(e,t,o,s){console.log("=== createCapsGeometryImproved (исправленный) ===");const r=[];return e.forEach((i,n)=>{console.log(`Создание крышек для фигуры ${n+1}/${e.length}`);const l=this.createShapeFromFigure(i);if(!l)return void console.log(`  Не удалось создать форму для фигуры ${i.id}`);const a=[l];if(this.selectedAxisLine){const e=this.calculateStartAngleForLineAxis(),o=this.createLineAxisCapImproved(a,e);o&&r.push(o);const i="positive"===s?e+t:e-t,n=this.createLineAxisCapImproved(a,i);n&&r.push(n)}else{const e=this.calculateStartAngleForGlobalAxis(o),i=this.createGlobalAxisCapImproved(a,o,s,e);i&&r.push(i);const n="positive"===s?e+t:e-t,l=this.createGlobalAxisCapImproved(a,o,s,n);l&&r.push(l)}}),console.log(`Создано ${r.length} крышек для ${e.length} фигур`),r}calculateStartAngleForGlobalAxis(e){if(!this.basePlane)return 0;const t=new THREE.Vector3(0,0,1);t.applyQuaternion(this.basePlane.quaternion);let o=new THREE.Vector3;switch(e){case"x":o.set(1,0,0);break;case"y":o.set(0,1,0);break;case"z":o.set(0,0,1)}const s=t.clone().projectOnPlane(o);let r=new THREE.Vector3;s.length()<.001?"x"===e?r.set(0,1,0):r.set(1,0,0):r=s.normalize();let i=new THREE.Vector3;switch(e){case"x":i.set(0,0,1);break;case"y":i.set(1,0,0);break;case"z":i.set(0,1,0)}const n=i.dot(r),l=(new THREE.Vector3).crossVectors(i,r),a=Math.atan2(l.dot(o),n);let c=THREE.MathUtils.radToDeg(a);return Math.abs(t.z)>.9?"x"!==e&&"z"!==e||(c+=90):Math.abs(t.y)>.9?"z"===e&&(c+=180):Math.abs(t.x)>.9&&"x"===e&&(c+=90),c=(c%360+360)%360,console.log(`Начальный угол для оси ${e}: ${c}°`),c}calculateStartAngleForLineAxis(){if(!this.selectedAxisLine||!this.basePlane)return 0;const e=new THREE.Vector3(0,0,1);e.applyQuaternion(this.basePlane.quaternion);const t=this.selectedAxisLine.geometry.attributes.position.array,o=new THREE.Vector3(t[0],t[1],t[2]),s=new THREE.Vector3(t[3],t[4],t[5]),r=new THREE.Vector3,i=new THREE.Vector3;this.selectedAxisLine.localToWorld(r.copy(o)),this.selectedAxisLine.localToWorld(i.copy(s));const n=(new THREE.Vector3).subVectors(i,r).normalize(),l=e.clone().projectOnPlane(n);let a=new THREE.Vector3;l.length()<.001?(a=Math.abs(n.dot(new THREE.Vector3(1,0,0)))<.9?new THREE.Vector3(1,0,0):new THREE.Vector3(0,1,0),a=a.projectOnPlane(n).normalize()):a=l.normalize();let c=new THREE.Vector3;c=Math.abs(n.dot(new THREE.Vector3(1,0,0)))<.9?new THREE.Vector3(1,0,0):new THREE.Vector3(0,1,0),c=c.projectOnPlane(n).normalize();const h=c.dot(a),p=(new THREE.Vector3).crossVectors(c,a),d=Math.atan2(p.dot(n),h);let u=THREE.MathUtils.radToDeg(d);return u<0&&(u+=360),console.log(`Начальный угол для линии: ${u}°`),u}createGlobalAxisCapImproved(e,t,o,s){if(console.log(`Создание крышки для глобальной оси ${t}, угол: ${s}°`),0===e.length)return null;try{let r=e[0];for(let t=1;t<e.length;t++){(e[t].holes||[]).forEach(e=>{r.holes.push(e)})}const i={depth:this.capThickness,bevelEnabled:!1,steps:1},n=new THREE.ExtrudeGeometry(r,i),l=new THREE.Vector2(0,0),a=new THREE.Vector3(l.x,l.y,0),c=this.basePlane.localToWorld(a.clone());let h=new THREE.Vector3;switch(t){case"x":h.set(1,0,0);break;case"y":h.set(0,1,0);break;case"z":h.set(0,0,1)}const p="positive"===o?1:-1,d=THREE.MathUtils.degToRad(s),u=new THREE.Quaternion;u.setFromAxisAngle(h,d*p);const v=new THREE.Vector3(0,0,1);v.applyQuaternion(this.basePlane.quaternion);const g=v.clone().applyQuaternion(u),E=new THREE.Vector3(0,0,0),m=c.clone().sub(E).clone().applyQuaternion(u),y=E.clone().add(m),x=g.clone().multiplyScalar(this.capThickness/2),w=y.clone().add(x),R=this.basePlane.quaternion.clone(),b=new THREE.Quaternion;b.multiplyQuaternions(u,R);const T=new THREE.Matrix4;return T.compose(w,b,new THREE.Vector3(1,1,1)),n.applyMatrix4(T),n}catch(e){return console.error("Ошибка создания крышки для глобальной оси:",e),null}}createLineAxisCapImproved(e,t){if(console.log(`Создание крышки для линии, угол: ${t}°`),!this.selectedAxisLine||0===e.length)return null;try{let o=e[0];for(let t=1;t<e.length;t++){(e[t].holes||[]).forEach(e=>{o.holes.push(e)})}const s={depth:this.capThickness,bevelEnabled:!1,steps:1},r=new THREE.ExtrudeGeometry(o,s),i=this.selectedAxisLine.geometry.attributes.position.array,n=new THREE.Vector3(i[0],i[1],i[2]),l=new THREE.Vector3(i[3],i[4],i[5]),a=new THREE.Vector3,c=new THREE.Vector3;this.selectedAxisLine.localToWorld(a.copy(n)),this.selectedAxisLine.localToWorld(c.copy(l));const h=(new THREE.Vector3).subVectors(c,a).normalize(),p=new THREE.Vector2(0,0),d=new THREE.Vector3(p.x,p.y,0),u=this.basePlane.localToWorld(d.clone()),v=u.clone().sub(a).dot(h),g=a.clone().add(h.clone().multiplyScalar(v)),E=u.clone().sub(g),m=THREE.MathUtils.degToRad(t),y=new THREE.Quaternion;y.setFromAxisAngle(h,m);const x=E.clone().applyQuaternion(y),w=g.clone().add(x),R=new THREE.Vector3(0,0,1);R.applyQuaternion(this.basePlane.quaternion);const b=R.clone().applyQuaternion(y).clone().multiplyScalar(this.capThickness/2),T=w.clone().add(b),H=this.basePlane.quaternion.clone(),f=new THREE.Quaternion;f.multiplyQuaternions(y,H);const A=new THREE.Matrix4;return A.compose(T,f,new THREE.Vector3(1,1,1)),r.applyMatrix4(A),r}catch(e){return console.error("Ошибка создания крышки для линии:",e),null}}createShapesFromFigures(e){const t=[];return e.forEach(e=>{try{const o=this.getFigurePointsForBasePlane(e);if(o.length<3)return void console.log(`  Недостаточно точек: ${o.length}`);const s=new THREE.Shape;if(o.length>0){s.moveTo(o[0].x,o[0].y);for(let e=1;e<o.length;e++)s.lineTo(o[e].x,o[e].y);s.closePath()}e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{try{const t=this.getContourPointsForBasePlane(e);if(t.length>=3){const e=new THREE.Path;e.moveTo(t[0].x,t[0].y);for(let o=1;o<t.length;o++)e.lineTo(t[o].x,t[o].y);s.holes.push(e)}}catch(e){console.error(`  Ошибка создания отверстия ${t}:`,e)}}),t.push(s),console.log("  Форма успешно создана")}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),t}mergeGeometries(e){if(0===e.length)return null;if(1===e.length)return e[0];try{const t=new THREE.BufferGeometry,o=[],s=[];let r=0;return e.forEach((e,t)=>{if(!e||!e.attributes.position)return void console.warn(`Геометрия ${t} не имеет атрибутов позиции`);const i=e.attributes.position.array;for(let e=0;e<i.length;e+=3)o.push(i[e],i[e+1],i[e+2]);if(e.index){const t=e.index.array;for(let e=0;e<t.length;e++)s.push(t[e]+r)}else{const e=i.length/3;for(let t=0;t<e;t++)s.push(t+r)}r+=i.length/3}),t.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),t.setIndex(s),t.computeVertexNormals(),console.log(`Объединено ${e.length} геометрий, вершин: ${o.length/3}`),t}catch(t){return console.error("Ошибка объединения геометрий:",t),e[0]}}createRevolveGeometryFromFigures(e,t,o,s){if(console.log("=== createRevolveGeometryFromFigures (исправленный) ==="),console.log(`Параметры: угол=${t}°, ось=${o}, направление=${s}`),console.log(`Фигур для вращения: ${e.length}`),0===e.length||!this.basePlane)return console.error("Нет фигур или базовой плоскости!"),null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;if(1===e.length)return console.log("Одна фигура - стандартная обработка"),this.createRevolveGeometryForSingleFigure(e[0],t,o,s);console.log(`Создаем вращение для ${e.length} фигур`);const r=[];return e.forEach((i,n)=>{try{console.log(`Создание геометрии для фигуры ${n+1}/${e.length}: ${i.id}`);const l=this.createRevolveGeometryForSingleFigure(i,t,o,s);l?(r.push(l),console.log("  Геометрия создана успешно")):console.log(`  Не удалось создать геометрию для фигуры ${i.id}`)}catch(e){console.error(`  Ошибка создания геометрии для фигуры ${i.id}:`,e)}}),0===r.length?(console.error("Не удалось создать ни одну геометрию!"),null):(console.log(`Создано ${r.length} геометрий`),1===r.length?r[0]:(console.log("Объединяем геометрии..."),this.mergeGeometries(r)))}createRevolveGeometryForSingleFigure(e,t,o,s){console.log(`Создание геометрии для фигуры: ${e.id}`);const r=this.createShapeFromFigure(e);return r?this.selectedAxisLine?this.createRevolveAroundLine(r,t,s):this.createRevolveAroundGlobalAxis(r,o,t,s):(console.error(`Не удалось создать форму для фигуры ${e.id}`),null)}createShapeFromFigure(e){try{const t=this.getFigurePointsForBasePlane(e);if(t.length<3)return console.log(`  Недостаточно точек: ${t.length}`),null;const o=new THREE.Shape;if(t.length>0){o.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)o.lineTo(t[e].x,t[e].y);o.closePath()}return e.holes&&e.holes.length>0&&e.holes.forEach((e,t)=>{try{const t=this.getContourPointsForBasePlane(e);if(t.length>=3){const e=new THREE.Path;e.moveTo(t[0].x,t[0].y);for(let o=1;o<t.length;o++)e.lineTo(t[o].x,t[o].y);o.holes.push(e)}}catch(e){console.error(`  Ошибка создания отверстия ${t}:`,e)}}),console.log("  Форма успешно создана"),o}catch(t){return console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t),null}}createRevolveAroundGlobalAxis(e,t,o,s){console.log(`Создание вращения вокруг глобальной оси ${t}`);const r=e.getPoints();if(!r||r.length<3)return null;const i=r.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)}),n=new THREE.Vector3;i.forEach(e=>n.add(e)),n.divideScalar(i.length);let l,a=new THREE.Vector3(0,0,0);switch(t){case"x":l=new THREE.Vector3(1,0,0);break;case"y":default:l=new THREE.Vector3(0,1,0);break;case"z":l=new THREE.Vector3(0,0,1)}const c=i.map(e=>{const t=(new THREE.Vector3).subVectors(e,a),o=t.dot(l),s=l.clone().multiplyScalar(o),r=(new THREE.Vector3).subVectors(t,s).length(),i=o;return new THREE.Vector2(r,i)}),h="negative"===s?-THREE.MathUtils.degToRad(o):THREE.MathUtils.degToRad(o),p=new THREE.LatheGeometry(c,Math.max(16,Math.round(o/5)),0,h),d=new THREE.Matrix4,u=new THREE.Vector3(0,1,0),v=new THREE.Quaternion;return v.setFromUnitVectors(u,l),d.makeRotationFromQuaternion(v),d.setPosition(a),p.applyMatrix4(d),p}createRevolveAroundLine(e,t,o){if(console.log("Создание вращения вокруг выбранной линии"),!this.selectedAxisLine)return console.error("Нет выбранной линии!"),null;const s=e.getPoints();if(!s||s.length<3)return null;const r=this.selectedAxisLine.geometry.attributes.position.array,i=new THREE.Vector3(r[0],r[1],r[2]),n=new THREE.Vector3(r[3],r[4],r[5]),l=new THREE.Vector3,a=new THREE.Vector3;this.selectedAxisLine.localToWorld(l.copy(i)),this.selectedAxisLine.localToWorld(a.copy(n));const c=(new THREE.Vector3).subVectors(a,l).normalize(),h=s.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)}).map(e=>{const t=(new THREE.Vector3).subVectors(e,l),o=t.dot(c),s=c.clone().multiplyScalar(o),r=(new THREE.Vector3).subVectors(t,s).length(),i=o;return new THREE.Vector2(r,i)}),p="negative"===o?-THREE.MathUtils.degToRad(t):THREE.MathUtils.degToRad(t),d=new THREE.LatheGeometry(h,Math.max(16,Math.round(t/5)),0,p),u=new THREE.Matrix4,v=new THREE.Vector3(0,1,0),g=new THREE.Quaternion;return g.setFromUnitVectors(v,c),u.makeRotationFromQuaternion(g),u.setPosition(l),d.applyMatrix4(u),d}updateRevolvePreview(){console.log("=== updateRevolvePreview ===");const e=this.getFiguresForOperation();if(0===e.length)return console.log("Нет фигур для предпросмотра"),void this.removeRevolvePreview();const t=parseFloat(this.propertiesElement?.querySelector("#revolveAngle")?.value)||360,o=this.propertiesElement?.querySelector("#revolveAxis")?.value||"y",s=this.propertiesElement?.querySelector("#revolveDirection")?.value||"positive";if(console.log(`Параметры предпросмотра: угол=${t}°, ось=${o}, направление=${s}`),this.revolvePreviewGroup&&this.revolvePreviewGroup.children.length>0){console.log("Обновление существующего предпросмотра");const r=this.revolvePreviewGroup.children[0],i=this.createRevolveGeometryWithCaps(e,t,o,s);i?(r.geometry.dispose(),r.geometry=i):console.error("Не удалось создать новую геометрию для предпросмотра")}else console.log("Создание нового предпросмотра"),this.createNewRevolvePreview(e,t,o,s)}createNewRevolvePreview(e,t,o,s){console.log("=== createNewRevolvePreview ==="),this.removeRevolvePreview();const r=this.createRevolveGeometryWithCaps(e,t,o,s);if(!r)return void console.error("Не удалось создать геометрию для предпросмотра");this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:16750592,transparent:!0,opacity:.4,side:THREE.DoubleSide}));const i=new THREE.Mesh(r,this.previewMaterial);this.revolvePreviewGroup=new THREE.Group,this.revolvePreviewGroup.name="revolvePreview",this.revolvePreviewGroup.add(i),this.editor.objectsGroup.add(this.revolvePreviewGroup),console.log("Предпросмотр создан и добавлен на сцену")}removeRevolvePreview(){this.revolvePreviewGroup&&(this.editor.objectsGroup.remove(this.revolvePreviewGroup),this.revolvePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.revolvePreviewGroup=null,console.log("Предпросмотр удален"))}createPropertiesUI(){const e=this.selectedFigures.size;return`\n            <div class="property-group" data-tool="revolve">\n                <h4>ВРАЩЕНИЕ</h4>\n\n                <div class="property-row">\n                    <label>Угол(°):</label>\n                    <div class="property-input-group">\n                        <input type="range" id="revolveAngleSlider" min="1" max="360" value="360" style = "width: 70%;" step="1">\n                        <input type="number" id="revolveAngle" class="property-input" value="360" min="1" max="360" step="1">\n                    </div>\n\n                </div>\n                <div id="angleHint" class="property-hint">\n                    При угле 360° торцы не закрываются\n                </div>\n\n                <div class="property-row">\n                    <label>Ось вращения:</label>\n                    <div class="property-input-group">\n                        <select id="revolveAxis" class="property-select">\n                            <option value="x">Глобальная ось X</option>\n                            <option value="y" selected>Глобальная ось Y</option>\n                            <option value="z">Глобальная ось Z</option>\n                        </select>\n                        <button id="selectAxisButton" class="btn-secondary" title="Выбрать ось на чертеже">\n                            <i class="fas fa-mouse-pointer"></i>\n                        </button>\n                    </div>\n                </div>\n                <div id="axisInfo" class="property-hint">\n                        ${this.selectedAxisLine?"Ось: выбранная линия":`Ось: глобальная ${this.selectedAxis.toUpperCase()}`}\n                </div>\n\n                <div class="property-row">\n                    <label>Направление:</label>\n                    <select id="revolveDirection" class="property-select">\n                        <option value="positive">По часовой стрелке</option>\n                        <option value="negative">Против часовой стрелки</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label>Операция:</label>\n                    <select id="revolveOperation" class="property-select">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label class="property-checkbox">\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                        Объединять фигуры\n                        ${this.clipperAvailable?"":" (недоступно)"}\n                    </label>\n                </div>\n\n                <div class="property-row">\n                    <label class="property-checkbox">\n                        <input type="checkbox" id="addCaps" ${this.addCaps?"checked":""}>\n                        Закрывать торцы при угле < 360°\n                    </label>\n\n                </div>\n                <div class="property-hint">\n                        Торцы создаются толщиной ${this.capThickness} мм\n                    </div>\n\n                <div class="property-buttons">\n                    <button id="performOperation" class="btn-primary" >\n                        <i class="fas fa-check"></i> Выполнить\n                    </button>\n                    <button id="cancelRevolve" class="btn-secondary">\n                        <i class="fas fa-times"></i> Отмена\n                    </button>\n                </div>\n\n\n                <div class="property-hint">\n                    <div id="selectedContourInfo">\n                        ${e>0?`Выбрано фигур: ${e}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" class="property-status"></div>\n                    <div id="clipperStatus" class="property-status"></div>\n                    <div id="capsStatus" class="property-status"></div>\n                </div>\n\n                <div class="property-row">\n                    <div class="property-hint">\n                        <i class="fas fa-info-circle"></i> Описание:\n                        <div>• Клик по фигуре: выделить/снять выделение</div>\n                        <div>• Нажмите <i class="fas fa-mouse-pointer"></i> чтобы выбрать ось на чертеже</div>\n                        <div>• При угле < 360° торцы автоматически закрываются (опционально)</div>\n                        <div>• Escape для отмены, Enter для подтверждения</div>\n                    </div>\n                </div>\n            </div>\n        `}showRevolveUI(){this.removeRevolveUI();const e=document.getElementById("propertiesContent");e&&(this.propertiesElement=document.createElement("div"),this.propertiesElement.innerHTML=this.createPropertiesUI(),e.appendChild(this.propertiesElement),this.setupPropertiesEventListeners(),this.updateRevolveUI())}setupPropertiesEventListeners(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#cancelRevolve");e&&e.addEventListener("click",()=>{this.exitRevolveMode()});const t=this.propertiesElement.querySelector("#performOperation");t&&t.addEventListener("click",()=>{this.performRevolve()});const o=this.propertiesElement.querySelector("#revolveAngleSlider"),s=this.propertiesElement.querySelector("#revolveAngle"),r=this.propertiesElement.querySelector("#angleHint");o&&s&&(o.addEventListener("input",()=>{s.value=o.value,r&&(r.textContent=o.value<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются"),console.log("Изменен угол (слайдер):",o.value),this.updateRevolvePreview()}),s.addEventListener("input",()=>{o.value=s.value,r&&(r.textContent=s.value<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются"),console.log("Изменен угол (поле):",s.value),this.updateRevolvePreview()}));const i=this.propertiesElement.querySelector("#revolveAxis");i&&(i.value=this.selectedAxis,i.addEventListener("change",()=>{console.log("Изменена ось через селект:",i.value),this.isSelectingAxis||(this.selectedAxis=i.value,this.selectedAxisLine=null,this.updateAxisInfo(),this.showSelectedAxis(),this.updateRevolvePreview())}));const n=this.propertiesElement.querySelector("#revolveDirection");n&&n.addEventListener("change",()=>{console.log("Изменено направление:",n.value),this.updateRevolvePreview()});const l=this.propertiesElement.querySelector("#revolveOperation");l&&l.addEventListener("change",()=>{console.log("Изменена операция:",l.value),this.currentOperation=l.value});const a=this.propertiesElement.querySelector("#mergeFigures");a&&a.addEventListener("change",e=>{console.log("Изменен чекбокс объединения:",e.target.checked),this.mergeConnectedFigures=e.target.checked&&this.clipperAvailable,this.clipperAvailable||(a.checked=!1,this.editor.showStatus("Clipper.js не найден. Объединение недоступно.","warning")),this.updateRevolvePreview(),this.updateRevolveUI()});const c=this.propertiesElement.querySelector("#addCaps");c&&(c.checked=this.addCaps,c.addEventListener("change",e=>{console.log("Изменен чекбокс закрытия торцов:",e.target.checked),this.addCaps=e.target.checked,this.updateRevolvePreview(),this.updateRevolveUI()}));const h=this.propertiesElement.querySelector("#selectAxisButton");h&&h.addEventListener("click",()=>{console.log("Нажата кнопка выбора оси"),this.startAxisSelection()})}updateRevolveUI(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#selectedContourInfo"),t=this.propertiesElement.querySelector("#performOperation"),o=this.propertiesElement.querySelector("#mergeFigures"),s=this.propertiesElement.querySelector("#mergeStatus"),r=this.propertiesElement.querySelector("#clipperStatus"),i=this.propertiesElement.querySelector("#capsStatus"),n=this.propertiesElement.querySelector("#revolveAngle"),l=this.propertiesElement.querySelector("#addCaps"),a=this.propertiesElement.querySelector("#angleHint");if(!e||!t)return;const c=this.selectedFigures.size,h=n?parseFloat(n.value):360;c>0?(e.textContent=`Выбрано фигур: ${c}`,e.style.color="#28a745",s&&c>1&&(this.mergeConnectedFigures&&this.clipperAvailable?(s.textContent="Фигуры будут объединены",s.style.color="#28a745"):this.clipperAvailable?(s.textContent="Объединение отключено",s.style.color="#dc3545"):(s.textContent="Clipper.js не найден",s.style.color="#ffc107")),i&&(h<360&&this.addCaps?(i.textContent=`Торцы будут закрыты (толщина ${this.capThickness} мм)`,i.style.color="#28a745"):h<360&&!this.addCaps?(i.textContent="Торцы не будут закрыты (опция отключена)",i.style.color="#ffc107"):(i.textContent="При угле 360° торцы не закрываются",i.style.color="#6c757d")),a&&(a.textContent=h<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются")):(e.textContent="Кликните по фигуре для выбора",e.style.color="#6c757d",s&&(s.textContent=""),i&&(i.textContent=""),a&&(a.textContent="При угле < 360° торцы будут закрыты")),o&&(o.disabled=!this.clipperAvailable),t&&(t.disabled=0===this.selectedFigures.size,console.log("selectedFigures.size",this.selectedFigures.size)),r&&(this.clipperAvailable?(r.textContent="Clipper.js доступен",r.style.color="#28a745"):(r.textContent="Clipper.js не найден - объединение недоступно",r.style.color="#f44336")),l&&(l.checked=this.addCaps)}removeRevolveUI(){this.propertiesElement&&(this.propertiesElement.remove(),this.propertiesElement=null)}startAxisSelection(){this.isSelectingAxis=!0,this.editor.axesHelper?this.editor.axesHelper.visible=!0:this.createGlobalAxes(),this.editor.showStatus("Кликните на ось координат или линию для выбора оси вращения","info"),this.updateAxisInfo()}createGlobalAxes(){this.editor.axesHelper||(this.editor.axesHelper=new THREE.AxesHelper(100),this.editor.axesHelper.name="globalAxes",this.editor.scene.add(this.editor.axesHelper)),this.editor.axesHelper.visible=!0}handleAxisSelection(e){if(console.log("=== handleAxisSelection ==="),this.editor.axesHelper){const t=this.editor.renderer.domElement.getBoundingClientRect(),o=new THREE.Vector2((e.clientX-t.left)/t.width*2-1,-(e.clientY-t.top)/t.height*2+1);this.editor.raycaster.setFromCamera(o,this.editor.camera);const s=this.editor.raycaster.intersectObject(this.editor.axesHelper,!0);if(s.length>0){const e=s[0],t=this.getAxisFromIntersection(e);if(t)return this.selectedAxis=t,this.selectedAxisLine=null,this.isSelectingAxis=!1,this.updateAxisInfo(),this.updateRevolvePreview(),this.showSelectedAxis(),this.editor.showStatus(`Выбрана глобальная ось: ${t.toUpperCase()}`,"success"),!0}}const t=this.editor.objectsManager.getAllSketchElements().filter(e=>"line"===e.userData?.elementType&&e.visible);if(t.length>0){const o=this.findLineAtPoint(e,t);if(o){this.selectedAxisLine=o,this.isSelectingAxis=!1;const e=this.getClosestAxisToLine(o);return this.selectedAxis=e,this.updateAxisInfo(),this.updateRevolvePreview(),this.showSelectedAxis(),this.editor.showStatus("Выбрана линия как ось вращения","success"),!0}}return!1}getAxisFromIntersection(e){if(e.object&&e.object.parent===this.editor.axesHelper){if("x-axis"===e.object.name||"x"===e.object.userData?.axis)return"x";if("y-axis"===e.object.name||"y"===e.object.userData?.axis)return"y";if("z-axis"===e.object.name||"z"===e.object.userData?.axis)return"z"}return null}findLineAtPoint(e,t){const o=this.editor.renderer.domElement.getBoundingClientRect(),s=new THREE.Vector2((e.clientX-o.left)/o.width*2-1,-(e.clientY-o.top)/o.height*2+1);this.editor.raycaster.setFromCamera(s,this.editor.camera);const r=this.editor.raycaster.intersectObjects(t,!0);return r.length>0?r[0].object:null}showSelectedAxis(){if(this.removeAxisVisualization(),this.selectedAxisLine){const e=new THREE.BufferGeometry,t=this.selectedAxisLine.geometry.attributes.position.array,o=new Float32Array(t);e.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),this.axisHelper=new THREE.Line(e,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.axisHelper.position.copy(this.selectedAxisLine.position),this.axisHelper.rotation.copy(this.selectedAxisLine.rotation),this.axisHelper.scale.copy(this.selectedAxisLine.scale),this.editor.scene.add(this.axisHelper)}else{const e=200;let t,o;switch(this.selectedAxis){case"x":t=new THREE.Vector3(-e/2,0,0),o=new THREE.Vector3(e/2,0,0);break;case"y":t=new THREE.Vector3(0,-e/2,0),o=new THREE.Vector3(0,e/2,0);break;case"z":t=new THREE.Vector3(0,0,-e/2),o=new THREE.Vector3(0,0,e/2)}const s=(new THREE.BufferGeometry).setFromPoints([t,o]);this.axisHelper=new THREE.Line(s,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.editor.scene.add(this.axisHelper)}}removeAxisVisualization(){this.axisHelper&&(this.editor.scene.remove(this.axisHelper),this.axisHelper.geometry&&this.axisHelper.geometry.dispose(),this.axisHelper.material&&this.axisHelper.material.dispose(),this.axisHelper=null)}updateAxisInfo(){const e=this.propertiesElement?.querySelector("#axisInfo");e&&(this.selectedAxisLine?(e.textContent="Ось: выбранная линия",e.style.color="#FF0000"):(e.textContent=`Ось: глобальная ${this.selectedAxis.toUpperCase()}`,e.style.color="#666"));const t=this.propertiesElement?.querySelector("#revolveAxis");t&&!this.isSelectingAxis&&(t.value=this.selectedAxis)}getClosestAxisToLine(e){const t=e.geometry.attributes.position.array,o=new THREE.Vector3(t[0],t[1],t[2]),s=new THREE.Vector3(t[3],t[4],t[5]);e.localToWorld(o),e.localToWorld(s);const r=(new THREE.Vector3).subVectors(s,o).normalize(),i=Math.abs(r.dot(new THREE.Vector3(1,0,0))),n=Math.abs(r.dot(new THREE.Vector3(0,1,0))),l=Math.abs(r.dot(new THREE.Vector3(0,0,1))),a=Math.max(i,n,l);return a===i?"x":a===n?"y":"z"}performRevolve(){console.log("=== performRevolve (с крышками) ===");const e=this.getFiguresForOperation();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вращения","error");const t=parseFloat(this.propertiesElement?.querySelector("#revolveAngle")?.value)||360,o=this.propertiesElement?.querySelector("#revolveAxis")?.value||"y",s=this.propertiesElement?.querySelector("#revolveDirection")?.value||"positive",r=this.propertiesElement?.querySelector("#revolveOperation")?.value||"new";if(isNaN(t)||t<=0)return void this.editor.showStatus("Введите корректный угол вращения","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");console.log(`Создание вращения: угол=${t}°, ось=${o}, операция=${r}`);const i=this.createRevolveGeometryWithCaps(e,t,o,s);if(!i)return void this.editor.showStatus("Не удалось создать геометрию вращения","error");const n=this.createRevolveMesh(i,t,o,s,e);if(!n)return void this.editor.showStatus("Не удалось создать объект вращения","error");const l={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),angle:t,axis:o,direction:s,operation:r,merged:e.some(e=>e.isMerged),clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,usedLineAxis:!!this.selectedAxisLine,hasCaps:t<360&&this.addCaps,capThickness:this.capThickness};switch(r){case"new":default:this.handleNewOperation(n,l);break;case"cut":this.handleCutOperation(n,l);break;case"join":this.handleJoinOperation(n,l)}this.exitRevolveMode();const a=e.filter(e=>e.isMerged).length,c=e.length;let h=`Выполнено вращение (${t}°)`;h+=a>0&&c>a?`: ${a} объединенных + ${c-a} отдельных фигур`:a>0?` с объединением ${a} фигур`:` ${c} фигур`,t<360&&this.addCaps&&(h+=" (торцы закрыты)"),this.editor.showStatus(h,"success")}createRevolveMesh(e,t,o,s,r){if(!e)return null;const i=new THREE.MeshStandardMaterial({color:16750592,metalness:.3,roughness:.6,side:THREE.DoubleSide}),n=new THREE.Mesh(e,i);n.castShadow=!0,n.receiveShadow=!0;const l=r.some(e=>e.isMerged),a=r.filter(e=>e.isMerged),c=a.length,h=t<360&&this.addCaps,p=r.length,d=p>1;let u=`Вращение (${t}°)`;return l&&(u+=` [${c} объединенных]`),d&&(u+=` [${p} фигур]`),h&&(u+=" [с крышками]"),n.userData={type:"revolve",sourceFigureIds:r.flatMap(e=>e.sourceFigures||[e.id]),angle:t,axis:o,direction:s,operation:this.currentOperation,name:u,figureCount:p,holeCount:r.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:l,mergedFrom:l?a.flatMap(e=>e.sourceFigures||[]):null,clipperUsed:this.clipperAvailable&&this.mergeConnectedFigures,closedEnds:h,hasCaps:h,capThickness:this.capThickness,usedLineAxis:!!this.selectedAxisLine,axisLineId:this.selectedAxisLine?this.selectedAxisLine.uuid:null,isMultipleFigures:d},n}handleNewOperation(e,t){console.log("Создание нового объекта вращения"),this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectSingleObject(e);const o=this.editor.projectManager.serializeObjectForHistory(e);this.editor.history.addAction({type:"create",subtype:"revolve",object:e.uuid,data:{...t,objectData:o}})}handleCutOperation(e,t){console.log("=== handleCutOperation (Revolve) ===");const o=this.findIntersectingObjects(e);if(0===o.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const s=o.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let r=!1,i=null;o.forEach(o=>{try{console.log(`Выполняем вычитание для объекта ${o.uuid}`);const n=this.editor.booleanOps.subtract(o,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(i=n,this.replaceObjectsWithResult([o],i,"cut",{sourceRevolve:t,targetObjectData:s}),r=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),r||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){console.log("=== handleJoinOperation (Revolve) ===");const o=this.findIntersectingObjects(e);if(0===o.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const s=o.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),r=this.editor.projectManager.serializeObjectForHistory(e);try{const i=[...o,e],n=this.editor.booleanOps.unionMultiple(i);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(i,n,"join",{sourceObjectsData:s,revolveData:r,sourceRevolve:t})}catch(o){console.error("Ошибка соединения:",o),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],o=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(s=>{if(!s.visible||!0===s.userData.hidden)return;if(s===e||"sketch_plane"===s.userData.type||"work_plane"===s.userData.type||"sketch_element"===s.userData.type||"axis_helper"===s.userData.type)return;const r=(new THREE.Box3).setFromObject(s);o.intersectsBox(r)&&t.push(s)}),console.log(`Найдено ${t.length} пересекающихся объектов`),t}replaceObjectsWithResult(e,t,o,s){console.log(`Замена ${e.length} объектов результатом операции ${o}`);const r=this.editor.projectManager.serializeObjectForHistory(t),i={type:"boolean",operation:o,result:t.uuid,sourceObjects:e.map(e=>e.uuid),resultData:r,context:s?.sourceRevolve};console.log("Добавление в историю:",i),this.editor.history.addAction(i),e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectSingleObject(t)}exitRevolveMode(){this.editor.toolManager.setCurrentTool("select")}cancelRevolveMode(){console.log("=== cancelRevolveMode ==="),this.clearSelection(),this.removeRevolvePreview(),this.removeAxisVisualization(),this.removeRevolveUI();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.isSelectingAxis=!1,this.editor.showStatus("Режим вращения завершен","info"),document.body.style.cursor="default"}highlightRevolvableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,16750592):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,16750592)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вращения","warning")}}