class FigureManager{constructor(e){this.editor=e,this.figureTree=new Map,this.rootNodes=[],this.elementToNodes=new Map,this.figureCacheTimestamp=0,this.autoContours=[],this.brokenElements=new Set,this.clipperScale=1e5,this.clipperAvailable=!1,this.useClipperForContourSeparation=!0,this.initializeHelpers(),this.initializeClipper(),console.log("FigureManager2: создан (полная совместимость с оригиналом + группировка по плоскостям)")}initializeHelpers(){THREE.Vector2.prototype.distanceTo||(THREE.Vector2.prototype.distanceTo=function(e){return Math.sqrt(Math.pow(e.x-this.x,2)+Math.pow(e.y-this.y,2))})}initializeClipper(){"undefined"!=typeof ClipperLib?(this.clipperAvailable=!0,console.log("Clipper.js доступен в FigureManager2"),ClipperLib.JS.ScaleUp=this.clipperScale,ClipperLib.JS.ScaleDown=1/this.clipperScale):(console.warn("Clipper.js не найден! Разделение контуров будет недоступно."),this.clipperAvailable=!1,this.useClipperForContourSeparation=!1)}getLineIntersection(e,t,n,o){const r=(o.y-n.y)*(t.x-e.x)-(o.x-n.x)*(t.y-e.y);if(Math.abs(r)<1e-4)return null;const i=((o.x-n.x)*(e.y-n.y)-(o.y-n.y)*(e.x-n.x))/r,s=((t.x-e.x)*(e.y-n.y)-(t.y-e.y)*(e.x-n.x))/r;return i>=0&&i<=1&&s>=0&&s<=1?new THREE.Vector2(e.x+i*(t.x-e.x),e.y+i*(t.y-e.y)):null}getIntersectionParameter(e,t,n){const o=t.x-e.x,r=t.y-e.y;return Math.abs(o)>Math.abs(r)?(n.x-e.x)/o:(n.y-e.y)/r}getDistance(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}calculatePolygonArea(e){if(e.length<3)return 0;let t=0;const n=e.length;for(let o=0;o<n;o++){const r=(o+1)%n;t+=e[o].x*e[r].y,t-=e[r].x*e[o].y}return t/2}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,n=0;for(const o of e)t+=o.x,n+=o.y;const o=e.length;return new THREE.Vector2(t/o,n/o)}calculateBoundingBox(e){if(0===e.length)return{min:new THREE.Vector2(0,0),max:new THREE.Vector2(0,0)};const t=new THREE.Vector2(1/0,1/0),n=new THREE.Vector2(-1/0,-1/0);for(const o of e)t.x=Math.min(t.x,o.x),t.y=Math.min(t.y,o.y),n.x=Math.max(n.x,o.x),n.y=Math.max(n.y,o.y);return{min:t,max:n}}isPointInsidePolygon(e,t){if(t.length<3)return!1;let n=!1;const o=e.x,r=e.y;for(let e=0,i=t.length-1;e<t.length;i=e++){const s=t[e].x,l=t[e].y,a=t[i].x,u=t[i].y;l>r!=u>r&&o<(a-s)*(r-l)/(u-l)+s&&(n=!n)}return n}isContourInside(e,t){const n=e.points||[],o=t.points||[];if(0===n.length||0===o.length)return!1;const r=this.getContourPlane(e),i=this.getContourPlane(t);if(!r||!i||r.uuid!==i.uuid)return!1;for(const e of n)if(!this.isPointInsidePolygon(e,o))return!1;return!0}getPlaneById(e){return[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e)||null}getContourPlane(e){return e.plane?e.plane:e.planeId?this.getPlaneById(e.planeId):e.element?this.getElementPlane(e.element):null}getElementPlane(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}const n=this.editor.sketchPlanes||[],o=this.editor.workPlanes||[];return n.length>0?n[0]:o.length>0?o[0]:null}arePlanesCompatible(e,t){if(!e||!t)return!1;if(e.uuid===t.uuid)return!0;const n=e.position,o=t.position,r=e.quaternion,i=t.quaternion,s=n.distanceTo(o),l=r.angleTo(i);return s<.001&&l<.001}getAllSketchElements(){const e=[],t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];return 0===t.length?this.editor.scene.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)}):t.forEach(t=>{t.traverse(t=>{t.userData&&"sketch_element"===t.userData.type&&e.push(t)})}),e}getElementPoints(e){if(!e.userData)return[];if(e.userData.localPoints&&e.userData.localPoints.length>0)return e.userData.localPoints.map(e=>e instanceof THREE.Vector3||void 0!==e.x&&void 0!==e.y?new THREE.Vector2(e.x,e.y):new THREE.Vector2(0,0));if(e.geometry&&e.geometry.attributes.position){const t=e.geometry.attributes.position.array,n=[];for(let e=0;e<t.length;e+=3)n.push(new THREE.Vector2(t[e],t[e+1]));return n}return e.userData.elementType,[]}isSketchElementClosed(e){if(!e.userData)return!1;const t=e.userData.elementType;return!!["rectangle","circle","polygon","oval","stadium","arc","polyline"].includes(t)}collectSimpleContours(e){const t=[];return e.forEach(e=>{if(!e.userData)return;const n=e.userData.elementType,o=this.getElementPoints(e);if("line"===n||"polyline"===n){if(o.length<2)return;const r=this.isSketchElementClosed(e);if(this.brokenElements.has(e))return;if(!r)return;const i=this.calculatePolygonArea(o);if(Math.abs(i)<.001)return;const s=this.calculateContourCenter(o),l=this.calculateBoundingBox(o),a=i<0,u=this.getElementPlane(e);if(!u)return;return void t.push({element:e,points:o,area:Math.abs(i),center:s,boundingBox:l,type:n,isClosed:!0,isClockwise:a,originalArea:i,planeId:u.uuid,plane:u,uuid:THREE.MathUtils.generateUUID()})}if(o.length<3)return;if(!this.isSketchElementClosed(e))return;if(this.brokenElements.has(e))return;const r=this.calculatePolygonArea(o);if(Math.abs(r)<.001)return;const i=this.calculateContourCenter(o),s=this.calculateBoundingBox(o),l=r<0,a=this.getElementPlane(e);a&&t.push({element:e,points:o,area:Math.abs(r),center:i,boundingBox:s,type:n,isClosed:!0,isClockwise:l,originalArea:r,planeId:a.uuid,plane:a,uuid:THREE.MathUtils.generateUUID()})}),t}collectLineContours(e,t){const n=new Set;t.forEach(e=>{e.element&&n.add(e.element.uuid)});const o=e.filter(e=>{const t=e.userData?.elementType;return"line"===t&&!n.has(e.uuid)});if(o.length<3)return[];const r=o.map(e=>{const t=this.getElementPoints(e);return{element:e,start:t[0],end:t[1],points:t}});return this.findClosedContoursFromLines(r)}findClosedContoursFromLines(e){if(e.length<3)return[];const t=[],n=new Set;for(let o=0;o<e.length;o++){if(n.has(o))continue;const r=this.buildContourFromLine(o,e,n);if(r&&r.points.length>=3){const e=this.calculatePolygonArea(r.points);if(Math.abs(e)>.01){const n=this.calculateContourCenter(r.points),o=this.calculateBoundingBox(r.points),i=r.elements[0],s=this.getElementPlane(i);t.push({elements:r.elements,points:r.points,area:Math.abs(e),center:n,boundingBox:o,type:"line_contour",isClosed:!0,isClockwise:e<0,planeId:s?s.uuid:null,plane:s,uuid:THREE.MathUtils.generateUUID()})}}}return t}buildContourFromLine(e,t,n){const o=t[e],r=[o.element],i=[];let s=o.start,l=o.end;i.push(s.clone()),i.push(l.clone()),n.add(e);let a=!0,u=0;for(;a&&u<100;){a=!1,u++;for(let e=0;e<t.length;e++){if(n.has(e))continue;const o=t[e],s=this.getDistance(l,o.start),u=this.getDistance(l,o.end);if(s<.5){l=o.end,i.push(l.clone()),r.push(o.element),n.add(e),a=!0;break}if(u<.5){l=o.start,i.push(l.clone()),r.push(o.element),n.add(e),a=!0;break}}if(this.getDistance(l,o.start)<.5)return{elements:r,points:i}}return null}getCuttingLines(e,t){const n=[],o=new Set;return t.forEach(e=>{e.element&&"line"===e.element.userData?.elementType&&o.add(e.element.uuid),e.elements&&e.elements.forEach(e=>{"line"===e.userData?.elementType&&o.add(e.uuid)})}),e.forEach(e=>{"line"!==e.userData?.elementType||o.has(e.uuid)||n.push(e)}),n}groupLinesByPlane(e){const t={};return e.forEach(e=>{const n=this.getElementPlane(e);if(!n)return;const o=n.uuid;t[o]||(t[o]=[]),t[o].push(e)}),t}groupContoursByPlane(e){const t={};return e.forEach(e=>{const n=e.planeId||this.getContourPlaneId(e);n&&(t[n]||(t[n]=[]),t[n].push(e))}),t}getContourPlaneId(e){if(e.planeId)return e.planeId;if(e.plane)return e.plane.uuid;if(e.element){const t=this.getElementPlane(e.element);return t?t.uuid:null}return null}cutContoursWithLines(e,t){if(console.log("=== FigureManager2: разрезание контуров линиями ==="),0===t.length||0===e.length)return e;try{const n=this.groupContoursByPlane(e),o=this.groupLinesByPlane(t);let r=[];for(const e of Object.keys(n)){const t=n[e]||[],i=o[e]||[];if(0===t.length||0===i.length){r=r.concat(t);continue}console.log(`Плоскость ${e}: ${t.length} контуров, ${i.length} линий`);const s=this.splitContoursWithLines(t,i);r=r.concat(s)}return console.log(`После разрезания: было ${e.length}, стало ${r.length} контуров`),r}catch(t){return console.error("Ошибка при разрезании контуров линиями:",t),e}}splitContoursWithLines(e,t){if(0===e.length||0===t.length)return e;let n=[...e];for(const e of t){const t=this.getElementPoints(e);if(t.length<2)continue;const o=[];for(const e of n){const n=e.points||[];if(n.length<3){o.push(e);continue}if(this.findContourLineIntersections(n,t).length>=2){const n=this.splitContourByLine(e,t);o.push(...n)}else o.push(e)}n=o}return n}findContourLineIntersections(e,t){const n=[],o=t[0],r=t[1];for(let t=0;t<e.length;t++){const i=(t+1)%e.length,s=e[t],l=e[i],a=this.getLineIntersection(s,l,o,r);a&&n.push({point:a,segmentIndex:t,t:this.getIntersectionParameter(s,l,a)})}return n}splitContourByLine(e,t){const n=e.points||[];if(n.length<4)return[e];const o=[];for(let e=0;e<n.length;e++){const r=(e+1)%n.length,i=this.getLineIntersection(n[e],n[r],t[0],t[1]);i&&o.push({point:i,segmentIndex:e,t:this.getIntersectionParameter(n[e],n[r],i)})}if(2!==o.length)return[e];o.sort((e,t)=>e.segmentIndex!==t.segmentIndex?e.segmentIndex-t.segmentIndex:e.t-t.t);const[r,i]=o,s=this.buildNewContour(n,r,i,!0),l=this.buildNewContour(n,i,r,!0),a=[];if(s.length>=4){const t=this.createCutContour(e,s);t&&a.push(t)}if(l.length>=4){const t=this.createCutContour(e,l);t&&a.push(t)}return a.length>0?a:[e]}buildNewContour(e,t,n,o){const r=[];r.push(t.point.clone());let i=t.segmentIndex;const s=e.length;let l=0;for(;l<2*s;){let a;if(l++,a=o?(i+1)%s:(i-1+s)%s,a===n.segmentIndex){e[a].equals(t.point)||r.push(e[a].clone());break}e[a].equals(t.point)||r.push(e[a].clone()),i=a}return r.push(n.point.clone()),r.length>0&&!r[0].equals(r[r.length-1])&&r.push(r[0].clone()),r}createCutContour(e,t){const n=this.calculatePolygonArea(t),o=Math.abs(n);if(o<.01)return null;const r=n<0,i=r?t:t.reverse();return{...e,points:i,area:o,center:this.calculateContourCenter(i),boundingBox:this.calculateBoundingBox(i),isClockwise:r,isCut:!0,cutFrom:e.id||e.type,originalContourId:e.id||e.uuid}}collectAllFigures(){console.log("=== FigureManager2: начинаем сбор фигур ===");const e=Date.now();if(this.figureTree.size>0&&e-this.figureCacheTimestamp<200)return console.log("FigureManager2: используем кэш, узлов:",this.figureTree.size),this.getAllFiguresFlat();const t=this.getAllSketchElements();console.log("FigureManager2: найдено элементов:",t.length);const n=this.collectSimpleContours(t);console.log("FigureManager2: простых контуров:",n.length);const o=this.collectLineContours(t,n);console.log("FigureManager2: контуров из линий:",o.length);const r=this.getAutoContours();console.log("FigureManager2: автоматических контуров:",r.length),this.updateBrokenElements(r);const i=this.filterBrokenContours(n);console.log("FigureManager2: после фильтрации контуров:",i.length);const s=[...i,...o,...r];console.log("FigureManager2: всего контуров до обработки:",s.length);const l=this.getCuttingLines(t,s);console.log("FigureManager2: линий для разрезания:",l.length);let a=s;l.length>0&&(a=this.cutContoursWithLines(s,l),console.log("FigureManager2: после разрезания линиями:",a.length,"контуров"));let u=a;this.useClipperForContourSeparation&&this.clipperAvailable&&a.length>0&&(u=this.advancedSeparateContours(a),console.log("FigureManager2: после разделения Clipper:",u.length,"контуров"));const c=u.map(e=>new FigureNode(e));return console.log("FigureManager2: создано узлов:",c.length),c.length>0?this.buildEnhancedNestingTree(c):this.rootNodes=[],this.rootNodes.length>0&&this.determineContourTypes(),this.updateDataStructures(c),this.figureCacheTimestamp=e,this.getAllFiguresFlat()}buildEnhancedNestingTree(e){e.forEach(e=>{e.parent=null,e.children=[],e.depth=0});const t=[...e].sort((e,t)=>t.area-e.area);for(let e=0;e<t.length;e++){const n=t[e];let o=null,r=1/0;for(let i=0;i<e;i++){const e=t[i];this.isContourInside(n.contour,e.contour)&&e.area<r&&(o=e,r=e.area)}o&&o.addChild(n)}this.rootNodes=t.filter(e=>null===e.parent),this.updateDepthsRecursively()}updateDepthsRecursively(){const e=(t,n)=>{t.depth=n,t.children.forEach(t=>e(t,n+1))};this.rootNodes.forEach(t=>e(t,0))}determineContourTypes(){const e=t=>{t.isHole=t.depth%2==1,t.isOuter=!t.isHole,t.children.forEach(e)};this.rootNodes.forEach(e)}updateDataStructures(e){this.figureTree.clear(),this.elementToNodes.clear(),e.forEach(e=>{this.figureTree.set(e.id,e),e.elementIds.forEach(t=>{this.elementToNodes.has(t)||this.elementToNodes.set(t,[]),this.elementToNodes.get(t).push(e)})})}advancedSeparateContours(e){if(console.log("=== FigureManager2: улучшенное разделение контуров ==="),!this.clipperAvailable||0===e.length)return e;try{const t=this.groupContoursByPlane(e);let n=[];for(const[e,o]of Object.entries(t)){if(console.log(`Обрабатываем плоскость ${e}: ${o.length} контуров`),0===o.length)continue;const t=this.getPlaneById(e);if(!t){n=n.concat(o);continue}const{holes:r,solids:i}=this.separateHolesAndSolids(o),s=this.separateSolidContours(i,t);n=n.concat(s,r)}return console.log(`Всего получено ${n.length} контуров`),n}catch(t){return console.error("Ошибка при улучшенном разделении контуров:",t),e}}separateHolesAndSolids(e){const t=[],n=[],o=[...e.map(e=>new FigureNode(e))].sort((e,t)=>t.area-e.area);for(let e=0;e<o.length;e++){const t=o[e];for(let n=0;n<e;n++){const e=o[n];if(this.isContourInside(t.contour,e.contour)){e.addChild(t);break}}}const r=o.filter(e=>null===e.parent),i=(e,o)=>{e.depth=o,e.isHole=o%2==1,e.isHole?t.push(e.contour):n.push(e.contour),e.children.forEach(e=>i(e,o+1))};return r.forEach(e=>i(e,0)),console.log(`Найдено: ${n.length} твердых тел, ${t.length} отверстий`),{holes:t,solids:n}}separateSolidContours(e,t){if(0===e.length)return[];try{return 1===e.length?[e[0]]:2===e.length?this.separateTwoSolids(e[0],e[1],t):this.separateMultipleSolids(e,t)}catch(t){return console.error("Ошибка при разделении твердых контуров:",t),e}}separateTwoSolids(e,t,n){try{const o=e.points||[],r=t.points||[];if(o.length<3||r.length<3)return[e,t];const i=[];this.clipperDifference(o,r,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid1_minus_2",n))});this.clipperDifference(r,o,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"solid2_minus_1",n))});return this.clipperIntersection(o,r,n).forEach(e=>{const t=this.calculatePolygonArea(e);Math.abs(t)>.01&&i.push(this.createSeparatedContour(e,"intersection",n))}),console.log(`Разделение двух тел: было 2, стало ${i.length}`),i.length>0?i:[e,t]}catch(n){return console.error("Ошибка при разделении двух тел:",n),[e,t]}}separateMultipleSolids(e,t){try{console.log(`Разделение ${e.length} твердых тел`);let n=[];for(let o=1;o<1<<e.length;o++){const r=[];for(let t=0;t<e.length;t++)o&1<<t&&r.push(e[t]);if(0===r.length)continue;let i=r[0].points||[];for(let e=1;e<r.length&&0!==i.length;e++)i=this.clipperIntersection(i,r[e].points||[],t)[0]||[];if(i.length<3)continue;let s=i;for(let n=0;n<e.length;n++)if(!(o&1<<n)){if(s=this.clipperDifference(s,e[n].points||[],t)[0]||[],0===s.length)break}if(s.length>=3){const e=this.calculatePolygonArea(s);Math.abs(e)>.01&&n.push({points:s,mask:o,area:Math.abs(e)})}}const o=n.map((e,n)=>this.createSeparatedContour(e.points,`area_${n}`,t));return console.log(`Разделение ${e.length} тел: было ${e.length}, стало ${o.length}`),o.length>0?o:e}catch(t){return console.error("Ошибка при разделении нескольких тел:",t),e}}clipperDifference(e,t,n){try{const n=new ClipperLib.Clipper,o=this.pointsToClipperPath(e);n.AddPath(o,ClipperLib.PolyType.ptSubject,!0);const r=this.pointsToClipperPath(t);n.AddPath(r,ClipperLib.PolyType.ptClip,!0);const i=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctDifference,i,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?i.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Difference:",e),[]}}clipperIntersection(e,t,n){try{const n=new ClipperLib.Clipper,o=this.pointsToClipperPath(e);n.AddPath(o,ClipperLib.PolyType.ptSubject,!0);const r=this.pointsToClipperPath(t);n.AddPath(r,ClipperLib.PolyType.ptClip,!0);const i=new ClipperLib.Paths;return n.Execute(ClipperLib.ClipType.ctIntersection,i,ClipperLib.PolyFillType.pftNonZero,ClipperLib.PolyFillType.pftNonZero)?i.map(e=>this.clipperPathToPoints(e)):[]}catch(e){return console.error("Ошибка Clipper Intersection:",e),[]}}createSeparatedContour(e,t,n){const o=this.calculatePolygonArea(e),r=Math.abs(o),i=o<0,s=i?e:e.reverse();return{points:s,area:r,center:this.calculateContourCenter(s),boundingBox:this.calculateBoundingBox(s),type:t,isClosed:!0,isClockwise:i,planeId:n.uuid,plane:n,isSeparated:!0}}pointsToClipperPath(e){const t=new ClipperLib.Path(e.length);for(let n=0;n<e.length;n++)t[n]=new ClipperLib.IntPoint(Math.round(e[n].x*this.clipperScale),Math.round(e[n].y*this.clipperScale));return t}clipperPathToPoints(e){const t=[];for(let n=0;n<e.length;n++)t.push(new THREE.Vector2(e[n].X/this.clipperScale,e[n].Y/this.clipperScale));return t}getAutoContours(){return this.autoContours||[]}updateWithAutoContours(e,t=null){t&&e.forEach(e=>{e.planeId=t}),this.autoContours=e.filter(e=>e&&e.points&&e.points.length>=3&&e.area>.01),this.figureCacheTimestamp=0,this.collectAllFigures()}clearAutoContours(){this.autoContours=[]}updateBrokenElements(e){this.brokenElements.clear(),e.forEach(e=>{e.elements&&e.elements.forEach(e=>{this.isSketchElementClosed(e)&&this.brokenElements.add(e)})}),console.log("Разбитых элементов:",this.brokenElements.size)}filterBrokenContours(e){return 0===this.brokenElements.size?e:e.filter(e=>{if(e.element&&this.brokenElements.has(e.element))return!1;if(e.elements&&e.elements.length>0){if(e.elements.every(e=>this.brokenElements.has(e)))return!1}return!0})}getAllFiguresFlat(){const e=[],t=n=>{const o=n.getImmediateHoles().map(e=>e.contour),r={id:n.id,outer:n.contour,holes:o,area:n.area,selected:!1,parentId:n.parent?n.parent.id:null,childrenIds:n.children.map(e=>e.id),isStandalone:null===n.parent,canBeSelected:!0,isHole:n.isHole,isOuter:n.isOuter,depth:n.depth,elementIds:new Set(n.elementIds),element:n.element,boundingBox:n.boundingBox,center:n.center,type:n.type,holeDepth:n.isHole?n.depth:null,hasDeepHoles:n.getHoleDescendants().length>0,plane:n.contour.plane,planeId:n.contour.planeId,isSeparated:n.contour.isSeparated||!1,isCut:n.contour.isCut||!1};e.push(r),n.children.forEach(e=>t(e))};return this.rootNodes.forEach(e=>t(e)),e.sort((e,t)=>e.depth-t.depth),e}getFigureById(e){for(const t of this.figureTree.values())if(t.id===e)return this.nodeToFigure(t);return this.getAllFiguresFlat().find(t=>t.id===e)||null}getNodeById(e){return this.figureTree.get(e)}nodeToFigure(e){const t=e.getImmediateHoles().map(e=>({points:e.contour.points,center:e.contour.center,area:e.contour.area,element:e.element,elements:e.contour.elements}));return{id:e.id,outer:{points:e.contour.points,center:e.contour.center,area:e.contour.area,element:e.element,elements:e.contour.elements},holes:t,area:e.area,isHole:e.isHole,isOuter:e.isOuter,depth:e.depth,parentId:e.parent?e.parent.id:null,childrenIds:e.children.map(e=>e.id),elementIds:new Set(e.elementIds),element:e.element,boundingBox:e.boundingBox,center:e.center,type:e.type,plane:e.contour.plane,planeId:e.contour.planeId,isSeparated:e.contour.isSeparated||!1,isCut:e.contour.isCut||!1}}getFiguresByElement(e){const t=e.uuid;return(this.elementToNodes.get(t)||[]).filter(e=>{if(e.element&&this.brokenElements.has(e.element))return!1;if(e.elementIds&&e.elementIds.size>0){if(Array.from(e.elementIds).every(e=>{const t=this.findElementById(e);return t&&this.brokenElements.has(t)}))return!1}return!0}).map(e=>this.nodeToFigure(e))}findElementById(e){let t=null;const n=o=>{if(o.uuid===e)return t=o,!0;if(o.children&&o.children.length>0)for(const e of o.children)if(n(e))return!0;return!1};return n(this.editor.scene),t}findNodeByContour(e){for(const t of this.figureTree.values())if(t.contour===e)return t;return null}getFigurePlane(e){if(e.plane)return e.plane;if(e.planeId){const t=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]].find(t=>t.uuid===e.planeId);if(t)return e.plane=t,t}let t=null;if(e.element?t=e.element:e.outer&&e.outer.element?t=e.outer.element:e.outer&&e.outer.elements&&e.outer.elements.length>0&&(t=e.outer.elements[0]),t){const n=this.getElementPlane(t);return n&&(e.plane=n,e.planeId=n.uuid),n}return console.warn(`Не удалось определить плоскость для фигуры ${e.id}`),null}getImmediateHolesForFigure(e){const t=this.getNodeById(e);return t?t.getImmediateHoles().map(e=>e.contour):[]}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=e[0],n=this.getFigurePlane(t);if(!n)return!1;for(let t=1;t<e.length;t++){const o=e[t],r=this.getFigurePlane(o);if(!r)return!1;if(r.uuid!==n.uuid)return!1}return!0}getAllFigures(){return this.getAllFiguresFlat()}findFigureByHoleContour(e){const t=this.findNodeByContour(e);return t?this.nodeToFigure(t):null}findNodeByHoleContour(e){return this.findNodeByContour(e)}setUseClipperForContourSeparation(e){this.useClipperForContourSeparation=e&&this.clipperAvailable,e&&!this.clipperAvailable&&console.warn("Clipper.js недоступен, разделение контуров отключено"),this.figureCacheTimestamp=0}isClipperAvailable(){return this.clipperAvailable}debugPrintTree(){if(console.log("\n=== ДЕРЕВО ФИГУР (FigureManager2) ==="),0===this.rootNodes.length)return void console.log("  Дерево пустое");const e=(t,n="  ")=>{const o=t.isHole?"○ ОТВЕРСТИЕ":"● ВНЕШНИЙ",r=t.area.toFixed(2),i=t.elementIds.size,s=t.children.length,l=t.depth,a=t.contour.isSeparated?" [РАЗДЕЛЕН]":"",u=t.contour.isCut?" [РАЗРЕЗАН]":"";console.log(`${n}${o}${a}${u} [ID: ${t.id.substring(0,8)}...]`),console.log(`${n}  Глубина: ${l}, Площадь: ${r}, Элементов: ${i}, Детей: ${s}`),t.children.forEach(t=>e(t,n+"  "))};this.rootNodes.forEach((t,n)=>{console.log(`\nКорень ${n+1}:`),e(t)})}}