import*as THREE from"three";import{ParametricOperation}from"/js/core/parametric/ParametricOperation.js";import{OperationManager}from"./OperationManager.js";export class RevolveManager extends OperationManager{constructor(e){super(e),this.revolvePreviewGroup=null,this.previewMaterial=null,this.currentOperation="new",this.selectedAxis="y",this.selectedAxisLine=null,this.isSelectingAxis=!1,this.axisHelper=null,this.addCaps=!0,this.capThickness=.1,this.propertiesElement=null,this._currentAngle=360,this._currentAxis="y",this._currentDirection="positive",console.log("RevolveManager создан (версия с регионами и предпросмотром отверстий)")}createOperationFigure(e){return this.regionToOperationFigure(e)}getFiguresForOperation(){return this.getRegionsForOperation()}getPreviewColor(){switch(this.currentOperation){case"cut":return 16711680;case"join":return 255;default:return 16750592}}_toNonIndexed(e){return e?e.index?e.toNonIndexed():e.clone():null}getAxisVector(e){switch(e){case"x":return new THREE.Vector3(1,0,0);case"y":default:return new THREE.Vector3(0,1,0);case"z":return new THREE.Vector3(0,0,1)}}_contourToWorldPoints(e){return e.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)})}_createRevolveAroundGlobalAxis(e,t){if(!e||0===e.length)return null;const i=this.getAxisVector(this._currentAxis).normalize(),r=new THREE.Vector3(0,0,0),s=(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),i),o=new THREE.Vector3(1,0,0).applyQuaternion(s).normalize(),n=new THREE.Vector3(0,0,1).applyQuaternion(s).normalize(),l=e[0],a=(new THREE.Vector3).subVectors(l,r),c=a.dot(i),h=(new THREE.Vector3).subVectors(a,i.clone().multiplyScalar(c));let p=-Math.atan2(h.dot(n),h.dot(o))+Math.PI/2;p<0&&(p+=2*Math.PI);const u=[];for(const t of e){const e=(new THREE.Vector3).subVectors(t,r),s=e.dot(i),o=e.clone().sub(i.clone().multiplyScalar(s)).length();u.push(new THREE.Vector2(o,s))}let d=0;const v=u.length;for(let e=0;e<v;e++){const t=(e+1)%v;d+=u[e].x*u[t].y,d-=u[t].x*u[e].y}if(d/=2,t?d>0&&u.reverse():d<0&&u.reverse(),u.length>0){const e=u[0],t=u[u.length-1];(Math.abs(e.x-t.x)>1e-6||Math.abs(e.y-t.y)>1e-6)&&u.push(e.clone())}const E="negative"===this._currentDirection?-THREE.MathUtils.degToRad(this._currentAngle):THREE.MathUtils.degToRad(this._currentAngle),g=Math.max(16,Math.round(this._currentAngle/5)),m=new THREE.LatheGeometry(u,g,p,E);return m.applyQuaternion(s),m.translate(r.x,r.y,r.z),m}_createRevolveAroundLine(e,t){if(!e||0===e.length)return null;if(!this.selectedAxisLine)return null;const i=this.selectedAxisLine.geometry.attributes.position.array,r=new THREE.Vector3(i[0],i[1],i[2]),s=new THREE.Vector3(i[3],i[4],i[5]),o=this.selectedAxisLine.localToWorld(r),n=this.selectedAxisLine.localToWorld(s),l=(new THREE.Vector3).subVectors(n,o).normalize(),a=(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),l),c=new THREE.Vector3(1,0,0).applyQuaternion(a).normalize(),h=new THREE.Vector3(0,0,1).applyQuaternion(a).normalize(),p=e[0],u=(new THREE.Vector3).subVectors(p,o),d=u.dot(l),v=(new THREE.Vector3).subVectors(u,l.clone().multiplyScalar(d));let E=-Math.atan2(v.dot(h),v.dot(c))+Math.PI/2;E<0&&(E+=2*Math.PI);const g=[];for(const t of e){const e=(new THREE.Vector3).subVectors(t,o),i=e.dot(l),r=e.clone().sub(l.clone().multiplyScalar(i)).length();g.push(new THREE.Vector2(r,i))}let m=0;const x=g.length;for(let e=0;e<x;e++){const t=(e+1)%x;m+=g[e].x*g[t].y,m-=g[t].x*g[e].y}if(m/=2,t?m>0&&g.reverse():m<0&&g.reverse(),g.length>0){const e=g[0],t=g[g.length-1];(Math.abs(e.x-t.x)>1e-6||Math.abs(e.y-t.y)>1e-6)&&g.push(e.clone())}const w="negative"===this._currentDirection?-THREE.MathUtils.degToRad(this._currentAngle):THREE.MathUtils.degToRad(this._currentAngle),y=Math.max(16,Math.round(this._currentAngle/5)),R=new THREE.LatheGeometry(g,y,E,w);return R.applyQuaternion(a),R.translate(o.x,o.y,o.z),R}_createCapsForFigures(e){const t=[],i=[];for(const t of e){const e=[];for(let i=0;i<t.outer.length;i+=2)e.push(new THREE.Vector2(t.outer[i],t.outer[i+1]));if(e.length<3)continue;const r=new THREE.Shape(e);if(t.holes&&t.holes.length)for(const e of t.holes){const t=[];for(let i=0;i<e.length;i+=2)t.push(new THREE.Vector2(e[i],e[i+1]));if(t.length>=3){const e=new THREE.Path(t);r.holes.push(e)}}i.push(r)}if(0===i.length)return[];const r={depth:this.capThickness,bevelEnabled:!1,steps:1},s="positive"===this._currentDirection?this._currentAngle:-this._currentAngle;for(const e of[0,s])try{const s=new THREE.ExtrudeGeometry(i,r),o=THREE.MathUtils.degToRad(e);if(this.selectedAxisLine){const e=this.selectedAxisLine.geometry.attributes.position.array,t=new THREE.Vector3(e[0],e[1],e[2]),i=new THREE.Vector3(e[3],e[4],e[5]),r=this.selectedAxisLine.localToWorld(t),n=this.selectedAxisLine.localToWorld(i),l=(new THREE.Vector3).subVectors(n,r).normalize(),a=(new THREE.Matrix4).makeRotationAxis(l,o),c=(new THREE.Matrix4).makeTranslation(-r.x,-r.y,-r.z),h=(new THREE.Matrix4).makeTranslation(r.x,r.y,r.z),p=h.clone().multiply(a).multiply(c).multiply(this.basePlane.matrixWorld);s.applyMatrix4(p)}else{const e=this.getAxisVector(this._currentAxis),t=(new THREE.Matrix4).makeRotationAxis(e,o).multiply(this.basePlane.matrixWorld);s.applyMatrix4(t)}t.push(s)}catch(e){console.error("Ошибка создания крышки:",e)}return t}_createContourGeometry(e,t){if(!e||e.length<6)return null;const i=[];for(let t=0;t<e.length;t+=2)i.push(new THREE.Vector2(e[t],e[t+1]));if(0===i.length)return null;const r=i.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this.basePlane.localToWorld(t)});if(0===r.length)return null;let s;return s=this.selectedAxisLine?this._createRevolveAroundLine(r,t):this._createRevolveAroundGlobalAxis(r,t),s}createPreviewMesh(e,t,i,r){if(0===e.length||!this.basePlane)return null;this._currentAngle=t,this._currentAxis=i,this._currentDirection=r;const s=e.map(e=>({outer:e.outer.points.flatMap(e=>[e.x,e.y]),holes:e.holes.map(e=>e.points.flatMap(e=>[e.x,e.y]))})),o=[];for(const e of s){const t=this._createContourGeometry(e.outer,!1);if(t&&o.push(t),e.holes&&e.holes.length)for(const t of e.holes){const e=this._createContourGeometry(t,!0);e&&o.push(e)}}if(this.addCaps&&t<360){const e=this._createCapsForFigures(s);o.push(...e)}if(0===o.length)return null;const n=o.map(e=>this._toNonIndexed(e)).filter(Boolean),l=1===n.length?n[0]:this.mergeGeometries(n),a=new THREE.MeshBasicMaterial;return new THREE.Mesh(l,a)}updateRevolvePreview(){const e=this.getFiguresForOperation();if(0===e.length)return void this.removeRevolvePreview();const t=parseFloat(this.propertiesElement?.querySelector("#revolveAngle")?.value)||360,i=this.propertiesElement?.querySelector("#revolveAxis")?.value||"y",r=this.propertiesElement?.querySelector("#revolveDirection")?.value||"positive";if(this.revolvePreviewGroup&&this.revolvePreviewGroup.children.length>0){const s=this.revolvePreviewGroup.children[0],o=this.createPreviewMesh(e,t,i,r);o&&(s.geometry.dispose(),s.geometry=o.geometry,s.material.color.setHex(this.getPreviewColor()))}else this.createNewRevolvePreview(e,t,i,r)}createNewRevolvePreview(e,t,i,r){this.removeRevolvePreview();const s=this.createPreviewMesh(e,t,i,r);s&&(s.material=new THREE.MeshPhongMaterial({color:this.getPreviewColor(),transparent:!0,opacity:.4,side:THREE.DoubleSide}),this.revolvePreviewGroup=new THREE.Group,this.revolvePreviewGroup.add(s),this.editor.objectsGroup.add(this.revolvePreviewGroup))}removeRevolvePreview(){this.revolvePreviewGroup&&(this.editor.objectsGroup.remove(this.revolvePreviewGroup),this.revolvePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.revolvePreviewGroup=null)}mergeGeometries(e){if(0===e.length)return null;if(1===e.length)return e[0];if(THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeBufferGeometries)return THREE.BufferGeometryUtils.mergeBufferGeometries(e);const t=new THREE.BufferGeometry,i=[],r=[];let s=0;for(const t of e){if(!t||!t.attributes.position)continue;const e=t.attributes.position.array;for(let t=0;t<e.length;t+=3)i.push(e[t],e[t+1],e[t+2]);if(t.index){const e=t.index.array;for(let t=0;t<e.length;t++)r.push(e[t]+s)}else for(let t=0;t<e.length/3;t++)r.push(t+s);s+=e.length/3}return t.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),t.setIndex(r),t.computeVertexNormals(),t}startAxisSelection(){this.isSelectingAxis=!0,this.editor.axesHelper?this.editor.axesHelper.visible=!0:(this.editor.axesHelper=new THREE.AxesHelper(100),this.editor.scene.add(this.editor.axesHelper)),this.editor.showStatus("Кликните на ось координат или линию для выбора оси вращения","info"),this.updateAxisInfo()}handleAxisSelection(e){if(this.editor.axesHelper){const t=this.editor.renderer.domElement.getBoundingClientRect(),i=new THREE.Vector2((e.clientX-t.left)/t.width*2-1,-(e.clientY-t.top)/t.height*2+1);this.editor.raycaster.setFromCamera(i,this.editor.camera);const r=this.editor.raycaster.intersectObject(this.editor.axesHelper,!0);if(r.length>0){const e=this._getAxisFromIntersection(r[0]);if(e)return this.selectedAxis=e,this.selectedAxisLine=null,this.isSelectingAxis=!1,this.updateAxisInfo(),this.showSelectedAxis(),this.removeRevolvePreview(),this.updateRevolvePreview(),this.editor.showStatus(`Выбрана глобальная ось: ${e.toUpperCase()}`,"success"),!0}}const t=this.editor.objectsManager.getAllSketchElements().filter(e=>"line"===e.userData?.elementType&&e.visible);if(t.length>0){const i=this._findLineAtPoint(e,t);if(i)return this.selectedAxisLine=i,this.isSelectingAxis=!1,this.selectedAxis=this._getClosestAxisToLine(i),this.updateAxisInfo(),this.showSelectedAxis(),this.updateRevolvePreview(),this.editor.showStatus("Выбрана линия как ось вращения","success"),!0}return!1}_getAxisFromIntersection(e){return"x-axis"===e.object.name||"x"===e.object.userData?.axis?"x":"y-axis"===e.object.name||"y"===e.object.userData?.axis?"y":"z-axis"===e.object.name||"z"===e.object.userData?.axis?"z":null}_findLineAtPoint(e,t){const i=this.editor.renderer.domElement.getBoundingClientRect(),r=new THREE.Vector2((e.clientX-i.left)/i.width*2-1,-(e.clientY-i.top)/i.height*2+1);this.editor.raycaster.setFromCamera(r,this.editor.camera);const s=this.editor.raycaster.intersectObjects(t,!0);return s.length>0?s[0].object:null}_getClosestAxisToLine(e){const t=e.geometry.attributes.position.array,i=new THREE.Vector3(t[0],t[1],t[2]),r=new THREE.Vector3(t[3],t[4],t[5]);e.localToWorld(i),e.localToWorld(r);const s=(new THREE.Vector3).subVectors(r,i).normalize(),o=Math.abs(s.dot(new THREE.Vector3(1,0,0))),n=Math.abs(s.dot(new THREE.Vector3(0,1,0))),l=Math.abs(s.dot(new THREE.Vector3(0,0,1))),a=Math.max(o,n,l);return a===o?"x":a===n?"y":"z"}showSelectedAxis(){if(this.removeAxisVisualization(),this.selectedAxisLine){const e=new THREE.BufferGeometry,t=this.selectedAxisLine.geometry.attributes.position.array;e.setAttribute("position",new THREE.Float32BufferAttribute(t.slice(),3)),this.axisHelper=new THREE.Line(e,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.axisHelper.position.copy(this.selectedAxisLine.position),this.axisHelper.quaternion.copy(this.selectedAxisLine.quaternion),this.axisHelper.scale.copy(this.selectedAxisLine.scale),this.editor.scene.add(this.axisHelper)}else{const e=200;let t,i;switch(this.selectedAxis){case"x":t=new THREE.Vector3(-e/2,0,0),i=new THREE.Vector3(e/2,0,0);break;case"y":t=new THREE.Vector3(0,-e/2,0),i=new THREE.Vector3(0,e/2,0);break;case"z":t=new THREE.Vector3(0,0,-e/2),i=new THREE.Vector3(0,0,e/2)}const r=(new THREE.BufferGeometry).setFromPoints([t,i]);this.axisHelper=new THREE.Line(r,new THREE.LineBasicMaterial({color:16711680,linewidth:3,opacity:.8,transparent:!0})),this.editor.scene.add(this.axisHelper)}}removeAxisVisualization(){this.axisHelper&&(this.editor.scene.remove(this.axisHelper),this.axisHelper.geometry&&this.axisHelper.geometry.dispose(),this.axisHelper.material&&this.axisHelper.material.dispose(),this.axisHelper=null)}updateAxisInfo(){const e=this.propertiesElement?.querySelector("#axisInfo");e&&(this.selectedAxisLine?(e.textContent="Ось: выбранная линия",e.style.color="#FF0000"):(e.textContent=`Ось: глобальная ${this.selectedAxis.toUpperCase()}`,e.style.color="#666"));const t=this.propertiesElement?.querySelector("#revolveAxis");t&&!this.isSelectingAxis&&(t.value=this.selectedAxis)}createPropertiesUI(){const e=this.selectedRegions.size;return`\n            <div class="property-group" data-tool="revolve">\n                <h4>ВРАЩЕНИЕ</h4>\n\n                <div class="property-row">\n                    <label>Угол (°):</label>\n                    <div class="property-input-group">\n                        <input type="range" id="revolveAngleSlider" min="1" max="360" value="360" style="width: 70%;" step="1">\n                        <input type="number" id="revolveAngle" class="property-input" value="360" min="1" max="360" step="1">\n                    </div>\n                </div>\n                <div id="angleHint" class="property-hint">При угле < 360° торцы будут закрыты</div>\n\n                <div class="property-row">\n                    <label>Ось вращения:</label>\n                    <div class="property-input-group">\n                        <select id="revolveAxis" class="property-select">\n                            <option value="x">Глобальная ось X</option>\n                            <option value="y" selected>Глобальная ось Y</option>\n                            <option value="z">Глобальная ось Z</option>\n                        </select>\n                        <button id="selectAxisButton" class="btn-secondary" title="Выбрать ось на чертеже">\n                            <i class="fas fa-mouse-pointer"></i>\n                        </button>\n                    </div>\n                </div>\n                <div id="axisInfo" class="property-hint">Ось: глобальная Y</div>\n\n                <div class="property-row">\n                    <label>Направление:</label>\n                    <select id="revolveDirection" class="property-select">\n                        <option value="positive">По часовой стрелке</option>\n                        <option value="negative">Против часовой стрелки</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label>Операция:</label>\n                    <select id="revolveOperation" class="property-select">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n\n                <div class="property-row">\n                    <label class="property-checkbox">\n                        <input type="checkbox" id="addCaps" checked> Закрывать торцы при угле < 360°\n                    </label>\n                </div>\n\n                <div class="property-buttons">\n                    <button id="performOperation" class="btn-primary" ${0===e?"disabled":""}>\n                        <i class="fas fa-check"></i> Выполнить\n                    </button>\n                    <button id="cancelRevolve" class="btn-secondary">\n                        <i class="fas fa-times"></i> Отмена\n                    </button>\n                </div>\n\n                <div class="property-hint">\n                    <div id="selectedContourInfo">\n                        ${e>0?`Выбрано регионов: ${e}`:"Кликните по региону для выбора"}\n                    </div>\n                </div>\n                <div class="property-row">\n                    <div class="property-hint">\n                        <i class="fas fa-info-circle"></i> Описание:\n                        <div>Вращение плоского эскиза вокруг оси.</div><br>\n                        <div>• Клик по региону: выделить/снять выделение</div>\n                        <div>• Нажмите кнопку <i class="fas fa-mouse-pointer"></i> чтобы выбрать ось</div>\n                        <div>• Отверстия учитываются автоматически (булевы операции)</div>\n                        <div>• Escape для отмены, Enter для подтверждения</div>\n                    </div>\n                </div>\n            </div>\n        `}showRevolveUI(){this.removeRevolveUI();const e=document.getElementById("propertiesContent");e&&(this.propertiesElement=document.createElement("div"),this.propertiesElement.innerHTML=this.createPropertiesUI(),e.appendChild(this.propertiesElement),this.setupPropertiesEventListeners(),this.updateRevolveUI())}setupPropertiesEventListeners(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#cancelRevolve");e&&e.addEventListener("click",()=>this.exitRevolveMode());const t=this.propertiesElement.querySelector("#performOperation");t&&t.addEventListener("click",()=>this.performRevolve());const i=this.propertiesElement.querySelector("#revolveAngleSlider"),r=this.propertiesElement.querySelector("#revolveAngle"),s=this.propertiesElement.querySelector("#angleHint");i&&r&&(i.addEventListener("input",()=>{r.value=i.value,s&&(s.textContent=i.value<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются"),this.updateRevolvePreview()}),r.addEventListener("input",()=>{i.value=r.value,s&&(s.textContent=r.value<360?"При угле < 360° торцы будут закрыты":"При угле 360° торцы не закрываются"),this.updateRevolvePreview()}));const o=this.propertiesElement.querySelector("#revolveAxis");o&&o.addEventListener("change",()=>{this.isSelectingAxis||(this.selectedAxis=o.value,this.selectedAxisLine=null,this.updateAxisInfo(),this.showSelectedAxis(),this.removeRevolvePreview(),this.updateRevolvePreview())});const n=this.propertiesElement.querySelector("#revolveDirection");n&&n.addEventListener("change",()=>this.updateRevolvePreview());const l=this.propertiesElement.querySelector("#revolveOperation");l&&l.addEventListener("change",e=>{this.currentOperation=e.target.value,this.updateRevolvePreview()});const a=this.propertiesElement.querySelector("#addCaps");a&&a.addEventListener("change",e=>{this.addCaps=e.target.checked,this.updateRevolvePreview()});const c=this.propertiesElement.querySelector("#selectAxisButton");c&&c.addEventListener("click",()=>this.startAxisSelection())}updateRevolveUI(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#selectedContourInfo"),t=this.propertiesElement.querySelector("#performOperation"),i=this.selectedRegions.size;e&&(e.textContent=i>0?`Выбрано регионов: ${i}`:"Кликните по региону для выбора",e.style.color=i>0?"#4CAF50":"#888"),t&&(t.disabled=0===i)}removeRevolveUI(){this.propertiesElement&&(this.propertiesElement.remove(),this.propertiesElement=null)}performRevolve(){const e=this.getFiguresForOperation();if(0===e.length)return void this.editor.showStatus("Выберите регион(ы) для вращения","error");const t=parseFloat(this.propertiesElement?.querySelector("#revolveAngle")?.value)||360,i=this.propertiesElement?.querySelector("#revolveAxis")?.value||"y",r=this.propertiesElement?.querySelector("#revolveDirection")?.value||"positive",s=this.propertiesElement?.querySelector("#revolveOperation")?.value||"new",o=this.propertiesElement?.querySelector("#addCaps")?.checked??!0;if(isNaN(t)||t<=0||t>360)return void this.editor.showStatus("Введите корректный угол (1-360)","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const n={figures:e.map(e=>({outer:e.outer.points.flatMap(e=>[e.x,e.y]),holes:e.holes.map(e=>e.points.flatMap(e=>[e.x,e.y]))})),angle:t,axis:this.selectedAxisLine?"line":i,direction:r,operationType:s,color:16750592,planeId:this.basePlane.uuid,addCaps:o,capThickness:this.capThickness},l=[];if(this.selectedAxisLine&&(n.lineAxisId=this.selectedAxisLine.uuid,l.push(this.selectedAxisLine.uuid)),"cut"===s||"join"===s){const s=this.createPreviewMesh(e,t,i,r);if(!s)return void this.editor.showStatus("Не удалось создать временную геометрию","error");{const e=this.findIntersectingObjects(s).map(e=>e.uuid);if(s.geometry.dispose(),0===e.length)return void this.editor.showStatus("Нет пересекающихся объектов для операции","warning");l.push(...e)}}const a=new ParametricOperation("revolve",n,l),c=this.editor.parametricModel.addOperation(a);this.editor.clearSelection(),c.forEach(e=>{const t=this.editor.parametricModel.objectMap.get(e);t&&(this.editor.selectedObjects.push(t),this.editor.objectsManager.highlightObject(t))}),this.editor.showStatus(`Вращение выполнено: угол ${t}°, ${e.length} регионов`,"success"),this.exitRevolveMode()}findIntersectingObjects(e){const t=[],i=(new THREE.Box3).setFromObject(e);return this.editor.parametricModel.objectMap.forEach(r=>{if(!r.visible||r.userData.isHelper)return;if(r===e)return;const s=r.userData?.type;if("sketch_plane"===s||"work_plane"===s||"sketch_element"===s)return;const o=(new THREE.Box3).setFromObject(r);i.intersectsBox(o)&&t.push(r)}),t}exitRevolveMode(){this.editor.toolManager.setCurrentTool("select")}cancelRevolveMode(){this.clearSelection(),this.removeRevolvePreview(),this.removeAxisVisualization(),this.removeRevolveUI(),this.editor.scene.traverse(e=>{e.userData?.regionManager&&e.userData.regionManager.clearHighlight()}),this.isSelectingAxis=!1,this.editor.showStatus("Режим вращения завершён","info"),document.body.style.cursor="default"}highlightRevolvableRegions(){this.editor.scene.traverse(e=>{e.userData?.regionManager&&e.userData.regionManager.clearHighlight()});const e=this.getAllRegions();e.forEach(e=>{this.highlightRegion(e,16750592)}),0===e.length&&this.editor.showStatus("Нет замкнутых регионов для вращения","warning")}highlightRevolvableFigures(){this.highlightRevolvableRegions()}toggleSelection(e){super.toggleSelection(e),this.updateRevolvePreview(),this.updateRevolveUI(),this.selectedRegions.size>0?this.showSelectedAxis():this.removeAxisVisualization()}}