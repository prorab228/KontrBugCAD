import*as THREE from"three";import{ParametricOperation}from"/js/core/parametric/ParametricOperation.js";import{TransformToolBase}from"./transform-tool-base.js";export class MoveTool extends TransformToolBase{constructor(t){super("move","fa-arrows-alt",t),this.useLocalCoordinates=!1,this.moveLine=null,this.moveLineGeometry=null,this.moveLineMaterial=null,this.startWorldPosition=new THREE.Vector3,this.showMoveLine=!0,this.lineThickness=.3,this.arrowBaseLength=7,this.arrowHeadBaseLength=2.5,this.arrowHeadBaseRadius=1.5,this.lineBaseRadius=.05,this.minArrowLength=2,this.arrowOffset=2,this.axisArrows={x:{line:null,cone:null,group:null,axis:"x",positive:!0},y:{line:null,cone:null,group:null,axis:"y",positive:!0},z:{line:null,cone:null,group:null,axis:"z",positive:!0},nx:{line:null,cone:null,group:null,axis:"x",positive:!1},ny:{line:null,cone:null,group:null,axis:"y",positive:!1},nz:{line:null,cone:null,group:null,axis:"z",positive:!1}},this.hoveredAxis=null,this.lastDistance=0,this.lastDragAxis=null,this.cachedVectors={currentWorldPos:new THREE.Vector3,midPoint:new THREE.Vector3,direction:new THREE.Vector3,cameraDirection:new THREE.Vector3,perpDirection:new THREE.Vector3,objectCenter:new THREE.Vector3},this._inputContainer=null,this._inputElement=null,this._isInputFocused=!1,this._lastInputDistance=0,this._currentDragAxis=null,this._currentDragPositive=null,this.initGizmo(),this._moveLinesInitialized=!1}initGizmo(){for(;this.gizmoGroup.children.length>0;){const t=this.gizmoGroup.children[0];t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose(),this.gizmoGroup.remove(t)}this.createTranslateGizmo(),this.gizmoGroup.visible=!1,this.initMoveLine()}initMoveLine(){this._moveLinesInitialized||(this.moveLineGeometry=new THREE.CylinderGeometry(this.lineThickness/2,this.lineThickness/2,1,6,1,!1),this.moveLineMaterial=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.7,side:THREE.DoubleSide,depthTest:!0,depthWrite:!0}),this.moveLine=new THREE.Mesh(this.moveLineGeometry,this.moveLineMaterial),this.moveLine.name="move_tool_line",this.moveLine.visible=!1,this.moveLine.renderOrder=999,this.moveLine.userData.isMoveToolLine=!0,this.editor.scene.add(this.moveLine),this.initDistanceInput(),this._moveLinesInitialized=!0)}initDistanceInput(){this._inputContainer=document.createElement("div"),this._inputContainer.className="distance-input-container",this._inputElement=document.createElement("input"),this._inputElement.type="number",this._inputElement.step="0.1",this._inputContainer.appendChild(this._inputElement),document.body.appendChild(this._inputContainer),this._inputElement.addEventListener("focus",()=>{this._isInputFocused=!0}),this._inputElement.addEventListener("blur",()=>{this._isInputFocused=!1}),this._inputElement.addEventListener("input",t=>{const e=parseFloat(t.target.value);!isNaN(e)&&this.attachedObject&&this._currentDragAxis&&this.updateFromInput(e)})}updateFromInput(t){if(!this.attachedObject||!this._currentDragAxis)return;const e=this.getAxisVector(this._currentDragAxis,!0).clone().multiplyScalar(t);this.attachedObject.position.copy(this.startPosition).add(e),this.moveDelta.copy(e),this.updateGizmoPosition(),this.moveLine&&this.moveLine.visible&&this.updateLineTransform(this.startWorldPosition,this.attachedObject.getWorldPosition(new THREE.Vector3))}createTranslateGizmo(){this.createAxisArrow("x",!0),this.createAxisArrow("y",!0),this.createAxisArrow("z",!0),this.createAxisArrow("x",!1),this.createAxisArrow("y",!1),this.createAxisArrow("z",!1)}createAxisArrow(t,e){const i=e?t:`n${t}`,s=e?1:-1,o=this.axisColors[t],n=new THREE.Group;n.name=`translate_${i}`,n.userData.type="translate",n.userData.axis=t,n.userData.positive=e,n.userData.key=i,this.axisArrows[i].group=n;const r=new THREE.CylinderGeometry(this.lineBaseRadius,this.lineBaseRadius,this.arrowBaseLength,6),a=new THREE.MeshBasicMaterial({color:o,transparent:!0,depthTest:!1,opacity:.8}),h=new THREE.Mesh(r,a);h.renderOrder=1,h.name=`translate_line_${i}`,h.userData.axis=t,h.userData.positive=e,h.userData.key=i,this.axisArrows[i].line=h;const c=new THREE.ConeGeometry(this.arrowHeadBaseRadius,this.arrowHeadBaseLength,6),l=new THREE.MeshBasicMaterial({color:o,transparent:!0,depthTest:!1,opacity:.8}),u=new THREE.Mesh(c,l);u.renderOrder=1,u.name=`translate_cone_${i}`,u.userData.axis=t,u.userData.positive=e,u.userData.key=i,this.axisArrows[i].cone=u,"x"===t?(h.rotation.z=-Math.PI/2,h.position.x=s*this.arrowBaseLength/2,e?(u.rotation.z=-Math.PI/2,u.position.x=this.arrowBaseLength+this.arrowHeadBaseLength/2):(u.rotation.z=Math.PI/2,u.position.x=-this.arrowBaseLength-this.arrowHeadBaseLength/2)):"y"===t?(h.position.y=s*this.arrowBaseLength/2,e?u.position.y=this.arrowBaseLength+this.arrowHeadBaseLength/2:(u.rotation.x=Math.PI,u.position.y=-this.arrowBaseLength-this.arrowHeadBaseLength/2)):"z"===t&&(h.rotation.x=Math.PI/2,h.position.z=s*this.arrowBaseLength/2,e?(u.rotation.x=Math.PI/2,u.position.z=this.arrowBaseLength+this.arrowHeadBaseLength/2):(u.rotation.x=-Math.PI/2,u.position.z=-this.arrowBaseLength-this.arrowHeadBaseLength/2)),n.add(h),n.add(u),this.gizmoGroup.add(n)}onActivate(){super.onActivate(),this._moveLinesInitialized||this.initMoveLine(),1===this.editor.selectedObjects.length&&this.attachToObject(this.editor.selectedObjects[0])}getPropertiesHTML(){return`\n            <div class="property-group" data-type="move-position">\n                <h4><i class="fas fa-arrows-alt"></i> Позиция (мм)</h4>\n                <div class="property-row">\n                    <label>Локальные координаты:</label>\n                    <input type="checkbox" id="localCoordinates" ${this.useLocalCoordinates?"checked":""}>\n                </div>\n                <div class="property-row">\n                    <label>Показывать линию перемещения:</label>\n                    <input type="checkbox" id="showMoveLine" ${this.showMoveLine?"checked":""}>\n                </div>\n                <div class="property-row">\n                    <label>X:</label>\n                    <input type="number" id="movePosX" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Y:</label>\n                    <input type="number" id="movePosY" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Z:</label>\n                    <input type="number" id="movePosZ" step="any" value="0">\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const t=this.propertiesElement.querySelector("#movePosX"),e=this.propertiesElement.querySelector("#movePosY"),i=this.propertiesElement.querySelector("#movePosZ"),s=this.propertiesElement.querySelector("#localCoordinates"),o=this.propertiesElement.querySelector("#showMoveLine");t&&(t.addEventListener("input",t=>this.onPositionChange("x",t)),t.addEventListener("change",t=>this.onPositionChange("x",t,!0))),e&&(e.addEventListener("input",t=>this.onPositionChange("y",t)),e.addEventListener("change",t=>this.onPositionChange("y",t,!0))),i&&(i.addEventListener("input",t=>this.onPositionChange("z",t)),i.addEventListener("change",t=>this.onPositionChange("z",t,!0))),s&&(s.checked=this.useLocalCoordinates,s.addEventListener("change",t=>{this.useLocalCoordinates=t.target.checked,this.updateGizmoPosition()})),o&&(o.checked=this.showMoveLine,o.addEventListener("change",t=>{this.showMoveLine=t.target.checked,this.showMoveLine||this.hideMoveLine()}))}hideMoveLine(){this.moveLine&&(this.moveLine.visible=!1),this._inputContainer&&(this._inputContainer.style.display="none")}clearMoveLine(){this.hideMoveLine(),this._currentDragAxis=null,this._currentDragPositive=null}onPositionChange(t,e,i=!1){if(!this.attachedObject)return;const s=parseFloat(e.target.value);isNaN(s)||(this.hideMoveLine(),this.attachedObject.position[t]=s,this.updateGizmoPosition(),i&&this.saveToHistory())}updatePropertiesValues(){if(!this.propertiesElement||!this.attachedObject)return;const t=this.propertiesElement.querySelector("#movePosX"),e=this.propertiesElement.querySelector("#movePosY"),i=this.propertiesElement.querySelector("#movePosZ");t&&(t.value=this.attachedObject.position.x.toFixed(2)),e&&(e.value=this.attachedObject.position.y.toFixed(2)),i&&(i.value=this.attachedObject.position.z.toFixed(2))}onMouseDown(t){if(0!==t.button)return!1;this.snapEnabled=!t.ctrlKey,this.editor.updateMousePosition(t),this.lastMousePosition.copy(this.editor.mouse),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(i.length>0){let e=null,s=!0,o=i[0].object;for(;o&&!e;){if(o.userData&&o.userData.axis){e=o.userData.axis,s=o.userData.positive;break}o=o.parent}if(e){const i=s?e:`n${e}`;return this.startDragging(i,t),!0}}const s=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(s.length>0){const t=this.editor.objectsManager.findTopParent(s[0].object);if(this.canTransformObject(t))return this.clearMoveLine(),this.editor.selectSingleObject(t),this.attachToObject(t),!0}return!1}onMouseMove(t){if(super.onMouseMove(t),this.isDragging)return;this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.axis&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(this.hoveredAxis&&(this.hoveredAxis=null),i.length>0){const t=i[0].object;this.hoveredAxis=t.userData.key}this.updateGizmoPosition()}startDragging(t,e){if(super.startDragging(t,e),this.attachedObject){let e,i,s;this.moveDelta.set(0,0,0),t.startsWith("n")?(e=t.substring(1),i=!1):(e=t,i=!0),this._currentDragAxis=e,this._currentDragPositive=i,this.currentAxisVector=this.getAxisVector(e,i),"x"===e?s=new THREE.Vector3(0,1,0):"y"===e?s=new THREE.Vector3(0,0,1):"z"===e&&(s=new THREE.Vector3(1,0,0)),s&&(this.dragPlane=new THREE.Plane,this.dragPlane.setFromNormalAndCoplanarPoint(s,this.gizmoGroup.position)),this.attachedObject.getWorldPosition(this.startWorldPosition),this.dragAxis=e,this.dragPositive=i,this.lastDragAxis=`${e}${i?"+":"-"}`,this._inputContainer&&(this._inputContainer.style.display="block",this._inputElement.value="0.0","x"===e?this._inputContainer.style.borderColor="#ff4444":"y"===e?this._inputContainer.style.borderColor="#44ff44":"z"===e&&(this._inputContainer.style.borderColor="#4444ff"),this.updateInputPositionOnStart(t)),this.setupMoveLine()}}updateInputPositionOnStart(t){if(!this._inputContainer||!this.attachedObject)return;const e=this.axisArrows[t]?.group;if(!e)return;const i=new THREE.Vector3;e.getWorldPosition(i);const s=this.worldToScreen(i,this.editor.camera,this.editor.renderer);this._inputContainer.style.left=`${s.x}px`,this._inputContainer.style.top=`${s.y}px`}setupMoveLine(){this.moveLine&&this.showMoveLine&&(this.moveLine.visible=!0,"x"===this.dragAxis?(this.moveLineMaterial.color.setHex(16729156),this._inputContainer.style.borderColor="#ff4444"):"y"===this.dragAxis?(this.moveLineMaterial.color.setHex(4521796),this._inputContainer.style.borderColor="#44ff44"):"z"===this.dragAxis&&(this.moveLineMaterial.color.setHex(4474111),this._inputContainer.style.borderColor="#4444ff"),this.lastDistance=0,this._lastInputDistance=0,this._inputElement&&(this._inputElement.value="0.0"))}updateLineTransform(t,e){if(!this.moveLine||!this.moveLine.visible)return;const{midPoint:i,direction:s}=this.cachedVectors;i.addVectors(t,e).multiplyScalar(.5);const o=t.distanceTo(e);s.subVectors(e,t).normalize(),this.moveLine.position.copy(i),this.moveLine.scale.set(1,o,1),s.length()>0&&this.moveLine.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),s),this.updateDistanceInput(i,o,s)}updateDistanceInput(t,e,i){if(!this._inputContainer||this._isInputFocused)return;let s=e;if(this.attachedObject&&this._currentDragAxis){const t=this.cachedVectors.currentWorldPos;this.attachedObject.getWorldPosition(t);const e=this.startWorldPosition;"x"===this._currentDragAxis?s=t.x-e.x:"y"===this._currentDragAxis?s=t.y-e.y:"z"===this._currentDragAxis&&(s=t.z-e.z)}this.lastDistance=s,this.lastDragAxis=this.dragAxis,this._lastInputDistance=s,this._inputElement.value=s.toFixed(1),this._inputContainer.style.display="block";const o=s<0;"x"===this.dragAxis?this._inputContainer.style.borderColor=o?"#ff8888":"#ff4444":"y"===this.dragAxis?this._inputContainer.style.borderColor=o?"#88ff88":"#44ff44":"z"===this.dragAxis&&(this._inputContainer.style.borderColor=o?"#8888ff":"#4444ff"),this.updateInputPosition(t)}updateInputPosition(t){if(!this._inputContainer)return;const e=this.worldToScreen(t,this.editor.camera,this.editor.renderer);this._inputContainer.style.left=`${e.x}px`,this._inputContainer.style.top=`${e.y}px`}worldToScreen(t,e,i){const s=t.clone();s.project(e);return{x:(.5*s.x+.5)*i.domElement.clientWidth,y:(-.5*s.y+.5)*i.domElement.clientHeight}}updateMoveLine(){if(!(this.moveLine&&this.attachedObject&&this.moveLine.visible&&this.showMoveLine))return;const{currentWorldPos:t}=this.cachedVectors;this.attachedObject.getWorldPosition(t),this.updateLineTransform(this.startWorldPosition,t)}handleTransform(t,e){if(!this.attachedObject||!this.currentAxisVector||!this.dragPlane)return;const i=this.editor.renderer.domElement.getBoundingClientRect(),s=this.startMouse.x+t,o=this.startMouse.y+e,n=(s-i.left)/i.width*2-1,r=-(o-i.top)/i.height*2+1,a=new THREE.Raycaster;a.setFromCamera(new THREE.Vector2(n,r),this.editor.camera);const h=new THREE.Vector3;if(a.ray.intersectPlane(this.dragPlane,h)){const t=(this.startMouse.x-i.left)/i.width*2-1,e=-(this.startMouse.y-i.top)/i.height*2+1,s=new THREE.Raycaster;s.setFromCamera(new THREE.Vector2(t,e),this.editor.camera);const o=new THREE.Vector3;if(s.ray.intersectPlane(this.dragPlane,o)){const t=(new THREE.Vector3).subVectors(h,o).dot(this.currentAxisVector),e=this.currentAxisVector.clone().multiplyScalar(t);this.snapEnabled&&!this.editor.spacePressed&&(e.x=Math.round(e.x/this.moveSnapValue)*this.moveSnapValue,e.y=Math.round(e.y/this.moveSnapValue)*this.moveSnapValue,e.z=Math.round(e.z/this.moveSnapValue)*this.moveSnapValue),this.attachedObject.position.copy(this.startPosition).add(e),this.moveDelta.copy(e),this.updateGizmoPosition(),this.updateMoveLine()}}}updateGizmoPosition(){if(!this.attachedObject)return;const t=new THREE.Vector3;this.attachedObject.getWorldPosition(t),this.gizmoGroup.position.copy(t),this.useLocalCoordinates?this.gizmoGroup.quaternion.copy(this.attachedObject.quaternion):this.gizmoGroup.quaternion.identity();const e=(new THREE.Box3).setFromObject(this.attachedObject),i=new THREE.Vector3;e.getSize(i),this.gizmoGroup.scale.set(1,1,1),Object.keys(this.axisArrows).forEach(t=>{const e=this.axisArrows[t];if(!e.group)return;const s=e.axis,o=e.positive;let n;n="x"===s?i.x:"y"===s?i.y:i.z;let r=n/2+this.arrowOffset;r=Math.max(this.minArrowLength,r);let a=r-this.arrowHeadBaseLength/2;a<0&&(a=0,r=this.arrowHeadBaseLength/2);const h=a/this.arrowBaseLength,c=e.line,l=e.cone;if(c&&l){const e=o?1:-1;"x"===s?(c.position.x=e*a/2,c.scale.x=h,l.position.x=e*r):"y"===s?(c.position.y=e*a/2,c.scale.y=h,l.position.y=e*r):"z"===s&&(c.position.z=e*a/2,c.scale.z=h,l.position.z=e*r);const i=this.hoveredAxis===t,n=i?16776960:this.axisColors[s],u=i?1:.8;c.material&&(c.material.color.set(n),c.material.opacity=u),l.material&&(l.material.color.set(n),l.material.opacity=u),c.updateMatrix(),l.updateMatrix()}})}getAxisVector(t,e=!0){const i=new THREE.Vector3;return"x"===t?i.set(e?1:-1,0,0):"y"===t?i.set(0,e?1:-1,0):"z"===t&&i.set(0,0,e?1:-1),i.applyQuaternion(this.gizmoGroup.quaternion),i.normalize()}saveToHistory(){if(this.attachedObject&&!this.startPosition.equals(this.attachedObject.position)){const t=new ParametricOperation("move",{target:this.attachedObject.uuid,position:this.attachedObject.position.toArray()},[]);this.editor.parametricModel.addOperation(t),this.attachToObject(this.editor.selectedObjects[0])}}onMouseUp(t){this.isDragging&&(this.isDragging=!1,this.saveToHistory(),this.hoveredAxis=null)}detach(){this.hoveredAxis=null,super.detach()}onDeactivate(){this.clearMoveLine(),this.hoveredAxis=null,super.onDeactivate()}}