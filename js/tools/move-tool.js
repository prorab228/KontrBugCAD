class MoveTool extends TransformToolBase{constructor(t){super("move","fa-arrows-alt",t),this.useLocalCoordinates=!1,this.moveLine=null,this.moveLineGeometry=null,this.moveLineMaterial=null,this.distanceInput=null,this.startWorldPosition=new THREE.Vector3,this.showMoveLine=!0,this.lineThickness=.3,this.arrowBaseLength=7,this.arrowHeadBaseLength=1.5,this.arrowHeadBaseRadius=1,this.lineBaseRadius=.05,this.minArrowLength=2,this.arrowOffset=2,this.axisArrows={x:{line:null,cone:null,group:null,axis:"x",positive:!0},y:{line:null,cone:null,group:null,axis:"y",positive:!0},z:{line:null,cone:null,group:null,axis:"z",positive:!0},nx:{line:null,cone:null,group:null,axis:"x",positive:!1},ny:{line:null,cone:null,group:null,axis:"y",positive:!1},nz:{line:null,cone:null,group:null,axis:"z",positive:!1}},this.hoveredAxis=null,this.lastDistance=0,this.lastDragAxis=null,this.frameCount=0,this.updateInterval=3,this.minDistanceChange=.5,this.cachedVectors={currentWorldPos:new THREE.Vector3,midPoint:new THREE.Vector3,direction:new THREE.Vector3,cameraDirection:new THREE.Vector3,perpDirection:new THREE.Vector3,objectCenter:new THREE.Vector3},this._inputContainer=null,this._inputElement=null,this._inputValue=null,this._isInputFocused=!1,this._lastInputDistance=0,this._isDragging=!1,this._currentDragAxis=null,this._currentDragPositive=null,this.initGizmo(),this._moveLinesInitialized=!1}initGizmo(){for(;this.gizmoGroup.children.length>0;){const t=this.gizmoGroup.children[0];t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose(),this.gizmoGroup.remove(t)}this.createTranslateGizmo(),this.gizmoGroup.visible=!1,this.initMoveLine()}initMoveLine(){this._moveLinesInitialized||(this.moveLineGeometry=new THREE.CylinderBufferGeometry(this.lineThickness/2,this.lineThickness/2,1,6,1,!1),this.moveLineMaterial=new THREE.MeshBasicMaterial({color:65280,transparent:!0,opacity:.7,side:THREE.DoubleSide,depthTest:!0,depthWrite:!0}),this.moveLine=new THREE.Mesh(this.moveLineGeometry,this.moveLineMaterial),this.moveLine.name="move_tool_line",this.moveLine.visible=!1,this.moveLine.renderOrder=999,this.moveLine.userData.isMoveToolLine=!0,this.editor.scene.add(this.moveLine),this.initDistanceInput(),this._moveLinesInitialized=!0)}initDistanceInput(){this._inputContainer=document.createElement("div"),this._inputContainer.className="distance-input-container",this._inputElement=document.createElement("input"),this._inputElement.type="number",this._inputElement.step="0.1",this._inputContainer.appendChild(this._inputElement),document.body.appendChild(this._inputContainer),this._inputElement.addEventListener("focus",()=>{this._isInputFocused=!0}),this._inputElement.addEventListener("blur",()=>{this._isInputFocused=!1}),this._inputElement.addEventListener("input",t=>{const e=parseFloat(t.target.value);isNaN(e)||this.updateFromInput(e)})}updateFromInput(t){if(!this.attachedObject||!this._currentDragAxis||!this._currentDragPositive)return;this.attachedObject.userData.transformStartState||(this.attachedObject.userData.transformStartState={position:this.attachedObject.position.clone(),rotation:this.attachedObject.rotation.clone(),scale:this.attachedObject.scale.clone()});const e=t*(this._currentDragPositive?1:-1),i=this.getAxisVector(this._currentDragAxis,!0).clone().multiplyScalar(e);this.attachedObject.position.copy(this.startPosition).add(i),this.moveDelta.copy(i),this.updateGizmoPosition(),this.moveLine&&this.moveLine.visible&&this.updateLineTransform(this.startWorldPosition,this.attachedObject.getWorldPosition(new THREE.Vector3))}createTranslateGizmo(){this.axisArrows={x:{line:null,cone:null,group:null,axis:"x",positive:!0},y:{line:null,cone:null,group:null,axis:"y",positive:!0},z:{line:null,cone:null,group:null,axis:"z",positive:!0},nx:{line:null,cone:null,group:null,axis:"x",positive:!1},ny:{line:null,cone:null,group:null,axis:"y",positive:!1},nz:{line:null,cone:null,group:null,axis:"z",positive:!1}},this.createAxisArrow("x",!0),this.createAxisArrow("y",!0),this.createAxisArrow("z",!0),this.createAxisArrow("x",!1),this.createAxisArrow("y",!1),this.createAxisArrow("z",!1)}createAxisArrow(t,e){const i=e?t:`n${t}`,s=e?1:-1,o=this.axisColors[t],n=new THREE.Group;n.name=`translate_${i}`,n.userData.type="translate",n.userData.axis=t,n.userData.positive=e,n.userData.key=i,this.axisArrows[i].group=n;const r=new THREE.CylinderBufferGeometry(this.lineBaseRadius,this.lineBaseRadius,this.arrowBaseLength,6),a=new THREE.MeshBasicMaterial({color:o,transparent:!0,opacity:.8}),h=new THREE.Mesh(r,a);h.name=`translate_line_${i}`,h.userData.axis=t,h.userData.positive=e,h.userData.key=i,this.axisArrows[i].line=h;const l=new THREE.ConeBufferGeometry(this.arrowHeadBaseRadius,this.arrowHeadBaseLength,6),c=new THREE.MeshBasicMaterial({color:o,transparent:!0,opacity:.8}),d=new THREE.Mesh(l,c);d.name=`translate_cone_${i}`,d.userData.axis=t,d.userData.positive=e,d.userData.key=i,this.axisArrows[i].cone=d,"x"===t?(h.rotation.z=-Math.PI/2,h.position.x=s*this.arrowBaseLength/2,e?(d.rotation.z=-Math.PI/2,d.position.x=this.arrowBaseLength+this.arrowHeadBaseLength/2):(d.rotation.z=Math.PI/2,d.position.x=-this.arrowBaseLength-this.arrowHeadBaseLength/2)):"y"===t?(h.position.y=s*this.arrowBaseLength/2,e?(d.rotation.x=0,d.position.y=this.arrowBaseLength+this.arrowHeadBaseLength/2):(d.rotation.x=Math.PI,d.position.y=-this.arrowBaseLength-this.arrowHeadBaseLength/2)):"z"===t&&(h.rotation.x=Math.PI/2,h.position.z=s*this.arrowBaseLength/2,e?(d.rotation.x=Math.PI/2,d.position.z=this.arrowBaseLength+this.arrowHeadBaseLength/2):(d.rotation.x=-Math.PI/2,d.position.z=-this.arrowBaseLength-this.arrowHeadBaseLength/2)),n.add(h),n.add(d),this.gizmoGroup.add(n)}onActivate(){super.onActivate(),this._moveLinesInitialized||this.initMoveLine(),this.ensureCleanScene(),1===this.editor.selectedObjects.length&&this.attachToObject(this.editor.selectedObjects[0])}ensureCleanScene(){const t=this.editor.scene,e=[];t.traverse(t=>{t.name&&(t.name.includes("drag_line")||t.name.includes("drag_text"))&&e.push(t)}),e.forEach(t=>{t.parent&&t.parent.remove(t)})}getPropertiesHTML(){return`\n            <div class="property-group" data-type="move-position">\n                <h4><i class="fas fa-arrows-alt"></i> Позиция (мм)</h4>\n\n                <div class="property-row">\n                    <label>Локальные координаты:</label>\n                    <input type="checkbox" id="localCoordinates" ${this.useLocalCoordinates?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>Показывать линию перемещения:</label>\n                    <input type="checkbox" id="showMoveLine" ${this.showMoveLine?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>Толщина линии:</label>\n                    <input type="range" id="lineThickness" min="0.1" max="2" step="0.1" value="${this.lineThickness}">\n                    <span id="thicknessValue">${this.lineThickness.toFixed(1)}</span>\n                </div>\n\n                <div class="property-row">\n                    <label>X:</label>\n                    <input type="number" id="movePosX" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Y:</label>\n                    <input type="number" id="movePosY" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <label>Z:</label>\n                    <input type="number" id="movePosZ" step="any" value="0">\n                </div>\n                <div class="property-row">\n                    <button id="applyMovePosition" class="btn-small">\n                        <i class="fas fa-check"></i> Применить позицию\n                    </button>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const t=this.propertiesElement.querySelector("#movePosX"),e=this.propertiesElement.querySelector("#movePosY"),i=this.propertiesElement.querySelector("#movePosZ"),s=this.propertiesElement.querySelector("#applyMovePosition"),o=this.propertiesElement.querySelector("#localCoordinates"),n=this.propertiesElement.querySelector("#showMoveLine"),r=this.propertiesElement.querySelector("#lineThickness"),a=this.propertiesElement.querySelector("#thicknessValue");t&&(t.addEventListener("change",t=>this.onPositionChange("x",t)),t.addEventListener("input",t=>this.onPositionChange("x",t))),e&&(e.addEventListener("change",t=>this.onPositionChange("y",t)),e.addEventListener("input",t=>this.onPositionChange("y",t))),i&&(i.addEventListener("change",t=>this.onPositionChange("z",t)),i.addEventListener("input",t=>this.onPositionChange("z",t))),s&&s.addEventListener("click",()=>this.applyPositionFromInputs()),o&&(o.checked=this.useLocalCoordinates,o.addEventListener("change",t=>{this.useLocalCoordinates=t.target.checked,this.updateGizmoPosition()})),n&&(n.checked=this.showMoveLine,n.addEventListener("change",t=>{this.showMoveLine=t.target.checked,this.showMoveLine||this.hideMoveLine()})),r&&(r.value=this.lineThickness,r.addEventListener("input",t=>{this.lineThickness=parseFloat(t.target.value),a&&(a.textContent=this.lineThickness.toFixed(1)),this.moveLine&&this.moveLine.visible&&this.updateLineThickness()}))}updateLineThickness(){if(!this.moveLine||!this.moveLine.geometry)return;const t=this.moveLine.geometry,e=this.lineThickness/2,i=t.attributes.position.array,s=i.length/3;for(let t=0;t<s;t++){const s=i[3*t],o=i[3*t+1];if(Math.abs(s)>.001||Math.abs(o)>.001){const n=Math.atan2(o,s);i[3*t]=Math.cos(n)*e,i[3*t+1]=Math.sin(n)*e}}t.attributes.position.needsUpdate=!0,t.computeBoundingSphere()}hideMoveLine(){this.moveLine&&(this.moveLine.visible=!1),this._inputContainer&&(this._inputContainer.style.display="none")}clearMoveLine(){this.hideMoveLine(),this._currentDragAxis=null,this._currentDragPositive=null,this._isDragging=!1}onPositionChange(t,e){if(!this.attachedObject)return;const i=parseFloat(e.target.value);isNaN(i)||(this.hideMoveLine(),this.attachedObject.position[t]=i,this.updateGizmoPosition())}applyPositionFromInputs(){if(!this.propertiesElement||!this.attachedObject)return;const t=parseFloat(this.propertiesElement.querySelector("#movePosX").value),e=parseFloat(this.propertiesElement.querySelector("#movePosY").value),i=parseFloat(this.propertiesElement.querySelector("#movePosZ").value);if(isNaN(t)||isNaN(e)||isNaN(i))return void this.editor.showStatus("Некорректные значения позиции","error");this.hideMoveLine();const s=this.attachedObject.position.clone();this.attachedObject.position.set(t,e,i),this.updateGizmoPosition(),this.editor.history.addAction({type:"modify_position",object:this.attachedObject.uuid,data:{position:this.attachedObject.position.toArray(),previousPosition:s.toArray()}}),this.editor.showStatus(`Позиция установлена: ${t}, ${e}, ${i}`,"success")}updatePropertiesValues(){if(!this.propertiesElement||!this.attachedObject)return;const t=this.propertiesElement.querySelector("#movePosX"),e=this.propertiesElement.querySelector("#movePosY"),i=this.propertiesElement.querySelector("#movePosZ");t&&(t.value=this.attachedObject.position.x.toFixed(2)),e&&(e.value=this.attachedObject.position.y.toFixed(2)),i&&(i.value=this.attachedObject.position.z.toFixed(2))}onMouseDown(t){if(0!==t.button)return!1;this.snapEnabled=!t.ctrlKey,this.editor.updateMousePosition(t),this.lastMousePosition.copy(this.editor.mouse),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(i.length>0){let e=null,s=!0,o=i[0].object;for(;o&&!e;){if(o.userData&&o.userData.axis){e=o.userData.axis,s=o.userData.positive;break}o=o.parent}if(e){const i=s?e:`n${e}`;return this.startDragging(i,t),!0}}const s=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(s.length>0){const t=this.editor.objectsManager.findTopParent(s[0].object);if(this.canTransformObject(t))return this.clearMoveLine(),this.editor.selectSingleObject(t),this.attachToObject(t),!0}return!1}onMouseMove(t){if(super.onMouseMove(t),this.isDragging)return;this.editor.updateMousePosition(t),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const e=[];this.gizmoGroup.traverse(t=>{t instanceof THREE.Mesh&&t.userData.axis&&e.push(t)});const i=this.editor.raycaster.intersectObjects(e,!0);if(this.hoveredAxis&&(this.hoveredAxis=null),i.length>0){const t=i[0].object;this.hoveredAxis=t.userData.key}this.updateGizmoPosition()}startDragging(t,e){if(super.startDragging(t,e),this.attachedObject){let e,i;this._isDragging=!0,this.moveDelta.set(0,0,0),t.startsWith("n")?(e=t.substring(1),i=!1):(e=t,i=!0),this._currentDragAxis=e,this._currentDragPositive=i,this.currentAxisVector=this.getAxisVector(e,i);this.editor.camera.getWorldDirection(new THREE.Vector3);let s;"x"===e?s=new THREE.Vector3(0,1,0):"y"===e?s=new THREE.Vector3(0,0,1):"z"===e&&(s=new THREE.Vector3(1,0,0)),s&&(this.dragPlane=new THREE.Plane,this.dragPlane.setFromNormalAndCoplanarPoint(s,this.gizmoGroup.position)),this.attachedObject.getWorldPosition(this.startWorldPosition),this.dragAxis=e,this.dragPositive=i,this.lastDragAxis=`${e}${i?"+":"-"}`,this.setupMoveLine()}}setupMoveLine(){this.moveLine&&this.showMoveLine&&(this.moveLine.visible=!0,"x"===this.dragAxis?(this.moveLineMaterial.color.setHex(16729156),this._inputContainer.style.borderColor="#ff4444"):"y"===this.dragAxis?(this.moveLineMaterial.color.setHex(4521796),this._inputContainer.style.borderColor="#44ff44"):"z"===this.dragAxis&&(this.moveLineMaterial.color.setHex(4474111),this._inputContainer.style.borderColor="#4444ff"),this.frameCount=0,this.lastDistance=0,this._lastInputDistance=0,this._inputElement&&(this._inputElement.value="0.0"))}updateLineTransform(t,e){if(!this.moveLine||!this.moveLine.visible)return;const{midPoint:i,direction:s}=this.cachedVectors;i.addVectors(t,e).multiplyScalar(.5);const o=t.distanceTo(e);s.subVectors(e,t).normalize(),this.moveLine.position.copy(i),this.moveLine.scale.set(1,o,1),s.length()>0&&this.moveLine.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),s),this.updateDistanceInput(i,o,s)}updateDistanceInput(t,e,i){if(!this._inputContainer||this._isInputFocused)return;if(e<.1)return void(this._inputContainer.style.display="none");this.frameCount++;let s=e;if(this.attachedObject&&this._currentDragAxis){const t=this.attachedObject.getWorldPosition(new THREE.Vector3),e=this.startWorldPosition;"x"===this._currentDragAxis?s=t.x-e.x:"y"===this._currentDragAxis?s=t.y-e.y:"z"===this._currentDragAxis&&(s=t.z-e.z)}if(this.frameCount%this.updateInterval===0||Math.abs(s-this.lastDistance)>this.minDistanceChange||this.dragAxis!==this.lastDragAxis){this.lastDistance=s,this.lastDragAxis=this.dragAxis,this._lastInputDistance=s,this._inputElement.value=s.toFixed(1),this._inputContainer.style.display="block";const t=s<0;"x"===this.dragAxis?this._inputContainer.style.borderColor=t?"#ff8888":"#ff4444":"y"===this.dragAxis?this._inputContainer.style.borderColor=t?"#88ff88":"#44ff44":"z"===this.dragAxis&&(this._inputContainer.style.borderColor=t?"#8888ff":"#4444ff")}this.updateInputPosition(t,i)}updateInputPosition(t,e){if(!this._inputContainer)return;const i=this.worldToScreen(t,this.editor.camera,this.editor.renderer);this._inputContainer.style.left=`${i.x}px`,this._inputContainer.style.top=`${i.y}px`}worldToScreen(t,e,i){const s=t.clone();s.project(e);return{x:(.5*s.x+.5)*i.domElement.clientWidth,y:(-.5*s.y+.5)*i.domElement.clientHeight}}updateMoveLine(){if(!(this.moveLine&&this.attachedObject&&this.moveLine.visible&&this.showMoveLine))return;const{currentWorldPos:t}=this.cachedVectors;if(this.attachedObject.getWorldPosition(t),this.updateLineTransform(this.startWorldPosition,t),this.frameCount%5==0&&this.tooltip){const e=this.startWorldPosition.distanceTo(t);this.updateTooltipWithDistance(e)}}updateTooltipWithDistance(t){if(!this.tooltip)return;let e;e="x"===this.dragAxis?"#ff6b6b":"y"===this.dragAxis?"#51cf66":"z"===this.dragAxis?"#339af0":"#ffd43b";const i=this.getTooltipContent(),s=`\n            <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.2);">\n                <div style="display: flex; justify-content: space-between; align-items: center;">\n                    <span style="font-size: 10px; opacity: 0.8;">Общее расстояние:</span>\n                    <span style="font-weight: bold; color: ${e};">${t.toFixed(2)} мм</span>\n                </div>\n            </div>\n        `;this.tooltip.innerHTML=i+s}handleTransform(t,e){if(!this.attachedObject||!this.currentAxisVector||!this.dragPlane)return;const i=this.editor.renderer.domElement.getBoundingClientRect(),s=this.startMouse.x+t,o=this.startMouse.y+e,n=(s-i.left)/i.width*2-1,r=-(o-i.top)/i.height*2+1,a=new THREE.Raycaster;a.setFromCamera(new THREE.Vector2(n,r),this.editor.camera);const h=new THREE.Vector3;if(a.ray.intersectPlane(this.dragPlane,h)){const t=(this.startMouse.x-i.left)/i.width*2-1,e=-(this.startMouse.y-i.top)/i.height*2+1,s=new THREE.Raycaster;s.setFromCamera(new THREE.Vector2(t,e),this.editor.camera);const o=new THREE.Vector3;if(s.ray.intersectPlane(this.dragPlane,o)){const t=(new THREE.Vector3).subVectors(h,o).dot(this.currentAxisVector),e=this.currentAxisVector.clone().multiplyScalar(t);this.snapEnabled&&!this.editor.spacePressed&&(e.x=Math.round(e.x/this.moveSnapValue)*this.moveSnapValue,e.y=Math.round(e.y/this.moveSnapValue)*this.moveSnapValue,e.z=Math.round(e.z/this.moveSnapValue)*this.moveSnapValue),this.attachedObject.position.copy(this.startPosition).add(e),this.moveDelta.copy(e),this.updateGizmoPosition(),this.updateMoveLine()}}}updateGizmoPosition(){if(!this.attachedObject)return;const t=new THREE.Vector3;this.attachedObject.getWorldPosition(t),this.gizmoGroup.position.copy(t),this.useLocalCoordinates?this.gizmoGroup.quaternion.copy(this.attachedObject.quaternion):this.gizmoGroup.quaternion.identity();const e=(new THREE.Box3).setFromObject(this.attachedObject),i=new THREE.Vector3;e.getSize(i),this.gizmoGroup.scale.set(1,1,1),Object.keys(this.axisArrows).forEach(t=>{const e=this.axisArrows[t];if(!e.group)return;const s=e.axis,o=e.positive;let n;n="x"===s?i.x:"y"===s?i.y:i.z;let r=n/2+this.arrowOffset;r=Math.max(this.minArrowLength,r);let a=r-this.arrowHeadBaseLength/2;a<0&&(a=0,r=this.arrowHeadBaseLength/2);const h=a/this.arrowBaseLength,l=e.line,c=e.cone;if(l&&c){const e=o?1:-1;"x"===s?(l.position.x=e*a/2,l.scale.x=h,c.position.x=e*r):"y"===s?(l.position.y=e*a/2,l.scale.y=h,c.position.y=e*r):"z"===s&&(l.position.z=e*a/2,l.scale.z=h,c.position.z=e*r);const i=this.hoveredAxis===t,n=i?16776960:this.axisColors[s],d=i?1:.8;l.material&&(l.material.color.set(n),l.material.opacity=d),c.material&&(c.material.color.set(n),c.material.opacity=d),l.updateMatrix(),c.updateMatrix()}})}getAxisVector(t,e=!0){const i=new THREE.Vector3;return"x"===t?i.set(e?1:-1,0,0):"y"===t?i.set(0,e?1:-1,0):"z"===t&&i.set(0,0,e?1:-1),i.applyQuaternion(this.gizmoGroup.quaternion),i.normalize()}onMouseUp(t){if(super.onMouseUp(t),this._isDragging=!1,this.hoveredAxis=null,this.updateGizmoPosition(),this.moveLine&&this.moveLine.visible&&this.attachedObject){const t=this.attachedObject.getWorldPosition(new THREE.Vector3);let e=0;"x"===this._currentDragAxis?e=t.x-this.startWorldPosition.x:"y"===this._currentDragAxis?e=t.y-this.startWorldPosition.y:"z"===this._currentDragAxis&&(e=t.z-this.startWorldPosition.z);if(Math.abs(e)>.1&&this._inputContainer){this._lastInputDistance=e,this._inputElement.value=e.toFixed(1);const i=e<0;"x"===this.dragAxis?this._inputContainer.style.borderColor=i?"#ff8888":"#ff4444":"y"===this.dragAxis?this._inputContainer.style.borderColor=i?"#88ff88":"#44ff44":"z"===this.dragAxis&&(this._inputContainer.style.borderColor=i?"#8888ff":"#4444ff");const{midPoint:s,direction:o}=this.cachedVectors;s.addVectors(this.startWorldPosition,t).multiplyScalar(.5),o.subVectors(t,this.startWorldPosition).normalize(),this.updateInputPosition(s,o),this._inputContainer.style.display="block"}}}detach(){this.clearMoveLine(),this.hoveredAxis=null,super.detach()}onDeactivate(){this.clearMoveLine(),this.hoveredAxis=null,super.onDeactivate()}getTooltipContent(){return this.attachedObject?`\n            <div style="font-weight: 600; margin-bottom: 6px; color: #fff;">Перемещение (мм):</div>\n            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">\n                <div style="color: #ff6b6b;">\n                    <div style="font-size: 10px; opacity: 0.8;">ΔX</div>\n                    <div>${this.moveDelta.x.toFixed(1)}</div>\n                </div>\n                <div style="color: #51cf66;">\n                    <div style="font-size: 10px; opacity: 0.8;">ΔY</div>\n                    <div>${this.moveDelta.y.toFixed(1)}</div>\n                </div>\n                <div style="color: #339af0;">\n                    <div style="font-size: 10px; opacity: 0.8;">ΔZ</div>\n                    <div>${this.moveDelta.z.toFixed(1)}</div>\n                </div>\n            </div>\n            <div style="margin-top: 8px; font-size: 10px; opacity: 0.7; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 4px;">\n                Ctrl: ${this.snapEnabled?"с привязкой":"без привязки"}\n            </div>\n        `:""}createHistoryAction(){return this.attachedObject&&this.attachedObject.userData.transformStartState?{type:"modify_position",object:this.attachedObject.uuid,data:{position:this.attachedObject.position.toArray(),previousPosition:this.attachedObject.userData.transformStartState.position.toArray()}}:null}getHistoryActionType(){return"modify_position"}}