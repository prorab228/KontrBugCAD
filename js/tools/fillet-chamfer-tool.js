class FilletChamferTool extends Tool{constructor(e){super("filletChamfer","fa-shapes",e),this.requiresSelection=!0,this.type="chamfer",this.distance=5,this.angle=45,this.targetObject=null,this.selectedEdges=new Map,this.previewMesh=null,this.tempVisuals=[],this.raycaster=new THREE.Raycaster,this.mouse=new THREE.Vector2,this.autoPreview=!0,this.tolerance=.1}onActivate(){if(this.canActivate()){if(1!==this.editor.selectedObjects.length)return this.editor.showStatus("Выберите один объект для обработки","error"),void this.editor.toolManager.restorePreviousTool();if(this.targetObject=this.editor.selectedObjects[0],!this.targetObject.geometry)return this.editor.showStatus("Объект не имеет геометрии","error"),void this.editor.toolManager.restorePreviousTool();this.prepareGeometry(),this.selectedEdges.clear(),this.createPropertiesPanel(),this.editor.showStatus("Кликните по грани для выбора ребра. Shift добавляет к выделению.","info")}else this.editor.toolManager.restorePreviousTool()}onDeactivate(){this.cleanup(),this.removePropertiesPanel()}prepareGeometry(){let e=this.targetObject.geometry;e.index||(e=e.toNonIndexed()),THREE.BufferGeometryUtils?.mergeVertices&&(e=THREE.BufferGeometryUtils.mergeVertices(e,this.tolerance)),this.targetObject.geometry=e}onMouseDown(e){if(0!==e.button||!this.targetObject)return!1;this.updateMousePosition(e),this.raycaster.setFromCamera(this.mouse,this.editor.camera);const t=this.raycaster.intersectObject(this.targetObject,!0);if(0===t.length)return!1;const i=t[0];if(void 0===i.faceIndex)return!1;const s=this.getEdgesOfFace(i.faceIndex);if(0===s.length)return!1;e.shiftKey||(this.selectedEdges.clear(),this.clearTempVisuals());const r=(new THREE.Matrix4).copy(this.targetObject.matrixWorld).invert();return s.forEach(e=>{const t=e.v1.clone().applyMatrix4(r),i=e.v2.clone().applyMatrix4(r),s=this.getEdgeKey(t,i);this.selectedEdges.has(s)||(this.selectedEdges.set(s,{v1Local:t,v2Local:i,v1World:e.v1.clone(),v2World:e.v2.clone()}),this.highlightEdge(e.v1,e.v2))}),this.updateSelectionInfo(),this.autoPreview&&this.updatePreview(),!0}getEdgesOfFace(e){const t=this.targetObject.geometry,i=t.attributes.position,s=t.index;if(!s)return[];const r=3*e,o=s.array[r],a=s.array[r+1],n=s.array[r+2],l=(new THREE.Vector3).fromBufferAttribute(i,o),c=(new THREE.Vector3).fromBufferAttribute(i,a),h=(new THREE.Vector3).fromBufferAttribute(i,n);l.applyMatrix4(this.targetObject.matrixWorld),c.applyMatrix4(this.targetObject.matrixWorld),h.applyMatrix4(this.targetObject.matrixWorld);return[{v1:l.clone(),v2:c.clone()},{v1:c.clone(),v2:h.clone()},{v1:h.clone(),v2:l.clone()}].filter(e=>this.isEdgeSharp(e.v1,e.v2))}isEdgeSharp(e,t){const i=this.targetObject.geometry,s=i.attributes.position,r=i.index;if(!r)return!0;const o=(new THREE.Matrix4).copy(this.targetObject.matrixWorld).invert(),a=e.clone().applyMatrix4(o),n=t.clone().applyMatrix4(o),l=this.tolerance,c=[];for(let e=0;e<r.count;e+=3){const t=r.array[e],i=r.array[e+1],o=r.array[e+2],h=(new THREE.Vector3).fromBufferAttribute(s,t),d=(new THREE.Vector3).fromBufferAttribute(s,i),p=(new THREE.Vector3).fromBufferAttribute(s,o),u=h.distanceTo(a)<l||d.distanceTo(a)<l||p.distanceTo(a)<l,m=h.distanceTo(n)<l||d.distanceTo(n)<l||p.distanceTo(n)<l;if(u&&m){const e=d.clone().sub(h),t=p.clone().sub(h),i=(new THREE.Vector3).crossVectors(e,t).normalize();isNaN(i.x)||c.push(i)}}if(c.length<2)return!0;let h=-1/0;for(let e=0;e<c.length;e++)for(let t=e+1;t<c.length;t++){const i=c[e].dot(c[t]);i>h&&(h=i)}const d=Math.acos(Math.max(-1,Math.min(1,h)));return THREE.MathUtils.radToDeg(d)>1}updatePreview(){if(this.clearPreview(),0===this.selectedEdges.size)return;const e=[];this.selectedEdges.forEach(t=>{e.push(t.v1World,t.v2World)});const t=(new THREE.BufferGeometry).setFromPoints(e),i=new THREE.LineBasicMaterial({color:16755200}),s=new THREE.LineSegments(t,i);this.previewMesh=s,this.editor.scene.add(this.previewMesh)}applyOperation(){if(0===this.selectedEdges.size)return void this.editor.showStatus("Не выбраны рёбра","warning");const e=Array.from(this.selectedEdges.values()).map(e=>({v1:[e.v1Local.x,e.v1Local.y,e.v1Local.z],v2:[e.v2Local.x,e.v2Local.y,e.v2Local.z]}));console.log("Сохранённые рёбра (локальные):",e.map(e=>({v1:e.v1.map(e=>e.toFixed(2)),v2:e.v2.map(e=>e.toFixed(2))})));const t={targetId:this.targetObject.uuid,type:this.type,distance:this.distance,angle:this.angle,edges:e},i=new ParametricOperation("filletChamfer",t,[this.targetObject.uuid]),s=this.editor.parametricModel.addOperation(i);this.editor.clearSelection(),s.forEach(e=>{const t=this.editor.parametricModel.objectMap.get(e);t&&(this.editor.selectedObjects.push(t),this.editor.objectsManager.highlightObject(t))}),this.editor.showStatus(("chamfer"===this.type?"Фаска":"Скругление")+" созданы","success"),this.cleanup(),this.editor.toolManager.setCurrentTool("select")}createPropertiesPanel(){const e=document.getElementById("propertiesContent");e&&(this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","filletChamfer"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindEvents())}removePropertiesPanel(){const e=document.querySelector('.property-group[data-tool="filletChamfer"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <h4><i class="fas fa-shapes"></i> Фаска / Скругление</h4>\n            <div class="property-row">\n                <label>Тип:</label>\n                <select id="fcType">\n                    <option value="chamfer" ${"chamfer"===this.type?"selected":""}>Ровная фаска</option>\n                    <option value="fillet" ${"fillet"===this.type?"selected":""} disabled>Скругление (в разработке)</option>\n                </select>\n            </div>\n            <div class="property-row">\n                <label>${"chamfer"===this.type?"Расстояние":"Радиус"}:</label>\n                <input type="number" id="fcDistance" value="${this.distance}" min="0.1" max="100" step="0.1">\n                <span class="unit">мм</span>\n            </div>\n            ${"chamfer"===this.type?`\n            <div class="property-row">\n                <label>Угол:</label>\n                <input type="number" id="fcAngle" value="${this.angle}" min="1" max="89" step="1">\n                <span class="unit">°</span>\n            </div>`:""}\n            <div class="property-row">\n                <label>Автопредпросмотр:</label>\n                <input type="checkbox" id="fcAutoPreview" ${this.autoPreview?"checked":""}>\n            </div>\n            <div class="property-row">\n                <button class="btn btn-primary" id="fcApply">Применить</button>\n                <button class="btn btn-secondary" id="fcCancel">Отмена</button>\n            </div>\n            <div class="property-row">\n                <span id="fcSelectionInfo">Выбрано рёбер: ${this.selectedEdges.size}</span>\n            </div>\n        `}bindEvents(){document.getElementById("fcType")?.addEventListener("change",e=>{this.type=e.target.value,this.removePropertiesPanel(),this.createPropertiesPanel(),this.autoPreview&&this.updatePreview()}),document.getElementById("fcDistance")?.addEventListener("input",e=>{this.distance=parseFloat(e.target.value),this.autoPreview&&this.updatePreview()}),document.getElementById("fcAngle")?.addEventListener("input",e=>{this.angle=parseFloat(e.target.value),this.autoPreview&&this.updatePreview()}),document.getElementById("fcAutoPreview")?.addEventListener("change",e=>{this.autoPreview=e.target.checked,this.autoPreview&&this.updatePreview()}),document.getElementById("fcApply")?.addEventListener("click",()=>this.applyOperation()),document.getElementById("fcCancel")?.addEventListener("click",()=>{this.cleanup(),this.editor.toolManager.setCurrentTool("select")})}updateSelectionInfo(){const e=document.getElementById("fcSelectionInfo");e&&(e.textContent=`Выбрано рёбер: ${this.selectedEdges.size}`)}highlightEdge(e,t){const i=(new THREE.BufferGeometry).setFromPoints([e,t]),s=new THREE.LineBasicMaterial({color:65280}),r=new THREE.Line(i,s);r.userData.isEdgeHighlight=!0,this.editor.scene.add(r),this.tempVisuals.push(r)}clearTempVisuals(){this.tempVisuals.forEach(e=>{this.editor.scene.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.tempVisuals=[]}clearPreview(){this.previewMesh&&(this.editor.scene.remove(this.previewMesh),this.previewMesh.geometry&&this.previewMesh.geometry.dispose(),this.previewMesh.material&&this.previewMesh.material.dispose(),this.previewMesh=null)}cleanup(){this.clearPreview(),this.clearTempVisuals(),this.selectedEdges.clear(),this.targetObject=null}updateMousePosition(e){const t=this.editor.renderer.domElement.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/t.width*2-1,this.mouse.y=-(e.clientY-t.top)/t.height*2+1}getEdgeKey(e,t){const i=e.clone().multiplyScalar(1e3).round(),s=t.clone().multiplyScalar(1e3).round();return[i.x,i.y,i.z,s.x,s.y,s.z].sort().join("|")}}