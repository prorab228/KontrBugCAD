import*as THREE from"three";import{ParametricOperation}from"/js/core/parametric/ParametricOperation.js";import{Tool}from"./tool.js";export class FilletChamferTool extends Tool{constructor(e){super("filletChamfer","fa-shapes",e),this.requiresSelection=!0,this.type="chamfer",this.distance=5,this.angle=45,this.targetObject=null,this.selectedEdges=new Map,this.previewGroup=new THREE.Group,this.tempVisuals=[],this.raycaster=new THREE.Raycaster,this.mouse=new THREE.Vector2,this.autoPreview=!0,this.tolerance=.1,this.selectWholeFace=!0,this.edgeToTriangles=null,this.faceNormalTolerance=1}onActivate(){if(this.canActivate()){if(1!==this.editor.selectedObjects.length)return this.editor.showStatus("Выберите один объект для обработки","error"),void this.editor.toolManager.restorePreviousTool();if(this.targetObject=this.editor.selectedObjects[0],!this.targetObject.geometry)return this.editor.showStatus("Объект не имеет геометрии","error"),void this.editor.toolManager.restorePreviousTool();this.prepareGeometry(),this.buildAdjacency(),this.selectedEdges.clear(),this.editor.scene.add(this.previewGroup),this.createPropertiesPanel(),this.editor.showStatus("Кликните по грани для выбора ребра. Shift добавляет, Ctrl переключает.","info")}else this.editor.toolManager.restorePreviousTool()}onDeactivate(){this.cleanup(),this.removePropertiesPanel()}prepareGeometry(){let e=this.targetObject.geometry;e.index||(e=e.toNonIndexed()),THREE.BufferGeometryUtils?.mergeVertices&&(e=THREE.BufferGeometryUtils.mergeVertices(e,this.tolerance)),this.targetObject.geometry=e}buildAdjacency(){const e=this.targetObject.geometry.index;if(e){this.edgeToTriangles=new Map;for(let t=0;t<e.count;t+=3){const r=t/3,s=e.array[t],i=e.array[t+1],o=e.array[t+2],a=(e,t)=>{const s=e<t?`${e}|${t}`:`${t}|${e}`;this.edgeToTriangles.has(s)||this.edgeToTriangles.set(s,[]),this.edgeToTriangles.get(s).push(r)};a(s,i),a(i,o),a(o,s)}}}onMouseDown(e){if(0!==e.button||!this.targetObject)return!1;this.updateMousePosition(e),this.raycaster.setFromCamera(this.mouse,this.editor.camera);const t=this.raycaster.intersectObject(this.targetObject,!0);if(0===t.length)return!1;const r=t[0];if(void 0===r.faceIndex)return!1;let s=[];if(this.selectWholeFace){const e=this.getTrianglesOfFace(r.faceIndex);console.log(`Найдено треугольников в связной грани: ${e.length}`);const t=new Map;e.forEach(e=>{const r=this.getEdgesOfFace(e);console.log(`  Треугольник ${e}: получили ${r.length} рёбер`),r.forEach(e=>{const r=(new THREE.Matrix4).copy(this.targetObject.matrixWorld).invert(),s=e.v1.clone().applyMatrix4(r),i=e.v2.clone().applyMatrix4(r),o=this.getEdgeKey(s,i);t.has(o)||t.set(o,e)})}),console.log(`Всего уникальных рёбер в грани: ${t.size}`),s=Array.from(t.values())}else s=this.getEdgesOfFace(r.faceIndex);if(0===s.length)return!1;const i=e.shiftKey,o=e.ctrlKey;i||o||(this.selectedEdges.clear(),this.clearTempVisuals());const a=(new THREE.Matrix4).copy(this.targetObject.matrixWorld).invert();return s.forEach(e=>{const t=this.getEdgeNormals(e.v1,e.v2);if(t.length<2)return;const r=e.v1.clone().applyMatrix4(a),s=e.v2.clone().applyMatrix4(a),i=this.getEdgeKey(r,s);o?this.selectedEdges.has(i)?this.selectedEdges.delete(i):this.selectedEdges.set(i,{v1Local:r,v2Local:s,v1World:e.v1.clone(),v2World:e.v2.clone(),normals:t,convex:!0}):this.selectedEdges.has(i)||this.selectedEdges.set(i,{v1Local:r,v2Local:s,v1World:e.v1.clone(),v2World:e.v2.clone(),normals:t,convex:!0})}),this.clearTempVisuals(),this.selectedEdges.forEach(e=>{this.highlightEdge(e.v1World,e.v2World)}),this.updateSelectionInfo(),this.autoPreview&&this.updatePreview(),!0}getTrianglesOfFace(e){const t=this.targetObject.geometry,r=t.index,s=t.attributes.position;if(!r||!this.edgeToTriangles)return[e];const i=r.array[3*e],o=r.array[3*e+1],a=r.array[3*e+2],n=(new THREE.Vector3).fromBufferAttribute(s,i),c=(new THREE.Vector3).fromBufferAttribute(s,o),l=(new THREE.Vector3).fromBufferAttribute(s,a),h=c.clone().sub(n),d=l.clone().sub(n),u=(new THREE.Vector3).crossVectors(h,d).normalize(),p=Math.cos(THREE.MathUtils.degToRad(this.faceNormalTolerance)),g=new Set,m=[e];for(g.add(e);m.length;){const e=m.shift(),t=r.array[3*e],i=r.array[3*e+1],o=r.array[3*e+2],a=[t<i?`${t}|${i}`:`${i}|${t}`,i<o?`${i}|${o}`:`${o}|${i}`,o<t?`${o}|${t}`:`${t}|${o}`];for(const t of a){const i=this.edgeToTriangles.get(t)||[];for(const t of i){if(t===e)continue;if(g.has(t))continue;const i=r.array[3*t],o=r.array[3*t+1],a=r.array[3*t+2],n=(new THREE.Vector3).fromBufferAttribute(s,i),c=(new THREE.Vector3).fromBufferAttribute(s,o),l=(new THREE.Vector3).fromBufferAttribute(s,a),h=c.clone().sub(n),d=l.clone().sub(n),f=(new THREE.Vector3).crossVectors(h,d).normalize();u.dot(f)>p&&(g.add(t),m.push(t))}}}return Array.from(g)}getEdgeNormals(e,t){const r=this.targetObject.geometry,s=r.attributes.position,i=r.index;if(!i)return[];const o=(new THREE.Matrix4).copy(this.targetObject.matrixWorld).invert(),a=e.clone().applyMatrix4(o),n=t.clone().applyMatrix4(o),c=.1,l=[];for(let e=0;e<i.count;e+=3){const t=i.array[e],r=i.array[e+1],o=i.array[e+2],h=(new THREE.Vector3).fromBufferAttribute(s,t),d=(new THREE.Vector3).fromBufferAttribute(s,r),u=(new THREE.Vector3).fromBufferAttribute(s,o),p=h.distanceTo(a)<c||d.distanceTo(a)<c||u.distanceTo(a)<c,g=h.distanceTo(n)<c||d.distanceTo(n)<c||u.distanceTo(n)<c;if(p&&g){const e=d.clone().sub(h),t=u.clone().sub(h),r=(new THREE.Vector3).crossVectors(e,t).normalize();isNaN(r.x)||(r.applyQuaternion(this.targetObject.quaternion),l.push(r))}}return l}getEdgesOfFace(e){const t=this.targetObject.geometry,r=t.attributes.position,s=t.index;if(!s)return[];const i=3*e,o=s.array[i],a=s.array[i+1],n=s.array[i+2],c=(new THREE.Vector3).fromBufferAttribute(r,o),l=(new THREE.Vector3).fromBufferAttribute(r,a),h=(new THREE.Vector3).fromBufferAttribute(r,n);c.applyMatrix4(this.targetObject.matrixWorld),l.applyMatrix4(this.targetObject.matrixWorld),h.applyMatrix4(this.targetObject.matrixWorld);return[{v1:c.clone(),v2:l.clone()},{v1:l.clone(),v2:h.clone()},{v1:h.clone(),v2:c.clone()}].filter(e=>this.isEdgeSharp(e.v1,e.v2))}isEdgeSharp(e,t){const r=this.getEdgeNormals(e,t);if(r.length<2)return!1;let s=-1/0;for(let e=0;e<r.length;e++)for(let t=e+1;t<r.length;t++){const i=r[e].dot(r[t]);i>s&&(s=i)}const i=Math.acos(Math.max(-1,Math.min(1,s)));return THREE.MathUtils.radToDeg(i)>1}updatePreview(){this.clearPreview(),0!==this.selectedEdges.size&&this.selectedEdges.forEach(e=>{const t=this.buildChamferMesh(e.v1World,e.v2World,e.normals,this.distance,this.angle,3368703,.3);t&&this.previewGroup.add(t)})}buildChamferMesh(e,t,r,s,i,o,a){if(r.length<2)return null;const n=THREE.MathUtils.degToRad(i),c=s/Math.tan(n);if(Math.abs(c)<1e-6)return null;const l=1.2*c;let h=r[0].clone().normalize(),d=r[1].clone().normalize();const u=(new THREE.Box3).setFromObject(this.targetObject),p=new THREE.Vector3;u.getCenter(p);const g=e.clone().add(t).multiplyScalar(.5),m=p.clone().sub(g).normalize();h.dot(m)<0&&h.negate(),d.dot(m)<0&&d.negate();const f=h.dot(d);if(Math.abs(f)>.999)return null;const E=e.clone(),v=t.clone(),y=E.clone().addScaledVector(h,1*l),b=E.clone().addScaledVector(d,1*l),w=v.clone().addScaledVector(h,1*l),T=v.clone().addScaledVector(d,1*l),x=[E.x,E.y,E.z,y.x,y.y,y.z,b.x,b.y,b.z,v.x,v.y,v.z,w.x,w.y,w.z,T.x,T.y,T.z],M=new THREE.BufferGeometry;if(M.setAttribute("position",new THREE.Float32BufferAttribute(x,3)),M.setIndex([0,2,1,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),M.computeVertexNormals(),M.index.count<3)return null;const P=new THREE.MeshPhongMaterial({color:o,transparent:!0,opacity:a,side:THREE.DoubleSide,emissive:0});return new THREE.Mesh(M,P)}applyOperation(){if(0===this.selectedEdges.size)return void this.editor.showStatus("Не выбраны рёбра","warning");const e=Array.from(this.selectedEdges.values()).map(e=>({v1:[e.v1Local.x,e.v1Local.y,e.v1Local.z],v2:[e.v2Local.x,e.v2Local.y,e.v2Local.z]})),t={targetId:this.targetObject.uuid,type:this.type,distance:this.distance,angle:this.angle,edges:e},r=new ParametricOperation("filletChamfer",t,[this.targetObject.uuid]);try{const e=this.editor.parametricModel.addOperation(r);this.editor.clearSelection(),e.forEach(e=>{const t=this.editor.parametricModel.objectMap.get(e);t&&(this.editor.selectedObjects.push(t),this.editor.objectsManager.highlightObject(t))}),this.editor.showStatus(("chamfer"===this.type?"Фаска":"Скругление")+" созданы","success"),this.cleanup(),this.editor.toolManager.setCurrentTool("select")}catch(e){console.error("Ошибка при выполнении фаски:",e),this.editor.showStatus("Не удалось создать фаску. Проверьте параметры.","error"),this.showErrorPreview()}}showErrorPreview(){this.clearPreview(),this.selectedEdges.forEach(e=>{const t=this.buildChamferMesh(e.v1World,e.v2World,e.normals,this.distance,this.angle,16724787,.5);t&&this.previewGroup.add(t)})}createPropertiesPanel(){const e=document.getElementById("propertiesContent");e&&(this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","filletChamfer"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindEvents())}removePropertiesPanel(){const e=document.querySelector('.property-group[data-tool="filletChamfer"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <h4><i class="fas fa-shapes"></i> Фаска / Скругление</h4>\n            <div class="property-row">\n                <label>Тип:</label>\n                <select id="fcType">\n                    <option value="chamfer" ${"chamfer"===this.type?"selected":""}>Ровная фаска</option>\n                    <option value="fillet" ${"fillet"===this.type?"selected":""} disabled>Скругление (в разработке)</option>\n                </select>\n            </div>\n            <div class="property-row">\n                <label>${"chamfer"===this.type?"Расстояние":"Радиус"}:</label>\n                <input type="number" id="fcDistance" value="${this.distance}" min="0.1" max="100" step="0.1">\n                <span class="unit">мм</span>\n            </div>\n            ${"chamfer"===this.type?`\n            <div class="property-row">\n                <label>Угол:</label>\n                <input type="number" id="fcAngle" value="${this.angle}" min="1" max="89" step="1">\n                <span class="unit">°</span>\n            </div>`:""}\n            <div class="property-row">\n                <label>Автопредпросмотр:</label>\n                <input type="checkbox" id="fcAutoPreview" ${this.autoPreview?"checked":""}>\n            </div>\n            <div class="property-row">\n                <label>Выделять всю грань:</label>\n                <input type="checkbox" id="fcSelectWholeFace" ${this.selectWholeFace?"checked":""}>\n            </div>\n            <div class="property-row">\n                <button class="btn btn-primary" id="fcApply">Применить</button>\n                <button class="btn btn-secondary" id="fcCancel">Отмена</button>\n            </div>\n            <div class="property-row">\n                <span id="fcSelectionInfo">Выбрано рёбер: ${this.selectedEdges.size}</span>\n            </div>\n        `}bindEvents(){document.getElementById("fcType")?.addEventListener("change",e=>{this.type=e.target.value,this.removePropertiesPanel(),this.createPropertiesPanel(),this.autoPreview&&this.updatePreview()}),document.getElementById("fcDistance")?.addEventListener("input",e=>{this.distance=parseFloat(e.target.value),this.autoPreview&&this.updatePreview()}),document.getElementById("fcAngle")?.addEventListener("input",e=>{this.angle=parseFloat(e.target.value),this.autoPreview&&this.updatePreview()}),document.getElementById("fcAutoPreview")?.addEventListener("change",e=>{this.autoPreview=e.target.checked,this.autoPreview?this.updatePreview():this.clearPreview()}),document.getElementById("fcSelectWholeFace")?.addEventListener("change",e=>{this.selectWholeFace=e.target.checked}),document.getElementById("fcApply")?.addEventListener("click",()=>this.applyOperation()),document.getElementById("fcCancel")?.addEventListener("click",()=>{this.cleanup(),this.editor.toolManager.setCurrentTool("select")})}updateSelectionInfo(){const e=document.getElementById("fcSelectionInfo");e&&(e.textContent=`Выбрано рёбер: ${this.selectedEdges.size}`)}highlightEdge(e,t){const r=(new THREE.BufferGeometry).setFromPoints([e,t]),s=new THREE.LineBasicMaterial({color:65280}),i=new THREE.Line(r,s);i.userData.isEdgeHighlight=!0,this.editor.scene.add(i),this.tempVisuals.push(i)}clearTempVisuals(){this.tempVisuals.forEach(e=>{this.editor.scene.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.tempVisuals=[]}clearPreview(){for(;this.previewGroup.children.length;){const e=this.previewGroup.children[0];e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose()),this.previewGroup.remove(e)}}cleanup(){this.clearPreview(),this.clearTempVisuals(),this.previewGroup.parent&&this.editor.scene.remove(this.previewGroup),this.selectedEdges.clear(),this.targetObject=null,this.edgeToTriangles=null}updateMousePosition(e){const t=this.editor.renderer.domElement.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/t.width*2-1,this.mouse.y=-(e.clientY-t.top)/t.height*2+1}getEdgeKey(e,t){const r=e.clone().multiplyScalar(1e3).round(),s=t.clone().multiplyScalar(1e3).round();return r.x<s.x||r.x===s.x&&(r.y<s.y||r.y===s.y&&r.z<s.z)?`${r.x},${r.y},${r.z}|${s.x},${s.y},${s.z}`:`${s.x},${s.y},${s.z}|${r.x},${r.y},${r.z}`}}