class RulerTool extends Tool{constructor(e){super("rulerTool","fa-ruler",e),this.points=[],this.allMeasurements=[],this.tempLine=null,this.tempMarker=null,this.tempStartMarker=null,this.highlightedEdge=null,this.currentIntersection=null,this.snapToVertices=!0,this.snapToEdges=!0,this.shortestDistanceMode=!0,this.vertexSnapThreshold=2,this.edgeSnapThreshold=1,this.lineMaterial=new THREE.LineBasicMaterial({color:65280,linewidth:2,depthTest:!1,depthWrite:!1}),this.edgeHighlightMaterial=new THREE.LineBasicMaterial({color:16733525,linewidth:8,depthTest:!1,transparent:!0,opacity:1}),this.markerMaterial=new THREE.MeshBasicMaterial({color:16711680}),this.startMarkerMaterial=new THREE.MeshBasicMaterial({color:16733440}),this.vertexGeometry=new THREE.SphereGeometry(.5,8,8),this.snapEdge1=null,this.snapEdge2=null,this.snapVertex1=null,this.snapVertex2=null,this.snapType1=null,this.snapType2=null}onActivate(){this.clear(),this.createPropertiesSection(),document.body.style.cursor="crosshair",this.editor.showStatus("Линейка: кликните первую точку измерения (ESC - отмена)","info")}onDeactivate(){this.clear(),this.removePropertiesSection(),document.body.style.cursor="default",this.clearAllMeasurements(),this.clearHighlights(),this.resetSnapData()}onMouseDown(e){if(0!==e.button)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(t.length>0){const e=t[0];let s;return s=this.snapToVertices||this.snapToEdges?this.snapToGeometry(e):{point:e.point.clone(),type:"face",data:null},this.addPoint(s),!0}{const e=new THREE.Plane(new THREE.Vector3(0,1,0),0),t=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(e,t))return this.addPoint({point:t.clone(),type:"plane",data:null}),!0}return!1}onMouseMove(e){this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera),this.clearHighlights();const t=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(t.length>0){const e=t[0];let s;this.currentIntersection=e,s=this.snapToVertices||this.snapToEdges?this.snapToGeometry(e):{point:e.point.clone(),type:"face",data:null},this.showMarker(s.point),this.points.length>0&&this.updateTempLine(s.point),this.showHoverDistance(s.point)}else{this.hideMarker(),this.currentIntersection=null;const e=new THREE.Plane(new THREE.Vector3(0,1,0),0),t=new THREE.Vector3;this.editor.raycaster.ray.intersectPlane(e,t)&&(this.showMarker(t),this.points.length>0&&this.updateTempLine(t),this.showHoverDistance(t))}return!0}snapToGeometry(e){if(!e.object||!e.object.geometry)return{point:e.point.clone(),type:"face",data:null};let t=e.point.clone(),s=1/0,i=!1,r="face",n=null;if(this.snapToVertices){const o=this.snapToVertex(e);if(o){const a=o.point.distanceTo(e.point);a<s&&(t=o.point,s=a,r="vertex",n=o.data,i=!0)}}if(this.snapToEdges&&!i){const o=this.snapToEdge(e);if(o){const a=o.point.distanceTo(e.point);a<s&&(t=o.point,s=a,r="edge",n=o.data,i=!0)}}return i||this.clearHighlights(),{point:t,type:r,data:n}}snapToVertex(e){const t=e.object.geometry;if(!t||!t.attributes.position)return null;const s=t.attributes.position.array,i=e.object.matrixWorld;let r;r=e.uv?e.uv:new THREE.Vector3(.33,.33,.34);let n=-1;if(e.face){const t=e.face,s=[t.a,t.b,t.c];n=r.x>=r.y&&r.x>=r.z?s[0]:r.y>=r.x&&r.y>=r.z?s[1]:s[2]}else{if(void 0===e.faceIndex||!t.index)return this.findNearestVertexResult(e.point,t,i);{const s=e.faceIndex,i=t.index.array,o=[i[3*s],i[3*s+1],i[3*s+2]];n=r.x>=r.y&&r.x>=r.z?o[0]:r.y>=r.x&&r.y>=r.z?o[1]:o[2]}}if(-1===n)return null;const o=new THREE.Vector3(s[3*n],s[3*n+1],s[3*n+2]);o.applyMatrix4(i);return o.distanceTo(e.point)>this.vertexSnapThreshold?null:{point:o,data:{vertex:o.clone()}}}findNearestVertexResult(e,t,s){const i=t.attributes.position.array;let r=null,n=1/0;for(let t=0;t<i.length;t+=3){const o=new THREE.Vector3(i[t],i[t+1],i[t+2]);o.applyMatrix4(s);const a=o.distanceTo(e);a<n&&a<this.vertexSnapThreshold&&(n=a,r=o)}return r?{point:r,data:{vertex:r.clone()}}:null}snapToEdge(e){const t=e.object.geometry;if(!t||!t.attributes.position)return null;const s=t.attributes.position.array,i=e.object.matrixWorld;let r=null,n=1/0,o=null,a=[];if(e.face){const t=e.face;a=[t.a,t.b,t.c]}else{if(void 0===e.faceIndex||!t.index)return null;{const s=e.faceIndex,i=t.index.array;a=[i[3*s],i[3*s+1],i[3*s+2]]}}const h=a.map(e=>{const t=new THREE.Vector3(s[3*e],s[3*e+1],s[3*e+2]);return t.applyMatrix4(i),t}),p=[[h[0],h[1]],[h[1],h[2]],[h[2],h[0]]];for(const[t,s]of p){const i=this.getClosestPointOnSegment(e.point,t,s),a=i.distanceTo(e.point);a<n&&a<this.edgeSnapThreshold&&(n=a,r=i,o=[t.clone(),s.clone()],this.highlightEdge(t,s))}return r?{point:r,data:{edge:o}}:null}calculateShortestDistanceBetweenEdges(e,t){const s=e[0],i=e[1],r=t[0],n=t[1],o=(new THREE.Vector3).subVectors(i,s),a=(new THREE.Vector3).subVectors(n,r),h=(new THREE.Vector3).subVectors(s,r),p=o.dot(o),l=o.dot(a),c=a.dot(a),d=o.dot(h),u=a.dot(h),m=p*c-l*l;let E,g,T,y,M=m,x=m;m<1e-5?(g=0,M=1,y=u,x=c):(g=l*u-c*d,y=p*u-l*d,g<0?(g=0,y=u,x=c):g>M&&(g=M,y=u+l,x=c)),y<0?(y=0,-d<0?g=0:-d>p?g=M:(g=-d,M=p)):y>x&&(y=x,-d+l<0?g=0:-d+l>p?g=M:(g=-d+l,M=p)),E=Math.abs(g)<1e-5?0:g/M,T=Math.abs(y)<1e-5?0:y/x;const S=(new THREE.Vector3).addVectors(s,o.multiplyScalar(E));o.copy(i).sub(s);const w=(new THREE.Vector3).addVectors(r,a.multiplyScalar(T));return{point1:S,point2:w,distance:S.distanceTo(w)}}calculateShortestDistancePointToEdge(e,t){const s=t[0],i=t[1],r=(new THREE.Vector3).subVectors(i,s),n=r.length(),o=(new THREE.Vector3).subVectors(e,s);let a=r.dot(o)/(n*n);a=Math.max(0,Math.min(1,a));const h=(new THREE.Vector3).addVectors(s,r.multiplyScalar(a));return r.copy(i).sub(s),{point:h,distance:e.distanceTo(h)}}getClosestPointOnSegment(e,t,s){const i=(new THREE.Vector3).subVectors(s,t),r=(new THREE.Vector3).subVectors(e,t),n=i.length();if(n<1e-4)return t.clone();i.normalize();const o=r.dot(i);return o<=0?t.clone():o>=n?s.clone():t.clone().add(i.multiplyScalar(o))}highlightEdge(e,t){this.clearHighlights();const s=(new THREE.BufferGeometry).setFromPoints([e,t]);this.highlightedEdge=new THREE.Line(s,this.edgeHighlightMaterial),this.highlightedEdge.renderOrder=999,this.editor.scene.add(this.highlightedEdge)}clearHighlights(){this.highlightedEdge&&(this.editor.scene.remove(this.highlightedEdge),this.highlightedEdge.geometry.dispose(),this.highlightedEdge=null)}showMarker(e){if(!this.tempMarker){const e=new THREE.SphereGeometry(.5,8,8);this.tempMarker=new THREE.Mesh(e,this.markerMaterial),this.tempMarker.renderOrder=999,this.editor.scene.add(this.tempMarker)}this.tempMarker.position.copy(e),this.tempMarker.visible=!0}hideMarker(){this.tempMarker&&(this.tempMarker.visible=!1)}onKeyDown(e){return"Escape"===e.key?(this.editor.toolManager.setCurrentTool("select"),!0):("Delete"===e.key||"Backspace"===e.key)&&(this.clear(),!0)}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","rulerTool"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="rulerTool"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <div class="property-group" data-type="ruler-settings">\n                <h4>НАСТРОЙКИ ЛИНЕЙКИ</h4>\n\n                <div class="property-row">\n                    <label>Привязка к вершинам:</label>\n                    <input type="checkbox" id="snapToVertices" ${this.snapToVertices?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>Привязка к ребрам:</label>\n                    <input type="checkbox" id="snapToEdges" ${this.snapToEdges?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>Кратчайшее расстояние между ребрами:</label>\n                    <input type="checkbox" id="shortestDistanceMode" ${this.shortestDistanceMode?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>Чувствительность привязки:</label>\n                    <select id="snapSensitivity">\n                        <option value="2">Высокая</option>\n                        <option value="1" selected>Средняя</option>\n                        <option value="0.5">Низкая</option>\n                    </select>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#snapToVertices");e&&e.addEventListener("change",e=>{this.snapToVertices=e.target.checked,this.editor.showStatus("Привязка к вершинам: "+(this.snapToVertices?"ВКЛ":"ВЫКЛ"),"info")});const t=this.propertiesElement.querySelector("#snapToEdges");t&&t.addEventListener("change",e=>{this.snapToEdges=e.target.checked,this.editor.showStatus("Привязка к ребрам: "+(this.snapToEdges?"ВКЛ":"ВЫКЛ"),"info")});const s=this.propertiesElement.querySelector("#shortestDistanceMode");s&&s.addEventListener("change",e=>{this.shortestDistanceMode=e.target.checked;const t=this.shortestDistanceMode?"ВКЛ (измеряется кратчайшее расстояние между ребрами)":"ВЫКЛ (измеряется расстояние между выбранными точками)";this.editor.showStatus(`Кратчайшее расстояние: ${t}`,"info")});const i=this.propertiesElement.querySelector("#snapSensitivity");i&&(i.value=this.vertexSnapThreshold.toString(),i.addEventListener("change",e=>{const t=parseFloat(e.target.value);this.vertexSnapThreshold=2*t,this.edgeSnapThreshold=t,this.editor.showStatus(`Чувствительность: ${this.getSensitivityLabel(t)}`,"info")}))}getSensitivityLabel(e){return e>=2?"Высокая":e>=1?"Средняя":"Низкая"}showHoverDistance(e){if(0===this.points.length)document.getElementById("coords").textContent=`X: ${e.x.toFixed(2)}, Y: ${e.y.toFixed(2)}, Z: ${e.z.toFixed(2)}`;else{const t=this.points[0].point.distanceTo(e);document.getElementById("coords").textContent=`Расстояние: ${t.toFixed(2)} мм`}}addPoint(e){this.points.push(e),1===this.points.length?(this.snapType1=e.type,"edge"===e.type&&e.data&&e.data.edge?this.snapEdge1=e.data.edge:"vertex"===e.type&&e.data&&e.data.vertex&&(this.snapVertex1=e.data.vertex),this.hideMarker(),this.createStartMarker(e.point),this.editor.showStatus("Линейка: кликните вторую точку (ESC - отмена)","info")):2===this.points.length&&(this.snapType2=e.type,"edge"===e.type&&e.data&&e.data.edge?this.snapEdge2=e.data.edge:"vertex"===e.type&&e.data&&e.data.vertex&&(this.snapVertex2=e.data.vertex),this.createMeasurement(),setTimeout(()=>{this.points=[],this.resetSnapData(),this.clearTempMarker(),this.clearHighlights(),this.clearStartMarker(),this.clearTempLine(),this.editor.showStatus("Измерение завершено. Кликните для нового измерения","success")},100))}createStartMarker(e){if(!this.tempStartMarker){const e=new THREE.SphereGeometry(.5,8,8);this.tempStartMarker=new THREE.Mesh(e,this.startMarkerMaterial),this.tempStartMarker.renderOrder=1001,this.editor.scene.add(this.tempStartMarker)}this.tempStartMarker.position.copy(e),this.tempStartMarker.visible=!0}clearStartMarker(){this.tempStartMarker&&(this.editor.scene.remove(this.tempStartMarker),this.tempStartMarker.geometry&&this.tempStartMarker.geometry.dispose(),this.tempStartMarker.material&&this.tempStartMarker.material.dispose(),this.tempStartMarker=null)}clearTempMarker(){this.tempMarker&&(this.editor.scene.remove(this.tempMarker),this.tempMarker.geometry&&this.tempMarker.geometry.dispose(),this.tempMarker.material&&this.tempMarker.material.dispose(),this.tempMarker=null)}clearTempLine(){this.tempLine&&(this.editor.scene.remove(this.tempLine),this.tempLine.geometry&&this.tempLine.geometry.dispose(),this.tempLine.material&&this.tempLine.material.dispose(),this.tempLine=null)}updateTempLine(e){if(0===this.points.length)return;1!==this.points.length||this.tempStartMarker||this.createStartMarker(this.points[0].point),this.tempLine&&(this.editor.scene.remove(this.tempLine),this.tempLine.geometry.dispose());const t=(new THREE.BufferGeometry).setFromPoints([this.points[0].point,e]);this.tempLine=new THREE.Line(t,this.lineMaterial),this.tempLine.renderOrder=998,this.editor.scene.add(this.tempLine)}createMeasurement(){if(2!==this.points.length)return;let e,t,s,i=!1;if(this.shortestDistanceMode)if("edge"===this.snapType1&&"edge"===this.snapType2&&this.snapEdge1&&this.snapEdge2){const r=this.calculateShortestDistanceBetweenEdges(this.snapEdge1,this.snapEdge2);e=r.point1,t=r.point2,s=r.distance,i=!0}else if("edge"===this.snapType1&&this.snapEdge1){const r="vertex"===this.snapType2&&this.snapVertex2?this.snapVertex2:this.points[1].point,n=this.calculateShortestDistancePointToEdge(r,this.snapEdge1);e=n.point,t=r,s=n.distance,i=!0}else if("edge"===this.snapType2&&this.snapEdge2){const r="vertex"===this.snapType1&&this.snapVertex1?this.snapVertex1:this.points[0].point,n=this.calculateShortestDistancePointToEdge(r,this.snapEdge2);e=r,t=n.point,s=n.distance,i=!0}i||(e=this.points[0].point,t=this.points[1].point,s=e.distanceTo(t)),this.measurementGroup=new THREE.Group,this.measurementGroup.userData.isRulerMeasurement=!0;const r=i?11184640:43520,n=new THREE.LineBasicMaterial({color:r,linewidth:i?3:2,depthTest:!1,depthWrite:!1}),o=(new THREE.BufferGeometry).setFromPoints([e,t]),a=new THREE.Line(o,n);this.measurementGroup.add(a);const h=new THREE.MeshBasicMaterial({color:i?65535:16733440}),p=new THREE.MeshBasicMaterial({color:i?16711935:16711680}),l=new THREE.Mesh(this.vertexGeometry,h);l.position.copy(e);const c=new THREE.Mesh(this.vertexGeometry,p);c.position.copy(t),l.renderOrder=998,c.renderOrder=998,this.measurementGroup.add(l),this.measurementGroup.add(c);const d=(new THREE.Vector3).addVectors(e,t).multiplyScalar(.5),u=this.createDistanceText(s,d,i);u&&this.measurementGroup.add(u),this.editor.scene.add(this.measurementGroup),this.allMeasurements.push(this.measurementGroup);let m=`Измерение: ${s.toFixed(2)} мм`;i&&(m+=" (кратчайшее расстояние)"),this.editor.showStatus(m,"success")}createDistanceText(e,t,s=!1){try{const i=document.createElement("canvas"),r=i.getContext("2d"),n=60,o=`${e.toFixed(2)} мм`+(s?" (кр.)":"");r.font=`${n}px Arial`;const a=r.measureText(o).width,h=n;i.width=a+20,i.height=h+10,r.font=`${n}px Arial`,r.fillStyle=s?"#FFFF00":"#00ff00",r.textAlign="center",r.textBaseline="middle",r.fillText(o,i.width/2,i.height/2);const p=new THREE.CanvasTexture(i);p.needsUpdate=!0;const l=new THREE.SpriteMaterial({map:p,transparent:!0,depthTest:!1}),c=new THREE.Sprite(l);return c.renderOrder=1,c.position.copy(t),c.position.y+=5,c.scale.set(i.width/20,i.height/20,1),c}catch(e){return console.error("Ошибка создания текста:",e),null}}clearAllMeasurements(){this.allMeasurements.forEach(e=>{e.parent&&e.parent.remove(e),e.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()})}),this.allMeasurements=[]}clear(){this.clearHighlights(),this.clearTempMarker(),this.clearStartMarker(),this.clearTempLine(),this.resetSnapData(),this.points=[]}resetSnapData(){this.snapEdge1=null,this.snapEdge2=null,this.snapVertex1=null,this.snapVertex2=null,this.snapType1=null,this.snapType2=null}}