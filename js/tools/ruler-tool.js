class RulerTool extends Tool{constructor(e){super("rulerTool","fa-ruler",e),this.points=[],this.allMeasurements=[],this.tempLine=null,this.tempMarker=null,this.tempStartMarker=null,this.highlightedEdge=null,this.currentIntersection=null,this.snapToVertices=!0,this.snapToEdges=!0,this.vertexSnapThreshold=2,this.edgeSnapThreshold=1,this.lineMaterial=new THREE.LineBasicMaterial({color:65280,linewidth:2,depthTest:!1,depthWrite:!1}),this.edgeHighlightMaterial=new THREE.LineBasicMaterial({color:16733525,linewidth:8,depthTest:!1,transparent:!0,opacity:1}),this.markerMaterial=new THREE.MeshBasicMaterial({color:16711680}),this.startMarkerMaterial=new THREE.MeshBasicMaterial({color:16733440}),this.vertexGeometry=new THREE.SphereGeometry(.5,8,8)}onActivate(){this.clear(),this.createPropertiesSection(),document.body.style.cursor="crosshair",this.editor.showStatus("Линейка: кликните первую точку измерения (ESC - отмена)","info")}onDeactivate(){this.clear(),this.removePropertiesSection(),document.body.style.cursor="default",this.clearAllMeasurements(),this.clearHighlights()}onMouseDown(e){if(0!==e.button)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(t.length>0){const e=t[0];let r;return r=this.snapToVertices||this.snapToEdges?this.snapToGeometry(e):e.point.clone(),this.addPoint(r),!0}{const e=new THREE.Plane(new THREE.Vector3(0,1,0),0),t=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(e,t))return this.addPoint(t),!0}return!1}onMouseMove(e){this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera),this.clearHighlights();const t=this.editor.raycaster.intersectObjects(this.editor.objectsGroup.children,!0);if(t.length>0){const e=t[0];let r;this.currentIntersection=e,r=this.snapToVertices||this.snapToEdges?this.snapToGeometry(e):e.point.clone(),this.showMarker(r),this.points.length>0&&this.updateTempLine(r),this.showHoverDistance(r)}else{this.hideMarker(),this.currentIntersection=null;const e=new THREE.Plane(new THREE.Vector3(0,1,0),0),t=new THREE.Vector3;this.editor.raycaster.ray.intersectPlane(e,t)&&(this.showMarker(t),this.points.length>0&&this.updateTempLine(t),this.showHoverDistance(t))}return!0}snapToGeometry(e){if(!e.object||!e.object.geometry)return e.point.clone();let t=e.point.clone(),r=1/0,i=!1;if(this.snapToVertices){const s=this.snapToVertex(e);if(s){const n=s.distanceTo(e.point);n<r&&(t=s,r=n,i=!0)}}if(this.snapToEdges&&!i){const s=this.snapToEdge(e);if(s){const n=s.distanceTo(e.point);n<r&&(t=s,r=n,i=!0)}}return i||this.clearHighlights(),t}snapToVertex(e){const t=e.object.geometry;if(!t||!t.attributes.position)return null;const r=t.attributes.position.array,i=e.object.matrixWorld;let s;s=e.uv?e.uv:new THREE.Vector3(.33,.33,.34);let n=-1;if(e.face){const t=e.face,r=[t.a,t.b,t.c];n=s.x>=s.y&&s.x>=s.z?r[0]:s.y>=s.x&&s.y>=s.z?r[1]:r[2]}else{if(void 0===e.faceIndex||!t.index)return this.findNearestVertex(e.point,t,i);{const r=e.faceIndex,i=t.index.array,o=[i[3*r],i[3*r+1],i[3*r+2]];n=s.x>=s.y&&s.x>=s.z?o[0]:s.y>=s.x&&s.y>=s.z?o[1]:o[2]}}if(-1===n)return null;const o=new THREE.Vector3(r[3*n],r[3*n+1],r[3*n+2]);o.applyMatrix4(i);return o.distanceTo(e.point)>this.vertexSnapThreshold?null:o}findNearestVertex(e,t,r){const i=t.attributes.position.array;let s=null,n=1/0;for(let t=0;t<i.length;t+=3){const o=new THREE.Vector3(i[t],i[t+1],i[t+2]);o.applyMatrix4(r);const a=o.distanceTo(e);a<n&&a<this.vertexSnapThreshold&&(n=a,s=o)}return s}snapToEdge(e){const t=e.object.geometry;if(!t||!t.attributes.position)return null;const r=t.attributes.position.array,i=e.object.matrixWorld;let s=null,n=1/0,o=[];if(e.face){const t=e.face;o=[t.a,t.b,t.c]}else{if(void 0===e.faceIndex||!t.index)return null;{const r=e.faceIndex,i=t.index.array;o=[i[3*r],i[3*r+1],i[3*r+2]]}}const a=o.map(e=>{const t=new THREE.Vector3(r[3*e],r[3*e+1],r[3*e+2]);return t.applyMatrix4(i),t}),h=[[a[0],a[1]],[a[1],a[2]],[a[2],a[0]]];for(const[t,r]of h){const i=this.getClosestPointOnSegment(e.point,t,r),o=i.distanceTo(e.point);o<n&&o<this.edgeSnapThreshold&&(n=o,s=i,this.highlightEdge(t,r))}return s}getClosestPointOnSegment(e,t,r){const i=(new THREE.Vector3).subVectors(r,t),s=(new THREE.Vector3).subVectors(e,t),n=i.length();if(n<1e-4)return t.clone();i.normalize();const o=s.dot(i);return o<=0?t.clone():o>=n?r.clone():t.clone().add(i.multiplyScalar(o))}highlightEdge(e,t){this.clearHighlights();const r=(new THREE.BufferGeometry).setFromPoints([e,t]);this.highlightedEdge=new THREE.Line(r,this.edgeHighlightMaterial),this.highlightedEdge.renderOrder=999,this.editor.scene.add(this.highlightedEdge)}clearHighlights(){this.highlightedEdge&&(this.editor.scene.remove(this.highlightedEdge),this.highlightedEdge.geometry.dispose(),this.highlightedEdge=null)}showMarker(e){if(!this.tempMarker){const e=new THREE.SphereGeometry(.5,8,8);this.tempMarker=new THREE.Mesh(e,this.markerMaterial),this.tempMarker.renderOrder=999,this.editor.scene.add(this.tempMarker)}this.tempMarker.position.copy(e),this.tempMarker.visible=!0}hideMarker(){this.tempMarker&&(this.tempMarker.visible=!1)}onKeyDown(e){return"Escape"===e.key?(this.editor.toolManager.setCurrentTool("select"),!0):("Delete"===e.key||"Backspace"===e.key)&&(this.clear(),!0)}createPropertiesSection(){const e=document.getElementById("propertiesContent");e&&(this.removePropertiesSection(),this.propertiesElement=document.createElement("div"),this.propertiesElement.className="property-group",this.propertiesElement.setAttribute("data-tool","rulerTool"),this.propertiesElement.innerHTML=this.getPropertiesHTML(),e.appendChild(this.propertiesElement),this.bindPropertiesEvents())}removePropertiesSection(){const e=document.querySelector('.property-group[data-tool="rulerTool"]');e&&e.remove(),this.propertiesElement=null}getPropertiesHTML(){return`\n            <div class="property-group" data-type="ruler-settings">\n                <h4>НАСТРОЙКИ ЛИНЕЙКИ</h4>\n\n                <div class="property-row">\n                    <label>Привязка к вершинам:</label>\n                    <input type="checkbox" id="snapToVertices" ${this.snapToVertices?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>Привязка к ребрам:</label>\n                    <input type="checkbox" id="snapToEdges" ${this.snapToEdges?"checked":""}>\n                </div>\n\n                <div class="property-row">\n                    <label>Чувствительность привязки:</label>\n                    <select id="snapSensitivity">\n                        <option value="2">Высокая</option>\n                        <option value="1" selected>Средняя</option>\n                        <option value="0.5">Низкая</option>\n                    </select>\n                </div>\n            </div>\n        `}bindPropertiesEvents(){if(!this.propertiesElement)return;const e=this.propertiesElement.querySelector("#snapToVertices");e&&e.addEventListener("change",e=>{this.snapToVertices=e.target.checked,this.editor.showStatus("Привязка к вершинам: "+(this.snapToVertices?"ВКЛ":"ВЫКЛ"),"info")});const t=this.propertiesElement.querySelector("#snapToEdges");t&&t.addEventListener("change",e=>{this.snapToEdges=e.target.checked,this.editor.showStatus("Привязка к ребрам: "+(this.snapToEdges?"ВКЛ":"ВЫКЛ"),"info")});const r=this.propertiesElement.querySelector("#snapSensitivity");r&&(r.value=this.vertexSnapThreshold.toString(),r.addEventListener("change",e=>{const t=parseFloat(e.target.value);this.vertexSnapThreshold=2*t,this.edgeSnapThreshold=t,this.editor.showStatus(`Чувствительность: ${this.getSensitivityLabel(t)}`,"info")}))}getSensitivityLabel(e){return e>=2?"Высокая":e>=1?"Средняя":"Низкая"}showHoverDistance(e){if(0===this.points.length)document.getElementById("coords").textContent=`X: ${e.x.toFixed(2)}, Y: ${e.y.toFixed(2)}, Z: ${e.z.toFixed(2)}`;else{const t=this.points[0].distanceTo(e);document.getElementById("coords").textContent=`Расстояние: ${t.toFixed(2)} мм`}}addPoint(e){this.points.push(e.clone()),1===this.points.length?(this.hideMarker(),this.createStartMarker(e),this.editor.showStatus("Линейка: кликните вторую точку (ESC - отмена)","info")):2===this.points.length&&(this.createMeasurement(),setTimeout(()=>{this.points=[],this.clearTempMarker(),this.clearHighlights(),this.clearStartMarker(),this.clearTempLine(),this.editor.showStatus("Измерение завершено. Кликните для нового измерения","success")},100))}createStartMarker(e){if(!this.tempStartMarker){const e=new THREE.SphereGeometry(.5,8,8);this.tempStartMarker=new THREE.Mesh(e,this.startMarkerMaterial),this.tempStartMarker.renderOrder=1001,this.editor.scene.add(this.tempStartMarker)}this.tempStartMarker.position.copy(e),this.tempStartMarker.visible=!0}clearStartMarker(){this.tempStartMarker&&(this.editor.scene.remove(this.tempStartMarker),this.tempStartMarker.geometry&&this.tempStartMarker.geometry.dispose(),this.tempStartMarker.material&&this.tempStartMarker.material.dispose(),this.tempStartMarker=null)}clearTempMarker(){this.tempMarker&&(this.editor.scene.remove(this.tempMarker),this.tempMarker.geometry&&this.tempMarker.geometry.dispose(),this.tempMarker.material&&this.tempMarker.material.dispose(),this.tempMarker=null)}clearTempLine(){this.tempLine&&(this.editor.scene.remove(this.tempLine),this.tempLine.geometry&&this.tempLine.geometry.dispose(),this.tempLine.material&&this.tempLine.material.dispose(),this.tempLine=null)}updateTempLine(e){if(0===this.points.length)return;1!==this.points.length||this.tempStartMarker||this.createStartMarker(this.points[0]),this.tempLine&&(this.editor.scene.remove(this.tempLine),this.tempLine.geometry.dispose());const t=(new THREE.BufferGeometry).setFromPoints([this.points[0],e]);this.tempLine=new THREE.Line(t,this.lineMaterial),this.tempLine.renderOrder=998,this.editor.scene.add(this.tempLine)}createMeasurement(){if(2!==this.points.length)return;const e=this.points[0],t=this.points[1],r=e.distanceTo(t);this.measurementGroup=new THREE.Group,this.measurementGroup.userData.isRulerMeasurement=!0;const i=(new THREE.BufferGeometry).setFromPoints([e,t]),s=new THREE.LineBasicMaterial({color:65280,linewidth:2,depthTest:!1,depthWrite:!1}),n=new THREE.Line(i,s);this.measurementGroup.add(n);const o=new THREE.Mesh(this.vertexGeometry,this.startMarkerMaterial);o.position.copy(e);const a=new THREE.Mesh(this.vertexGeometry,this.markerMaterial);a.position.copy(t),o.renderOrder=998,a.renderOrder=998,this.measurementGroup.add(o),this.measurementGroup.add(a);const h=(new THREE.Vector3).addVectors(e,t).multiplyScalar(.5),l=this.createDistanceText(r,h);l&&this.measurementGroup.add(l),this.editor.scene.add(this.measurementGroup),this.allMeasurements.push(this.measurementGroup),this.editor.showStatus(`Измерение: ${r.toFixed(2)} мм`,"success")}createDistanceText(e,t){try{const r=document.createElement("canvas"),i=r.getContext("2d"),s=60,n=`${e.toFixed(2)} мм`;i.font=`${s}px Arial`;const o=i.measureText(n).width,a=s;r.width=o+20,r.height=a+10,i.font=`${s}px Arial`,i.fillStyle="#00ff00",i.textAlign="center",i.textBaseline="middle",i.fillText(n,r.width/2,r.height/2);const h=new THREE.CanvasTexture(r);h.needsUpdate=!0;const l=new THREE.SpriteMaterial({map:h,transparent:!0}),c=new THREE.Sprite(l);return c.position.copy(t),c.position.y+=5,c.scale.set(r.width/20,r.height/20,1),c}catch(e){return console.error("Ошибка создания текста:",e),null}}clearAllMeasurements(){this.allMeasurements.forEach(e=>{e.parent&&e.parent.remove(e),e.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()})}),this.allMeasurements=[]}clear(){this.clearHighlights(),this.clearTempMarker(),this.clearStartMarker(),this.clearTempLine(),this.points=[]}}