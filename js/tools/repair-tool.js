class RepairTool extends Tool{constructor(e){super("repair","fa-tools",e),this.requiresSelection=!0}onActivate(){this.canActivate()?this.showConfirmationDialog():this.editor.toolManager.restorePreviousTool()}showConfirmationDialog(){const e=document.createElement("div");e.className="modal-overlay active",e.style.cssText="\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.7);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 10000;\n        ",e.innerHTML=`\n            <div class="modal-content" style="\n                background: white;\n                padding: 20px;\n                border-radius: 8px;\n                min-width: 300px;\n                max-width: 450px;\n                box-shadow: 0 5px 15px rgba(0,0,0,0.3);\n            ">\n                <h3 style="margin-top: 0;">Ремонт геометрии</h3>\n                <div style="margin: 20px 0;">\n                    <p>Будет выполнена проверка и исправление геометрии для ${this.editor.selectedObjects.length} выбранных объектов.</p>\n\n                    <div style="margin-top: 15px;">\n                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">\n                            <input type="checkbox" id="fixOpenEdges" checked>\n                            <span>Исправлять открытые грани</span>\n                        </label>\n                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">\n                            <input type="checkbox" id="removeIsolated" checked>\n                            <span>Удалять изолированные вершины</span>\n                        </label>\n                        <label style="display: flex; align-items: center; gap: 8px;">\n                            <input type="checkbox" id="createUVs" ${1===this.editor.selectedObjects.length?"checked":""}>\n                            <span>Создавать UV координаты</span>\n                        </label>\n                    </div>\n\n                    <p style="font-size: 12px; color: #666; margin-top: 10px;">\n                        <strong>Что будет исправлено:</strong> NaN, дублирующиеся вершины,\n                        вырожденные треугольники, открытые грани, проблемы с нормалями.\n                    </p>\n                </div>\n                <div style="display: flex; justify-content: flex-end; gap: 10px;">\n                    <button id="cancelRepair" style="\n                        padding: 8px 16px;\n                        background: #f0f0f0;\n                        border: none;\n                        border-radius: 4px;\n                        cursor: pointer;\n                    ">Отмена</button>\n                    <button id="applyRepair" style="\n                        padding: 8px 16px;\n                        background: #2196F3;\n                        color: white;\n                        border: none;\n                        border-radius: 4px;\n                        cursor: pointer;\n                    ">Применить</button>\n                </div>\n            </div>\n        `,document.body.appendChild(e),document.getElementById("cancelRepair").addEventListener("click",()=>{document.body.removeChild(e),this.editor.toolManager.restorePreviousTool()}),document.getElementById("applyRepair").addEventListener("click",()=>{this.fixOpenEdges=document.getElementById("fixOpenEdges").checked,this.removeIsolated=document.getElementById("removeIsolated").checked,this.createUVs=document.getElementById("createUVs").checked,document.body.removeChild(e),this.performRepair()})}async performRepair(){this.showLoadingIndicator("Ремонт геометрии...");try{let e=0,t=0,n=0,o=0,s=0;const i=[],r=[];for(const a of this.editor.selectedObjects)if(console.log(`Обработка объекта: ${a.uuid}`),this.canRepairObject(a))try{const c=this.checkGeometryIssues(a.geometry);if(!c.hasIssues){console.log(`Геометрия объекта ${a.uuid} не требует ремонта`),t++;continue}console.log(`Обнаружены проблемы: ${JSON.stringify(c)}`);const l=this.cloneAndRepairObject(a,c);l&&l.geometry&&l.geometry.attributes&&l.geometry.attributes.position?(i.push(a),r.push(l),e++,c.openEdges>0&&o++,c.isolatedVertices>0&&s++):(console.error(`Не удалось создать объект после ремонта: ${a.uuid}`),n++)}catch(e){console.error(`Ошибка при ремонте объекта ${a.uuid}:`,e),n++}else console.log(`Пропуск объекта ${a.uuid}: неподдерживаемый тип или отсутствие геометрии`),t++;i.length>0&&this.applyRepairChanges(i,r),this.hideLoadingIndicator();let a="";e>0&&(a+=`Отремонтировано: ${e} объектов. `),o>0&&(a+=`Закрыто открытых граней: ${o}. `),s>0&&(a+=`Удалено изолированных вершин: ${s}. `),t>0&&(a+=`Пропущено: ${t} объектов. `),n>0&&(a+=`Ошибок: ${n}. `),a&&(this.editor.showStatus(a.trim(),e>0?"success":"info"),this.editor.objectsManager.updateSceneStats())}catch(e){this.hideLoadingIndicator(),console.error("Общая ошибка ремонта:",e),this.editor.showStatus(`Ошибка ремонта: ${e.message}`,"error")}this.editor.toolManager.restorePreviousTool()}canRepairObject(e){if(!e||!e.isObject3D)return console.log("Объект не является Object3D"),!1;if(!e.geometry)return console.log("У объекта нет геометрии"),!1;if(!e.geometry.isBufferGeometry)return console.log("Геометрия не BufferGeometry"),!1;if(!e.geometry.attributes.position)return console.log("Нет атрибута position"),!1;const t=e.geometry.attributes.position.count;return!(t<3)||(console.log(`Слишком мало вершин: ${t}`),!1)}checkGeometryIssues(e){const t={hasIssues:!1,nanCount:0,degenerateTriangles:0,openEdges:0,isolatedVertices:0,invalidNormals:0,duplicateVertices:0};try{const n=e.attributes.position.array;for(let e=0;e<n.length;e++)!isNaN(n[e])&&isFinite(n[e])||(t.nanCount++,t.hasIssues=!0);if(e.index){const n=e.index.array;for(let e=0;e<n.length;e+=3){const o=n[e],s=n[e+1],i=n[e+2];o!==s&&o!==i&&s!==i||(t.degenerateTriangles++,t.hasIssues=!0)}const o=this.findOpenEdges(e);t.openEdges=o.length,t.openEdges>0&&(t.hasIssues=!0),t.isolatedVertices=this.findIsolatedVertices(e),t.isolatedVertices>0&&(t.hasIssues=!0)}if(e.attributes.normal){const n=e.attributes.normal.array;for(let e=0;e<n.length;e++)isNaN(n[e])&&(t.invalidNormals++,t.hasIssues=!0)}const o=this.countUniqueVertices(e,.001);t.duplicateVertices=e.attributes.position.count-o,t.duplicateVertices>0&&(t.hasIssues=!0);try{e.computeBoundingBox(),(!e.boundingBox||isNaN(e.boundingBox.min.x)||isNaN(e.boundingBox.max.x))&&(t.hasIssues=!0)}catch(e){t.hasIssues=!0}}catch(e){console.log("Ошибка проверки геометрии:",e),t.hasIssues=!0}return t}findOpenEdges(e){if(!e.index)return[];const t=e.index.array,n=new Map,o=[];for(let e=0;e<t.length;e+=3){const o=t[e],s=t[e+1],i=t[e+2],r=[[Math.min(o,s),Math.max(o,s)],[Math.min(s,i),Math.max(s,i)],[Math.min(i,o),Math.max(i,o)]];for(const e of r){const t=`${e[0]}-${e[1]}`;n.set(t,(n.get(t)||0)+1)}}for(const[e,t]of n.entries())if(1===t){const[t,n]=e.split("-").map(Number);o.push([t,n])}return o}findIsolatedVertices(e){if(!e.index)return 0;const t=e.index.array,n=new Set;for(let e=0;e<t.length;e++)n.add(t[e]);return e.attributes.position.count-n.size}countUniqueVertices(e,t){const n=e.attributes.position,o=new Map;for(let e=0;e<n.count;e++){const s=n.getX(e),i=n.getY(e),r=n.getZ(e),a=`${Math.round(s/t)},${Math.round(i/t)},${Math.round(r/t)}`;o.set(a,!0)}return o.size}cloneAndRepairObject(e,t){try{console.log(`Клонирование и ремонт объекта: ${e.uuid}`);const n=e.geometry,o=e.material;if(!n||!n.isBufferGeometry)return console.error("Исходная геометрия отсутствует или не является BufferGeometry"),null;const s=new THREE.Mesh;s.uuid=THREE.MathUtils.generateUUID();const i=n.clone();return s.geometry=i,console.log(`Исходная геометрия вершин: ${n.attributes.position.count}`),t.nanCount>0&&(console.log(`Исправление ${t.nanCount} NaN значений`),this.fixNaNValues(i)),t.duplicateVertices>0&&(console.log(`Объединение ${t.duplicateVertices} дублирующихся вершин`),this.mergeVertices(i,.001)),t.degenerateTriangles>0&&(console.log(`Удаление ${t.degenerateTriangles} вырожденных треугольников`),this.removeDegenerateTriangles(i)),this.removeIsolated&&t.isolatedVertices>0&&(console.log(`Удаление ${t.isolatedVertices} изолированных вершин`),this.removeIsolatedVertices(i)),this.fixOpenEdges&&t.openEdges>0&&(console.log(`Закрытие ${t.openEdges} открытых граней`),this.fixOpenEdgesMethod(i)),(t.invalidNormals>0||!i.attributes.normal)&&i.computeVertexNormals(),this.createUVs&&!i.attributes.uv&&this.createSimpleUVs(i),this.optimizeGeometry(i),i.computeBoundingBox(),i.computeBoundingSphere(),e.userData&&(s.userData=JSON.parse(JSON.stringify(e.userData))),s.position.copy(e.position),s.rotation.copy(e.rotation),s.scale.copy(e.scale),o&&(s.material=o),i.attributes.position&&0!==i.attributes.position.count?(console.log(`Успешно отремонтирован объект: ${s.uuid}`),console.log(`Вершин после ремонта: ${i.attributes.position.count}`),s):(console.error("Геометрия пуста после ремонта!"),null)}catch(e){return console.error("Ошибка клонирования и ремонта:",e),null}}fixNaNValues(e){let t=!1;for(const n in e.attributes){const o=e.attributes[n],s=o.array;for(let e=0;e<s.length;e++)!isNaN(s[e])&&isFinite(s[e])||(s[e]=0,t=!0);t&&(o.needsUpdate=!0)}return t}mergeVertices(e,t=.001){if(!e.attributes.position)return!1;const n=e.attributes.position,o=n.count,s=new Map,i=[],r=new Array(o);for(let e=0;e<o;e++){const o=n.getX(e),a=n.getY(e),c=n.getZ(e),l=`${Math.round(o/t)},${Math.round(a/t)},${Math.round(c/t)}`;s.has(l)||(s.set(l,i.length),i.push({x:o,y:a,z:c,originalIndex:e})),r[e]=s.get(l)}return i.length!==o&&(console.log(`Объединение вершин: ${o} → ${i.length}`),this.rebuildGeometryWithUniqueVertices(e,i,r),!0)}rebuildGeometryWithUniqueVertices(e,t,n){const o=new Float32Array(3*t.length);if(t.forEach((e,t)=>{o[3*t]=e.x,o[3*t+1]=e.y,o[3*t+2]=e.z}),e.setAttribute("position",new THREE.BufferAttribute(o,3)),this.updateOtherAttributes(e,t,n),e.index){const t=e.index.array,o=new Uint32Array(t.length);for(let e=0;e<t.length;e++)o[e]=n[t[e]];e.setIndex(new THREE.BufferAttribute(o,1))}}updateOtherAttributes(e,t,n){if(e.attributes.normal){const n=e.attributes.normal,o=new Float32Array(3*t.length);for(let e=0;e<t.length;e++){const s=t[e].originalIndex;o[3*e]=n.getX(s),o[3*e+1]=n.getY(s),o[3*e+2]=n.getZ(s)}e.setAttribute("normal",new THREE.BufferAttribute(o,3))}if(e.attributes.uv){const n=e.attributes.uv,o=new Float32Array(2*t.length);for(let e=0;e<t.length;e++){const s=t[e].originalIndex;o[2*e]=n.getX(s),o[2*e+1]=n.getY(s)}e.setAttribute("uv",new THREE.BufferAttribute(o,2))}}removeDegenerateTriangles(e){if(!e.index)return!1;const t=e.index.array,n=[];let o=0;for(let e=0;e<t.length;e+=3){const s=t[e],i=t[e+1],r=t[e+2];s!==i&&s!==r&&i!==r?n.push(s,i,r):o++}return o>0&&(console.log(`Удалено вырожденных треугольников: ${o}`),e.setIndex(new THREE.BufferAttribute(new Uint32Array(n),1)),!0)}removeIsolatedVertices(e){if(!e.index)return!1;const t=e.index.array,n=new Set;for(let e=0;e<t.length;e++)n.add(t[e]);const o=e.attributes.position,s=o.count;if(n.size===s)return!1;const i=new Array(s).fill(-1),r=[];let a=0;for(let e=0;e<s;e++)n.has(e)&&(i[e]=a++,r.push({x:o.getX(e),y:o.getY(e),z:o.getZ(e),originalIndex:e}));const c=new Uint32Array(t.length);for(let e=0;e<t.length;e++)c[e]=i[t[e]];return this.rebuildGeometryWithUniqueVertices(e,r,i),e.setIndex(new THREE.BufferAttribute(c,1)),console.log("Удалено изолированных вершин: "+(s-n.size)),!0}fixOpenEdgesMethod(e){const t=this.findOpenEdges(e);if(0===t.length)return;console.log(`Найдено открытых рёбер: ${t.length}`);const n=t.map(([e,t])=>({v1:e,v2:t})),o=this.findContours(n);for(const t of o)t.length>=3&&this.closeContour(e,t)}findContours(e){const t=new Map;for(const n of e)t.has(n.v1)||t.set(n.v1,[]),t.has(n.v2)||t.set(n.v2,[]),t.get(n.v1).push(n.v2),t.get(n.v2).push(n.v1);const n=new Set,o=[];for(const[e]of t){if(n.has(e)||0===t.get(e).length)continue;const s=[];let i=e,r=null;for(;void 0!==i&&!n.has(i);){n.add(i),s.push(i);const o=(t.get(i)||[]).find(e=>e!==r);if(r=i,i=o,i===e)break}s.length>=3&&o.push(s)}return o}closeContour(e,t){const n=e.attributes.position,o=e.index?e.index.array:[];let s=0,i=0,r=0;for(const e of t)s+=n.getX(e),i+=n.getY(e),r+=n.getZ(e);s/=t.length,i/=t.length,r/=t.length;const a=n.count,c=new Float32Array(3*(n.count+1));c.set(n.array),c[3*a]=s,c[3*a+1]=i,c[3*a+2]=r,e.setAttribute("position",new THREE.BufferAttribute(c,3));const l=new Uint32Array(o.length+3*(t.length-2));l.set(o);let d=o.length;for(let e=0;e<t.length-2;e++)l[d++]=a,l[d++]=t[e+1],l[d++]=t[e+2];e.setIndex(new THREE.BufferAttribute(l,1)),console.log(`Закрыт контур из ${t.length} вершин`)}createSimpleUVs(e){if(!e.attributes.position)return;const t=e.attributes.position,n=t.count,o=new Float32Array(2*n);e.computeBoundingBox();const s=e.boundingBox,i=new THREE.Vector3;s.getSize(i);for(let e=0;e<n;e++){const n=t.getX(e),r=t.getY(e),a=t.getZ(e),c=(n-(s.min.x+s.max.x)/2)/Math.max(i.x,.001),l=(r-(s.min.y+s.max.y)/2)/Math.max(i.y,.001),d=(a-(s.min.z+s.max.z)/2)/Math.max(i.z,.001),u=.5+Math.atan2(d,c)/(2*Math.PI),h=.5-Math.asin(l)/Math.PI;o[2*e]=isNaN(u)?0:Math.max(0,Math.min(1,u)),o[2*e+1]=isNaN(h)?0:Math.max(0,Math.min(1,h))}e.setAttribute("uv",new THREE.BufferAttribute(o,2))}optimizeGeometry(e){try{if(void 0!==THREE.BufferGeometryUtils&&"function"==typeof THREE.BufferGeometryUtils.mergeVertices){const t={};for(const n in e.attributes)t[n]=e.attributes[n];try{const t=THREE.BufferGeometryUtils.mergeVertices(e,.001);t&&Object.assign(e,t)}catch(e){console.log("Ошибка при объединении вершин:",e)}}e.index&&e.attributes.position&&e.attributes.position.array.length>65535&&e.setIndex(new THREE.Uint32BufferAttribute(e.index.array,1))}catch(e){console.log("Оптимизация геометрии не удалась:",e)}}applyRepairChanges(e,t){console.log("Применение изменений ремонта: удаление",e.length,"объектов, создание",t.length,"объектов"),t.forEach(e=>{console.log("Объект для создания:",e.uuid,e.geometry?"есть геометрия":"нет геометрии"),e.geometry&&e.geometry.attributes&&e.geometry.attributes.position&&console.log("Вершин после ремонта:",e.geometry.attributes.position.count)});const n={type:"delete",objects:e.map(e=>({uuid:e.uuid,data:this.editor.projectManager.serializeObjectForHistory(e)}))},o={type:"create",objects:t.map(e=>({uuid:e.uuid,data:this.editor.projectManager.serializeObjectForHistory(e)}))};e.forEach(e=>{this.removeObjectSilently(e)}),t.forEach(e=>{this.addObjectSilently(e)});const s={type:"modify",deletedObjects:n.objects,createdObjects:o.objects,timestamp:(new Date).toISOString(),description:`Ремонт геометрии (${e.length} объектов)`};this.editor.history.addAction(s),this.editor.clearSelection(),t.forEach(e=>{this.editor.selectedObjects.push(e),this.editor.objectsManager.highlightObject(e)}),this.editor.updatePropertiesPanel(),this.editor.objectsManager.updateSceneList(),this.editor.updateStatus()}removeObjectSilently(e){if(!e)return;if(this.editor.selectedObjects.includes(e)){this.editor.objectsManager.unhighlightObject(e);const t=this.editor.selectedObjects.indexOf(e);t>-1&&this.editor.selectedObjects.splice(t,1)}e.parent&&e.parent.remove(e);const t=this.editor.objects.indexOf(e);if(t>-1&&this.editor.objects.splice(t,1),"sketch_plane"===e.userData.type){const t=this.editor.sketchPlanes.indexOf(e);t>-1&&this.editor.sketchPlanes.splice(t,1)}else if("work_plane"===e.userData.type){const t=this.editor.workPlanes.indexOf(e);t>-1&&this.editor.workPlanes.splice(t,1)}else if("group"===e.userData.type){const t=this.editor.groups.indexOf(e);t>-1&&this.editor.groups.splice(t,1)}e.geometry&&"function"==typeof e.geometry.dispose&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>{e&&"function"==typeof e.dispose&&e.dispose()}):"function"==typeof e.material.dispose&&e.material.dispose())}addObjectSilently(e){e&&e.geometry&&e.geometry.attributes&&e.geometry.attributes.position?(this.editor.objectsGroup.add(e),this.editor.objects.push(e),"sketch_plane"===e.userData.type?this.editor.sketchPlanes.push(e):"work_plane"===e.userData.type?this.editor.workPlanes.push(e):"group"===e.userData.type&&(this.editor.groups||(this.editor.groups=[]),this.editor.groups.push(e)),console.log("Объект успешно добавлен:",e.uuid,"вершин:",e.geometry.attributes.position.count)):console.error("Попытка добавить пустой объект!")}showLoadingIndicator(e){const t=document.createElement("div");t.id="repairLoadingIndicator",t.style.cssText="\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            background: rgba(0, 0, 0, 0.8);\n            color: white;\n            padding: 20px 30px;\n            border-radius: 8px;\n            z-index: 10001;\n            font-size: 16px;\n            display: flex;\n            align-items: center;\n            gap: 10px;\n        ",t.innerHTML=`\n            <i class="fas fa-spinner fa-spin"></i>\n            <span>${e}</span>\n        `,document.body.appendChild(t)}hideLoadingIndicator(){const e=document.getElementById("repairLoadingIndicator");e&&document.body.removeChild(e)}}