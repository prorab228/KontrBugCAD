class RepairTool extends Tool{constructor(e){super("repair","fa-tools",e),this.requiresSelection=!0,this.fixOpenEdges=!0,this.removeIsolated=!0,this.createUVs=!1,this.removeSmallComponents=!0,this.minComponentSize=10}onActivate(){if(this.canActivate())return 0===this.editor.selectedObjects.length?(this.editor.showStatus("Нет выбранных объектов для ремонта","error"),void this.editor.toolManager.restorePreviousTool()):void this.showConfirmationDialog();this.editor.toolManager.restorePreviousTool()}showConfirmationDialog(){const e=document.createElement("div");e.className="modal-overlay active",e.style.cssText="\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.7);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 10000;\n        ",e.innerHTML=`\n            <div class="modal-content" style="\n                background: white;\n                padding: 20px;\n                border-radius: 8px;\n                min-width: 350px;\n                max-width: 450px;\n                box-shadow: 0 5px 15px rgba(0,0,0,0.3);\n            ">\n                <h3 style="margin-top: 0; display: flex; align-items: center; gap: 8px;">\n                    <i class="fas fa-tools"></i> Ремонт геометрии\n                </h3>\n                <p style="margin-bottom: 15px; color: #555;">\n                    Будет выполнена проверка и исправление геометрии для\n                    <strong>${this.editor.selectedObjects.length}</strong> выбранных объектов.\n                </p>\n\n                <div style="margin: 15px 0; border-top: 1px solid #eee; padding-top: 15px;">\n                    <h4 style="margin: 0 0 10px 0; font-size: 14px;">Опции ремонта:</h4>\n\n                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">\n                        <input type="checkbox" id="fixOpenEdges" checked>\n                        <span><strong>Закрывать открытые грани</strong> (исправляет дыры)</span>\n                    </label>\n\n                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">\n                        <input type="checkbox" id="removeIsolated" checked>\n                        <span><strong>Удалять изолированные вершины</strong> (очистка)</span>\n                    </label>\n\n                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">\n                        <input type="checkbox" id="removeSmallComponents" checked>\n                        <span><strong>Удалять мелкие компоненты</strong> (менее 10 треугольников)</span>\n                    </label>\n\n                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">\n                        <input type="checkbox" id="createUVs">\n                        <span><strong>Создавать UV-координаты</strong> (для текстурирования)</span>\n                    </label>\n                </div>\n\n                <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">\n                    <button id="cancelRepair" style="\n                        padding: 8px 16px;\n                        background: #f0f0f0;\n                        border: none;\n                        border-radius: 4px;\n                        cursor: pointer;\n                    ">Отмена</button>\n                    <button id="applyRepair" style="\n                        padding: 8px 16px;\n                        background: #2196F3;\n                        color: white;\n                        border: none;\n                        border-radius: 4px;\n                        cursor: pointer;\n                    ">Применить</button>\n                </div>\n            </div>\n        `,document.body.appendChild(e),document.getElementById("cancelRepair").addEventListener("click",()=>{document.body.removeChild(e),this.editor.toolManager.restorePreviousTool()}),document.getElementById("applyRepair").addEventListener("click",()=>{this.fixOpenEdges=document.getElementById("fixOpenEdges").checked,this.removeIsolated=document.getElementById("removeIsolated").checked,this.removeSmallComponents=document.getElementById("removeSmallComponents").checked,this.createUVs=document.getElementById("createUVs").checked,document.body.removeChild(e),this.performRepair()})}canRepairObject(e){return!(!e||!e.isObject3D)&&(!(!e.geometry||!e.geometry.isBufferGeometry)&&(!!e.geometry.attributes.position&&!(e.geometry.attributes.position.count<3)))}async performRepair(){this.showLoadingIndicator("Ремонт геометрии...");try{if(!window.geometryRepair)throw new Error("GeometryRepair не загружен. Убедитесь, что geometry-repair.js подключён.");const e=[],t=[],o={total:0,success:0,failed:0,skipped:0};o.total=this.editor.selectedObjects.length;for(const i of this.editor.selectedObjects)if(console.log("Ремонтирую",i),this.canRepairObject(i))try{const n=i.geometry.clone();n.applyMatrix4(i.matrixWorld);const s={mergeDistance:1e-4,removeDegenerate:!0,removeDuplicates:!0,removeIsolated:!0,removeSmallComponents:this.removeSmallComponents,minComponentSize:10,closeHoles:this.fixOpenEdges,fixNormals:!0,checkInfinity:!0,verbose:!0,maxIterations:3};console.log("Запускаем ремонт");const r=window.geometryRepair.repair(n,s);if(console.log("Что-то получилось"),!r||!r.attributes.position||r.attributes.position.count<3||r.index&&r.index.count<3){console.warn(`Объект ${i.uuid} после ремонта не содержит геометрии, пропуск`),o.skipped++;continue}r.computeBoundingBox(),r.computeBoundingSphere();const a=r.boundingBox;if(a.min.distanceTo(a.max)<1e-4){console.warn(`Объект ${i.uuid} после ремонта имеет вырожденный bounding box, пропуск`),o.skipped++;continue}this.createUVs&&!r.attributes.uv&&this._createSimpleUVs(r);let d=null;i.material&&(d=Array.isArray(i.material)?i.material[0]||null:i.material);const l=this._safeCloneMaterial(d)||new THREE.MeshStandardMaterial({color:8421504}),c=new THREE.Mesh(r,l);if(c.uuid=THREE.MathUtils.generateUUID(),c.position.set(0,0,0),c.rotation.set(0,0,0),c.scale.set(1,1,1),c.updateMatrixWorld(!0),i.userData){const e={};for(const t in i.userData)if("originalMaterial"!==t&&"outline"!==t&&"isHighlighted"!==t)try{JSON.parse(JSON.stringify(i.userData[t])),e[t]=JSON.parse(JSON.stringify(i.userData[t]))}catch(e){}e.repaired=!0,e.repairedAt=(new Date).toISOString(),c.userData=e}c.castShadow=i.castShadow,c.receiveShadow=i.receiveShadow,c.visible=i.visible,e.push(i),t.push(c),o.success++}catch(e){console.error(`Ошибка ремонта объекта ${i.uuid}:`,e),o.failed++}else console.log(`Пропуск объекта ${i.uuid}: неподдерживаемый тип или пустая геометрия`),o.skipped++;if(t.length>0){this.applyRepairChanges(e,t);let i=`Отремонтировано: ${o.success} объектов.`;o.skipped>0&&(i+=` Пропущено: ${o.skipped}.`),o.failed>0&&(i+=` Ошибок: ${o.failed}.`),this.editor.showStatus(i,"success"),t.length>0&&setTimeout(()=>{this.editor.focusCameraOnObject(t[0])},100)}else this.editor.showStatus("Не удалось отремонтировать ни одного объекта","error")}catch(e){console.error("Общая ошибка ремонта:",e),this.editor.showStatus(`Ошибка ремонта: ${e.message}`,"error")}this.hideLoadingIndicator(),this.editor.toolManager.restorePreviousTool()}_safeCloneMaterial(e){if(!e)return null;if("function"==typeof e.clone)try{return e.clone()}catch(e){console.warn("Не удалось клонировать материал через clone(), создаём на основе цвета",e)}if(e.color){const t=e.color.clone?e.color.clone():new THREE.Color(e.color),o=new THREE.MeshStandardMaterial({color:t});return void 0!==e.opacity&&(o.opacity=e.opacity,o.transparent=e.opacity<1),void 0!==e.wireframe&&(o.wireframe=e.wireframe),void 0!==e.flatShading&&(o.flatShading=e.flatShading),void 0!==e.side&&(o.side=e.side),void 0!==e.roughness&&(o.roughness=e.roughness),void 0!==e.metalness&&(o.metalness=e.metalness),e.emissive&&(o.emissive=e.emissive.clone?e.emissive.clone():new THREE.Color(e.emissive)),o}return null}_createSimpleUVs(e){if(!e.attributes.position)return;const t=e.attributes.position,o=t.count,i=new Float32Array(2*o);e.computeBoundingBox();const n=e.boundingBox,s=new THREE.Vector3;n.getCenter(s);const r=new THREE.Vector3;n.getSize(r);for(let e=0;e<o;e++){const o=t.getX(e)-s.x,n=t.getY(e)-s.y,r=t.getZ(e)-s.z,a=Math.sqrt(o*o+n*n+r*r);if(a<.001)i[2*e]=.5,i[2*e+1]=.5;else{const t=Math.atan2(r,o),s=Math.acos(n/a);i[2*e]=(t+Math.PI)/(2*Math.PI),i[2*e+1]=s/Math.PI}}e.setAttribute("uv",new THREE.BufferAttribute(i,2))}applyRepairChanges(e,t){console.log(`Ремонт: удаление ${e.length} объектов, создание ${t.length} объектов`);const o=e.map(e=>({uuid:e.uuid,data:this.editor.projectManager.serializeObjectForHistory(e)}));e.forEach(e=>this._removeObjectSilently(e)),t.forEach(e=>this._addObjectSilently(e));const i={type:"modify",description:`Ремонт геометрии (${t.length} объектов)`,deletedObjects:o,createdObjects:t.map(e=>({uuid:e.uuid,data:this.editor.projectManager.serializeObjectForHistory(e)})),timestamp:Date.now()};this.editor.history&&this.editor.history.addAction(i),this.editor.clearSelection(!1),t.forEach(e=>{this.editor.selectedObjects.push(e),this.editor.objectsManager.highlightObject(e)}),this.editor.updatePropertiesPanel(),this.editor.objectsManager.updateSceneList(),this.editor.objectsManager.updateSceneStats(),this.editor.updateStatus()}_removeObjectSilently(e){if(!e)return;if(this.editor.selectedObjects.includes(e)){this.editor.objectsManager.unhighlightObject(e);const t=this.editor.selectedObjects.indexOf(e);t>-1&&this.editor.selectedObjects.splice(t,1)}e.parent&&e.parent.remove(e);const t=this.editor.objects.indexOf(e);if(t>-1&&this.editor.objects.splice(t,1),"sketch_plane"===e.userData?.type){const t=this.editor.sketchPlanes.indexOf(e);t>-1&&this.editor.sketchPlanes.splice(t,1)}else if("work_plane"===e.userData?.type){const t=this.editor.workPlanes.indexOf(e);t>-1&&this.editor.workPlanes.splice(t,1)}else if("group"===e.userData?.type){const t=this.editor.groups.indexOf(e);t>-1&&this.editor.groups.splice(t,1)}e.geometry&&"function"==typeof e.geometry.dispose&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e?.dispose?.()):e.material.dispose?.())}_addObjectSilently(e){e&&e.geometry&&e.geometry.attributes?.position?(this.editor.objectsGroup.add(e),this.editor.objects.push(e),"sketch_plane"===e.userData?.type?this.editor.sketchPlanes.push(e):"work_plane"===e.userData?.type?this.editor.workPlanes.push(e):"group"===e.userData?.type&&(this.editor.groups||(this.editor.groups=[]),this.editor.groups.push(e)),e.updateMatrixWorld(!0),console.log(`Объект ${e.uuid} добавлен, вершин: ${e.geometry.attributes.position.count}`)):console.error("Попытка добавить некорректный объект")}showLoadingIndicator(e){let t=document.getElementById("repairLoadingIndicator");if(t)t.querySelector("span").textContent=e,t.style.display="flex";else if(t=document.createElement("div"),t.id="repairLoadingIndicator",t.style.cssText="\n                position: fixed;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                background: rgba(0, 0, 0, 0.8);\n                color: white;\n                padding: 20px 30px;\n                border-radius: 8px;\n                z-index: 10001;\n                font-size: 16px;\n                display: flex;\n                align-items: center;\n                gap: 15px;\n                box-shadow: 0 4px 20px rgba(0,0,0,0.5);\n            ",t.innerHTML=`\n                <div class="spinner" style="\n                    width: 24px;\n                    height: 24px;\n                    border: 3px solid rgba(255,255,255,0.3);\n                    border-top-color: white;\n                    border-radius: 50%;\n                    animation: spin 1s linear infinite;\n                "></div>\n                <span>${e}</span>\n            `,document.body.appendChild(t),!document.getElementById("repairSpinnerStyle")){const e=document.createElement("style");e.id="repairSpinnerStyle",e.textContent="@keyframes spin { to { transform: rotate(360deg); } }",document.head.appendChild(e)}}hideLoadingIndicator(){const e=document.getElementById("repairLoadingIndicator");e&&(e.style.display="none")}}