class TransformControls{constructor(t){this.editor=t,this.gizmoGroup=new THREE.Group,this.scene=t.scene,this.transformMode="translate",this.isDragging=!1,this.currentAxis=null,this.startPosition=null,this.startRotation=null,this.startMouse=null,this.originalObjectData=null,this.axisColors={x:16729156,y:4521796,z:4474111},this.snapEnabled=!0,this.moveSnapValue=1,this.sizeSnapValue=1,this.rotateSnapValue=Math.PI/180*1,this.moveDelta=new THREE.Vector3,this.sizeDelta=new THREE.Vector3,this.startProjection=null,this.lastMousePosition=new THREE.Vector2,this.rotationPlane=null,this.startVector=null,this.accumulatedAngle=0,this.worldGroup=t.worldGroup,this.initGizmo()}initGizmo(){for(;this.gizmoGroup.children.length>0;)this.gizmoGroup.remove(this.gizmoGroup.children[0]);this.createTranslateGizmo(),this.createSizeGizmo(),this.createRotateGizmo(),this.gizmoGroup.visible=!1,this.scene.add(this.gizmoGroup)}createTranslateGizmo(){this.translateGroup=new THREE.Group,this.translateGroup.name="translate_gizmo",this.translateGroup.visible=!1;["x","y","z"].forEach(t=>{const e=new THREE.Group;e.name=`translate_${t}`,e.userData.type="translate",e.userData.axis=t;const i=new THREE.CylinderGeometry(.1,.1,10,8),s=new THREE.MeshBasicMaterial({color:this.axisColors[t],transparent:!0,opacity:.8}),o=new THREE.Mesh(i,s);o.name=`translate_line_${t}`;const a=new THREE.ConeGeometry(.2,1,8),r=new THREE.MeshBasicMaterial({color:this.axisColors[t],transparent:!0,opacity:.8}),n=new THREE.Mesh(a,r);n.name=`translate_cone_${t}`;"x"===t?(o.rotation.z=-Math.PI/2,o.position.x=5,n.position.x=11,n.rotation.z=-Math.PI/2):"y"===t?(o.position.y=5,n.position.y=11):"z"===t&&(o.rotation.x=Math.PI/2,o.position.z=5,n.position.z=11,n.rotation.x=Math.PI/2),e.add(o),e.add(n),this.createAxisLabel(t,e,15),this.translateGroup.add(e)}),this.gizmoGroup.add(this.translateGroup)}createSizeGizmo(){this.sizeGroup=new THREE.Group,this.sizeGroup.name="size_gizmo",this.sizeGroup.visible=!1;const t=10;["x","y","z"].forEach(e=>{const i=new THREE.BoxGeometry(.8,.8,.8),s=new THREE.MeshBasicMaterial({color:this.axisColors[e],transparent:!0,opacity:.8}),o=new THREE.Mesh(i,s);o.name=`size_${e}`,o.userData.type="size",o.userData.axis=e,"x"===e?o.position.x=t:"y"===e?o.position.y=t:"z"===e&&(o.position.z=t);const a=new THREE.CylinderGeometry(.1,.1,t,8),r=new THREE.MeshBasicMaterial({color:this.axisColors[e],transparent:!0,opacity:.5}),n=new THREE.Mesh(a,r);"x"===e?(n.rotation.z=-Math.PI/2,n.position.x=5):"y"===e?n.position.y=5:"z"===e&&(n.rotation.x=Math.PI/2,n.position.z=5),this.sizeGroup.add(n),this.sizeGroup.add(o),this.createAxisLabel(e,o,t)}),this.gizmoGroup.add(this.sizeGroup)}createRotateGizmo(){this.rotateGroup=new THREE.Group,this.rotateGroup.name="rotate_gizmo",this.rotateGroup.visible=!1;["x","y","z"].forEach(t=>{const e=new THREE.TorusGeometry(10,.1,6,48),i=new THREE.MeshBasicMaterial({color:this.axisColors[t],transparent:!0,opacity:.4,side:THREE.DoubleSide}),s=new THREE.Mesh(e,i);s.name=`rotate_${t}`,s.userData.type="rotate",s.userData.axis=t,"x"===t?s.rotation.y=Math.PI/2:"z"===t||"y"===t&&(s.rotation.x=Math.PI/2),this.rotateGroup.add(s),this.createRotationLabel(t,s,15)}),this.gizmoGroup.add(this.rotateGroup)}createAxisLabel(t,e,i){const s=document.createElement("canvas");s.width=128,s.height=128;const o=s.getContext("2d");o.clearRect(0,0,s.width,s.height),o.font="bold 14px Arial",o.fillStyle=this.getAxisColorHex(t),o.textAlign="center",o.textBaseline="middle",o.fillText(t.toUpperCase(),s.width/2,s.height/2);const a=new THREE.CanvasTexture(s);a.needsUpdate=!0;const r=new THREE.SpriteMaterial({map:a,transparent:!0}),n=new THREE.Sprite(r);n.scale.set(10,10,1),"x"===t?n.position.set(i,0,0):"y"===t?n.position.set(0,i,0):"z"===t&&n.position.set(0,0,i),e.add(n)}createRotationLabel(t,e,i){const s=document.createElement("canvas");s.width=64,s.height=32;const o=s.getContext("2d");o.clearRect(0,0,s.width,s.height),o.font="bold 24px Arial",o.fillStyle=this.getAxisColorHex(t),o.textAlign="center",o.textBaseline="middle",o.fillText("R",s.width/2,s.height/2);const a=new THREE.CanvasTexture(s);a.needsUpdate=!0;const r=new THREE.SpriteMaterial({map:a,transparent:!0}),n=new THREE.Sprite(r);n.scale.set(8,4,1),"x"===t?n.position.set(i,0,0):"y"===t?n.position.set(0,i,0):"z"===t&&n.position.set(0,0,i),e.add(n)}getAxisColorHex(t){return{x:"#ff4444",y:"#44ff44",z:"#4444ff"}[t]||"#ffffff"}attach(t){this.attachedObject=t,this.originalObjectData={position:t.position.clone(),rotation:t.rotation.clone()},this.updatePosition(),this.show(),this.updateMode(this.transformMode)}detach(){this.attachedObject=null,this.originalObjectData=null,this.hide()}updatePosition(){if(this.attachedObject){const t=new THREE.Vector3;this.attachedObject.getWorldPosition(t),this.gizmoGroup.position.copy(t),this.gizmoGroup.rotation.copy(this.worldGroup.rotation);const e=.015*this.editor.camera.position.distanceTo(t);this.gizmoGroup.scale.setScalar(e)}}updateMode(t){switch(this.transformMode=t,this.translateGroup.visible=!1,this.sizeGroup.visible=!1,this.rotateGroup.visible=!1,t){case"translate":this.translateGroup.visible=!0;break;case"scale":this.sizeGroup.visible=!0;break;case"rotate":this.rotateGroup.visible=!0}}onMouseDown(t,e){if(!this.attachedObject||!this.gizmoGroup.visible)return!1;this.snapEnabled=!t.ctrlKey,this.updateMousePosition(t,e),this.editor.raycaster.setFromCamera(e,this.editor.camera);let i=[],s=null;switch(this.transformMode){case"translate":s=this.translateGroup;break;case"scale":s=this.sizeGroup;break;case"rotate":s=this.rotateGroup}if(s&&s.visible){const t=[];s.traverse(e=>{e instanceof THREE.Mesh&&t.push(e)}),i=this.editor.raycaster.intersectObjects(t,!0)}if(i&&i.length>0){const t=i[0].object;let o=t,a=null;for(;o&&o!==s;){if(o.userData&&o.userData.axis){a=o.userData.axis;break}o=o.parent}if(!a){const e=t.name||"";e.includes("translate_")?a=e.replace("translate_","").replace("_line","").replace("_cone",""):e.includes("size_")?a=e.replace("size_",""):e.includes("rotate_")&&(a=e.replace("rotate_",""))}if(a)return this.currentAxis=a,this.isDragging=!0,this.startMouse=new THREE.Vector2(e.x,e.y),this.startPosition=this.attachedObject.position.clone(),this.startRotation=this.attachedObject.rotation.clone(),this.moveDelta.set(0,0,0),this.sizeDelta.set(0,0,0),this.accumulatedAngle=0,"scale"===this.transformMode?(this.sizeStartDimensions=this.getObjectDimensions(this.attachedObject),this.startProjection=this.getPlaneIntersection(e)):"rotate"===this.transformMode?this.setupRotation(e):this.saveStartProjection(e),this.createTooltip(),!0}return!1}onMouseMove(t,e){if(this.isDragging&&this.attachedObject&&this.currentAxis){switch(this.updateMousePosition(t,e),this.transformMode){case"translate":this.handleTranslate(e);break;case"scale":this.handleSizeChange(e);break;case"rotate":this.handleRotate(e)}this.updatePosition(),this.editor.updatePropertiesPanel(),this.updateTooltip()}}onMouseUp(){this.isDragging&&(this.isDragging=!1,this.saveHistory(),this.currentAxis=null,this.sizeStartDimensions=null,this.startProjection=null,this.rotationPlane=null,this.startVector=null,this.removeTooltip(),this.editor.updatePropertiesPanel(),this.editor.objectsManager.updateSceneStats())}handleTranslate(t){if(!this.currentAxis||!this.startProjection)return;const e=this.editor.camera.getWorldDirection(new THREE.Vector3),i=new THREE.Plane;i.setFromNormalAndCoplanarPoint(e,this.startProjection);const s=new THREE.Vector3;if(this.editor.raycaster.setFromCamera(t,this.editor.camera),this.editor.raycaster.ray.intersectPlane(i,s)){const t=(new THREE.Vector3).subVectors(s,this.startProjection);let e=t.clone();this.snapEnabled&&("x"===this.currentAxis?e.x=Math.round(t.x/this.moveSnapValue)*this.moveSnapValue:"y"===this.currentAxis?e.y=Math.round(t.y/this.moveSnapValue)*this.moveSnapValue:"z"===this.currentAxis&&(e.z=Math.round(t.z/this.moveSnapValue)*this.moveSnapValue)),"x"===this.currentAxis?(this.attachedObject.position.x=this.startPosition.x+e.x,this.moveDelta.set(e.x,0,0)):"y"===this.currentAxis?(this.attachedObject.position.y=this.startPosition.y+e.y,this.moveDelta.set(0,e.y,0)):"z"===this.currentAxis&&(this.attachedObject.position.z=this.startPosition.z+e.z,this.moveDelta.set(0,0,e.z))}}handleSizeChange(t){if(!this.currentAxis||!this.sizeStartDimensions||!this.startProjection)return;const e=this.getPlaneIntersection(t);if(!e)return;const i=(new THREE.Vector3).subVectors(e,this.startProjection);let s=0;"x"===this.currentAxis?(s=this.snapEnabled?Math.round(i.x/this.sizeSnapValue)*this.sizeSnapValue:i.x,this.sizeDelta.set(s,0,0)):"y"===this.currentAxis?(s=this.snapEnabled?Math.round(i.y/this.sizeSnapValue)*this.sizeSnapValue:i.y,this.sizeDelta.set(0,s,0)):"z"===this.currentAxis&&(s=this.snapEnabled?Math.round(i.z/this.sizeSnapValue)*this.sizeSnapValue:i.z,this.sizeDelta.set(0,0,s));const o=new THREE.Vector3(Math.max(1,this.sizeStartDimensions.x+this.sizeDelta.x),Math.max(1,this.sizeStartDimensions.y+this.sizeDelta.y),Math.max(1,this.sizeStartDimensions.z+this.sizeDelta.z));this.updateObjectSize(this.attachedObject,o)}setupRotation(t){let e=new THREE.Vector3;switch(this.currentAxis){case"x":e.set(1,0,0);break;case"y":e.set(0,1,0);break;case"z":e.set(0,0,1)}e.applyQuaternion(this.gizmoGroup.quaternion),this.rotationPlane=new THREE.Plane,this.rotationPlane.setFromNormalAndCoplanarPoint(e,this.gizmoGroup.position),this.startProjection=this.getPlaneIntersection(t),this.startProjection&&(this.startVector=(new THREE.Vector3).subVectors(this.startProjection,this.gizmoGroup.position).normalize())}handleRotate(t){if(!this.currentAxis||!this.rotationPlane||!this.startVector)return;const e=new THREE.Vector3;if(this.editor.raycaster.setFromCamera(t,this.editor.camera),this.editor.raycaster.ray.intersectPlane(this.rotationPlane,e)){const t=this.gizmoGroup.position,i=(new THREE.Vector3).subVectors(e,t).normalize();let s=new THREE.Vector3;switch(this.currentAxis){case"x":s.set(1,0,0);break;case"y":s.set(0,1,0);break;case"z":s.set(0,0,1)}s.applyQuaternion(this.gizmoGroup.quaternion);const o=this.startVector.dot(i),a=(new THREE.Vector3).crossVectors(this.startVector,i),r=Math.atan2(a.dot(s),o);let n=r;switch(this.snapEnabled&&(n=Math.round(r/this.rotateSnapValue)*this.rotateSnapValue),this.accumulatedAngle+=n,this.currentAxis){case"x":this.attachedObject.rotation.x=this.startRotation.x+this.accumulatedAngle;break;case"y":this.attachedObject.rotation.y=this.startRotation.y+this.accumulatedAngle;break;case"z":this.attachedObject.rotation.z=this.startRotation.z+this.accumulatedAngle}this.startVector.copy(i)}}getPlaneIntersection(t){const e=this.editor.camera.getWorldDirection(new THREE.Vector3),i=new THREE.Plane;i.setFromNormalAndCoplanarPoint(e,this.gizmoGroup.position);const s=new THREE.Vector3;return this.editor.raycaster.setFromCamera(t,this.editor.camera),this.editor.raycaster.ray.intersectPlane(i,s)?s:null}updateObjectSize(t,e){t.userData.originalSize||(t.userData.originalSize={x:t.geometry.parameters?.width||25,y:t.geometry.parameters?.height||25,z:t.geometry.parameters?.depth||25},t.userData.originalGeometry=t.geometry.clone());const i=e.x/t.userData.originalSize.x,s=e.y/t.userData.originalSize.y,o=e.z/t.userData.originalSize.z,a=(new THREE.Box3).setFromObject(t),r=new THREE.Vector3;a.getCenter(r),t.scale.set(i,s,o),t.userData.currentSize=e;const n=(new THREE.Box3).setFromObject(t),c=new THREE.Vector3;n.getCenter(c);const h=(new THREE.Vector3).subVectors(r,c);t.position.add(h)}getObjectDimensions(t){if(!t)return{x:0,y:0,z:0};if(t.userData.currentSize)return{x:t.userData.currentSize.x,y:t.userData.currentSize.y,z:t.userData.currentSize.z};const e=(new THREE.Box3).setFromObject(t),i=new THREE.Vector3;return e.getSize(i),{x:i.x,y:i.y,z:i.z}}updateObjectSizeDirect(t,e){if("group"===t.userData?.type){const i=(new THREE.Box3).setFromObject(t),s=new THREE.Vector3;i.getSize(s);const o=e.x/s.x,a=e.y/s.y,r=e.z/s.z;t.scale.set(o,a,r),t.userData.currentSize=e}else{if(!t.userData.originalSize){const e=this.getObjectDimensions(t);t.userData.originalSize={x:e.x,y:e.y,z:e.z},t.userData.originalScale={x:t.scale.x,y:t.scale.y,z:t.scale.z}}const i=e.x/t.userData.originalSize.x,s=e.y/t.userData.originalSize.y,o=e.z/t.userData.originalSize.z,a=(new THREE.Box3).setFromObject(t),r=new THREE.Vector3;a.getCenter(r),t.scale.set(i,s,o),t.userData.currentSize=e;const n=(new THREE.Box3).setFromObject(t),c=new THREE.Vector3;n.getCenter(c);const h=(new THREE.Vector3).subVectors(r,c);t.position.add(h)}}saveStartProjection(t){if(!this.attachedObject||!this.currentAxis)return;const e=this.editor.camera.getWorldDirection(new THREE.Vector3),i=new THREE.Plane;i.setFromNormalAndCoplanarPoint(e,this.gizmoGroup.position);const s=new THREE.Vector3;this.editor.raycaster.setFromCamera(t,this.editor.camera),this.editor.raycaster.ray.intersectPlane(i,s)&&(this.startProjection=s)}updateMousePosition(t,e){const i=this.editor.renderer.domElement.getBoundingClientRect();e.x=(t.clientX-i.left)/i.width*2-1,e.y=-(t.clientY-i.top)/i.height*2+1,this.lastMousePosition.copy(e)}createTooltip(){this.removeTooltip();const t=document.createElement("div");t.className="transform-tooltip",t.style.cssText="\n            position: fixed;\n            background: rgba(0, 0, 0, 0.85);\n            color: white;\n            padding: 8px 12px;\n            border-radius: 6px;\n            font-family: 'Segoe UI', Arial, sans-serif;\n            font-size: 12px;\n            pointer-events: none;\n            z-index: 10000;\n            min-width: 180px;\n            backdrop-filter: blur(5px);\n            border: 1px solid rgba(255, 255, 255, 0.15);\n            display: flex;\n            flex-direction: column;\n            gap: 4px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n            transition: opacity 0.2s;\n        ",this.tooltip=t,document.body.appendChild(t)}updateTooltip(){if(!this.tooltip||!this.attachedObject)return;const t=this.getGizmoScreenPosition();if(!t)return;let e="";const i=this.getObjectDimensions(this.attachedObject);switch(this.transformMode){case"translate":e=`\n                    <div style="font-weight: 600; margin-bottom: 6px; color: #fff;">Перемещение (мм):</div>\n                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">\n                        <div style="color: #ff6b6b;">\n                            <div style="font-size: 10px; opacity: 0.8;">ΔX</div>\n                            <div>${this.moveDelta.x.toFixed(1)}</div>\n                        </div>\n                        <div style="color: #51cf66;">\n                            <div style="font-size: 10px; opacity: 0.8;">ΔY</div>\n                            <div>${this.moveDelta.y.toFixed(1)}</div>\n                        </div>\n                        <div style="color: #339af0;">\n                            <div style="font-size: 10px; opacity: 0.8;">ΔZ</div>\n                            <div>${this.moveDelta.z.toFixed(1)}</div>\n                        </div>\n                    </div>\n                `;break;case"scale":e=`\n                    <div style="font-weight: 600; margin-bottom: 6px; color: #fff;">Размеры (мм):</div>\n                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">\n                        <div style="color: #ff6b6b;">\n                            <div style="font-size: 10px; opacity: 0.8;">Ширина (X)</div>\n                            <div>${i.x.toFixed(1)}</div>\n                        </div>\n                        <div style="color: #51cf66;">\n                            <div style="font-size: 10px; opacity: 0.8;">Высота (Y)</div>\n                            <div>${i.y.toFixed(1)}</div>\n                        </div>\n                        <div style="color: #339af0;">\n                            <div style="font-size: 10px; opacity: 0.8;">Глубина (Z)</div>\n                            <div>${i.z.toFixed(1)}</div>\n                        </div>\n                    </div>\n                `;break;case"rotate":const t=this.attachedObject.rotation;e=`\n                    <div style="font-weight: 600; margin-bottom: 6px; color: #fff;">Вращение (°):</div>\n                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">\n                        <div style="color: #ff6b6b;">\n                            <div style="font-size: 10px; opacity: 0.8;">X</div>\n                            <div>${THREE.MathUtils.radToDeg(t.x).toFixed(1)}</div>\n                        </div>\n                        <div style="color: #51cf66;">\n                            <div style="font-size: 10px; opacity: 0.8;">Y</div>\n                            <div>${THREE.MathUtils.radToDeg(t.y).toFixed(1)}</div>\n                        </div>\n                        <div style="color: #339af0;">\n                            <div style="font-size: 10px; opacity: 0.8;">Z</div>\n                            <div>${THREE.MathUtils.radToDeg(t.z).toFixed(1)}</div>\n                        </div>\n                    </div>\n                `}this.tooltip.innerHTML=e,this.tooltip.style.left=t.x+20+"px",this.tooltip.style.top=t.y-this.tooltip.offsetHeight/2+"px"}getGizmoScreenPosition(){if(!this.attachedObject)return null;const t=new THREE.Vector3;this.attachedObject.getWorldPosition(t),t.project(this.editor.camera);const e=this.editor.renderer.domElement.clientWidth,i=this.editor.renderer.domElement.clientHeight;return{x:(.5*t.x+.5)*e,y:(.5*-t.y+.5)*i}}saveHistory(){if(this.editor.history&&this.attachedObject){const t="translate"===this.transformMode?"modify_position":"scale"===this.transformMode?"modify_size":"modify_rotation",e={type:t,object:this.attachedObject.uuid,data:{}};switch(t){case"modify_position":e.data.position=this.attachedObject.position.toArray(),e.data.previousPosition=this.startPosition.toArray();break;case"modify_size":e.data.dimensions=this.getObjectDimensions(this.attachedObject),e.data.previousDimensions=this.sizeStartDimensions;break;case"modify_rotation":e.data.rotation=[this.attachedObject.rotation.x,this.attachedObject.rotation.y,this.attachedObject.rotation.z],e.data.previousRotation=[this.startRotation.x,this.startRotation.y,this.startRotation.z]}this.editor.history.addAction(e)}}removeTooltip(){this.tooltip&&this.tooltip.parentNode&&this.tooltip.parentNode.removeChild(this.tooltip),this.tooltip=null}show(){this.gizmoGroup.visible=!0}hide(){this.gizmoGroup.visible=!1,this.removeTooltip()}update(){this.attachedObject&&this.gizmoGroup.visible&&this.updatePosition()}}