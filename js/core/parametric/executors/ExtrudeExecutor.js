import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class ExtrudeExecutor extends ParametricExecutor{execute(e,t){const{figures:r,height:o,direction:n,operationType:u,color:a=5025616,planeId:s}=e.parameters,i=e.inputs||[],p=t.objectMap.get(s)||this.findPlaneById(s,t.editor);if(!p)throw new Error(`Extrude: плоскость ${s} не найдена`);const c=this._createGeometry(r,o,n,"new"!==u);if(!c)throw new Error("Extrude: не удалось создать геометрию");const l=new THREE.Mesh(c,new THREE.MeshStandardMaterial({color:a}));if(l.position.copy(p.position),l.quaternion.copy(p.quaternion),l.castShadow=!0,l.receiveShadow=!0,l.userData={type:"extrude",sourceFigures:r,height:o,direction:n,operationType:u,planeId:s},"new"===u)return e.outputs.length>0?l.uuid=e.outputs[0]:e.outputs=[l.uuid],l;if(!t.editor.booleanOps)throw new Error("Extrude: булевы операции не доступны");const d=i.map(e=>t.objectMap.get(e)).filter(Boolean);if(0===d.length)throw new Error("Extrude: не найдены целевые объекты");let h;if("cut"===u?h=t.editor.booleanOps.subtract(d[0],l):"join"===u&&(h=t.editor.booleanOps.unionMultiple([l,...d])),!h)throw new Error(`Extrude: не удалось выполнить ${u}`);return d.forEach(e=>{t.objectMap.delete(e.uuid),t.sceneGroup.remove(e)}),h.userData={...h.userData,type:"extrude_boolean",operationType:u},e.outputs.length>0?h.uuid=e.outputs[0]:e.outputs=[h.uuid],h}_createGeometry(e,t,r,o){const n=[];for(const t of e){const e=[];for(let r=0;r<t.outer.length;r+=2)e.push(new THREE.Vector2(t.outer[r],t.outer[r+1]));const r=new THREE.Shape(e);if(t.holes)for(const e of t.holes){const t=[];for(let r=0;r<e.length;r+=2)t.push(new THREE.Vector2(e[r],e[r+1]));const o=new THREE.Path(t);r.holes.push(o)}n.push(r)}let u=t;o&&(u+=.01);const a=new THREE.ExtrudeGeometry(n,{depth:u,bevelEnabled:!1,steps:1});return o?"positive"===r?a.translate(0,0,-.01):"both"===r?a.translate(0,0,-u/2):"negative"===r&&a.translate(0,0,-u):"both"===r?a.translate(0,0,-t/2):"negative"===r&&a.translate(0,0,-t),a}findPlaneById(e,t){let r=null;return t.scene.traverse(t=>{t.uuid===e&&t.userData?.type?.includes("plane")&&(r=t)}),r}}