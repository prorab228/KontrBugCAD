import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class ExtrudeExecutor extends ParametricExecutor{execute(e,t){const{figures:r,height:o,direction:n,operationType:u,color:a=5025616,planeId:s}=e.parameters,i=e.inputs||[],p=t.objectMap.get(s)||this.findPlaneById(s,t.editor);if(!p)throw new Error(`Extrude: плоскость ${s} не найдена`);const c=this._createGeometry(r,o,n,"new"!==u);if(!c)throw new Error("Extrude: не удалось создать геометрию");const l=new THREE.Mesh(c,new THREE.MeshStandardMaterial({color:a}));if(l.position.copy(p.position),l.quaternion.copy(p.quaternion),l.castShadow=!0,l.receiveShadow=!0,l.userData={type:"extrude",sourceFigures:r,height:o,direction:n,operationType:u,planeId:s},"new"===u)return e.outputs.length>0?l.uuid=e.outputs[0]:e.outputs=[l.uuid],l;if(!t.editor.booleanOps)throw new Error("Extrude: булевы операции не доступны");const d=i.map(e=>t.objectMap.get(e)).filter(Boolean);if(0===d.length)throw new Error("Extrude: не найдены целевые объекты");let h=[];if("cut"===u){for(const e of d){const r=t.editor.booleanOps.subtract(e,l);r&&h.push(r)}if(0===h.length)throw new Error("Extrude: ни одно вычитание не дало результата")}else if("join"===u){const e=[l,...d],r=t.editor.booleanOps.unionMultiple(e);if(!r)throw new Error("Extrude: не удалось выполнить объединение");h=[r]}if(d.forEach(e=>{t.objectMap.delete(e.uuid),t.sceneGroup.remove(e)}),1===h.length){const t=h[0];return e.outputs.length>0?t.uuid=e.outputs[0]:(t.uuid=THREE.MathUtils.generateUUID(),e.outputs=[t.uuid]),t.userData={...t.userData,type:"extrude_boolean",operationType:u},t}{const t=[];return h.forEach((e,r)=>{e.uuid||(e.uuid=THREE.MathUtils.generateUUID()),t.push(e.uuid),e.userData={...e.userData,type:"extrude_boolean",operationType:u}}),e.outputs=t,h}}_createGeometry(e,t,r,o){const n=[];for(const t of e){const e=[];for(let r=0;r<t.outer.length;r+=2)e.push(new THREE.Vector2(t.outer[r],t.outer[r+1]));const r=new THREE.Shape(e);if(t.holes)for(const e of t.holes){const t=[];for(let r=0;r<e.length;r+=2)t.push(new THREE.Vector2(e[r],e[r+1]));const o=new THREE.Path(t);r.holes.push(o)}n.push(r)}let u=t;o&&(u+=.01);const a=new THREE.ExtrudeGeometry(n,{depth:u,bevelEnabled:!1,steps:1});return o?"positive"===r?a.translate(0,0,-.01):"both"===r?a.translate(0,0,-u/2):"negative"===r&&a.translate(0,0,-u):"both"===r?a.translate(0,0,-t/2):"negative"===r&&a.translate(0,0,-t),a}findPlaneById(e,t){let r=null;return t.scene.traverse(t=>{t.uuid===e&&t.userData?.type?.includes("plane")&&(r=t)}),r}}