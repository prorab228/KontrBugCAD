import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class RevolveExecutor extends ParametricExecutor{execute(e,t){const{figures:r,angle:o,axis:n,direction:s,operationType:i,color:l=16750592,planeId:a,addCaps:c=!0,capThickness:u=.01,lineAxisId:h=null}=e.parameters,E=e.inputs||[],p=t.objectMap.get(a)||this.findPlaneById(a,t.editor);if(!p)throw new Error(`Revolve: плоскость ${a} не найдена`);let f=null;if(h&&(f=t.objectMap.get(h),!f))throw new Error(`Revolve: линия ${h} не найдена`);const d=this.createRevolveGeometry(r,p,o,n,s,c,u,f);if(!d)throw new Error("Revolve: не удалось создать геометрию");const R=new THREE.Mesh(d,new THREE.MeshStandardMaterial({color:l}));if(R.castShadow=!0,R.receiveShadow=!0,R.userData={type:"revolve",sourceFigures:r,angle:o,axis:n,direction:s,operationType:i,planeId:a,addCaps:c,capThickness:u,lineAxisId:h},"new"===i)return e.outputs.length>0?R.uuid=e.outputs[0]:e.outputs=[R.uuid],R;if(!t.editor.booleanOps)throw new Error("Revolve: булевы операции не доступны");const T=E.map(e=>t.objectMap.get(e)).filter(Boolean);if(0===T.length)throw new Error("Revolve: не найдены целевые объекты для cut/join");let m=[];if("cut"===i){for(const e of T){const r=t.editor.booleanOps.subtract(e,R);r&&m.push(r)}if(0===m.length)throw new Error("Revolve: ни одно вычитание не дало результата")}else if("join"===i){const e=[R,...T],r=t.editor.booleanOps.unionMultiple(e);if(!r)throw new Error("Revolve: не удалось выполнить объединение");m=[r]}if(T.forEach(e=>{t.objectMap.delete(e.uuid),t.sceneGroup.remove(e)}),1===m.length){const t=m[0];return e.outputs.length>0?t.uuid=e.outputs[0]:(t.uuid=THREE.MathUtils.generateUUID(),e.outputs=[t.uuid]),t.userData={...t.userData,type:"revolve_boolean",sourceOperation:e.id,operationType:i},t}{const t=[];return m.forEach((r,o)=>{r.uuid||(r.uuid=THREE.MathUtils.generateUUID()),t.push(r.uuid),r.userData={...r.userData,type:"revolve_boolean",sourceOperation:e.id,operationType:i}}),e.outputs=t,m}}createRevolveGeometry(e,t,r,o,n,s,i,l){this._currentPlane=t,this._currentLineMesh=l,this._currentAngle=r,this._currentAxis=o,this._currentDirection=n,this._currentAddCaps=s,this._currentCapThickness=i;const a=[];for(const t of e){const e=this._createSolidGeometryForContour(t.outer,!1,!1);if(e&&a.push(e),t.holes&&t.holes.length)for(const e of t.holes){const t=this._createSolidGeometryForContour(e,!1,!0);t&&a.push(t)}}if(s&&r<360){const t=this._createCapsForFigures(e);a.push(...t)}if(0===a.length)return null;const c=a.map(e=>this._toNonIndexed(e)).filter(Boolean),u=this.mergeGeometries(c);if(!u)return console.error("RevolveExecutor: не удалось объединить геометрии"),null;return this._mergeVertices(u,.1)}_createSolidGeometryForContour(e,t,r){if(!e||e.length<6)return null;const o=[];for(let t=0;t<e.length;t+=2)o.push(new THREE.Vector2(e[t],e[t+1]));const n=o.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this._currentPlane.localToWorld(t)});let s;return s=this._currentLineMesh?this._createRevolveAroundLine(n,r):this._createRevolveAroundGlobalAxis(n,r),s}_createCapsForFigures(e){const t=[],r=[];for(const t of e){const e=this.createShapeFromFigure(t,this._currentPlane);e&&r.push(e)}if(0===r.length)return[];const o={depth:this._currentCapThickness,bevelEnabled:!1,steps:1},n="positive"===this._currentDirection?this._currentAngle:-this._currentAngle;for(const e of[0,n])try{const n=new THREE.ExtrudeGeometry(r,o),s=THREE.MathUtils.degToRad(e);if(this._currentLineMesh){const e=this._currentLineMesh,t=e.geometry.attributes.position.array,r=new THREE.Vector3(t[0],t[1],t[2]),o=new THREE.Vector3(t[3],t[4],t[5]),i=e.localToWorld(r),l=e.localToWorld(o),a=(new THREE.Vector3).subVectors(l,i).normalize(),c=(new THREE.Matrix4).makeRotationAxis(a,s),u=(new THREE.Matrix4).makeTranslation(-i.x,-i.y,-i.z),h=(new THREE.Matrix4).makeTranslation(i.x,i.y,i.z),E=h.clone().multiply(c).multiply(u).multiply(this._currentPlane.matrixWorld);n.applyMatrix4(E)}else{const e=this.getAxisVector(this._currentAxis),t=(new THREE.Matrix4).makeRotationAxis(e,s).multiply(this._currentPlane.matrixWorld);n.applyMatrix4(t)}t.push(n)}catch(e){console.error("Ошибка создания крышки:",e)}return t}_toNonIndexed(e){return e?e.index?e.toNonIndexed():e.clone():null}_mergeVertices(e,t=.001){if(!e)return null;if(!THREE.BufferGeometryUtils||!THREE.BufferGeometryUtils.mergeVertices)return console.warn("BufferGeometryUtils.mergeVertices недоступен"),e;const r=THREE.BufferGeometryUtils.mergeVertices(e,t);return r.computeVertexNormals(),r}_createRevolveAroundGlobalAxis(e,t){const r=this.getAxisVector(this._currentAxis).normalize(),o=new THREE.Vector3(0,0,0),n=(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),r),s=new THREE.Vector3(1,0,0).applyQuaternion(n).normalize(),i=new THREE.Vector3(0,0,1).applyQuaternion(n).normalize(),l=e[0],a=(new THREE.Vector3).subVectors(l,o),c=a.dot(r),u=(new THREE.Vector3).subVectors(a,r.clone().multiplyScalar(c));let h=-Math.atan2(u.dot(i),u.dot(s))+Math.PI/2;h<0&&(h+=2*Math.PI);const E=[];for(const t of e){const e=(new THREE.Vector3).subVectors(t,o),n=e.dot(r),s=e.clone().sub(r.clone().multiplyScalar(n)).length();E.push(new THREE.Vector2(s,n))}let p=0;const f=E.length;for(let e=0;e<f;e++){const t=(e+1)%f;p+=E[e].x*E[t].y,p-=E[t].x*E[e].y}if(p/=2,t?p>0&&E.reverse():p<0&&E.reverse(),E.length>0){const e=E[0],t=E[E.length-1];(Math.abs(e.x-t.x)>1e-6||Math.abs(e.y-t.y)>1e-6)&&E.push(e.clone())}const d="negative"===this._currentDirection?-THREE.MathUtils.degToRad(this._currentAngle):THREE.MathUtils.degToRad(this._currentAngle),R=Math.max(16,Math.round(this._currentAngle/5)),T=new THREE.LatheGeometry(E,R,h,d);return T.applyQuaternion(n),T.translate(o.x,o.y,o.z),T}_createRevolveAroundLine(e,t){const r=this._currentLineMesh;if(!r)return null;const o=r.geometry.attributes.position.array,n=new THREE.Vector3(o[0],o[1],o[2]),s=new THREE.Vector3(o[3],o[4],o[5]),i=r.localToWorld(n),l=r.localToWorld(s),a=(new THREE.Vector3).subVectors(l,i).normalize(),c=(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),a),u=new THREE.Vector3(1,0,0).applyQuaternion(c).normalize(),h=new THREE.Vector3(0,0,1).applyQuaternion(c).normalize(),E=e[0],p=(new THREE.Vector3).subVectors(E,i),f=p.dot(a),d=(new THREE.Vector3).subVectors(p,a.clone().multiplyScalar(f));let R=-Math.atan2(d.dot(h),d.dot(u))+Math.PI/2;R<0&&(R+=2*Math.PI);const T=[];for(const t of e){const e=(new THREE.Vector3).subVectors(t,i),r=e.dot(a),o=e.clone().sub(a.clone().multiplyScalar(r)).length();T.push(new THREE.Vector2(o,r))}let m=0;const g=T.length;for(let e=0;e<g;e++){const t=(e+1)%g;m+=T[e].x*T[t].y,m-=T[t].x*T[e].y}if(m/=2,t?m>0&&T.reverse():m<0&&T.reverse(),T.length>0){const e=T[0],t=T[T.length-1];(Math.abs(e.x-t.x)>1e-6||Math.abs(e.y-t.y)>1e-6)&&T.push(e.clone())}const y="negative"===this._currentDirection?-THREE.MathUtils.degToRad(this._currentAngle):THREE.MathUtils.degToRad(this._currentAngle),w=Math.max(16,Math.round(this._currentAngle/5)),H=new THREE.LatheGeometry(T,w,R,y);return H.applyQuaternion(c),H.translate(i.x,i.y,i.z),H}createShapeFromFigure(e,t){const r=[];for(let t=0;t<e.outer.length;t+=2)r.push(new THREE.Vector2(e.outer[t],e.outer[t+1]));if(r.length<3)return null;const o=new THREE.Shape(r);if(e.holes&&e.holes.length>0)for(const t of e.holes){const e=[];for(let r=0;r<t.length;r+=2)e.push(new THREE.Vector2(t[r],t[r+1]));if(e.length>=3){const t=new THREE.Path(e);o.holes.push(t)}}return o}getAxisVector(e){switch(e){case"x":return new THREE.Vector3(1,0,0);case"y":default:return new THREE.Vector3(0,1,0);case"z":return new THREE.Vector3(0,0,1)}}mergeGeometries(e){if(0===e.length)return null;if(1===e.length)return e[0];if(THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeBufferGeometries)return THREE.BufferGeometryUtils.mergeBufferGeometries(e);const t=new THREE.BufferGeometry,r=[],o=[];let n=0;for(const t of e){if(!t||!t.attributes.position)continue;const e=t.attributes.position.array;for(let t=0;t<e.length;t+=3)r.push(e[t],e[t+1],e[t+2]);if(t.index){const e=t.index.array;for(let t=0;t<e.length;t++)o.push(e[t]+n)}else for(let t=0;t<e.length/3;t++)o.push(t+n);n+=e.length/3}return t.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),t.setIndex(o),t.computeVertexNormals(),t}findPlaneById(e,t){let r=null;return t.scene.traverse(t=>{t.uuid===e&&t.userData?.type?.includes("plane")&&(r=t)}),r}}