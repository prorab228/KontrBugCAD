import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class RevolveExecutor extends ParametricExecutor{execute(e,t){const{figures:r,angle:o,axis:n,direction:s,operationType:i,color:l=16750592,planeId:c,addCaps:a=!0,capThickness:u=.01,lineAxisId:h=null}=e.parameters,E=e.inputs||[],p=t.objectMap.get(c)||this.findPlaneById(c,t.editor);if(!p)throw new Error(`Revolve: плоскость ${c} не найдена`);let f=null;if(h&&(f=t.objectMap.get(h),!f))throw new Error(`Revolve: линия ${h} не найдена`);const d=this.createRevolveGeometry(r,p,o,n,s,a,u,f);if(!d)throw new Error("Revolve: не удалось создать геометрию");const R=new THREE.Mesh(d,new THREE.MeshStandardMaterial({color:l}));if(R.castShadow=!0,R.receiveShadow=!0,R.userData={type:"revolve",sourceFigures:r,angle:o,axis:n,direction:s,operationType:i,planeId:c,addCaps:a,capThickness:u,lineAxisId:h},"new"===i)return e.outputs.length>0?R.uuid=e.outputs[0]:e.outputs=[R.uuid],R;if(!t.editor.booleanOps)throw new Error("Revolve: булевы операции не доступны");const m=E.map(e=>t.objectMap.get(e)).filter(Boolean);if(0===m.length)throw new Error("Revolve: не найдены целевые объекты для cut/join");let T;if("cut"===i){if(T=t.editor.booleanOps.subtract(m[0],R),!T)throw new Error("Revolve: не удалось выполнить вычитание")}else if("join"===i){const e=[R,...m];if(T=t.editor.booleanOps.unionMultiple(e),!T)throw new Error("Revolve: не удалось выполнить объединение")}return m.forEach(e=>{t.objectMap.delete(e.uuid),t.sceneGroup.remove(e)}),T.userData={...T.userData,type:"revolve_boolean",sourceOperation:e.id,operationType:i},e.outputs.length>0?T.uuid=e.outputs[0]:e.outputs=[T.uuid],T}createRevolveGeometry(e,t,r,o,n,s,i,l){this._currentPlane=t,this._currentLineMesh=l,this._currentAngle=r,this._currentAxis=o,this._currentDirection=n,this._currentAddCaps=s,this._currentCapThickness=i;const c=[];for(const t of e){const e=this._createSolidGeometryForContour(t.outer,!1,!1);if(e&&c.push(e),t.holes&&t.holes.length)for(const e of t.holes){const t=this._createSolidGeometryForContour(e,!1,!0);t&&c.push(t)}}if(s&&r<360){const t=this._createCapsForFigures(e);c.push(...t)}if(0===c.length)return null;const a=c.map(e=>this._toNonIndexed(e)).filter(Boolean),u=this.mergeGeometries(a);if(!u)return console.error("RevolveExecutor: не удалось объединить геометрии"),null;return this._mergeVertices(u,.1)}_createSolidGeometryForContour(e,t,r){if(!e||e.length<6)return null;const o=[];for(let t=0;t<e.length;t+=2)o.push(new THREE.Vector2(e[t],e[t+1]));const n=o.map(e=>{const t=new THREE.Vector3(e.x,e.y,0);return this._currentPlane.localToWorld(t)});let s;return s=this._currentLineMesh?this._createRevolveAroundLine(n,r):this._createRevolveAroundGlobalAxis(n,r),s||null}_createCapsForFigures(e){const t=[],r=[];for(const t of e){const e=this.createShapeFromFigure(t,this._currentPlane);e&&r.push(e)}if(0===r.length)return[];const o={depth:this._currentCapThickness,bevelEnabled:!1,steps:1},n="positive"===this._currentDirection?this._currentAngle:-this._currentAngle;for(const e of[0,n])try{const n=new THREE.ExtrudeGeometry(r,o),s=THREE.MathUtils.degToRad(e);if(this._currentLineMesh){const e=this._currentLineMesh,t=e.geometry.attributes.position.array,r=new THREE.Vector3(t[0],t[1],t[2]),o=new THREE.Vector3(t[3],t[4],t[5]),i=e.localToWorld(r),l=e.localToWorld(o),c=(new THREE.Vector3).subVectors(l,i).normalize(),a=(new THREE.Matrix4).makeRotationAxis(c,s),u=(new THREE.Matrix4).makeTranslation(-i.x,-i.y,-i.z),h=(new THREE.Matrix4).makeTranslation(i.x,i.y,i.z),E=h.clone().multiply(a).multiply(u).multiply(this._currentPlane.matrixWorld);n.applyMatrix4(E)}else{const e=this.getAxisVector(this._currentAxis),t=(new THREE.Matrix4).makeRotationAxis(e,s).multiply(this._currentPlane.matrixWorld);n.applyMatrix4(t)}t.push(n)}catch(e){console.error("Ошибка создания крышки:",e)}return t}_toNonIndexed(e){return e?e.index?e.toNonIndexed():e.clone():null}_mergeVertices(e,t=.001){if(!e)return null;if(!THREE.BufferGeometryUtils||!THREE.BufferGeometryUtils.mergeVertices)return console.warn("BufferGeometryUtils.mergeVertices недоступен"),e;const r=THREE.BufferGeometryUtils.mergeVertices(e,t);return r.computeVertexNormals(),r}_createRevolveAroundGlobalAxis(e,t){const r=this.getAxisVector(this._currentAxis).normalize(),o=new THREE.Vector3(0,0,0),n=(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),r),s=new THREE.Vector3(1,0,0).applyQuaternion(n).normalize(),i=new THREE.Vector3(0,0,1).applyQuaternion(n).normalize(),l=e[0],c=(new THREE.Vector3).subVectors(l,o),a=c.dot(r),u=(new THREE.Vector3).subVectors(c,r.clone().multiplyScalar(a));let h=-Math.atan2(u.dot(i),u.dot(s))+Math.PI/2;h<0&&(h+=2*Math.PI);const E=[];for(const t of e){const e=(new THREE.Vector3).subVectors(t,o),n=e.dot(r),s=e.clone().sub(r.clone().multiplyScalar(n)).length();E.push(new THREE.Vector2(s,n))}let p=0;const f=E.length;for(let e=0;e<f;e++){const t=(e+1)%f;p+=E[e].x*E[t].y,p-=E[t].x*E[e].y}if(p/=2,t?p>0&&E.reverse():p<0&&E.reverse(),E.length>0){const e=E[0],t=E[E.length-1];(Math.abs(e.x-t.x)>1e-6||Math.abs(e.y-t.y)>1e-6)&&E.push(e.clone())}const d="negative"===this._currentDirection?-THREE.MathUtils.degToRad(this._currentAngle):THREE.MathUtils.degToRad(this._currentAngle),R=Math.max(16,Math.round(this._currentAngle/5)),m=new THREE.LatheGeometry(E,R,h,d);return m.applyQuaternion(n),m.translate(o.x,o.y,o.z),m}_createRevolveAroundLine(e,t){const r=this._currentLineMesh;if(!r)return null;const o=r.geometry.attributes.position.array,n=new THREE.Vector3(o[0],o[1],o[2]),s=new THREE.Vector3(o[3],o[4],o[5]),i=r.localToWorld(n),l=r.localToWorld(s),c=(new THREE.Vector3).subVectors(l,i).normalize(),a=(new THREE.Quaternion).setFromUnitVectors(new THREE.Vector3(0,1,0),c),u=new THREE.Vector3(1,0,0).applyQuaternion(a).normalize(),h=new THREE.Vector3(0,0,1).applyQuaternion(a).normalize(),E=e[0],p=(new THREE.Vector3).subVectors(E,i),f=p.dot(c),d=(new THREE.Vector3).subVectors(p,c.clone().multiplyScalar(f));let R=-Math.atan2(d.dot(h),d.dot(u))+Math.PI/2;R<0&&(R+=2*Math.PI);const m=[];for(const t of e){const e=(new THREE.Vector3).subVectors(t,i),r=e.dot(c),o=e.clone().sub(c.clone().multiplyScalar(r)).length();m.push(new THREE.Vector2(o,r))}let T=0;const g=m.length;for(let e=0;e<g;e++){const t=(e+1)%g;T+=m[e].x*m[t].y,T-=m[t].x*m[e].y}if(T/=2,t?T>0&&m.reverse():T<0&&m.reverse(),m.length>0){const e=m[0],t=m[m.length-1];(Math.abs(e.x-t.x)>1e-6||Math.abs(e.y-t.y)>1e-6)&&m.push(e.clone())}const w="negative"===this._currentDirection?-THREE.MathUtils.degToRad(this._currentAngle):THREE.MathUtils.degToRad(this._currentAngle),y=Math.max(16,Math.round(this._currentAngle/5)),x=new THREE.LatheGeometry(m,y,R,w);return x.applyQuaternion(a),x.translate(i.x,i.y,i.z),x}createShapeFromFigure(e,t){const r=[];for(let t=0;t<e.outer.length;t+=2)r.push(new THREE.Vector2(e.outer[t],e.outer[t+1]));if(r.length<3)return null;const o=new THREE.Shape(r);if(e.holes&&e.holes.length>0)for(const t of e.holes){const e=[];for(let r=0;r<t.length;r+=2)e.push(new THREE.Vector2(t[r],t[r+1]));if(e.length>=3){const t=new THREE.Path(e);o.holes.push(t)}}return o}getAxisVector(e){switch(e){case"x":return new THREE.Vector3(1,0,0);case"y":default:return new THREE.Vector3(0,1,0);case"z":return new THREE.Vector3(0,0,1)}}mergeGeometries(e){if(0===e.length)return null;if(1===e.length)return e[0];if(THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeBufferGeometries)return THREE.BufferGeometryUtils.mergeBufferGeometries(e);const t=new THREE.BufferGeometry,r=[],o=[];let n=0;for(const t of e){if(!t||!t.attributes.position)continue;const e=t.attributes.position.array;for(let t=0;t<e.length;t+=3)r.push(e[t],e[t+1],e[t+2]);if(t.index){const e=t.index.array;for(let t=0;t<e.length;t++)o.push(e[t]+n)}else for(let t=0;t<e.length/3;t++)o.push(t+n);n+=e.length/3}return t.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),t.setIndex(o),t.computeVertexNormals(),t}findPlaneById(e,t){let r=null;return t.scene.traverse(t=>{t.uuid===e&&t.userData?.type?.includes("plane")&&(r=t)}),r}}