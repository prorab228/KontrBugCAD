import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class FilletChamferExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e,this.tolerance=1e-4}execute(e,t){const{targetId:o,type:r,distance:n,angle:s,edges:a,operationType:i}=e.parameters,c=t.objectMap.get(o);if(!c)throw new Error(`FilletChamfer: объект ${o} не найден`);console.log("Выполнение фаски для объекта",c.uuid,c.position,c.rotation,c.scale),console.log("Тип операции:",i);const l=c.geometry.clone();l.computeBoundingBox();const d=l.boundingBox,u=new THREE.Vector3;d.getCenter(u),console.log("Центр геометрии (лок):",u);const f=this.findEdges(l,a);if(0===f.length)throw new Error("Не найдены выбранные рёбра в текущей геометрии");const p=[],m=[];for(const e of f){const t=this.buildChamferTool(e,n,s,u);t&&t.geometry.index.count>=3?(p.push(t),m.push(e)):console.warn("Не удалось построить инструмент для ребра",e)}if(0===p.length)throw new Error("Не удалось построить инструменты");let g;if(this.snapVerticesByTopology(p,m),1===p.length)g=p[0];else if(g=this.editor.booleanOps.unionMultiple(p,null,!1),p.forEach(e=>this.disposeMesh(e)),THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeVertices){const e=THREE.BufferGeometryUtils.mergeVertices(g.geometry,.001);g.geometry=e,g.geometry.computeVertexNormals()}if(!g||!g.geometry||g.geometry.index.count<3)throw new Error("Инструмент не содержит треугольников");const E=new THREE.MeshPhongMaterial({color:16711935,transparent:!0,opacity:.3,side:THREE.DoubleSide}),h=g.clone();let y;if(h.material=E,this.editor.scene.add(h),setTimeout(()=>this.editor.scene.remove(h),5e3),g.position.copy(c.position),g.rotation.copy(c.rotation),g.scale.copy(c.scale),g.updateMatrixWorld(),y=this.editor.booleanOps.subtract(c,g,null,!1),!y)throw new Error("Булева операция не дала результата");const x=(new THREE.Matrix4).copy(c.matrixWorld).invert(),T=y.geometry,w=T.attributes.position,$=w.array;for(let e=0;e<$.length;e+=3){const t=new THREE.Vector3($[e],$[e+1],$[e+2]);t.applyMatrix4(x),$[e]=t.x,$[e+1]=t.y,$[e+2]=t.z}if(w.needsUpdate=!0,THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeVertices){const e=THREE.BufferGeometryUtils.mergeVertices(T,.001);y.geometry=e}const b=this.keepLargestComponent(y.geometry);if(b!==y.geometry){const e=y.geometry;y.geometry=b,e.dispose()}T.computeBoundingBox(),T.computeVertexNormals(),y.position.copy(c.position),y.rotation.copy(c.rotation),y.scale.copy(c.scale),y.updateMatrixWorld();let V=c.material;return c.userData&&c.userData.originalMaterial&&(V=c.userData.originalMaterial),V&&"function"==typeof V.clone?y.material=V.clone():y.material=new THREE.MeshStandardMaterial({color:8421504,side:THREE.FrontSide,flatShading:!0}),y.material.flatShading=!0,y.userData={...JSON.parse(JSON.stringify(c.userData||{})),modifiedBy:"filletChamfer",originalMaterial:y.material,operationParams:{type:r,distance:n,angle:s,edges:a,operationType:i}},t.objectMap.delete(o),t.sceneGroup.remove(c),this.disposeMesh(c),e.outputs.length>0?y.uuid=e.outputs[0]:e.outputs=[y.uuid],y}snapVerticesByTopology(e,t){if(e.length!==t.length)return void console.warn("snapVerticesByTopology: несовпадение длины массивов");if(e.length<2)return;console.log("=== snapVerticesByTopology (геометрическая группировка) ==="),console.log("Количество инструментов:",e.length);const o=[];t.forEach((e,t)=>{e&&e.v1&&e.v2?(o.push({pos:e.v1.clone(),edgeIdx:t,type:"v1"}),o.push({pos:e.v2.clone(),edgeIdx:t,type:"v2"})):console.warn(`edgeData[${t}] не содержит v1/v2`)});const r=[],n=new Array(o.length).fill(!1);for(let e=0;e<o.length;e++){if(n[e])continue;const t=[o[e]];n[e]=!0;for(let r=e+1;r<o.length;r++)n[r]||o[e].pos.distanceTo(o[r].pos)<.01&&(t.push(o[r]),n[r]=!0);const s=new THREE.Vector3;t.forEach(e=>s.add(e.pos)),s.divideScalar(t.length),r.push({avgPos:s.clone(),items:t})}console.log(`Найдено ${r.length} групп исходных вершин`);const s=new Map;r.forEach((e,t)=>{e.items.forEach(e=>{const o=`${e.edgeIdx}_${e.type}`;s.set(o,t)})}),e.forEach((e,t)=>{const o=e.geometry.attributes.position,n=`${t}_v1`;if(s.has(n)){const e=s.get(n),t=r[e].avgPos;o.setXYZ(0,t.x,t.y,t.z)}const a=`${t}_v2`;if(s.has(a)){const e=s.get(a),t=r[e].avgPos;o.setXYZ(3,t.x,t.y,t.z)}});const a=new Map;e.forEach((e,o)=>{const r=t[o];if(!r||!r.normalsAndCenters||r.normalsAndCenters.length<2)return void console.warn(`edgeData[${o}] не содержит нормалей`);const n=e.geometry.attributes.position,i=r.normalsAndCenters[0].normal.clone().normalize(),c=r.normalsAndCenters[1].normal.clone().normalize(),l=e=>`${e.x.toFixed(6)},${e.y.toFixed(6)},${e.z.toFixed(6)}`,d=l(i),u=l(c),f=`${o}_v1`,p=`${o}_v2`,m=s.get(f),g=s.get(p);if(void 0===m||void 0===g)return void console.warn(`Не найдена группа для ребра ${o}`);const E=`${m}_${d}`;a.has(E)||a.set(E,[]),a.get(E).push({toolIdx:o,vertIdx:1,pos:(new THREE.Vector3).fromBufferAttribute(n,1)});const h=`${m}_${u}`;a.has(h)||a.set(h,[]),a.get(h).push({toolIdx:o,vertIdx:2,pos:(new THREE.Vector3).fromBufferAttribute(n,2)});const y=`${g}_${d}`;a.has(y)||a.set(y,[]),a.get(y).push({toolIdx:o,vertIdx:4,pos:(new THREE.Vector3).fromBufferAttribute(n,4)});const x=`${g}_${u}`;a.has(x)||a.set(x,[]),a.get(x).push({toolIdx:o,vertIdx:5,pos:(new THREE.Vector3).fromBufferAttribute(n,5)})}),console.log(`Групп смещённых вершин: ${a.size}`),a.forEach((t,o)=>{if(t.length<2)return;const r=new THREE.Vector3;t.forEach(e=>r.add(e.pos)),r.divideScalar(t.length),t.forEach(t=>{e[t.toolIdx].geometry.attributes.position.setXYZ(t.vertIdx,r.x,r.y,r.z)})});const i=[];e.forEach((e,t)=>{const o=e.geometry.attributes.position;for(let e=0;e<6;e++)i.push({toolIdx:t,vertIdx:e,pos:(new THREE.Vector3).fromBufferAttribute(o,e)})});const c=new Array(i.length).fill(!1);let l=0;for(let t=0;t<i.length;t++){if(c[t])continue;const o=[i[t]];c[t]=!0;for(let e=t+1;e<i.length;e++)c[e]||i[t].pos.distanceTo(i[e].pos)<.001&&(o.push(i[e]),c[e]=!0);if(o.length>1){l++;const t=new THREE.Vector3;o.forEach(e=>t.add(e.pos)),t.divideScalar(o.length),o.forEach(o=>{e[o.toolIdx].geometry.attributes.position.setXYZ(o.vertIdx,t.x,t.y,t.z)})}}console.log(`Финальных геометрических групп: ${l}`),e.forEach(e=>{e.geometry.attributes.position.needsUpdate=!0,e.geometry.computeVertexNormals()}),console.log("=== snapVerticesByTopology завершён ===")}keepLargestComponent(e){const t=e.index;if(!t)return e;const o=t.array,r=(e.attributes.position,o.length/3),n=new Map;for(let e=0;e<o.length;e+=3){const t=e/3,r=o[e],s=o[e+1],a=o[e+2];[r<s?`${r}|${s}`:`${s}|${r}`,s<a?`${s}|${a}`:`${a}|${s}`,a<r?`${a}|${r}`:`${r}|${a}`].forEach(e=>{n.has(e)||n.set(e,[]),n.get(e).push(t)})}const s=new Array(r).fill(!1),a=[];for(let e=0;e<r;e++){if(s[e])continue;const t=[e];s[e]=!0;const r=[];for(;t.length;){const e=t.pop();r.push(e);const a=3*e,i=o[a],c=o[a+1],l=o[a+2];[i<c?`${i}|${c}`:`${c}|${i}`,c<l?`${c}|${l}`:`${l}|${c}`,l<i?`${l}|${i}`:`${i}|${l}`].forEach(e=>{(n.get(e)||[]).forEach(e=>{s[e]||(s[e]=!0,t.push(e))})})}a.push(r)}let i=[];if(a.forEach(e=>{e.length>i.length&&(i=e)}),i.length===r)return e;const c=[];i.forEach(e=>{const t=3*e;c.push(o[t],o[t+1],o[t+2])});const l=new THREE.BufferGeometry;for(const t in e.attributes)l.setAttribute(t,e.attributes[t].clone());return l.setIndex(c),l.computeVertexNormals(),l}findEdges(e,t){const o=e.attributes.position;if(!e.index)return[];console.log("Поиск рёбер с допуском 0.1");const r=[];for(const n of t){const t=new THREE.Vector3(n.v1[0],n.v1[1],n.v1[2]),s=new THREE.Vector3(n.v2[0],n.v2[1],n.v2[2]);console.log(`Поиск ребра (лок: ${t.toArray().map(e=>e.toFixed(2))} - ${s.toArray().map(e=>e.toFixed(2))})`);let a=-1,i=-1,c=1/0,l=1/0;for(let e=0;e<o.count;e++){const r=(new THREE.Vector3).fromBufferAttribute(o,e),n=r.distanceTo(t);n<c&&(c=n,a=e);const d=r.distanceTo(s);d<l&&(l=d,i=e)}if(console.log(`  Ближайшая к v1: индекс ${a}, расстояние ${c.toFixed(4)}`),console.log(`  Ближайшая к v2: индекс ${i}, расстояние ${l.toFixed(4)}`),-1===a||-1===i||a===i)continue;if(c>.1||l>.1){console.warn(`  → Превышен допуск (${c.toFixed(4)} / ${l.toFixed(4)})`);continue}const d=(new THREE.Vector3).fromBufferAttribute(o,a),u=(new THREE.Vector3).fromBufferAttribute(o,i);console.log(`  → Найдено совпадение: (${d.toArray().map(e=>e.toFixed(2))} - ${u.toArray().map(e=>e.toFixed(2))})`);const f=this.getEdgeNormalsAndCenters(e,d,u);r.push({v1:d,v2:u,normalsAndCenters:f})}return r}getEdgeNormalsAndCenters(e,t,o){const r=e.attributes.position,n=e.index,s=this.tolerance,a=[];for(let e=0;e<n.count;e+=3){const i=n.array[e],c=n.array[e+1],l=n.array[e+2],d=(new THREE.Vector3).fromBufferAttribute(r,i),u=(new THREE.Vector3).fromBufferAttribute(r,c),f=(new THREE.Vector3).fromBufferAttribute(r,l),p=d.distanceTo(t)<s||u.distanceTo(t)<s||f.distanceTo(t)<s,m=d.distanceTo(o)<s||u.distanceTo(o)<s||f.distanceTo(o)<s;if(p&&m){const e=u.clone().sub(d),t=f.clone().sub(d),o=(new THREE.Vector3).crossVectors(e,t).normalize();if(!isNaN(o.x)){const e=d.clone().add(u).add(f).multiplyScalar(1/3);a.push({normal:o,center:e})}}}return a}buildChamferTool(e,t,o,r){const{v1:n,v2:s,normalsAndCenters:a}=e;if(!a||a.length<2)return console.warn("buildChamferTool: недостаточно данных"),null;const i=THREE.MathUtils.degToRad(o),c=t/Math.tan(i);if(Math.abs(c)<1e-6)return console.warn("buildChamferTool: offset слишком мал"),null;const l=1.2*c,d=a[0].normal.clone().normalize(),u=a[1].normal.clone().normalize(),f=a[0].center,p=a[1].center,m=n.clone().add(s).multiplyScalar(.5),g=f.clone().add(p).multiplyScalar(.5).clone().sub(m).normalize(),E=d.clone().add(u).normalize().dot(g)>0?1:-1,h=n.clone(),y=s.clone(),x=h.clone().addScaledVector(d,E*l),T=h.clone().addScaledVector(u,E*l),w=y.clone().addScaledVector(d,E*l),$=y.clone().addScaledVector(u,E*l),b=new THREE.Triangle(h,x,T).getArea(),V=new THREE.Triangle(y,w,$).getArea();if(b<1e-6||V<1e-6)return console.warn("buildChamferTool: вырожденный треугольник"),null;const v=[h.x,h.y,h.z,x.x,x.y,x.z,T.x,T.y,T.z,y.x,y.y,y.z,w.x,w.y,w.z,$.x,$.y,$.z],R=new THREE.BufferGeometry;R.setAttribute("position",new THREE.Float32BufferAttribute(v,3)),R.setIndex([0,1,2,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),R.computeVertexNormals();const H=new THREE.Vector3;for(let e=0;e<v.length;e+=3)H.x+=v[e],H.y+=v[e+1],H.z+=v[e+2];H.divideScalar(6);const A=R.index.array,B=R.attributes.position,M=[];for(let e=0;e<A.length;e+=3){const t=A[e],o=A[e+1],r=A[e+2],n=(new THREE.Vector3).fromBufferAttribute(B,t),s=(new THREE.Vector3).fromBufferAttribute(B,o),a=(new THREE.Vector3).fromBufferAttribute(B,r),i=(new THREE.Vector3).addVectors(n,s).add(a).multiplyScalar(1/3),c=H.clone().sub(i);(new THREE.Vector3).crossVectors(s.clone().sub(n),a.clone().sub(n)).normalize().dot(c)<0?M.push(t,o,r):M.push(r,o,t)}return R.setIndex(M),R.computeVertexNormals(),R.index.count<3?(console.warn("buildChamferTool: нет треугольников"),null):new THREE.Mesh(R,new THREE.MeshBasicMaterial)}disposeMesh(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}