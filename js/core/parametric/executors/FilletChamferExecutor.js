import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class FilletChamferExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e,this.tolerance=1e-4}execute(e,t){const{targetId:o,type:r,distance:n,angle:s,edges:i,operationType:a}=e.parameters,c=t.objectMap.get(o);if(!c)throw new Error(`FilletChamfer: объект ${o} не найден`);console.log("Выполнение фаски для объекта",c.uuid,c.position,c.rotation,c.scale),console.log("Тип операции:",a);const l=c.geometry.clone();l.computeBoundingBox();const d=l.boundingBox,u=new THREE.Vector3;d.getCenter(u),console.log("Центр геометрии (лок):",u);const f=this.findEdges(l,i);if(0===f.length)throw new Error("Не найдены выбранные рёбра в текущей геометрии");const p=[],m=[];for(const e of f){const t=this.buildChamferTool(e,n,s,u);t&&t.geometry.index.count>=3?(p.push(t),m.push(e)):console.warn("Не удалось построить инструмент для ребра",e)}if(0===p.length)throw new Error("Не удалось построить инструменты");let E;if(this.snapVerticesByTopology(p,m),1===p.length?E=p[0]:(E=this.editor.booleanOps.unionMultiple(p,!1),p.forEach(e=>this.disposeMesh(e))),!E||!E.geometry||E.geometry.index.count<3)throw new Error("Инструмент не содержит треугольников");const h=new THREE.MeshPhongMaterial({color:16711935,transparent:!0,opacity:.3,side:THREE.DoubleSide}),x=E.clone();let g;if(x.material=h,this.editor.scene.add(x),setTimeout(()=>this.editor.scene.remove(x),5e3),E.position.copy(c.position),E.rotation.copy(c.rotation),E.scale.copy(c.scale),E.updateMatrixWorld(),g=this.editor.booleanOps.subtract(c,E,!1),!g)throw new Error("Булева операция не дала результата");const y=(new THREE.Matrix4).copy(c.matrixWorld).invert(),$=g.geometry,T=$.attributes.position,w=T.array;for(let e=0;e<w.length;e+=3){const t=new THREE.Vector3(w[e],w[e+1],w[e+2]);t.applyMatrix4(y),w[e]=t.x,w[e+1]=t.y,w[e+2]=t.z}if(T.needsUpdate=!0,THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeVertices){const e=THREE.BufferGeometryUtils.mergeVertices($,.01);g.geometry=e}const b=this.keepLargestComponent(g.geometry);if(b!==g.geometry){const e=g.geometry;g.geometry=b,e.dispose()}$.computeBoundingBox(),$.computeVertexNormals(),g.position.copy(c.position),g.rotation.copy(c.rotation),g.scale.copy(c.scale),g.updateMatrixWorld();let V=c.material;return c.userData&&c.userData.originalMaterial&&(V=c.userData.originalMaterial),V&&"function"==typeof V.clone?g.material=V.clone():g.material=new THREE.MeshStandardMaterial({color:8421504,side:THREE.FrontSide,flatShading:!0}),g.material.flatShading=!0,g.userData={...JSON.parse(JSON.stringify(c.userData||{})),modifiedBy:"filletChamfer",originalMaterial:g.material,operationParams:{type:r,distance:n,angle:s,edges:i,operationType:a}},t.objectMap.delete(o),t.sceneGroup.remove(c),this.disposeMesh(c),e.outputs.length>0?g.uuid=e.outputs[0]:e.outputs=[g.uuid],g}snapVerticesByTopology(e,t){if(e.length!==t.length)return void console.warn("snapVerticesByTopology: несовпадение длины массивов");if(e.length<2)return;console.log("=== snapVerticesByTopology (топологическая группировка по нормалям) ==="),console.log("Инструментов:",e.length);const o=[],r=[];e.forEach((e,n)=>{const s=t[n];if(!s||!s.v1||!s.v2)return void console.warn(`edgeData[${n}] не содержит v1/v2`,s);const i=e.geometry.attributes.position,a=(new THREE.Vector3).fromBufferAttribute(i,0);o.push({toolIdx:n,vertIdx:0,pos:a.clone(),key:`${s.v1.x.toFixed(6)},${s.v1.y.toFixed(6)},${s.v1.z.toFixed(6)}`});const c=(new THREE.Vector3).fromBufferAttribute(i,3);r.push({toolIdx:n,vertIdx:3,pos:c.clone(),key:`${s.v2.x.toFixed(6)},${s.v2.y.toFixed(6)},${s.v2.z.toFixed(6)}`})});const n=e=>{const t=new Map;return e.forEach(e=>{t.has(e.key)||t.set(e.key,[]),t.get(e.key).push(e)}),t},s=t=>{if(t.length<2)return;const o=new THREE.Vector3;t.forEach(e=>o.add(e.pos)),o.divideScalar(t.length),t.forEach(t=>{e[t.toolIdx].geometry.attributes.position.setXYZ(t.vertIdx,o.x,o.y,o.z)})},i=n(o),a=n(r);i.forEach(e=>s(e)),a.forEach(e=>s(e));const c=new Map;e.forEach((e,o)=>{const r=t[o];if(!r||!r.normalsAndCenters||r.normalsAndCenters.length<2)return void console.warn(`edgeData[${o}] не содержит normalsAndCenters`);const n=r.normalsAndCenters[0].normal,s=r.normalsAndCenters[1].normal,i=r.v1,a=r.v2,l=e.geometry.attributes.position,d=`${i.x.toFixed(6)},${i.y.toFixed(6)},${i.z.toFixed(6)}|${n.x.toFixed(6)},${n.y.toFixed(6)},${n.z.toFixed(6)}`,u=(new THREE.Vector3).fromBufferAttribute(l,1);c.has(d)||c.set(d,[]),c.get(d).push({toolIdx:o,vertIdx:1,pos:u.clone()});const f=`${i.x.toFixed(6)},${i.y.toFixed(6)},${i.z.toFixed(6)}|${s.x.toFixed(6)},${s.y.toFixed(6)},${s.z.toFixed(6)}`,p=(new THREE.Vector3).fromBufferAttribute(l,2);c.has(f)||c.set(f,[]),c.get(f).push({toolIdx:o,vertIdx:2,pos:p.clone()});const m=`${a.x.toFixed(6)},${a.y.toFixed(6)},${a.z.toFixed(6)}|${n.x.toFixed(6)},${n.y.toFixed(6)},${n.z.toFixed(6)}`,E=(new THREE.Vector3).fromBufferAttribute(l,4);c.has(m)||c.set(m,[]),c.get(m).push({toolIdx:o,vertIdx:4,pos:E.clone()});const h=`${a.x.toFixed(6)},${a.y.toFixed(6)},${a.z.toFixed(6)}|${s.x.toFixed(6)},${s.y.toFixed(6)},${s.z.toFixed(6)}`,x=(new THREE.Vector3).fromBufferAttribute(l,5);c.has(h)||c.set(h,[]),c.get(h).push({toolIdx:o,vertIdx:5,pos:x.clone()})}),c.forEach((t,o)=>{if(t.length<2)return;const r=new THREE.Vector3;t.forEach(e=>r.add(e.pos)),r.divideScalar(t.length),t.forEach(t=>{e[t.toolIdx].geometry.attributes.position.setXYZ(t.vertIdx,r.x,r.y,r.z)})}),console.log(`Сгруппировано смещённых вершин: ${c.size} групп`),e.forEach(e=>{e.geometry.attributes.position.needsUpdate=!0,e.geometry.computeVertexNormals()}),console.log("=== snapVerticesByTopology завершён ===")}keepLargestComponent(e){const t=e.index;if(!t)return e;const o=t.array,r=(e.attributes.position,o.length/3),n=new Map;for(let e=0;e<o.length;e+=3){const t=e/3,r=o[e],s=o[e+1],i=o[e+2];[r<s?`${r}|${s}`:`${s}|${r}`,s<i?`${s}|${i}`:`${i}|${s}`,i<r?`${i}|${r}`:`${r}|${i}`].forEach(e=>{n.has(e)||n.set(e,[]),n.get(e).push(t)})}const s=new Array(r).fill(!1),i=[];for(let e=0;e<r;e++){if(s[e])continue;const t=[e];s[e]=!0;const r=[];for(;t.length;){const e=t.pop();r.push(e);const i=3*e,a=o[i],c=o[i+1],l=o[i+2];[a<c?`${a}|${c}`:`${c}|${a}`,c<l?`${c}|${l}`:`${l}|${c}`,l<a?`${l}|${a}`:`${a}|${l}`].forEach(e=>{(n.get(e)||[]).forEach(e=>{s[e]||(s[e]=!0,t.push(e))})})}i.push(r)}let a=[];if(i.forEach(e=>{e.length>a.length&&(a=e)}),a.length===r)return e;const c=[];a.forEach(e=>{const t=3*e;c.push(o[t],o[t+1],o[t+2])});const l=new THREE.BufferGeometry;for(const t in e.attributes)l.setAttribute(t,e.attributes[t].clone());return l.setIndex(c),l.computeVertexNormals(),l}findEdges(e,t){const o=e.attributes.position;if(!e.index)return[];console.log("Поиск рёбер с допуском 0.1");const r=[];for(const n of t){const t=new THREE.Vector3(n.v1[0],n.v1[1],n.v1[2]),s=new THREE.Vector3(n.v2[0],n.v2[1],n.v2[2]);console.log(`Поиск ребра (лок: ${t.toArray().map(e=>e.toFixed(2))} - ${s.toArray().map(e=>e.toFixed(2))})`);let i=-1,a=-1,c=1/0,l=1/0;for(let e=0;e<o.count;e++){const r=(new THREE.Vector3).fromBufferAttribute(o,e),n=r.distanceTo(t);n<c&&(c=n,i=e);const d=r.distanceTo(s);d<l&&(l=d,a=e)}if(console.log(`  Ближайшая к v1: индекс ${i}, расстояние ${c.toFixed(4)}`),console.log(`  Ближайшая к v2: индекс ${a}, расстояние ${l.toFixed(4)}`),-1===i||-1===a||i===a)continue;if(c>.1||l>.1){console.warn(`  → Превышен допуск (${c.toFixed(4)} / ${l.toFixed(4)})`);continue}const d=(new THREE.Vector3).fromBufferAttribute(o,i),u=(new THREE.Vector3).fromBufferAttribute(o,a);console.log(`  → Найдено совпадение: (${d.toArray().map(e=>e.toFixed(2))} - ${u.toArray().map(e=>e.toFixed(2))})`);const f=this.getEdgeNormalsAndCenters(e,d,u);r.push({v1:d,v2:u,normalsAndCenters:f})}return r}getEdgeNormalsAndCenters(e,t,o){const r=e.attributes.position,n=e.index,s=this.tolerance,i=[];for(let e=0;e<n.count;e+=3){const a=n.array[e],c=n.array[e+1],l=n.array[e+2],d=(new THREE.Vector3).fromBufferAttribute(r,a),u=(new THREE.Vector3).fromBufferAttribute(r,c),f=(new THREE.Vector3).fromBufferAttribute(r,l),p=d.distanceTo(t)<s||u.distanceTo(t)<s||f.distanceTo(t)<s,m=d.distanceTo(o)<s||u.distanceTo(o)<s||f.distanceTo(o)<s;if(p&&m){const e=u.clone().sub(d),t=f.clone().sub(d),o=(new THREE.Vector3).crossVectors(e,t).normalize();if(!isNaN(o.x)){const e=d.clone().add(u).add(f).multiplyScalar(1/3);i.push({normal:o,center:e})}}}return i}buildChamferTool(e,t,o,r){const{v1:n,v2:s,normalsAndCenters:i}=e;if(!i||i.length<2)return console.warn("buildChamferTool: недостаточно данных"),null;const a=THREE.MathUtils.degToRad(o),c=t/Math.tan(a);if(Math.abs(c)<1e-6)return console.warn("buildChamferTool: offset слишком мал"),null;const l=1.2*c,d=i[0].normal.clone().normalize(),u=i[1].normal.clone().normalize(),f=i[0].center,p=i[1].center,m=n.clone().add(s).multiplyScalar(.5),E=f.clone().add(p).multiplyScalar(.5).clone().sub(m).normalize(),h=d.clone().add(u).normalize().dot(E)>0?1:-1,x=n.clone(),g=s.clone(),y=x.clone().addScaledVector(d,h*l),$=x.clone().addScaledVector(u,h*l),T=g.clone().addScaledVector(d,h*l),w=g.clone().addScaledVector(u,h*l),b=new THREE.Triangle(x,y,$).getArea(),V=new THREE.Triangle(g,T,w).getArea();if(b<1e-6||V<1e-6)return console.warn("buildChamferTool: вырожденный треугольник"),null;const R=[x.x,x.y,x.z,y.x,y.y,y.z,$.x,$.y,$.z,g.x,g.y,g.z,T.x,T.y,T.z,w.x,w.y,w.z],F=new THREE.BufferGeometry;F.setAttribute("position",new THREE.Float32BufferAttribute(R,3)),F.setIndex([0,1,2,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),F.computeVertexNormals();const H=new THREE.Vector3;for(let e=0;e<R.length;e+=3)H.x+=R[e],H.y+=R[e+1],H.z+=R[e+2];H.divideScalar(6);const v=F.index.array,A=F.attributes.position,B=[];for(let e=0;e<v.length;e+=3){const t=v[e],o=v[e+1],r=v[e+2],n=(new THREE.Vector3).fromBufferAttribute(A,t),s=(new THREE.Vector3).fromBufferAttribute(A,o),i=(new THREE.Vector3).fromBufferAttribute(A,r),a=(new THREE.Vector3).addVectors(n,s).add(i).multiplyScalar(1/3),c=H.clone().sub(a);(new THREE.Vector3).crossVectors(s.clone().sub(n),i.clone().sub(n)).normalize().dot(c)<0?B.push(t,o,r):B.push(r,o,t)}return F.setIndex(B),F.computeVertexNormals(),F.index.count<3?(console.warn("buildChamferTool: нет треугольников"),null):new THREE.Mesh(F,new THREE.MeshBasicMaterial)}disposeMesh(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}