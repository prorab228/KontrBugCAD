import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class FilletChamferExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e,this.tolerance=1e-4}execute(e,t){const{targetId:o,type:r,distance:n,angle:s,edges:i,operationType:a}=e.parameters,l=t.objectMap.get(o);if(!l)throw new Error(`FilletChamfer: объект ${o} не найден`);console.log("Выполнение фаски для объекта",l.uuid,l.position,l.rotation,l.scale),console.log("Тип операции:",a);const c=l.geometry.clone();c.computeBoundingBox();const u=c.boundingBox,d=new THREE.Vector3;u.getCenter(d),console.log("Центр геометрии (лок):",d);const f=this.findEdges(c,i);if(0===f.length)throw new Error("Не найдены выбранные рёбра в текущей геометрии");const m=[],p=[];for(const e of f){const t=this.buildChamferTool(e,n,s,d);t&&t.geometry.index.count>=3?(m.push(t),p.push(e)):console.warn("Не удалось построить инструмент для ребра",e)}if(0===m.length)throw new Error("Не удалось построить инструменты");let E;if(this.snapVerticesByTopology(m,p),1===m.length)E=m[0];else if(E=this.editor.booleanOps.unionMultiple(m,null,!1),m.forEach(e=>this.disposeMesh(e)),THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeVertices){const e=THREE.BufferGeometryUtils.mergeVertices(E.geometry,1e-4);E.geometry=e,E.geometry.computeVertexNormals()}if(!E||!E.geometry||E.geometry.index.count<3)throw new Error("Инструмент не содержит треугольников");const g=new THREE.MeshPhongMaterial({color:16711935,transparent:!0,opacity:.3,side:THREE.DoubleSide}),h=E.clone();let y;if(h.material=g,this.editor.scene.add(h),setTimeout(()=>this.editor.scene.remove(h),5e3),E.position.copy(l.position),E.rotation.copy(l.rotation),E.scale.copy(l.scale),E.updateMatrixWorld(),y=this.editor.booleanOps.subtract(l,E,null,!1),!y)throw new Error("Булева операция не дала результата");const x=(new THREE.Matrix4).copy(l.matrixWorld).invert(),T=y.geometry,w=T.attributes.position,b=w.array;for(let e=0;e<b.length;e+=3){const t=new THREE.Vector3(b[e],b[e+1],b[e+2]);t.applyMatrix4(x),b[e]=t.x,b[e+1]=t.y,b[e+2]=t.z}if(w.needsUpdate=!0,THREE.BufferGeometryUtils&&THREE.BufferGeometryUtils.mergeVertices){const e=THREE.BufferGeometryUtils.mergeVertices(T,1e-4);y.geometry=e}const V=this.keepLargestComponent(y.geometry);if(V!==y.geometry){const e=y.geometry;y.geometry=V,e.dispose()}T.computeBoundingBox(),T.computeVertexNormals(),y.position.copy(l.position),y.rotation.copy(l.rotation),y.scale.copy(l.scale),y.updateMatrixWorld();let $=l.material;return l.userData&&l.userData.originalMaterial&&($=l.userData.originalMaterial),$&&"function"==typeof $.clone?y.material=$.clone():y.material=new THREE.MeshStandardMaterial({color:8421504,side:THREE.FrontSide,flatShading:!0}),y.material.flatShading=!0,y.userData={...JSON.parse(JSON.stringify(l.userData||{})),modifiedBy:"filletChamfer",originalMaterial:y.material,operationParams:{type:r,distance:n,angle:s,edges:i,operationType:a}},t.objectMap.delete(o),t.sceneGroup.remove(l),this.disposeMesh(l),e.outputs.length>0?y.uuid=e.outputs[0]:e.outputs=[y.uuid],y}snapVerticesByTopology(e,t){if(e.length!==t.length)return void console.warn("snapVerticesByTopology: несовпадение длины массивов");if(e.length<2)return;console.log("=== snapVerticesByTopology (топологическая группировка + геометрическая сварка) ==="),console.log("Количество инструментов:",e.length);const o=e=>`${e.x.toFixed(6)},${e.y.toFixed(6)},${e.z.toFixed(6)}`,r=[];e.forEach((e,n)=>{const s=t[n];if(!s||!s.v1||!s.v2)return void console.warn(`edgeData[${n}] не содержит v1/v2`,s);const i=e.geometry.attributes.position;r.push({toolIdx:n,vertIdx:0,pos:(new THREE.Vector3).fromBufferAttribute(i,0),key:o(s.v1)}),r.push({toolIdx:n,vertIdx:3,pos:(new THREE.Vector3).fromBufferAttribute(i,3),key:o(s.v2)})});const n=t=>{if(t.length<2)return;const o=new THREE.Vector3;t.forEach(e=>o.add(e.pos)),o.divideScalar(t.length),t.forEach(t=>{e[t.toolIdx].geometry.attributes.position.setXYZ(t.vertIdx,o.x,o.y,o.z)})},s=(e=>{const t=new Map;return e.forEach(e=>{t.has(e.key)||t.set(e.key,[]),t.get(e.key).push(e)}),t})(r);console.log(`Групп исходных вершин: ${s.size}`),s.forEach(n);const i=[];e.forEach((e,r)=>{const n=t[r];if(!n||!n.normalsAndCenters||n.normalsAndCenters.length<2)return void console.warn(`edgeData[${r}] не содержит нормалей`,n);const s=e.geometry.attributes.position,a=n.normalsAndCenters[0].normal.clone().normalize(),l=n.normalsAndCenters[1].normal.clone().normalize(),c=o(n.v1),u=o(n.v2),d=e=>`${e.x.toFixed(6)},${e.y.toFixed(6)},${e.z.toFixed(6)}`,f=d(a),m=d(l);i.push({toolIdx:r,vertIdx:1,pos:(new THREE.Vector3).fromBufferAttribute(s,1),originKey:c,normalKey:f}),i.push({toolIdx:r,vertIdx:2,pos:(new THREE.Vector3).fromBufferAttribute(s,2),originKey:c,normalKey:m}),i.push({toolIdx:r,vertIdx:4,pos:(new THREE.Vector3).fromBufferAttribute(s,4),originKey:u,normalKey:f}),i.push({toolIdx:r,vertIdx:5,pos:(new THREE.Vector3).fromBufferAttribute(s,5),originKey:u,normalKey:m})});const a=new Map;i.forEach(e=>{const t=`${e.originKey}|${e.normalKey}`;a.has(t)||a.set(t,[]),a.get(t).push(e)}),console.log(`Групп смещённых вершин: ${a.size}`),a.forEach(n);const l=[];e.forEach((e,t)=>{const o=e.geometry.attributes.position;for(let e=0;e<6;e++)l.push({toolIdx:t,vertIdx:e,pos:(new THREE.Vector3).fromBufferAttribute(o,e)})});const c=new Array(l.length).fill(!1);let u=0;for(let t=0;t<l.length;t++){if(c[t])continue;const o=[l[t]];c[t]=!0;for(let e=t+1;e<l.length;e++)c[e]||l[t].pos.distanceTo(l[e].pos)<1e-4&&(o.push(l[e]),c[e]=!0);if(o.length>1){u++;const t=new THREE.Vector3;o.forEach(e=>t.add(e.pos)),t.divideScalar(o.length),o.forEach(o=>{e[o.toolIdx].geometry.attributes.position.setXYZ(o.vertIdx,t.x,t.y,t.z)})}}console.log(`Финальных геометрических групп: ${u}`),e.forEach(e=>{e.geometry.attributes.position.needsUpdate=!0,e.geometry.computeVertexNormals()}),console.log("=== snapVerticesByTopology завершён ===")}keepLargestComponent(e){const t=e.index;if(!t)return e;const o=t.array,r=(e.attributes.position,o.length/3),n=new Map;for(let e=0;e<o.length;e+=3){const t=e/3,r=o[e],s=o[e+1],i=o[e+2];[r<s?`${r}|${s}`:`${s}|${r}`,s<i?`${s}|${i}`:`${i}|${s}`,i<r?`${i}|${r}`:`${r}|${i}`].forEach(e=>{n.has(e)||n.set(e,[]),n.get(e).push(t)})}const s=new Array(r).fill(!1),i=[];for(let e=0;e<r;e++){if(s[e])continue;const t=[e];s[e]=!0;const r=[];for(;t.length;){const e=t.pop();r.push(e);const i=3*e,a=o[i],l=o[i+1],c=o[i+2];[a<l?`${a}|${l}`:`${l}|${a}`,l<c?`${l}|${c}`:`${c}|${l}`,c<a?`${c}|${a}`:`${a}|${c}`].forEach(e=>{(n.get(e)||[]).forEach(e=>{s[e]||(s[e]=!0,t.push(e))})})}i.push(r)}let a=[];if(i.forEach(e=>{e.length>a.length&&(a=e)}),a.length===r)return e;const l=[];a.forEach(e=>{const t=3*e;l.push(o[t],o[t+1],o[t+2])});const c=new THREE.BufferGeometry;for(const t in e.attributes)c.setAttribute(t,e.attributes[t].clone());return c.setIndex(l),c.computeVertexNormals(),c}findEdges(e,t){const o=e.attributes.position;if(!e.index)return[];console.log("Поиск рёбер с допуском 0.1");const r=[];for(const n of t){const t=new THREE.Vector3(n.v1[0],n.v1[1],n.v1[2]),s=new THREE.Vector3(n.v2[0],n.v2[1],n.v2[2]);console.log(`Поиск ребра (лок: ${t.toArray().map(e=>e.toFixed(2))} - ${s.toArray().map(e=>e.toFixed(2))})`);let i=-1,a=-1,l=1/0,c=1/0;for(let e=0;e<o.count;e++){const r=(new THREE.Vector3).fromBufferAttribute(o,e),n=r.distanceTo(t);n<l&&(l=n,i=e);const u=r.distanceTo(s);u<c&&(c=u,a=e)}if(console.log(`  Ближайшая к v1: индекс ${i}, расстояние ${l.toFixed(4)}`),console.log(`  Ближайшая к v2: индекс ${a}, расстояние ${c.toFixed(4)}`),-1===i||-1===a||i===a)continue;if(l>.1||c>.1){console.warn(`  → Превышен допуск (${l.toFixed(4)} / ${c.toFixed(4)})`);continue}const u=(new THREE.Vector3).fromBufferAttribute(o,i),d=(new THREE.Vector3).fromBufferAttribute(o,a);console.log(`  → Найдено совпадение: (${u.toArray().map(e=>e.toFixed(2))} - ${d.toArray().map(e=>e.toFixed(2))})`);const f=this.getEdgeNormalsAndCenters(e,u,d);r.push({v1:u,v2:d,normalsAndCenters:f})}return r}getEdgeNormalsAndCenters(e,t,o){const r=e.attributes.position,n=e.index,s=this.tolerance,i=[];for(let e=0;e<n.count;e+=3){const a=n.array[e],l=n.array[e+1],c=n.array[e+2],u=(new THREE.Vector3).fromBufferAttribute(r,a),d=(new THREE.Vector3).fromBufferAttribute(r,l),f=(new THREE.Vector3).fromBufferAttribute(r,c),m=u.distanceTo(t)<s||d.distanceTo(t)<s||f.distanceTo(t)<s,p=u.distanceTo(o)<s||d.distanceTo(o)<s||f.distanceTo(o)<s;if(m&&p){const e=d.clone().sub(u),t=f.clone().sub(u),o=(new THREE.Vector3).crossVectors(e,t).normalize();if(!isNaN(o.x)){const e=u.clone().add(d).add(f).multiplyScalar(1/3);i.push({normal:o,center:e})}}}return i}buildChamferTool(e,t,o,r){const{v1:n,v2:s,normalsAndCenters:i}=e;if(!i||i.length<2)return console.warn("buildChamferTool: недостаточно данных"),null;const a=THREE.MathUtils.degToRad(o),l=t/Math.tan(a);if(Math.abs(l)<1e-6)return console.warn("buildChamferTool: offset слишком мал"),null;const c=1.2*l,u=i[0].normal.clone().normalize(),d=i[1].normal.clone().normalize(),f=i[0].center,m=i[1].center,p=n.clone().add(s).multiplyScalar(.5),E=f.clone().add(m).multiplyScalar(.5).clone().sub(p).normalize(),g=u.clone().add(d).normalize().dot(E)>0?1:-1,h=n.clone(),y=s.clone(),x=h.clone().addScaledVector(u,g*c),T=h.clone().addScaledVector(d,g*c),w=y.clone().addScaledVector(u,g*c),b=y.clone().addScaledVector(d,g*c),V=new THREE.Triangle(h,x,T).getArea(),$=new THREE.Triangle(y,w,b).getArea();if(V<1e-6||$<1e-6)return console.warn("buildChamferTool: вырожденный треугольник"),null;const R=[h.x,h.y,h.z,x.x,x.y,x.z,T.x,T.y,T.z,y.x,y.y,y.z,w.x,w.y,w.z,b.x,b.y,b.z],H=new THREE.BufferGeometry;H.setAttribute("position",new THREE.Float32BufferAttribute(R,3)),H.setIndex([0,1,2,3,4,5,0,1,4,0,4,3,1,2,5,1,5,4,2,0,3,2,3,5]),H.computeVertexNormals();const v=new THREE.Vector3;for(let e=0;e<R.length;e+=3)v.x+=R[e],v.y+=R[e+1],v.z+=R[e+2];v.divideScalar(6);const A=H.index.array,B=H.attributes.position,M=[];for(let e=0;e<A.length;e+=3){const t=A[e],o=A[e+1],r=A[e+2],n=(new THREE.Vector3).fromBufferAttribute(B,t),s=(new THREE.Vector3).fromBufferAttribute(B,o),i=(new THREE.Vector3).fromBufferAttribute(B,r),a=(new THREE.Vector3).addVectors(n,s).add(i).multiplyScalar(1/3),l=v.clone().sub(a);(new THREE.Vector3).crossVectors(s.clone().sub(n),i.clone().sub(n)).normalize().dot(l)<0?M.push(t,o,r):M.push(r,o,t)}return H.setIndex(M),H.computeVertexNormals(),H.index.count<3?(console.warn("buildChamferTool: нет треугольников"),null):new THREE.Mesh(H,new THREE.MeshBasicMaterial)}disposeMesh(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}