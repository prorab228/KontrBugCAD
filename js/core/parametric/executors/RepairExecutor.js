import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class RepairExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e}execute(e,t){const{targets:r,fixOpenEdges:o=!0,removeIsolated:a=!0,removeSmallComponents:s=!1,createUVs:i=!0,repairStrategy:n="balanced",fallbackToConvexHull:l=!1}=e.parameters,c=[];for(const e of r){const r=t.objectMap.get(e);if(r&&r.isMesh)try{const p=this.repairObject(r,{fixOpenEdges:o,removeIsolated:a,removeSmallComponents:s,createUVs:i,repairStrategy:n,fallbackToConvexHull:l});p&&(t.objectMap.delete(e),t.sceneGroup.remove(r),this.disposeObject(r),c.push(p))}catch(t){throw console.error(`Repair: ошибка при ремонте объекта ${e}:`,t),t}}return c}repairObject(e,t){if(!this.editor.booleanOps.geometryRepair)throw new Error("GeometryRepair не загружен");const r=e.geometry.clone();r.applyMatrix4(e.matrixWorld);const o={mergeDistance:1e-4,removeDegenerate:!0,removeDuplicates:!0,removeIsolated:t.removeIsolated,removeSmallComponents:t.removeSmallComponents,minComponentSize:10,closeHoles:t.fixOpenEdges&&"fast"!==t.repairStrategy,fixNormals:!0,checkInfinity:!0,verbose:!0,maxIterations:"fast"===t.repairStrategy?1:3};let a=this.editor.booleanOps.geometryRepair.repair(r,o);if("guaranteed"===t.repairStrategy&&t.fallbackToConvexHull&&this.editor.booleanOps&&this.editor.booleanOps.isReady)try{const e=this.editor.booleanOps._threeGeometryToManifold(a);if(0!==e.status()){console.warn("Результат ремонта не манифолден, применяем convex hull");const e=this._createConvexHull(a);e&&(a=e)}e.delete?.()}catch(e){console.warn("Ошибка проверки manifold, применяем convex hull",e);const t=this._createConvexHull(a);t&&(a=t)}t.createUVs&&!a.attributes.uv&&this._createSimpleUVs(a);const s=this._cloneMaterial(e.material),i=new THREE.Mesh(a,s);return i.position.set(0,0,0),i.rotation.set(0,0,0),i.scale.set(1,1,1),i.castShadow=e.castShadow,i.receiveShadow=e.receiveShadow,i.visible=e.visible,i.name=`repaired_${e.name||e.uuid}`,i.userData={...JSON.parse(JSON.stringify(e.userData||{})),repaired:!0,repairedAt:(new Date).toISOString(),originalId:e.uuid},i}_createConvexHull(e){if(!this.editor.booleanOps||!this.editor.booleanOps.manifold)return null;const{manifold:t}=this.editor.booleanOps;try{const r=e.attributes.position.array,o=[];for(let e=0;e<r.length;e+=3)o.push([r[e],r[e+1],r[e+2]]);const a=t.Manifold.hull(o),s=this.editor.booleanOps._manifoldToThreeGeometry(a);return a.delete(),s}catch(e){return console.warn("Convex hull failed:",e),null}}_createSimpleUVs(e){const t=e.attributes.position,r=t.count,o=new Float32Array(2*r);e.computeBoundingBox();const a=e.boundingBox,s=new THREE.Vector3;a.getCenter(s);for(let e=0;e<r;e++){const r=t.getX(e)-s.x,a=t.getY(e)-s.y,i=t.getZ(e)-s.z,n=Math.sqrt(r*r+a*a+i*i);if(n<.001)o[2*e]=.5,o[2*e+1]=.5;else{const t=Math.atan2(i,r),s=Math.acos(a/n);o[2*e]=(t+Math.PI)/(2*Math.PI),o[2*e+1]=s/Math.PI}}e.setAttribute("uv",new THREE.BufferAttribute(o,2))}_cloneMaterial(e){return e?Array.isArray(e)?e.map(e=>this._cloneMaterial(e)):"function"==typeof e.clone?e.clone():new THREE.MeshStandardMaterial({color:8421504}):new THREE.MeshStandardMaterial({color:8421504})}disposeObject(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}