import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class DecimateExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e}execute(e,t){const{targets:r,reductionFactor:a,preserveBorders:o,preserveNormals:s}=e.parameters,i=[];for(const e of r){const r=t.objectMap.get(e);if(r)if(this.canDecimate(r))try{const c=this.decimateObject(r,a,o,s);c&&(t.objectMap.delete(e),t.sceneGroup.remove(r),this.disposeObject(r),i.push(c))}catch(t){console.error(`Decimate: ошибка при упрощении объекта ${e}:`,t)}else console.warn(`Decimate: объект ${e} не подходит для упрощения`);else console.warn(`Decimate: объект ${e} не найден, пропускаем`)}return i}canDecimate(e){if(!e.isMesh||!e.geometry)return!1;return this.getFaceCount(e.geometry)>=100}getFaceCount(e){return e.index?e.index.count/3:e.attributes.position?e.attributes.position.count/3:0}decimateObject(e,t,r,a){const o=e.geometry.clone();o.applyMatrix4(e.matrixWorld);const s=this.editor.booleanOps.simplify(o,t);if(!s||this.getFaceCount(s)<4)throw new Error("Упрощение привело к пустой геометрии");const i=this.cloneMaterial(e.material),c=new THREE.Mesh(s,i);return c.position.set(0,0,0),c.rotation.set(0,0,0),c.scale.set(1,1,1),c.castShadow=e.castShadow,c.receiveShadow=e.receiveShadow,c.visible=e.visible,c.userData=JSON.parse(JSON.stringify(e.userData||{})),c.userData.decimated=!0,c.userData.decimatedAt=(new Date).toISOString(),c.userData.reductionFactor=t,a&&c.geometry.computeVertexNormals(),c}cloneMaterial(e){return e?Array.isArray(e)?e.map(e=>this.cloneMaterial(e)):"function"==typeof e.clone?e.clone():new THREE.MeshStandardMaterial({color:8421504}):new THREE.MeshStandardMaterial({color:8421504})}disposeObject(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose())}}