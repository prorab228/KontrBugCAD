import{ParametricExecutor}from"./ParametricExecutor.js";export class BooleanBaseExecutor extends ParametricExecutor{constructor(e,t){super(e),this.operationType=t}execute(e,t){const r=t.editor.booleanOps;let o;switch(this.operationType){case"union":{const a=e.inputs.map(e=>t.objectMap.get(e)).filter(e=>e);if(a.length<2)throw new Error("Boolean union: недостаточно объектов");o=r.unionMultiple(a);break}case"subtract":{let a=[],s=[];if(e.parameters&&e.parameters.baseUuids&&e.parameters.subtractUuids)a=e.parameters.baseUuids.map(e=>t.objectMap.get(e)).filter(e=>e),s=e.parameters.subtractUuids.map(e=>t.objectMap.get(e)).filter(e=>e);else{const r=e.inputs.map(e=>t.objectMap.get(e)).filter(e=>e);if(r.length<2)throw new Error("Boolean subtract: недостаточно объектов");a=[r[0]],s=r.slice(1)}if(0===a.length)throw new Error("Boolean subtract: нет уменьшаемых объектов");if(0===s.length)throw new Error("Boolean subtract: нет вычитаемых объектов");o=r.subtractMultiple(a,s);break}case"intersect":{const a=e.inputs.map(e=>t.objectMap.get(e)).filter(e=>e);if(a.length<2)throw new Error("Boolean intersect: недостаточно объектов");o=r.intersectMultiple(a);break}default:throw new Error(`Неизвестная булева операция: ${this.operationType}`)}e.outputs.length>0?o.uuid=e.outputs[0]:e.outputs=[o.uuid],o.userData={type:"boolean",operation:this.operationType,sourceObjects:e.inputs};for(const r of e.inputs){const e=t.objectMap.get(r);e&&(t.sceneGroup.remove(e),t.objectMap.delete(r),e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose()))}return o}}export class BooleanUnionExecutor extends BooleanBaseExecutor{constructor(e){super(e,"union")}}export class BooleanSubtractExecutor extends BooleanBaseExecutor{constructor(e){super(e,"subtract")}}export class BooleanIntersectExecutor extends BooleanBaseExecutor{constructor(e){super(e,"intersect")}}