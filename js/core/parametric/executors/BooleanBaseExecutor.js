import{ParametricExecutor}from"./ParametricExecutor.js";export class BooleanBaseExecutor extends ParametricExecutor{constructor(e,t){super(e),this.operationType=t}execute(e,t){const o=e.inputs.map(e=>t.objectMap.get(e)).filter(e=>e);if(o.length<2)throw new Error(`Boolean ${this.operationType}: недостаточно объектов`);const r=t.editor.booleanOps;let s;switch(this.operationType){case"union":s=r.unionMultiple(o);break;case"subtract":s=r.subtract(o[0],o[1]);break;case"intersect":s=r.intersect(o[0],o[1]);break;default:throw new Error(`Неизвестная булева операция: ${this.operationType}`)}e.outputs.length>0?s.uuid=e.outputs[0]:e.outputs=[s.uuid],s.userData={type:"boolean",operation:this.operationType,sourceObjects:e.inputs};for(const o of e.inputs){const e=t.objectMap.get(o);e&&(t.sceneGroup.remove(e),t.objectMap.delete(o),e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>e.dispose()):e.material.dispose()))}return s}}export class BooleanUnionExecutor extends BooleanBaseExecutor{constructor(e){super(e,"union")}}export class BooleanSubtractExecutor extends BooleanBaseExecutor{constructor(e){super(e,"subtract")}}export class BooleanIntersectExecutor extends BooleanBaseExecutor{constructor(e){super(e,"intersect")}}