import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class PaintFacesExecutor extends ParametricExecutor{execute(e,r){const{target:t,faceColors:a}=e.parameters,o=r.objectMap.get(t);if(!o||!o.isMesh)throw new Error(`PaintFaces: объект ${t} не найден или не является Mesh`);return this.applyColors(o,a),o.userData.faceColors=a,null}preview(e,r){this.applyColors(e,r)}applyColors(e,r){let t=e.geometry;t=this._ensurePerFaceGeometry(t);const a=t.attributes.position.count,o=a/3;if(r.length!==o)return void console.warn("PaintFaces: размер массива цветов не совпадает с количеством граней");const s=new Float32Array(3*a);for(let e=0;e<o;e++){const t=r[e],a=(t>>16&255)/255,o=(t>>8&255)/255,i=(255&t)/255;for(let r=0;r<3;r++){const t=3*(3*e+r);s[t]=a,s[t+1]=o,s[t+2]=i}}t.setAttribute("color",new THREE.BufferAttribute(s,3)),e.material?Array.isArray(e.material)?e.material.forEach(e=>e.vertexColors=!0):(e.material.vertexColors=!0,e.material.needsUpdate=!0):e.material=new THREE.MeshStandardMaterial({vertexColors:!0})}_ensurePerFaceGeometry(e){return e.index?THREE.BufferGeometryUtils.toNonIndexed(e):e}}