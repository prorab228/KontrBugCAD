import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class MirrorExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e}execute(e,t){const{targets:r,mirrorType:o,axis:a,planeId:i}=e.parameters,n=[];for(const e of r){const r=t.objectMap.get(e);if(!r){console.warn(`Mirror: объект ${e} не найден, пропускаем`);continue}const s=r.clone(!0);if("axis"===o)this.reflectByAxis(s,a);else{if("plane"!==o)throw new Error(`Mirror: неизвестный тип ${o}`);{const r=t.objectMap.get(i);if(!r){console.warn(`Mirror: плоскость ${i} не найдена, пропускаем объект ${e}`);continue}this.reflectByPlane(s,r)}}this.setupMirroredObject(s,r,o,a,i),n.push(s)}return n}reflectByAxis(e,t){const r=(new THREE.Box3).setFromObject(e),o=new THREE.Vector3;r.getCenter(o);const a=e.position.clone().sub(o);switch(t){case"x":a.x=-a.x,this.reflectGeometry(e,"x"),this.reflectRotation(e,"x");break;case"y":a.y=-a.y,this.reflectGeometry(e,"y"),this.reflectRotation(e,"y");break;case"z":a.z=-a.z,this.reflectGeometry(e,"z"),this.reflectRotation(e,"z")}e.position.copy(o).add(a)}reflectByPlane(e,t){const r=new THREE.Vector3(0,0,1).applyQuaternion(t.quaternion).normalize(),o=t.position.clone(),a=e.position.clone().sub(o).dot(r),i=r.clone().multiplyScalar(-2*a);e.position.add(i),this.reflectGeometryByPlane(e,r)}reflectGeometry(e,t){if(!e.geometry)return;const r=e.geometry.clone(),o=r.attributes.position.array;for(let e=0;e<o.length;e+=3)switch(t){case"x":o[e]=-o[e];break;case"y":o[e+1]=-o[e+1];break;case"z":o[e+2]=-o[e+2]}if(r.attributes.position.needsUpdate=!0,r.computeVertexNormals(),r.index){const e=r.index.array;for(let t=0;t<e.length;t+=3){const r=e[t];e[t]=e[t+1],e[t+1]=r}r.index.needsUpdate=!0}e.geometry=r}reflectGeometryByPlane(e,t){if(!e.geometry)return;const r=e.geometry.clone(),o=r.attributes.position.array;for(let e=0;e<o.length;e+=3){const r=new THREE.Vector3(o[e],o[e+1],o[e+2]),a=r.dot(t);r.x-=2*a*t.x,r.y-=2*a*t.y,r.z-=2*a*t.z,o[e]=r.x,o[e+1]=r.y,o[e+2]=r.z}if(r.attributes.position.needsUpdate=!0,r.computeVertexNormals(),r.index){const e=r.index.array;for(let t=0;t<e.length;t+=3){const r=e[t];e[t]=e[t+1],e[t+1]=r}r.index.needsUpdate=!0}e.geometry=r}reflectRotation(e,t){const r=new THREE.Quaternion;switch(t){case"x":r.setFromEuler(new THREE.Euler(0,Math.PI,Math.PI));break;case"y":r.setFromEuler(new THREE.Euler(Math.PI,0,Math.PI));break;case"z":r.setFromEuler(new THREE.Euler(Math.PI,Math.PI,0))}e.quaternion.multiply(r),e.quaternion.normalize()}setupMirroredObject(e,t,r,o,a){const i=JSON.parse(JSON.stringify(t.userData||{}));i.name=`${t.userData?.name||"Объект"} (зеркало)`,i.isMirrored=!0,i.originalObject=t.uuid,i.mirrorType=r,"axis"===r?i.mirrorAxis=o:i.mirrorPlaneId=a;const n=t.userData?.originalMaterial||t.material;n&&(Array.isArray(n)?e.material=n.map(e=>e.clone()):e.material=n.clone(),Array.isArray(e.material)?e.material.forEach(e=>{e.side=THREE.FrontSide,e.needsUpdate=!0}):(e.material.side=THREE.FrontSide,e.material.needsUpdate=!0),i.originalMaterial=e.material),e.userData=i,e.updateMatrixWorld(!0)}}