import*as THREE from"three";import{ParametricExecutor}from"./ParametricExecutor.js";export class SplitExecutor extends ParametricExecutor{constructor(e){super(),this.editor=e}execute(e,t){const{target:r,planeId:a}=e.parameters,o=t.objectMap.get(r);if(!o)throw new Error(`Split: объект ${r} не найден`);const i=t.objectMap.get(a);if(!i)throw new Error(`Split: плоскость ${a} не найдена`);const s=this.cutWithCSG(o,i);return t.objectMap.delete(r),t.sceneGroup.remove(o),s}cutWithCSG(e,t){if(!this.editor.booleanOps)throw new Error("Библиотека булевых операций не загружена");const r=new THREE.Vector3(0,0,1).applyQuaternion(t.quaternion).normalize(),a=t.position.clone(),o=(new THREE.Box3).setFromObject(e),i=new THREE.Vector3;o.getSize(i);const s=Math.max(i.x,i.y,i.z),n=this.createHalfSpace(r,a,!0,s),c=this.createHalfSpace(r,a,!1,s),l=this.editor.booleanOps.intersect(e,n),p=this.editor.booleanOps.intersect(e,c);return n.geometry.dispose(),c.geometry.dispose(),this.setupPart(l,e,"positive"),this.setupPart(p,e,"negative"),[l,p]}createHalfSpace(e,t,r,a){const o=10*a,i=new THREE.BoxGeometry(o,o,o),s=new THREE.Mesh(i,new THREE.MeshBasicMaterial),n=e.clone().multiplyScalar(r?o/2:-o/2);return s.position.copy(t.clone().add(n)),s.lookAt(t.clone().add(e)),s}setupPart(e,t,r){e.userData=JSON.parse(JSON.stringify(t.userData||{})),e.userData.name=`${t.userData?.name||"Объект"} (${r})`,e.userData.isSplitPart=!0,e.userData.originalObject=t.uuid,e.userData.splitSide=r;const a=t.userData?.originalMaterial||t.material;a&&(Array.isArray(a)?e.material=a.map(e=>e.clone()):e.material=a.clone(),e.userData.originalMaterial=e.material),e.updateMatrixWorld(!0)}}