class DragManager{constructor(t){this.editor=t,this.isDragging=!1,this.draggedObjects=[],this.dragStartPositions=[],this.dragStartMouse=null,this.dragPlane=null,this.dragOffsets=[],this.mainObjectIndex=0,this.moveLinesX=[],this.moveLinesY=[],this.moveLinesZ=[],this.lineThickness=.3,this.showMoveLines=!0,this.snapToGrid=!0,this.gridSize=1,this.verticalThreshold=.4,this._tempVector=new THREE.Vector3,this._tempVector2=new THREE.Vector3,this._tempQuaternion=new THREE.Quaternion,this._raycaster=new THREE.Raycaster,this._lastUpdateTime=0,this._updateInterval=16,this._inputContainerX=null,this._inputElementX=null,this._inputContainerY=null,this._inputElementY=null,this._inputContainerZ=null,this._inputElementZ=null,this._isInputFocusedX=!1,this._isInputFocusedY=!1,this._isInputFocusedZ=!1,this._lastInputX=0,this._lastInputY=0,this._lastInputZ=0,this._linesInitialized=!1,this.mainObjectOffset=null,this.currentPlaneMode="XZ"}prepareDrag(t,i){if(this.draggedObjects=[...this.editor.selectedObjects],this.mainObjectIndex=this.draggedObjects.indexOf(t),-1===this.mainObjectIndex&&(this.draggedObjects.unshift(t),this.mainObjectIndex=0),this.mainObjectIndex>0&&(this.draggedObjects.splice(this.mainObjectIndex,1),this.draggedObjects.unshift(t),this.mainObjectIndex=0),this.dragStartPositions=this.draggedObjects.map(t=>t.position.clone()),this.draggedObjects.length>1){const t=this.draggedObjects[0];this.dragOffsets=this.draggedObjects.map(i=>i.position.clone().sub(t.position))}else this.dragOffsets=[new THREE.Vector3(0,0,0)];this.mainObjectOffset=i.clone().sub(t.position);const e=new THREE.Vector3;this.editor.camera.getWorldDirection(e),e.normalize();if(Math.abs(e.y)<this.verticalThreshold){Math.abs(e.x)>Math.abs(e.z)?(this.currentPlaneMode="YZ",this.dragPlane=new THREE.Plane(new THREE.Vector3(1,0,0),-i.x)):(this.currentPlaneMode="XY",this.dragPlane=new THREE.Plane(new THREE.Vector3(0,0,1),-i.z))}else this.currentPlaneMode="XZ",this.dragPlane=new THREE.Plane(new THREE.Vector3(0,1,0),-i.y)}startDrag(t){this.isDragging=!0,this.dragStartMouse=new THREE.Vector2(t.clientX,t.clientY),this.clearLinesAndInputs(),this.showMoveLines&&this.initMoveLines(),this.editor.showStatus(`Перетаскивание: ${this.draggedObjects.length} объект(ов) (плоскость ${this.currentPlaneMode})`,"info"),this.initInputElements(),this.onMouseMove(t)}initMoveLines(){this.removeMoveLines(),this._linesInitialized=!0;for(let t=0;t<this.draggedObjects.length;t++){this.draggedObjects[t];const i=this.dragStartPositions[t],e=this.createAxisLine(i,i,16729156,"x");this.editor.scene.add(e),this.moveLinesX.push(e);const s=this.createAxisLine(i,i,4521796,"y");this.editor.scene.add(s),this.moveLinesY.push(s);const n=this.createAxisLine(i,i,4474111,"z");this.editor.scene.add(n),this.moveLinesZ.push(n)}}createAxisLine(t,i,e,s){const n=new THREE.CylinderGeometry(this.lineThickness/2,this.lineThickness/2,1,6,1,!1),o=new THREE.MeshBasicMaterial({color:e,transparent:!0,opacity:.6,side:THREE.DoubleSide}),r=new THREE.Mesh(n,o);return r.userData.axis=s,r.visible=this.showMoveLines,r.renderOrder=1e3,this.updateAxisLine(r,t,i,s),r}updateAxisLine(t,i,e,s){if(!t)return null;const n=this._tempVector,o=this._tempVector2;"x"===s?(n.copy(i),o.set(e.x,i.y,i.z)):"y"===s?(n.set(e.x,i.y,e.z),o.set(e.x,e.y,e.z)):"z"===s&&(n.set(e.x,i.y,i.z),o.set(e.x,i.y,e.z));const r=n.distanceTo(o);if(r<.001)return t.visible=!1,null;t.visible=!0;const a=(new THREE.Vector3).addVectors(n,o).multiplyScalar(.5);if(t.position.copy(a),t.scale.set(1,r,1),r>.001){const i=(new THREE.Vector3).subVectors(o,n).normalize();this._tempQuaternion.setFromUnitVectors(new THREE.Vector3(0,1,0),i),t.quaternion.copy(this._tempQuaternion)}return{midPoint:a.clone(),distance:r,direction:o.clone().sub(n).normalize()}}initInputElements(){this._inputContainerX||(this._inputContainerX=document.createElement("div"),this._inputContainerX.className="drag-input-container-x",this._inputContainerX.style.cssText="\n                border: 2px solid #ff4444;\n            ",this._inputElementX=document.createElement("input"),this._inputElementX.type="number",this._inputElementX.step="0.1",this._inputElementX.style.width="60px",this._inputContainerX.appendChild(this._inputElementX),document.body.appendChild(this._inputContainerX),this._inputElementX.addEventListener("focus",()=>{this._isInputFocusedX=!0}),this._inputElementX.addEventListener("blur",()=>{this._isInputFocusedX=!1}),this._inputElementX.addEventListener("input",t=>{const i=parseFloat(t.target.value);isNaN(i)||this.updateFromInput("x",i)})),this._inputContainerY||(this._inputContainerY=document.createElement("div"),this._inputContainerY.className="drag-input-container-y",this._inputContainerY.style.cssText="\n                border: 2px solid #44ff44;\n            ",this._inputElementY=document.createElement("input"),this._inputElementY.type="number",this._inputElementY.step="0.1",this._inputElementY.style.width="60px",this._inputContainerY.appendChild(this._inputElementY),document.body.appendChild(this._inputContainerY),this._inputElementY.addEventListener("focus",()=>{this._isInputFocusedY=!0}),this._inputElementY.addEventListener("blur",()=>{this._isInputFocusedY=!1}),this._inputElementY.addEventListener("input",t=>{const i=parseFloat(t.target.value);isNaN(i)||this.updateFromInput("y",i)})),this._inputContainerZ||(this._inputContainerZ=document.createElement("div"),this._inputContainerZ.className="drag-input-container-z",this._inputContainerZ.style.cssText="\n                border: 2px solid #4444ff;\n            ",this._inputElementZ=document.createElement("input"),this._inputElementZ.type="number",this._inputElementZ.step="0.1",this._inputElementZ.style.width="60px",this._inputContainerZ.appendChild(this._inputElementZ),document.body.appendChild(this._inputContainerZ),this._inputElementZ.addEventListener("focus",()=>{this._isInputFocusedZ=!0}),this._inputElementZ.addEventListener("blur",()=>{this._isInputFocusedZ=!1}),this._inputElementZ.addEventListener("input",t=>{const i=parseFloat(t.target.value);isNaN(i)||this.updateFromInput("z",i)}))}updateFromInput(t,i){if(0===this.draggedObjects.length)return;const e=this.draggedObjects[0],s=this.dragStartPositions[0];if("x"===t){const t=s.x+i;e.position.x=t;for(let i=1;i<this.draggedObjects.length;i++)this.draggedObjects[i].position.x=t+this.dragOffsets[i].x}else if("y"===t){const t=s.y+i;e.position.y=t;for(let i=1;i<this.draggedObjects.length;i++)this.draggedObjects[i].position.y=t+this.dragOffsets[i].y}else if("z"===t){const t=s.z+i;e.position.z=t;for(let i=1;i<this.draggedObjects.length;i++)this.draggedObjects[i].position.z=t+this.dragOffsets[i].z}this.updateMoveLines()}addHistoryAction(){if(0===this.draggedObjects.length)return;const t=this.draggedObjects.map((t,i)=>({uuid:t.uuid,position:t.position.toArray()})),i=new ParametricOperation("move_multiple",{objects:t},[]);this.editor.parametricModel.addOperation(i)}updateMoveLines(){if(!this.showMoveLines||!this._linesInitialized)return;const t=performance.now();if(!(t-this._lastUpdateTime<this._updateInterval&&this.isDragging)){this._lastUpdateTime=t;for(let t=0;t<this.draggedObjects.length;t++){const i=this.draggedObjects[t],e=this.dragStartPositions[t],s=i.position,n=this.moveLinesX[t];if(n){const i=this.updateAxisLine(n,e,s,"x"),o=s.x-e.x;i&&Math.abs(o)>.1?(n.visible=!0,0===t&&!this._isInputFocusedX&&this._inputContainerX&&(this._lastInputX=o,this._inputElementX.value=o.toFixed(1),this._inputContainerX.style.display="block",this.updateInputPosition("x",i.midPoint))):(n.visible=!1,0===t&&this._inputContainerX&&(this._inputContainerX.style.display="none"))}const o=this.moveLinesY[t];if(o){const i=this.updateAxisLine(o,e,s,"y"),n=s.y-e.y;i&&Math.abs(n)>.1?(o.visible=!0,0===t&&!this._isInputFocusedY&&this._inputContainerY&&(this._lastInputY=n,this._inputElementY.value=n.toFixed(1),this._inputContainerY.style.display="block",this.updateInputPosition("y",i.midPoint))):(o.visible=!1,0===t&&this._inputContainerY&&(this._inputContainerY.style.display="none"))}const r=this.moveLinesZ[t];if(r){const i=this.updateAxisLine(r,e,s,"z"),n=s.z-e.z;i&&Math.abs(n)>.1?(r.visible=!0,0===t&&!this._isInputFocusedZ&&this._inputContainerZ&&(this._lastInputZ=n,this._inputElementZ.value=n.toFixed(1),this._inputContainerZ.style.display="block",this.updateInputPosition("z",i.midPoint))):(r.visible=!1,0===t&&this._inputContainerZ&&(this._inputContainerZ.style.display="none"))}}}}updateInputPosition(t,i){if(!this.editor.camera||!this.editor.renderer)return;const e=this.worldToScreen(i,this.editor.camera,this.editor.renderer);"x"===t&&this._inputContainerX?(this._inputContainerX.style.left=`${e.x}px`,this._inputContainerX.style.top=`${e.y}px`):"y"===t&&this._inputContainerY?(this._inputContainerY.style.left=`${e.x}px`,this._inputContainerY.style.top=`${e.y}px`):"z"===t&&this._inputContainerZ&&(this._inputContainerZ.style.left=`${e.x}px`,this._inputContainerZ.style.top=`${e.y}px`)}worldToScreen(t,i,e){const s=t.clone();s.project(i);return{x:(.5*s.x+.5)*e.domElement.clientWidth,y:(-.5*s.y+.5)*e.domElement.clientHeight}}onMouseMove(t){if(!this.isDragging||0===this.draggedObjects.length)return;t.preventDefault(),this.editor.updateMousePosition(t);const i=this.getDragPosition(t);if(!i)return;let e=i.clone().sub(this.mainObjectOffset);this.snapToGrid&&(e.x=Math.round(e.x/this.gridSize)*this.gridSize,e.y=Math.round(e.y/this.gridSize)*this.gridSize,e.z=Math.round(e.z/this.gridSize)*this.gridSize);this.draggedObjects[0].position.copy(e);for(let t=1;t<this.draggedObjects.length;t++){this.draggedObjects[t].position.copy(e.clone().add(this.dragOffsets[t]))}this.showMoveLines&&(this._linesInitialized||this.initMoveLines(),this.updateMoveLines()),this.updateCoordinates(e),document.body.style.cursor="grabbing"}getDragPosition(t){if(!this.dragPlane)return null;const i=this.editor.renderer.domElement.getBoundingClientRect(),e=new THREE.Vector2((t.clientX-i.left)/i.width*2-1,-(t.clientY-i.top)/i.height*2+1);this._raycaster.setFromCamera(e,this.editor.camera);const s=new THREE.Vector3;return this._raycaster.ray.intersectPlane(this.dragPlane,s)?s:null}updateCoordinates(t){const i=this.draggedObjects[0];document.getElementById("coords").textContent=`X: ${t.x.toFixed(2)}, Y: ${i.position.y.toFixed(2)}, Z: ${t.z.toFixed(2)}`}finishDrag(){if(0===this.draggedObjects.length)return;this.isDragging=!1,this.dragStartMouse=null,this.dragPlane=null,document.body.style.cursor="default";let t=!1;for(let i=0;i<this.draggedObjects.length;i++)if(!this.dragStartPositions[i].equals(this.draggedObjects[i].position)){t=!0;break}if(t&&(this.addHistoryAction(),this.editor.showStatus(`Перемещено ${this.draggedObjects.length} объект(ов)`,"success")),this.draggedObjects.length>0){const t=this.draggedObjects[0],i=this.dragStartPositions[0],e=t.position.x-i.x,s=t.position.y-i.y,n=t.position.z-i.z;Math.abs(e)>.1&&this._inputContainerX&&!this._isInputFocusedX&&(this._lastInputX=e,this._inputElementX.value=e.toFixed(1)),Math.abs(s)>.1&&this._inputContainerY&&!this._isInputFocusedY&&(this._lastInputY=s,this._inputElementY.value=s.toFixed(1)),Math.abs(n)>.1&&this._inputContainerZ&&!this._isInputFocusedZ&&(this._lastInputZ=n,this._inputElementZ.value=n.toFixed(1))}}cancelDrag(){if(this.draggedObjects.length>0){for(let t=0;t<this.draggedObjects.length;t++)this.draggedObjects[t].position.copy(this.dragStartPositions[t]);this.clearLinesAndInputs(),this.editor.showStatus("Перетаскивание отменено","info")}this.resetDrag()}removeMoveLines(){for(const t of this.moveLinesX)t&&t.parent&&(t.parent.remove(t),t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose());this.moveLinesX=[];for(const t of this.moveLinesY)t&&t.parent&&(t.parent.remove(t),t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose());this.moveLinesY=[];for(const t of this.moveLinesZ)t&&t.parent&&(t.parent.remove(t),t.geometry&&t.geometry.dispose(),t.material&&t.material.dispose());this.moveLinesZ=[],this._linesInitialized=!1}clearLinesAndInputs(){this.removeMoveLines(),this._inputContainerX&&(this._inputContainerX.style.display="none"),this._inputContainerY&&(this._inputContainerY.style.display="none"),this._inputContainerZ&&(this._inputContainerZ.style.display="none")}resetDrag(){this.isDragging=!1,this.draggedObjects=[],this.dragStartPositions=[],this.dragOffsets=[],this.dragStartMouse=null,this.dragPlane=null,this.mainObjectIndex=0,this.mainObjectOffset=null,this._linesInitialized=!1,this.clearLinesAndInputs(),document.body.style.cursor="default"}toggleSnapToGrid(){return this.snapToGrid=!this.snapToGrid,this.editor.showStatus("Привязка к сетке: "+(this.snapToGrid?"ВКЛ":"ВЫКЛ"),"info"),this.snapToGrid}setGridSize(t){this.gridSize=Math.max(1,Math.min(100,t)),this.editor.showStatus(`Размер сетки: ${this.gridSize} мм`,"info")}toggleMoveLines(){this.showMoveLines=!this.showMoveLines,this.editor.showStatus("Линии перемещения: "+(this.showMoveLines?"ВКЛ":"ВЫКЛ"),"info");for(const t of this.moveLinesX)t&&(t.visible=this.showMoveLines);for(const t of this.moveLinesY)t&&(t.visible=this.showMoveLines);for(const t of this.moveLinesZ)t&&(t.visible=this.showMoveLines);return this.showMoveLines||(this._inputContainerX&&(this._inputContainerX.style.display="none"),this._inputContainerY&&(this._inputContainerY.style.display="none"),this._inputContainerZ&&(this._inputContainerZ.style.display="none")),this.showMoveLines}destroy(){this.removeMoveLines(),this._inputContainerX&&this._inputContainerX.parentElement&&(document.body.removeChild(this._inputContainerX),this._inputContainerX=null,this._inputElementX=null),this._inputContainerY&&this._inputContainerY.parentElement&&(document.body.removeChild(this._inputContainerY),this._inputContainerY=null,this._inputElementY=null),this._inputContainerZ&&this._inputContainerZ.parentElement&&(document.body.removeChild(this._inputContainerZ),this._inputContainerZ=null,this._inputElementZ=null)}}