import*as THREE from"three";export class PlanesManager{constructor(e,t={}){this.editor=e,this.enableFaceGrouping=void 0===t.enableFaceGrouping||t.enableFaceGrouping,this.cylinderEndTolerance=t.cylinderEndTolerance||.01,this.normalTolerance=t.normalTolerance||.99,this.PLANE_OFFSET=0}createBasePlanes(){this.editor.basePlanes&&this.editor.worldGroup.remove(this.editor.basePlanes),this.editor.basePlanes=new THREE.Group,this.editor.basePlanes.name="base_planes";[{type:"xy",color:65280,position:{z:0},rotation:{x:0}},{type:"xz",color:16711680,position:{y:0},rotation:{x:-Math.PI/2}},{type:"yz",color:255,position:{x:0},rotation:{y:Math.PI/2,x:0}}].forEach(e=>{const t=this.createBasePlane(e.type,e.color);Object.assign(t.position,e.position),Object.assign(t.rotation,e.rotation),this.editor.basePlanes.add(t)}),this.editor.basePlanes.visible=!1,this.editor.worldGroup.add(this.editor.basePlanes)}createBasePlane(e,t){const o=new THREE.PlaneGeometry(50,50),n=new THREE.MeshBasicMaterial({color:t,transparent:!0,opacity:.1,side:THREE.DoubleSide}),a=new THREE.Mesh(o,n);let r,i;switch(a.name=`base_plane_${e}`,e){case"xy":default:r=new THREE.Vector3(0,0,1),i=new THREE.Vector3(0,1,0);break;case"xz":r=new THREE.Vector3(0,1,0),i=new THREE.Vector3(0,0,1);break;case"yz":r=new THREE.Vector3(1,0,0),i=new THREE.Vector3(0,1,0)}return a.userData={type:"base_plane",planeType:e,basePlane:!0,normal:r.clone(),up:i.clone()},a.castShadow=!1,a.receiveShadow=!1,a}createWorkPlaneObject(e={}){const{name:t="Рабочая плоскость",planeType:o="custom",position:n=new THREE.Vector3(0,0,0),normal:a=new THREE.Vector3(0,0,1),up:r=new THREE.Vector3(0,1,0)}=e,i=new THREE.PlaneGeometry(50,50),c=new THREE.MeshBasicMaterial({color:9868816,transparent:!0,opacity:.1,side:THREE.DoubleSide,depthWrite:!1}),s=new THREE.Mesh(i,c);return s.name=`WorkPlane_${Date.now()}`,s.position.copy(n),this.orientPlaneToNormal(s,a,r),s.userData={type:"work_plane",id:`work_plane_${Date.now()}`,name:t,planeType:o,createdAt:(new Date).toISOString(),operations:[],originalNormal:a.clone(),originalUp:r.clone(),normal:a.clone(),up:r.clone()},s}createSketchPlaneObject(e={}){const{position:t=new THREE.Vector3(0,0,0),normal:o=new THREE.Vector3(0,0,1),up:n=new THREE.Vector3(0,1,0),name:a="Плоскость скетча"}=e,r=new THREE.PlaneGeometry(100,100),i=new THREE.MeshBasicMaterial({color:16777215,transparent:!0,opacity:.5,side:THREE.DoubleSide,depthWrite:!1,polygonOffset:!0,polygonOffsetFactor:-1,polygonOffsetUnits:-1}),c=new THREE.Mesh(r,i);return c.name=`SketchPlane_${Date.now()}`,c.position.copy(t),this.orientPlaneToNormal(c,o,n),c.userData={type:"sketch_plane",id:`sketch_plane_${Date.now()}`,name:a,createdAt:(new Date).toISOString(),sketchElements:[],originalNormal:o.clone(),originalUp:n.clone(),normal:o.clone(),up:n.clone()},c}orientPlaneToNormal(e,t,o=new THREE.Vector3(0,1,0)){const n=t.clone().normalize(),a=o.clone().normalize(),r=new THREE.Vector3(0,0,1);new THREE.Vector3(0,1,0);if(Math.abs(n.dot(r))>.9999)Math.abs(n.y)>.5?(e.lookAt(e.position.clone().add(n)),e.rotateY(Math.PI/2)):e.lookAt(e.position.clone().add(n));else{const t=new THREE.Quaternion;t.setFromUnitVectors(r,n),e.setRotationFromQuaternion(t);const o=new THREE.Vector3(0,1,0).applyQuaternion(e.quaternion),i=new THREE.Quaternion;i.setFromUnitVectors(o,a),e.quaternion.premultiply(i)}e.updateMatrixWorld(!0)}getFacePolygons(e,t){if(!this.enableFaceGrouping)return[t];if(e.geometry.attributes.position.count>5e3)return[t];if(!e||!e.geometry)return[t];const o=e.geometry,n=o.attributes.position,a=(o.attributes.normal,o.index,this.getFaceIndices(o,t)),r=this.getFaceVertices(n,a,e.matrixWorld),i=this.calculateFaceNormal(r[0],r[1],r[2]),c=(new THREE.Plane).setFromCoplanarPoints(r[0],r[1],r[2]),s=[t],l=new Set([t]),d=[t];for(;d.length>0;){const t=d.pop(),a=this.getFaceIndices(o,t);for(let r=0;r<3;r++){const p=a[r],E=a[(r+1)%3],u=this.findPolygonsWithEdge(o,p,E);for(const a of u){if(a===t||l.has(a))continue;const r=this.getFaceIndices(o,a),p=this.getFaceVertices(n,r,e.matrixWorld),E=this.calculateFaceNormal(p[0],p[1],p[2]),u=i.dot(E),h=Math.abs(c.distanceToPoint(p[0]))<.001&&Math.abs(c.distanceToPoint(p[1]))<.001&&Math.abs(c.distanceToPoint(p[2]))<.001;u>.99&&h&&(s.push(a),l.add(a),d.push(a))}}}return s}findPolygonsWithEdge(e,t,o){const n=[],a=e.index,r=a?a.count/3:e.attributes.position.count/3;for(let a=0;a<r;a++){const r=this.getFaceIndices(e,a);for(let e=0;e<3;e++){const i=r[e],c=r[(e+1)%3];if(i===t&&c===o||i===o&&c===t){n.push(a);break}}}return n}getFaceCenter(e,t){const o=this.getFacePolygons(e,t);if(0===o.length)return this.getPolygonCenter(e,t);const n=e.geometry,a=n.attributes.position;if(this.isCylinderEndFace(e,o,n,a))return this.getCylinderEndCenter(e,o,n,a);const r=new Set;for(const t of o){const o=this.getFaceIndices(n,t),i=this.getFaceVertices(a,o,e.matrixWorld);for(const e of i){const t=`${e.x.toFixed(4)},${e.y.toFixed(4)},${e.z.toFixed(4)}`;r.add(t)}}const i=new THREE.Vector3;let c=0;return r.forEach(e=>{const[t,o,n]=e.split(",").map(Number);i.x+=t,i.y+=o,i.z+=n,c++}),c>0&&i.divideScalar(c),i}isCylinderEndFace(e,t,o,n){if(t.length<=1)return!1;const a=[],r=new Set;for(const i of t){const t=this.getFaceIndices(o,i),c=this.getFaceVertices(n,t,e.matrixWorld),s=new THREE.Vector3;s.add(c[0]),s.add(c[1]),s.add(c[2]),s.divideScalar(3),r.add(s),a.push(...c)}return r.size<.5*t.length}getCylinderEndCenter(e,t,o,n){const a=[];for(const r of t){const t=this.getFaceIndices(o,r),i=this.getFaceVertices(n,t,e.matrixWorld);a.push(...i)}const r=new Map;for(const e of a){let t=!1;for(const[o,n]of r.entries()){const[a,r,i]=o.split(",").map(Number),c=new THREE.Vector3(a,r,i);if(e.distanceTo(c)<this.cylinderEndTolerance){n.count++,t=!0;break}}if(!t){const t=`${e.x.toFixed(4)},${e.y.toFixed(4)},${e.z.toFixed(4)}`;r.set(t,{vertex:e.clone(),count:1})}}let i=null,c=0;for(const e of r.values())e.count>c&&(c=e.count,i=e.vertex);if(!i){i=new THREE.Vector3;for(const e of r.values())i.add(e.vertex);i.divideScalar(r.size)}return i}getPolygonCenter(e,t){const o=e.geometry,n=o.attributes.position,a=this.getFaceIndices(o,t),r=this.getFaceVertices(n,a,e.matrixWorld),i=new THREE.Vector3;for(const e of r)i.add(e);return i.divideScalar(r.length),i}getFaceIndices(e,t){return e.index?[e.index.array[3*t],e.index.array[3*t+1],e.index.array[3*t+2]]:[3*t,3*t+1,3*t+2]}getFaceVertices(e,t,o){const n=[];for(let a=0;a<3;a++){const r=new THREE.Vector3;r.fromBufferAttribute(e,t[a]),r.applyMatrix4(o),n.push(r)}return n}calculateFaceNormal(e,t,o){const n=new THREE.Vector3,a=(new THREE.Vector3).subVectors(t,e),r=(new THREE.Vector3).subVectors(o,e);return n.crossVectors(a,r).normalize(),n}createWorkPlaneOnFaceIntersection(e){if(!e||!e.face)return console.warn("Неверные данные пересечения для создания рабочей плоскости"),null;const t=e.object,o=e.faceIndex,n=t.geometry,a=n.attributes.position,r=this.getFaceIndices(n,o),i=this.getFaceVertices(a,r,t.matrixWorld),c=this.calculateFaceNormal(i[0],i[1],i[2]),s=this.getFaceCenter(t,o),l=s.clone().add(c.clone().multiplyScalar(this.PLANE_OFFSET)),d=new THREE.Vector3;t.getWorldPosition(d);let p=new THREE.Vector3;Math.abs(c.y)>.9?p=new THREE.Vector3(1,0,0):(p=s.clone().sub(d).normalize(),p=p.projectOnPlane(c).normalize(),p.length()<.1&&(p=new THREE.Vector3(0,1,0).projectOnPlane(c).normalize()));const E={position:l,normal:c,up:p,name:"Рабочая плоскость на грани объекта",planeType:"face_center"},u=this.createWorkPlaneObject(E);return u.userData.parentObject=t.uuid,u.userData.faceIndex=o,u.userData.faceNormal=c.clone(),u}createPlaneOnObjectFace(e,t=!1){if(!e||!e.face)return console.warn("Неверные данные пересечения для создания плоскости"),null;const o=e.point,n=e.object;let a=e.face.normal.clone();if(n.matrixWorld){const e=(new THREE.Matrix3).getNormalMatrix(n.matrixWorld);a.applyMatrix3(e).normalize()}const r=new THREE.Vector3;n.getWorldPosition(r);r.clone().sub(o).normalize();let i=new THREE.Vector3(0,1,0);if(Math.abs(a.y)>.9)i=new THREE.Vector3(1,0,0);else{i=new THREE.Vector3(0,1,0);const e=i.clone().projectOnPlane(a).normalize();i=e.length()<.1?new THREE.Vector3(1,0,0).projectOnPlane(a).normalize():e}const c={position:o,normal:a,up:i,name:t?"Скетч на поверхности":"Рабочая плоскость на поверхности"},s=t?this.createSketchPlaneObject(c):this.createWorkPlaneObject(c);return s&&void 0!==e.faceIndex&&(s.userData.parentObject=n.uuid,s.userData.faceIndex=e.faceIndex,s.userData.intersectionPoint=o.clone(),s.userData.faceNormal=a.clone(),console.log(`Сохранена информация о грани: объект ${n.uuid}, грань ${e.faceIndex}`)),s}createPlaneFacingCamera(e=!1,t=100){const o=this.editor.camera,n=new THREE.Vector3;o.getWorldDirection(n);const a={position:o.position.clone().add(n.multiplyScalar(t)),normal:n.clone().negate(),up:o.up.clone(),name:e?"Скетч перед камерой":"Рабочая плоскость перед камерой"};return e?this.createSketchPlaneObject(a):this.createWorkPlaneObject(a)}setCameraForSketch(e){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const o=e.position.clone().add(t.multiplyScalar(100));this.editor.camera.position.copy(o),this.editor.camera.lookAt(e.position);const n=new THREE.Vector3(0,1,0);n.applyQuaternion(e.quaternion),this.editor.camera.up.copy(n),this.editor.controls.target.copy(e.position),this.editor.controls.update()}getPlaneOrientation(e){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const o=new THREE.Vector3(0,1,0);o.applyQuaternion(e.quaternion);const n=new THREE.Vector3(1,0,0);return n.applyQuaternion(e.quaternion),{normal:t,up:o,right:n,isValid:Math.abs(t.length()-1)<.001}}setFaceGroupingEnabled(e){this.enableFaceGrouping=e,console.log("Группировка граней "+(e?"включена":"отключена"))}getFaceGroupingEnabled(){return this.enableFaceGrouping}}