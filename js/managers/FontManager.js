import*as THREE from"three";import{FontLoader}from"three/addons/loaders/FontLoader.js";import{TTFConverter}from"../utils/font-converter.js";export class FontManager{constructor(t){this.editor=t,this.fonts={},this.fontData={},this.loadingPromises={},this.availableFonts=[{name:"Roboto",file:"fonts/Roboto_Regular.json"},{name:"Arial",file:"fonts/helvetiker_regular.typeface.json"},{name:"Bold",file:"fonts/helvetiker_bold.typeface.json"},{name:"Optima",file:"fonts/optimer_regular.typeface.json"}],this.ttfConverter=new TTFConverter,this.init()}init(){this.loadStandardFonts(),this.loadCustomFonts()}async loadStandardFonts(){const t=new FontLoader;for(const o of this.availableFonts)this.loadingPromises[o.name]=new Promise((n,e)=>{fetch(o.file).then(t=>{if(!t.ok)throw new Error(`HTTP ${t.status}`);return t.json()}).then(e=>{this.fontData[o.name]=e;const s=t.parse(e);this.fonts[o.name]=s,console.log(`Шрифт ${o.name} загружен`),n(s)}).catch(t=>{console.error(`Ошибка загрузки шрифта ${o.name}:`,t),e(t)})})}loadCustomFonts(){const t=this.ttfConverter.loadFontsFromLocalStorage(),o=new FontLoader;for(const[n,e]of Object.entries(t))try{const t=o.parse(e);this.fonts[n]=t,this.fontData[n]=e,console.log(`Кастомный шрифт ${n} загружен из localStorage`)}catch(t){console.error(`Ошибка загрузки кастомного шрифта ${n}:`,t)}}async waitForFont(t){if(!this.fonts[t]){if(!this.loadingPromises[t])throw new Error(`Шрифт ${t} не найден и не загружается`);await this.loadingPromises[t]}}async waitForFonts(t){const o=[...new Set(t)];await Promise.all(o.map(t=>this.waitForFont(t).catch(t=>console.warn(t))))}addCustomFont(t,o){const n=(new FontLoader).parse(o);this.fonts[t]=n,this.fontData[t]=o,this.ttfConverter.saveFontToLocalStorage(t,o)}getFontData(t){return this.fontData[t]||null}}