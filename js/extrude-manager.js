class ExtrudeManager{constructor(e){this.editor=e,this.figureManager=e.objectsManager.figureManager,this.extrudePreviewGroup=null,this.previewMaterial=null,this.selectedFigures=new Map,this.basePlane=null,this.extrudeArrow=null,this.isDraggingArrow=!1,this.arrowStartHeight=0,this.startMouseY=0,this.isArrowHovered=!1,this.arrowNormalColor=65280,this.arrowHoverColor=65416,this.hoveredFigure=null,this.hoveredColor=16776960,this.selectedColor=26367,this.isProcessingClick=!1,this.mergeConnectedFigures=!1,this.mergeThreshold=.1,console.log("ExtrudeManager: создан (доработанная версия)")}initialize(){console.log("ExtrudeManager: инициализация"),this.figureManager?this.figureManager.collectAllFigures():console.error("ExtrudeManager: FigureManager не найден!")}handleFigureClick(e){if(console.log("=== handleFigureClick ==="),this.isProcessingClick)return!1;this.isProcessingClick=!0;try{const t=this.figureManager.getAllFigures();if(0===t.length)return console.log("Нет фигур для выбора"),!1;const r=this.findFigureAtPoint(e,t);return r?(console.log("Найдена фигура:",r.id,"плоскость:",this.getFigurePlane(r)?.uuid),this.toggleSelection(r),this.updateExtrudePreview(),this.updateExtrudeUI(),this.createExtrudeDirectionIndicator(),!0):(console.log("Не найдена фигура под курсором"),!1)}finally{setTimeout(()=>{this.isProcessingClick=!1},50)}}isPlaneVisible(e){if(!e)return!1;if(!e.visible)return!1;if(e.userData&&!1===e.userData.visible)return!1;let t=e.parent;for(;t;){if(!t.visible)return!1;t=t.parent}return!0}findFigureAtPoint(e,t){const r=[...t].sort((e,t)=>e.depth!==t.depth?t.depth-e.depth:e.area-t.area);for(const t of r){if(!t.outer||!t.outer.points)continue;const r=this.getFigurePlane(t);if(!r)continue;if(!this.isPlaneVisible(r))continue;const o=this.getPointOnPlane(e,r);if(!o)continue;const i=r.worldToLocal(o.clone()),s=new THREE.Vector2(i.x,i.y);if(this.isPointInContour(s,t.outer.points))return t}return null}recalculateBasePlane(){if(0===this.selectedFigures.size)return void(this.basePlane=null);const e=this.selectedFigures.values().next().value;this.basePlane=this.getFigurePlane(e),console.log("Пересчитана базовая плоскость:",this.basePlane?.uuid)}toggleSelection(e){const t=e.id;if(this.selectedFigures.has(t))this.selectedFigures.delete(t),this.unhighlightFigure(e),0===this.selectedFigures.size?this.basePlane=null:this.recalculateBasePlane();else{this.selectedFigures.set(t,e);const r=this.getFigurePlane(e);if(this.basePlane){if(!this.arePlanesCompatible(this.basePlane,r))return this.editor.showStatus("Выбраны фигуры на разных плоскостях!","error"),void this.selectedFigures.delete(t)}else this.basePlane=r;this.highlightFigure(e,this.selectedColor)}console.log("Выделено фигур:",this.selectedFigures.size,"Базовая плоскость:",this.basePlane?.uuid)}getFiguresForExtrusion(){const e=[];new Set;if(console.log("=== getFiguresForExtrusion ==="),console.log("Выделено фигур:",this.selectedFigures.size),this.selectedFigures.size>1&&this.mergeConnectedFigures){const t=Array.from(this.selectedFigures.values()),r=t.filter(e=>{const t=this.getFigurePlane(e);return t&&this.isPlaneVisible(t)});if(0===r.length)return console.log("Все выбранные фигуры на скрытых плоскостях"),e;r.length!==t.length&&this.editor.showStatus("Некоторые фигуры на скрытых плоскостях не учитываются","warning");if(!this.areAllFiguresOnSamePlane(r))return console.log("Фигуры на разных плоскостях, объединение невозможно"),this.getIndividualFigures(r);if(this.areFiguresGeometricallyConnected(r)){console.log("Фигуры геометрически соединены, создаем объединенную фигуру");const e=this.createMergedFigureFromConnected(r);if(e)return[e]}else console.log("Фигуры не соединены геометрически")}return this.getIndividualFigures(Array.from(this.selectedFigures.values()))}getIndividualFigures(e){const t=[],r=new Set;for(const o of e){if(r.has(o.id))continue;console.log(`Обрабатываем фигуру ${o.id}: isHole=${o.isHole}, depth=${o.depth}`);const e=this.getAllImmediateHoles(o);console.log(`  Найдено отверстий вложенности 1: ${e.length}`);const i={id:o.id,outer:o.outer,holes:e,area:o.area,isHole:o.isHole,parentId:o.parentId,childrenIds:o.childrenIds,depth:o.depth};t.push(i),r.add(o.id),console.log(`  Добавлена фигура с ${e.length} отверстиями`)}return console.log("Итого фигур для вытягивания:",t.length),t}areAllFiguresOnSamePlane(e){if(e.length<2)return!0;const t=this.getFigurePlane(e[0]);if(!t)return!1;for(let r=1;r<e.length;r++){const o=this.getFigurePlane(e[r]);if(!o||!this.arePlanesCompatible(t,o))return!1}return!0}areFiguresGeometricallyConnected(e){if(e.length<2)return!0;const t=e.map(e=>{const t=this.getFigurePointsForBasePlane(e);if(!t||0===t.length)return null;const r=new THREE.Box2;return t.forEach(e=>{r.expandByPoint(new THREE.Vector2(e.x,e.y))}),r.expandByScalar(this.mergeThreshold),{figure:e,bbox:r,points:t}}).filter(e=>null!==e);for(let e=0;e<t.length;e++)for(let r=e+1;r<t.length;r++)if(t[e].bbox.intersectsBox(t[r].bbox)&&this.areTwoFiguresConnected(t[e],t[r]))return!0;return!1}areTwoFiguresConnected(e,t){return!!this.doContoursIntersect(e.points,t.points)||(!(!this.isContourInsideAnother(e.points,t.points)&&!this.isContourInsideAnother(t.points,e.points))||this.areVerticesClose(e.points,t.points))}doContoursIntersect(e,t){for(let r=0;r<e.length;r++){const o=e[r],i=e[(r+1)%e.length];for(let e=0;e<t.length;e++){const r=t[e],s=t[(e+1)%t.length];if(this.segmentsIntersect(o,i,r,s))return!0}}return!1}isContourInsideAnother(e,t){for(const r of e)if(!this.isPointInContour(r,t))return!1;return!0}areVerticesClose(e,t){const r=this.mergeThreshold*this.mergeThreshold;for(const o of e)for(const e of t){const t=o.x-e.x,i=o.y-e.y;if(t*t+i*i<r)return!0}return!1}segmentsIntersect(e,t,r,o){const i=this.direction(r,o,e),s=this.direction(r,o,t),n=this.direction(e,t,r),a=this.direction(e,t,o);return(i>0&&s<0||i<0&&s>0)&&(n>0&&a<0||n<0&&a>0)||(!(0!==i||!this.onSegment(r,o,e))||(!(0!==s||!this.onSegment(r,o,t))||(!(0!==n||!this.onSegment(e,t,r))||!(0!==a||!this.onSegment(e,t,o)))))}onSegment(e,t,r){return Math.min(e.x,t.x)<=r.x&&r.x<=Math.max(e.x,t.x)&&Math.min(e.y,t.y)<=r.y&&r.y<=Math.max(e.y,t.y)}direction(e,t,r){return(r.x-e.x)*(t.y-e.y)-(t.x-e.x)*(r.y-e.y)}createMergedFigureFromConnected(e){console.log("Создание объединенной фигуры из",e.length,"фигур");const t=[],r=[];for(const o of e){const e=this.getFigurePointsForBasePlane(o);t.push(...e);const i=this.getAllImmediateHoles(o);r.push(...i)}if(0===t.length)return console.log("Нет точек для создания фигуры"),null;const o=this.createConvexHull(t);return!o||o.length<3?(console.log("Не удалось создать выпуклую оболочку"),null):{id:"merged_"+Date.now(),outer:{points:o,center:this.calculateContourCenter(o),area:this.calculateSignedPolygonArea(o)},holes:r.map(e=>({points:this.getContourPointsForBasePlane(e),center:this.calculateContourCenter(this.getContourPointsForBasePlane(e)),area:this.calculateSignedPolygonArea(this.getContourPointsForBasePlane(e))})),area:this.calculateSignedPolygonArea(o),isHole:!1,parentId:null,childrenIds:[],depth:e[0].depth,isMerged:!0,sourceFigures:e.map(e=>e.id),geometricMerge:!0}}createConvexHull(e){if(e.length<3)return e;const t=[],r=new Set;for(const o of e){const e=`${o.x.toFixed(6)},${o.y.toFixed(6)}`;r.has(e)||(r.add(e),t.push(o))}if(t.length<3)return t;let o=0;for(let e=1;e<t.length;e++)(t[e].y<t[o].y||t[e].y===t[o].y&&t[e].x<t[o].x)&&(o=e);const i=[];let s=o;do{i.push(t[s]);let e=(s+1)%t.length;for(let r=0;r<t.length;r++){if(r===s)continue;const o=this.crossProduct(t[s],t[r],t[e]);(o>0||0===o&&this.distanceSquared(t[s],t[r])>this.distanceSquared(t[s],t[e]))&&(e=r)}s=e}while(s!==o);return i}distanceSquared(e,t){const r=e.x-t.x,o=e.y-t.y;return r*r+o*o}crossProduct(e,t,r){return(t.x-e.x)*(r.y-e.y)-(t.y-e.y)*(r.x-e.x)}calculateContourCenter(e){if(0===e.length)return new THREE.Vector2(0,0);let t=0,r=0;return e.forEach(e=>{t+=e.x,r+=e.y}),new THREE.Vector2(t/e.length,r/e.length)}getAllImmediateHoles(e){const t=[];if(e.childrenIds&&e.childrenIds.length>0)for(const r of e.childrenIds){const o=this.figureManager.getFigureById(r);o&&(!e.isHole&&o.isHole||e.isHole&&!o.isHole)&&(t.push(o.outer),console.log(`    Добавлено отверстие: ${r}, isHole=${o.isHole}`))}return t}highlightFigure(e,t){e&&e.outer&&(e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,t):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,t)}))}unhighlightFigure(e){e&&e.outer&&(this.selectedFigures.has(e.id)||(e.outer.element?this.editor.objectsManager.safeRestoreElementColor(e.outer.element):e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)})))}highlightFiguresOnHover(e){if(this.hoveredFigure&&!this.selectedFigures.has(this.hoveredFigure.id)&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),this.isDraggingArrow)return;const t=this.figureManager.getAllFigures(),r=this.findFigureAtPoint(e,t);if(r){if(this.selectedFigures.has(r.id))return this.hoveredFigure&&(this.hoveredFigure=null),void(document.body.style.cursor="default");this.hoveredFigure=r,this.highlightFigure(r,this.hoveredColor),document.body.style.cursor="pointer"}else document.body.style.cursor="default"}clearSelection(){console.log("=== clearSelection ===");for(const e of this.selectedFigures.values())this.unhighlightFigure(e);this.selectedFigures.clear(),this.basePlane=null,this.hoveredFigure&&(this.unhighlightFigure(this.hoveredFigure),this.hoveredFigure=null),document.body.style.cursor="default"}getPointOnPlane(e,t=null){const r=this.editor.renderer.domElement.getBoundingClientRect(),o=new THREE.Vector2((e.clientX-r.left)/r.width*2-1,-(e.clientY-r.top)/r.height*2+1);if(this.editor.raycaster.setFromCamera(o,this.editor.camera),t){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(t.quaternion);const r=new THREE.Plane;r.setFromNormalAndCoplanarPoint(e,t.position);const o=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(r,o))return o}if(this.basePlane){const e=new THREE.Vector3(0,0,1);e.applyQuaternion(this.basePlane.quaternion);const t=new THREE.Plane;t.setFromNormalAndCoplanarPoint(e,this.basePlane.position);const r=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(t,r))return r}const i=[...this.editor.sketchPlanes||[],...this.editor.workPlanes||[]];for(const e of i){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const r=new THREE.Plane;r.setFromNormalAndCoplanarPoint(t,e.position);const o=new THREE.Vector3;if(this.editor.raycaster.ray.intersectPlane(r,o))return o}return null}isPointInContour(e,t){if(t.length<3)return!1;let r=!1;const o=t.length;for(let i=0,s=o-1;i<o;s=i++){const o=t[i].x,n=t[i].y,a=t[s].x,l=t[s].y;n>e.y!=l>e.y&&e.x<(a-o)*(e.y-n)/(l-n)+o&&(r=!r)}return r}getFigurePlane(e){let t=null;return e.element?t=e.element:e.outer&&e.outer.element?t=e.outer.element:e.outer&&e.outer.elements&&e.outer.elements.length>0&&(t=e.outer.elements[0]),t?this.findSketchPlaneForElement(t):null}findSketchPlaneForElement(e){if(!e)return null;let t=e.parent;for(;t;){if(t.userData&&("sketch_plane"===t.userData.type||"work_plane"===t.userData.type))return t;t=t.parent}return this.editor.sketchPlanes.length>0?this.editor.sketchPlanes[0]:this.editor.workPlanes.length>0?this.editor.workPlanes[0]:null}calculateSignedPolygonArea(e){if(e.length<3)return 0;let t=0;const r=e.length;for(let o=0;o<r;o++){const i=(o+1)%r;t+=e[o].x*e[i].y,t-=e[i].x*e[o].y}return t/2}fixContourOrientation(e,t){if(e.length<3)return e;return this.calculateSignedPolygonArea(e)<0!==t?[...e].reverse():e}createExtrusionGeometryFromFigures(e,t,r){if(0===e.length||!this.basePlane)return null;if(0===e.length||!this.basePlane)return console.error("Нет базовой плоскости для создания геометрии!"),null;if(!this.areAllFiguresOnSamePlane(e))return console.error("Фигуры находятся на разных плоскостях!"),null;const o=[];if(e.forEach(e=>{console.log(`Создание фигуры: ${e.id}, isHole: ${e.isHole}, отверстий: ${e.holes?e.holes.length:0}`);const t=this.getFigurePointsForBasePlane(e);if(t.length<3)return void console.log(`  Недостаточно точек: ${t.length}`);let r=!1;e.isHole&&(r=!1);const i=this.fixContourOrientation(t,r);try{const t=new THREE.Shape(i.map(e=>new THREE.Vector2(e.x,e.y)));e.holes&&e.holes.length>0&&e.holes.forEach((e,r)=>{const o=this.getContourPointsForBasePlane(e);if(o.length>=3){const e=this.fixContourOrientation(o,!0);try{const o=new THREE.Path(e.map(e=>new THREE.Vector2(e.x,e.y)));t.holes.push(o),console.log(`    Добавлено отверстие ${r}`)}catch(e){console.error(`    Ошибка создания отверстия ${r}:`,e)}}}),o.push(t),console.log("  Форма успешно создана")}catch(t){console.error(`  Ошибка создания формы для фигуры ${e.id}:`,t)}}),0===o.length)return console.log("Нет фигур для создания геометрии"),null;console.log(`Создано ${o.length} форм для выдавливания`);const i={depth:t,bevelEnabled:!1,steps:1};try{console.log("Создание ExtrudeGeometry...");const e=new THREE.ExtrudeGeometry(o,i);return"negative"===r?e.translate(0,0,-t):"both"===r&&e.translate(0,0,-t/2),console.log("Геометрия успешно создана, вершин:",e.attributes.position.count),e}catch(e){return console.error("Ошибка создания геометрии выдавливания:",e),null}}getFigurePointsForBasePlane(e){const t=this.getFigurePlane(e);return t?!this.basePlane||this.arePlanesCompatible(t,this.basePlane)?e.outer.points||[]:(e.outer.points||[]).map(e=>{const r=new THREE.Vector3(e.x,e.y,0),o=t.localToWorld(r.clone()),i=this.basePlane.worldToLocal(o.clone());return new THREE.Vector2(i.x,i.y)}):e.outer.points||[]}getContourPointsForBasePlane(e){return e.points||[]}arePlanesCompatible(e,t){if(!e||!t)return!1;const r=e.position,o=t.position,i=e.quaternion,s=t.quaternion,n=r.distanceTo(o),a=i.angleTo(s);return n<.001&&a<.001}createExtrudeDirectionIndicator(){this.extrudeArrow&&(this.extrudeArrow.parent&&this.extrudeArrow.parent.remove(this.extrudeArrow),this.extrudeArrow=null);const e=this.getFiguresForExtrusion();if(!e||0===e.length||!this.basePlane)return;if(!this.isPlaneVisible(this.basePlane))return void console.log("Базовая плоскость скрыта, не создаем стрелку");const t=document.getElementById("extrudeDirection")?.value||"positive",r=new THREE.Vector3(0,0,1);r.applyQuaternion(this.basePlane.quaternion),r.normalize(),"negative"===t&&r.negate(),this.extrudeArrow=new THREE.Group,this.extrudeArrow.userData.isExtrudeArrow=!0,this.extrudeArrow.userData.isDraggable=!0,this.extrudeArrow.raycast=()=>{};const o=new THREE.CylinderGeometry(.5,.5,15,8),i=new THREE.MeshBasicMaterial({color:this.arrowNormalColor,transparent:!0,opacity:.7}),s=new THREE.Mesh(o,i);s.position.y=7.5,s.userData.isArrowPart=!0,s.userData.isDraggable=!0,s.userData.isArrowHandle=!0,this.extrudeArrow.add(s);const n=new THREE.ConeGeometry(3,6,8),a=new THREE.MeshBasicMaterial({color:this.arrowNormalColor,transparent:!0,opacity:.9}),l=new THREE.Mesh(n,a);l.position.y=18,l.userData.isArrowPart=!0,l.userData.isArrowHandle=!0,l.userData.isDraggable=!0,this.extrudeArrow.add(l);const u=new THREE.MeshBasicMaterial({color:this.arrowHoverColor,transparent:!0,opacity:.9});s.userData.originalMaterial=i,l.userData.originalMaterial=a,s.userData.highlightMaterial=u.clone(),l.userData.highlightMaterial=u.clone(),this.setupArrowHoverEvents(s),this.setupArrowHoverEvents(l);const c=new THREE.Vector3(0,1,0),h=(new THREE.Quaternion).setFromUnitVectors(c,r.clone().normalize());this.extrudeArrow.quaternion.copy(h),this.updateArrowPosition(),this.editor.scene.add(this.extrudeArrow)}setupArrowHoverEvents(e){e.userData.isHovered=!1,e.onPointerEnter=()=>{e.userData.isHovered||this.isDraggingArrow||(e.userData.isHovered=!0,this.highlightArrow(!0),document.body.style.cursor="grab")},e.onPointerLeave=()=>{e.userData.isHovered&&!this.isDraggingArrow&&(e.userData.isHovered=!1,this.highlightArrow(!1),document.body.style.cursor="default")}}highlightArrow(e){this.extrudeArrow&&(this.extrudeArrow.traverse(t=>{t.userData&&t.userData.isArrowPart&&(t.material=e?t.userData.highlightMaterial:t.userData.originalMaterial)}),this.isArrowHovered=e)}updateArrowPosition(){if(!this.extrudeArrow||!this.basePlane)return;const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10,t=document.getElementById("extrudeDirection")?.value||"positive",r=this.getFiguresForExtrusion();if(0===r.length)return;const o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();let i=o.clone();"negative"===t&&i.negate();const s=new THREE.Vector3(0,1,0),n=(new THREE.Quaternion).setFromUnitVectors(s,i.clone().normalize());this.extrudeArrow.quaternion.copy(n);const a=new THREE.Vector3(0,0,0);let l=0;r.forEach(e=>{if(e.outer&&e.outer.center){const t=e.outer.area||1;a.x+=e.outer.center.x*t,a.y+=e.outer.center.y*t,l+=t}}),l>0&&(a.x/=l,a.y/=l);const u=this.basePlane.localToWorld(a.clone()),c=new THREE.Vector3;this.basePlane.getWorldPosition(c);const h=(new THREE.Vector3).subVectors(u,c);let d=e;"both"===t&&(d=e/2);const g=c.clone().add(h).clone().clone().add(i.clone().multiplyScalar(d));this.extrudeArrow.position.copy(g),this.extrudeArrow.updateMatrixWorld(!0)}handleArrowDragStart(e){if(!this.extrudeArrow)return!1;this.editor.updateMousePosition(e),this.editor.raycaster.setFromCamera(this.editor.mouse,this.editor.camera);const t=[];if(this.extrudeArrow&&this.extrudeArrow.traverse(e=>{e.userData&&(e.userData.isDraggable||e.userData.isArrowHandle)&&t.push(e)}),0===t.length)return!1;t.forEach(e=>e.updateMatrixWorld(!0));return this.editor.raycaster.intersectObjects(t,!0).length>0&&(this.isDraggingArrow=!0,this.startMouseY=e.clientY,this.arrowStartHeight=parseFloat(document.getElementById("extrudeHeight")?.value)||10,document.body.style.cursor="grabbing",this.bindGlobalDragHandlers(),e.stopPropagation(),e.preventDefault(),!0)}handleArrowDrag(e){if(!this.isDraggingArrow||!this.extrudeArrow||!this.basePlane)return;const t=e.clientY-this.startMouseY,r=document.getElementById("extrudeDirection")?.value||"positive",o=new THREE.Vector3(0,0,1);o.applyQuaternion(this.basePlane.quaternion),o.normalize();const i=this.extrudeArrow.position.clone(),s=i.clone().project(this.editor.camera);let n=.4*-t;i.clone().add(o.clone().multiplyScalar(10)).clone().project(this.editor.camera).y-s.y<0&&(n=-n),"negative"===r&&(n=-n);let a=this.arrowStartHeight+n;a=Math.max(.1,a),a=Math.round(10*a)/10;const l=document.getElementById("extrudeHeight");if(l){l.value=a;const e=new Event("input",{bubbles:!0});l.dispatchEvent(e),this.updateExtrudePreview(),this.updateArrowPosition()}e.preventDefault()}handleArrowDragEnd(){this.isDraggingArrow=!1,this.unbindGlobalDragHandlers(),document.body.style.cursor=this.isArrowHovered?"grab":"default",this.updateExtrudePreview(),this.updateArrowPosition();const e=parseFloat(document.getElementById("extrudeHeight")?.value)||10;this.editor.showStatus(`Высота установлена: ${e.toFixed(1)} мм`,"info")}bindGlobalDragHandlers(){this.globalMouseMoveHandler=e=>{this.isDraggingArrow&&this.handleArrowDrag(e)},this.globalMouseUpHandler=e=>{this.isDraggingArrow&&0===e.button&&this.handleArrowDragEnd()},document.addEventListener("mousemove",this.globalMouseMoveHandler),document.addEventListener("mouseup",this.globalMouseUpHandler)}unbindGlobalDragHandlers(){this.globalMouseMoveHandler&&(document.removeEventListener("mousemove",this.globalMouseMoveHandler),this.globalMouseMoveHandler=null),this.globalMouseUpHandler&&(document.removeEventListener("mouseup",this.globalMouseUpHandler),this.globalMouseUpHandler=null)}updateExtrudePreview(){const e=this.getFiguresForExtrusion();if(0===e.length)return void this.removeExtrudePreview();const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive";if(this.extrudePreviewGroup&&this.extrudePreviewGroup.children.length>0){const o=this.extrudePreviewGroup.children[0],i=this.createExtrusionGeometryFromFigures(e,t,r);i&&(o.geometry.dispose(),o.geometry=i,this.updatePreviewPosition(o,t,r))}else this.createNewExtrudePreview(e,t,r)}createNewExtrudePreview(e,t,r){this.removeExtrudePreview();const o=this.createExtrusionGeometryFromFigures(e,t,r);if(!o)return;this.previewMaterial||(this.previewMaterial=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.3,side:THREE.DoubleSide}));const i=new THREE.Mesh(o,this.previewMaterial);this.updatePreviewPosition(i,t,r),this.extrudePreviewGroup=new THREE.Group,this.extrudePreviewGroup.add(i),this.editor.objectsGroup.add(this.extrudePreviewGroup)}updatePreviewPosition(e,t,r){if(!e||!this.basePlane)return;const o=new THREE.Vector3;this.basePlane.getWorldPosition(o),e.position.copy(o),e.quaternion.copy(this.basePlane.quaternion);const i=new THREE.Vector3(0,0,1);i.applyQuaternion(this.basePlane.quaternion),i.normalize();e.position.add(i.clone().multiplyScalar(.1))}removeExtrudePreview(){this.extrudePreviewGroup&&(this.editor.objectsGroup.remove(this.extrudePreviewGroup),this.extrudePreviewGroup.traverse(e=>{e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}),this.extrudePreviewGroup=null)}showExtrudeUI(){const e=document.getElementById("extrudeUI");e&&e.remove();const t=this.selectedFigures.size,r=document.createElement("div");r.id="extrudeUI",r.className="extrude-ui",r.innerHTML=`\n            <div class="extrude-header">\n                <h3><i class="fas fa-arrows-alt-v"></i> Вытягивание фигур</h3>\n                <button id="cancelExtrude" class="btn-secondary">\n                    <i class="fas fa-times"></i> Отмена\n                </button>\n            </div>\n            <div class="extrude-controls">\n                <div class="control-group">\n                    <label>Высота (мм):</label>\n                    <input type="number" id="extrudeHeight" value="10" step="0.1" min="0.1" style="width: 100px;">\n                </div>\n                <div class="control-group">\n                    <label>Направление:</label>\n                    <select id="extrudeDirection">\n                        <option value="positive">Наружу</option>\n                        <option value="negative">Внутрь</option>\n                        <option value="both">В обе стороны</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>Операция:</label>\n                    <select id="extrudeOperation">\n                        <option value="new">Новый объект</option>\n                        <option value="cut">Вырезать</option>\n                        <option value="join">Объединить</option>\n                    </select>\n                </div>\n                <div class="control-group">\n                    <label>\n\n                        Автоматически объединять соединённые фигуры (экспериментальное)\n                        <input type="checkbox" id="mergeFigures" ${this.mergeConnectedFigures?"checked":""}>\n                    </label>\n                </div>\n                <div class="extrude-info">\n                    <div id="selectedContourInfo">\n                        ${t>0?`Выбрано фигур: ${t}`:"Кликните по фигуре для выбора"}\n                    </div>\n                    <div id="mergeStatus" style="font-size: 12px; color: #888; margin-top: 5px;"></div>\n                </div>\n                <button id="performExtrude" class="btn-primary" ${t>0?"":"disabled"}>\n                    <i class="fas fa-check"></i> Выполнить вытягивание\n                </button>\n            </div>\n            <div class="extrude-hint">\n                <i class="fas fa-info-circle"></i>\n                <div>• Клик по фигуре: выделить/снять выделение</div>\n                <div>• Соединённые фигуры будут объединены при вытягивании</div>\n                <div>• Перетаскивайте стрелку для изменения высоты</div>\n                <div>• Escape для отмены, Enter для подтверждения</div>\n            </div>\n        `,document.querySelector(".viewport-container").appendChild(r),r.querySelector("#cancelExtrude").addEventListener("click",()=>{this.exitExtrudeMode()}),r.querySelector("#performExtrude").addEventListener("click",()=>{this.performExtrude()});r.querySelector("#extrudeHeight").addEventListener("input",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});r.querySelector("#extrudeDirection").addEventListener("change",()=>{this.updateExtrudePreview(),this.updateArrowPosition()});const o=r.querySelector("#extrudeOperation");o.addEventListener("change",()=>{this.currentOperation=o.value,this.updateExtrudeUI()});r.querySelector("#mergeFigures").addEventListener("change",e=>{this.mergeConnectedFigures=e.target.checked,this.updateExtrudePreview(),this.updateExtrudeUI()}),this.updateExtrudeUI()}updateExtrudeUI(){const e=document.getElementById("selectedContourInfo"),t=document.getElementById("mergeStatus"),r=document.getElementById("performExtrude");if(e){const r=this.selectedFigures.size;if(r>0)if(e.textContent=`Выбрано фигур: ${r}`,e.style.color="#4CAF50",t&&r>1&&this.mergeConnectedFigures){const e=Array.from(this.selectedFigures.values());if(this.areAllFiguresOnSamePlane(e)){this.areFiguresGeometricallyConnected(e)?(t.textContent="✓ Фигуры соединены и будут объединены",t.style.color="#4CAF50"):(t.textContent="✗ Фигуры не соединены",t.style.color="#f44336")}else t.textContent="✗ Фигуры на разных плоскостях",t.style.color="#f44336"}else t.textContent="";else e.textContent="Кликните по фигуре для выбора",e.style.color="#888",t&&(t.textContent="")}r&&(r.disabled=0===this.selectedFigures.size)}performExtrude(){const e=this.getFiguresForExtrusion();if(0===e.length)return void this.editor.showStatus("Выберите фигуру(ы) для вытягивания","error");const t=parseFloat(document.getElementById("extrudeHeight")?.value)||10,r=document.getElementById("extrudeDirection")?.value||"positive",o=document.getElementById("extrudeOperation")?.value||"new";if(isNaN(t))return void this.editor.showStatus("Введите корректную высоту","error");if(!this.basePlane)return void this.editor.showStatus("Не определена базовая плоскость","error");const i=this.createExtrusionGeometryFromFigures(e,t,r);if(!i)return void this.editor.showStatus("Не удалось создать геометрию выдавливания","error");const s=this.createExtrusionMesh(i,t,r,e);if(!s)return void this.editor.showStatus("Не удалось создать объект выдавливания","error");const n=new THREE.Vector3;this.basePlane.getWorldPosition(n),s.position.copy(n),s.quaternion.copy(this.basePlane.quaternion);const a={sourceFigures:e.map(e=>({id:e.id,elements:e.outer.element?[e.outer.element]:e.outer.elements,isMerged:e.isMerged||!1,sourceFigures:e.sourceFigures||[e.id]})),sketchPlane:this.editor.projectManager.serializeObject(this.basePlane),height:t,direction:r,operation:o,merged:e.some(e=>e.isMerged)};switch(o){case"new":this.handleNewOperation(s,a);break;case"cut":this.handleCutOperation(s,a);break;case"join":this.handleJoinOperation(s,a)}this.exitExtrudeMode();e.filter(e=>e.isMerged).length>0?this.editor.showStatus(`Выполнено выдавливание (${t} мм) с объединением фигур`,"success"):this.editor.showStatus(`Выполнено выдавливание (${t} мм)`,"success")}createExtrusionMesh(e,t,r,o){if(!e)return null;const i=new THREE.MeshPhongMaterial({color:5025616,transparent:!0,opacity:.9,side:THREE.DoubleSide}),s=new THREE.Mesh(e,i);s.castShadow=!0,s.receiveShadow=!0;const n=o.some(e=>e.isMerged);return s.userData={type:"extrusion",sourceFigureIds:o.flatMap(e=>e.sourceFigures||[e.id]),height:t,direction:r,operation:this.currentOperation,name:`Вытягивание (${t} мм)${n?" [объединенное]":""}`,figureCount:o.length,holeCount:o.reduce((e,t)=>e+(t.holes?t.holes.length:0),0),basePlaneId:this.basePlane?.uuid,createdAt:(new Date).toISOString(),isMerged:n,mergedFrom:n?o.flatMap(e=>e.sourceFigures||[]):null},s}handleNewOperation(e,t){const r=e.position.clone(),o=e.scale.clone();this.editor.objectsGroup.add(e),this.editor.objects.push(e),this.editor.selectObject(e);const i=this.editor.projectManager.serializeObjectForHistory(e);i.userData.finalPosition=r.toArray(),i.userData.finalScale=o.toArray(),this.editor.history.addAction({type:"create",subtype:"extrude",object:e.uuid,data:{...t,objectData:i,finalPosition:r.toArray(),finalScale:o.toArray()}})}handleCutOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для вырезания","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e));let i=!1,s=null;r.forEach(r=>{try{const n=this.editor.booleanOps.subtract(r,e);n&&n.geometry&&n.geometry.attributes.position.count>0&&(s=n,this.replaceObjectWithResult(r,n,"cut",{sourceExtrude:t,targetObjectData:o}),i=!0)}catch(e){console.error("Ошибка вырезания:",e)}}),i||(this.editor.showStatus("Не удалось выполнить вырезание","error"),this.handleNewOperation(e,t))}handleJoinOperation(e,t){const r=this.findIntersectingObjects(e);if(0===r.length)return this.editor.showStatus("Нет пересекающихся объектов для соединения","warning"),void this.handleNewOperation(e,t);if(!this.editor.booleanOps)return this.editor.showStatus("Булевы операции не доступны","error"),void this.handleNewOperation(e,t);const o=r.map(e=>this.editor.projectManager.serializeObjectForHistory(e)),i=this.editor.projectManager.serializeObjectForHistory(e);try{const s=[...r,e],n=this.editor.booleanOps.unionMultiple(s);if(!(n&&n.geometry&&n.geometry.attributes.position.count>0))throw new Error("Результат объединения пуст");this.replaceObjectsWithResult(s,n,"join",{sourceObjectsData:o,extrudeData:i,sourceExtrude:t})}catch(r){console.error("Ошибка соединения:",r),this.editor.showStatus("Не удалось выполнить соединение","error"),this.handleNewOperation(e,t)}}findIntersectingObjects(e){const t=[],r=(new THREE.Box3).setFromObject(e);return this.editor.objects.forEach(o=>{if(o===e||"sketch_plane"===o.userData.type||"work_plane"===o.userData.type||"sketch_element"===o.userData.type)return;const i=(new THREE.Box3).setFromObject(o);r.intersectsBox(i)&&t.push(o)}),t}replaceObjectWithResult(e,t,r,o){const i=(new THREE.Box3).setFromObject(e),s=new THREE.Vector3;i.getSize(s);const n=this.editor.objects.indexOf(e);n>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(n,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()),t.userData={...t.userData,type:"boolean_result",operation:r,originalObjects:[e.uuid],createdAt:(new Date).toISOString(),originalSize:s.toArray(),originalPosition:e.position.toArray()},this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectObject(t),this.editor.history.addAction({type:"boolean",operation:"subtract",result:t.uuid,sourceObjects:[e.uuid],originalObjects:o?[{uuid:e.uuid,data:o.targetObjectData[0]}]:[],resultData:this.editor.projectManager.serializeObjectForHistory(t),context:o?.sourceExtrude})}replaceObjectsWithResult(e,t,r,o){const i=e.map(e=>{const t=(new THREE.Box3).setFromObject(e),r=new THREE.Vector3;return t.getSize(r),{uuid:e.uuid,position:e.position.toArray(),size:r.toArray(),data:this.editor.projectManager.serializeObjectForHistory(e)}});e.forEach(e=>{const t=this.editor.objects.indexOf(e);t>-1&&(this.editor.objectsGroup.remove(e),this.editor.objects.splice(t,1),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose())}),t.userData={...t.userData,type:"boolean_result",operation:r,originalObjects:e.map(e=>e.uuid),createdAt:(new Date).toISOString(),originalSizes:i.map(e=>e.size),originalPositions:i.map(e=>e.position)},this.editor.objectsGroup.add(t),this.editor.objects.push(t),this.editor.selectObject(t),this.editor.history.addAction({type:"boolean",operation:"union",result:t.uuid,sourceObjects:e.map(e=>e.uuid),originalObjects:i.map(e=>({uuid:e.uuid,data:e.data})),resultData:this.editor.projectManager.serializeObjectForHistory(t),context:o?.sourceExtrude})}exitExtrudeMode(){this.editor.toolManager.setCurrentTool("select")}cancelExtrudeMode(){this.clearSelection(),this.extrudeArrow&&(this.editor.scene.remove(this.extrudeArrow),this.extrudeArrow=null),this.removeExtrudePreview();const e=document.getElementById("extrudeUI");e&&e.remove();this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)}),this.editor.showStatus("Режим вытягивания завершен","info"),document.body.style.cursor="default"}highlightExtrudableFigures(){this.editor.objectsManager.getAllSketchElements().forEach(e=>{this.editor.objectsManager.safeRestoreElementColor(e)});const e=this.figureManager.collectAllFigures();e.forEach(e=>{e.outer&&e.outer.element?this.editor.objectsManager.safeSetElementColor(e.outer.element,2201331):e.outer&&e.outer.elements&&e.outer.elements.forEach(e=>{this.editor.objectsManager.safeSetElementColor(e,2201331)})}),0===e.length&&this.editor.showStatus("Нет замкнутых фигур для вытягивания","warning")}}