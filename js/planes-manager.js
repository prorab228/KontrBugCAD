class PlanesManager{constructor(e,t={}){this.editor=e,this.enableFaceGrouping=void 0===t.enableFaceGrouping||t.enableFaceGrouping,this.cylinderEndTolerance=t.cylinderEndTolerance||.01,this.normalTolerance=t.normalTolerance||.99,this.PLANE_OFFSET=.01}createBasePlanes(){this.editor.basePlanes&&this.editor.worldGroup.remove(this.editor.basePlanes),this.editor.basePlanes=new THREE.Group,this.editor.basePlanes.name="base_planes";[{type:"xy",color:65280,position:{z:0},rotation:{x:0}},{type:"xz",color:16711680,position:{y:0},rotation:{x:-Math.PI/2}},{type:"yz",color:255,position:{x:0},rotation:{y:Math.PI/2,x:0}}].forEach(e=>{const t=this.createBasePlane(e.type,e.color);Object.assign(t.position,e.position),Object.assign(t.rotation,e.rotation),this.editor.basePlanes.add(t)}),this.editor.basePlanes.visible=!1,this.editor.worldGroup.add(this.editor.basePlanes)}createBasePlane(e,t){const n=new THREE.PlaneGeometry(50,50),o=new THREE.MeshBasicMaterial({color:t,transparent:!0,opacity:.1,side:THREE.DoubleSide}),a=new THREE.Mesh(n,o);return a.name=`base_plane_${e}`,a.userData={type:"base_plane",planeType:e,basePlane:!0},a.castShadow=!1,a.receiveShadow=!1,a}createWorkPlaneObject(e={}){const{name:t="Рабочая плоскость",planeType:n="custom",position:o=new THREE.Vector3(0,0,0),normal:a=new THREE.Vector3(0,0,1),up:r=new THREE.Vector3(0,1,0)}=e,i=new THREE.PlaneGeometry(50,50),c=new THREE.MeshBasicMaterial({color:9868816,transparent:!0,opacity:.1,side:THREE.DoubleSide,depthWrite:!1}),s=new THREE.Mesh(i,c);return s.name=`WorkPlane_${Date.now()}`,s.position.copy(o),this.orientPlaneToNormal(s,a,r),s.userData={type:"work_plane",id:`work_plane_${Date.now()}`,name:t,planeType:n,createdAt:(new Date).toISOString(),operations:[],originalNormal:a.clone(),originalUp:r.clone()},s}createSketchPlaneObject(e={}){const{position:t=new THREE.Vector3(0,0,0),normal:n=new THREE.Vector3(0,0,1),up:o=new THREE.Vector3(0,1,0),name:a="Плоскость скетча"}=e,r=new THREE.PlaneGeometry(100,100),i=new THREE.MeshBasicMaterial({color:16777215,transparent:!0,opacity:.5,side:THREE.DoubleSide,depthWrite:!1,polygonOffset:!0,polygonOffsetFactor:-1,polygonOffsetUnits:-1}),c=new THREE.Mesh(r,i);return c.name=`SketchPlane_${Date.now()}`,c.position.copy(t),this.orientPlaneToNormal(c,n,o),c.userData={type:"sketch_plane",id:`sketch_plane_${Date.now()}`,name:a,createdAt:(new Date).toISOString(),sketchElements:[],originalNormal:n.clone(),originalUp:o.clone()},c}orientPlaneToNormal(e,t,n=new THREE.Vector3(0,1,0)){const o=t.clone().normalize(),a=n.clone().normalize(),r=new THREE.Vector3(0,0,1);new THREE.Vector3(0,1,0);if(Math.abs(o.dot(r))>.9999)Math.abs(o.y)>.5?(e.lookAt(e.position.clone().add(o)),e.rotateY(Math.PI/2)):e.lookAt(e.position.clone().add(o));else{const t=new THREE.Quaternion;t.setFromUnitVectors(r,o),e.setRotationFromQuaternion(t);const n=new THREE.Vector3(0,1,0).applyQuaternion(e.quaternion),i=new THREE.Quaternion;i.setFromUnitVectors(n,a),e.quaternion.premultiply(i)}e.updateMatrixWorld(!0)}getFacePolygons(e,t){if(!this.enableFaceGrouping)return[t];if(e.geometry.attributes.position.count>5e3)return[t];if(!e||!e.geometry)return[t];const n=e.geometry,o=n.attributes.position,a=(n.attributes.normal,n.index,this.getFaceIndices(n,t)),r=this.getFaceVertices(o,a,e.matrixWorld),i=this.calculateFaceNormal(r[0],r[1],r[2]),c=(new THREE.Plane).setFromCoplanarPoints(r[0],r[1],r[2]),s=[t],l=new Set([t]),d=[t];for(;d.length>0;){const t=d.pop(),a=this.getFaceIndices(n,t);for(let r=0;r<3;r++){const p=a[r],E=a[(r+1)%3],u=this.findPolygonsWithEdge(n,p,E);for(const a of u){if(a===t||l.has(a))continue;const r=this.getFaceIndices(n,a),p=this.getFaceVertices(o,r,e.matrixWorld),E=this.calculateFaceNormal(p[0],p[1],p[2]),u=i.dot(E),h=Math.abs(c.distanceToPoint(p[0]))<.001&&Math.abs(c.distanceToPoint(p[1]))<.001&&Math.abs(c.distanceToPoint(p[2]))<.001;u>.99&&h&&(s.push(a),l.add(a),d.push(a))}}}return s}findPolygonsWithEdge(e,t,n){const o=[],a=e.index,r=a?a.count/3:e.attributes.position.count/3;for(let a=0;a<r;a++){const r=this.getFaceIndices(e,a);for(let e=0;e<3;e++){const i=r[e],c=r[(e+1)%3];if(i===t&&c===n||i===n&&c===t){o.push(a);break}}}return o}getFaceCenter(e,t){const n=this.getFacePolygons(e,t);if(0===n.length)return this.getPolygonCenter(e,t);const o=e.geometry,a=o.attributes.position;if(this.isCylinderEndFace(e,n,o,a))return this.getCylinderEndCenter(e,n,o,a);const r=new Set;for(const t of n){const n=this.getFaceIndices(o,t),i=this.getFaceVertices(a,n,e.matrixWorld);for(const e of i){const t=`${e.x.toFixed(4)},${e.y.toFixed(4)},${e.z.toFixed(4)}`;r.add(t)}}const i=new THREE.Vector3;let c=0;return r.forEach(e=>{const[t,n,o]=e.split(",").map(Number);i.x+=t,i.y+=n,i.z+=o,c++}),c>0&&i.divideScalar(c),i}isCylinderEndFace(e,t,n,o){if(t.length<=1)return!1;const a=[],r=new Set;for(const i of t){const t=this.getFaceIndices(n,i),c=this.getFaceVertices(o,t,e.matrixWorld),s=new THREE.Vector3;s.add(c[0]),s.add(c[1]),s.add(c[2]),s.divideScalar(3),r.add(s),a.push(...c)}return r.size<.5*t.length}getCylinderEndCenter(e,t,n,o){const a=[];for(const r of t){const t=this.getFaceIndices(n,r),i=this.getFaceVertices(o,t,e.matrixWorld);a.push(...i)}const r=new Map;for(const e of a){let t=!1;for(const[n,o]of r.entries()){const[a,r,i]=n.split(",").map(Number),c=new THREE.Vector3(a,r,i);if(e.distanceTo(c)<this.cylinderEndTolerance){o.count++,t=!0;break}}if(!t){const t=`${e.x.toFixed(4)},${e.y.toFixed(4)},${e.z.toFixed(4)}`;r.set(t,{vertex:e.clone(),count:1})}}let i=null,c=0;for(const e of r.values())e.count>c&&(c=e.count,i=e.vertex);if(!i){i=new THREE.Vector3;for(const e of r.values())i.add(e.vertex);i.divideScalar(r.size)}return i}getPolygonCenter(e,t){const n=e.geometry,o=n.attributes.position,a=this.getFaceIndices(n,t),r=this.getFaceVertices(o,a,e.matrixWorld),i=new THREE.Vector3;for(const e of r)i.add(e);return i.divideScalar(r.length),i}getFaceIndices(e,t){return e.index?[e.index.array[3*t],e.index.array[3*t+1],e.index.array[3*t+2]]:[3*t,3*t+1,3*t+2]}getFaceVertices(e,t,n){const o=[];for(let a=0;a<3;a++){const r=new THREE.Vector3;r.fromBufferAttribute(e,t[a]),r.applyMatrix4(n),o.push(r)}return o}calculateFaceNormal(e,t,n){const o=new THREE.Vector3,a=(new THREE.Vector3).subVectors(t,e),r=(new THREE.Vector3).subVectors(n,e);return o.crossVectors(a,r).normalize(),o}createWorkPlaneOnFaceIntersection(e){if(!e||!e.face)return console.warn("Неверные данные пересечения для создания рабочей плоскости"),null;const t=e.object,n=e.faceIndex,o=t.geometry,a=o.attributes.position,r=this.getFaceIndices(o,n),i=this.getFaceVertices(a,r,t.matrixWorld),c=this.calculateFaceNormal(i[0],i[1],i[2]),s=this.getFaceCenter(t,n),l=s.clone().add(c.clone().multiplyScalar(this.PLANE_OFFSET)),d=new THREE.Vector3;t.getWorldPosition(d);let p=new THREE.Vector3;Math.abs(c.y)>.9?p=new THREE.Vector3(1,0,0):(p=s.clone().sub(d).normalize(),p=p.projectOnPlane(c).normalize(),p.length()<.1&&(p=new THREE.Vector3(0,1,0).projectOnPlane(c).normalize()));const E={position:l,normal:c,up:p,name:"Рабочая плоскость на грани объекта",planeType:"face_center"},u=this.createWorkPlaneObject(E);return u.userData.parentObject=t.uuid,u.userData.faceIndex=n,u.userData.faceNormal=c.clone(),u}createPlaneOnObjectFace(e,t=!1){if(!e||!e.face)return console.warn("Неверные данные пересечения для создания плоскости"),null;const n=e.point,o=e.object;let a=e.face.normal.clone();if(o.matrixWorld){const e=(new THREE.Matrix3).getNormalMatrix(o.matrixWorld);a.applyMatrix3(e).normalize()}const r=new THREE.Vector3;o.getWorldPosition(r);r.clone().sub(n).normalize();let i=new THREE.Vector3(0,1,0);if(Math.abs(a.y)>.9)i=new THREE.Vector3(1,0,0);else{i=new THREE.Vector3(0,1,0);const e=i.clone().projectOnPlane(a).normalize();i=e.length()<.1?new THREE.Vector3(1,0,0).projectOnPlane(a).normalize():e}const c={position:n,normal:a,up:i,name:t?"Скетч на поверхности":"Рабочая плоскость на поверхности"};return t?this.createSketchPlaneObject(c):this.createWorkPlaneObject(c)}createPlaneFacingCamera(e=!1,t=100){const n=this.editor.camera,o=new THREE.Vector3;n.getWorldDirection(o);const a={position:n.position.clone().add(o.multiplyScalar(t)),normal:o.clone().negate(),up:n.up.clone(),name:e?"Скетч перед камерой":"Рабочая плоскость перед камерой"};return e?this.createSketchPlaneObject(a):this.createWorkPlaneObject(a)}setCameraForSketch(e){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const n=e.position.clone().add(t.multiplyScalar(100));this.editor.camera.position.copy(n),this.editor.camera.lookAt(e.position);const o=new THREE.Vector3(0,1,0);o.applyQuaternion(e.quaternion),this.editor.camera.up.copy(o),this.editor.controls.target.copy(e.position),this.editor.controls.update()}getPlaneOrientation(e){const t=new THREE.Vector3(0,0,1);t.applyQuaternion(e.quaternion);const n=new THREE.Vector3(0,1,0);n.applyQuaternion(e.quaternion);const o=new THREE.Vector3(1,0,0);return o.applyQuaternion(e.quaternion),{normal:t,up:n,right:o,isValid:Math.abs(t.length()-1)<.001}}setFaceGroupingEnabled(e){this.enableFaceGrouping=e,console.log("Группировка граней "+(e?"включена":"отключена"))}getFaceGroupingEnabled(){return this.enableFaceGrouping}}