class ProjectManager{constructor(e){this.editor=e,this.currentProject={name:"Новый проект",description:"",created:(new Date).toISOString(),modified:(new Date).toISOString()}}newProject(){this.editor.objects.length>0&&!confirm("Создать новый проект? Несохраненные изменения будут потеряны.")||(this.safeClearScene(),this.currentProject={name:"Новый проект",description:"",created:(new Date).toISOString(),modified:(new Date).toISOString()},document.getElementById("projectName").textContent="Новый проект",this.editor.objectsManager&&(this.editor.objectsManager.updateSceneStats(),this.editor.objectsManager.updateSceneList()),this.editor.updateStatus(),this.editor.showStatus("Создан новый проект","info"))}safeClearScene(){if([...this.editor.objects].forEach(e=>{e.parent&&e.parent.remove(e),this.safeDisposeObject(e)}),this.editor.objectsGroup)for(;this.editor.objectsGroup.children.length>0;){const e=this.editor.objectsGroup.children[0];this.editor.objectsGroup.remove(e),this.safeDisposeObject(e)}if(this.editor.sketchGroup)for(;this.editor.sketchGroup.children.length>0;){const e=this.editor.sketchGroup.children[0];this.editor.sketchGroup.remove(e),this.safeDisposeObject(e)}this.editor.objects=[],this.editor.workPlanes=[],this.editor.sketchPlanes=[],this.editor.selectedObjects=[],this.editor.transformControls&&(this.editor.transformControls.detach(),this.editor.transformControls.hide()),this.editor.history&&this.editor.history.clear()}safeDisposeObject(e){if(e)try{if(e.geometry&&"function"==typeof e.geometry.dispose&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach(e=>{e&&"function"==typeof e.dispose&&e.dispose()}):"function"==typeof e.material.dispose&&e.material.dispose()),e.children&&e.children.length>0)for(let t=e.children.length-1;t>=0;t--)this.safeDisposeObject(e.children[t])}catch(e){console.warn("Ошибка при освобождении ресурсов объекта:",e)}}showSaveModal(){document.getElementById("saveModal").classList.add("active")}saveProject(){const e=document.getElementById("projectNameInput").value||"Без названия",t=document.getElementById("projectDescription").value;this.currentProject={metadata:{version:"4.0",type:"cad-project",generator:"КонтрБагCAD",createdAt:(new Date).toISOString(),appVersion:this.editor.APP_VERSION},name:e,description:t,scene:this.serializeScene(),history:this.editor.history?this.editor.history.exportHistory():null,modified:(new Date).toISOString()};try{this.downloadProjectFile(this.currentProject),document.getElementById("projectName").textContent=e,document.getElementById("saveModal").classList.remove("active"),this.editor.showStatus(`Проект "${e}" сохранен в файл`,"success")}catch(e){console.error("Ошибка сохранения:",e),this.editor.showStatus("Ошибка сохранения: "+e.message,"error")}}serializeScene(){const e={objects:[],sketches:[]};return this.editor.objects.forEach(t=>{try{const r=this.serializeObject(t);r&&e.objects.push(r)}catch(e){console.warn("Ошибка сериализации объекта:",e,t)}}),e.sketches=this.serializeAllSketches(),e}serializeObject(e){if(!e||!e.userData)return null;if(console.log("Serializing object:",{type:e.userData.type,elementType:e.userData.elementType,uuid:e.uuid,objectType:e.type}),"group"===e.userData.type||e.isGroup)return this.serializeGroup(e);if("Line"===e.type||"LineLoop"===e.type||e.userData.elementType||"sketch_element"===e.userData.type)return this.serializeSketchElement(e);const t={uuid:e.uuid,type:e.type,userData:this.cleanUserData(e.userData),position:e.position.toArray(),rotation:[e.rotation.x,e.rotation.y,e.rotation.z],scale:e.scale.toArray(),visible:e.visible,castShadow:e.castShadow,receiveShadow:e.receiveShadow};let r=e.userData.originalMaterial||e.material;if(e.userData.currentColor&&!e.userData.originalMaterial&&(r=new THREE.MeshPhongMaterial({color:new THREE.Color(e.userData.currentColor),transparent:void 0!==e.userData.currentOpacity?e.userData.currentOpacity<1:e.material?.transparent||!1,opacity:e.userData.currentOpacity||1})),r&&(t.material=this.serializeMaterial(r)),e.geometry&&(t.geometry=this.serializeGeometry(e.geometry),console.log("Geometry serialized:",t.geometry?.type),"Line"!==e.type&&"LineLoop"!==e.type||(t.geometry.isLine=!0)),"sketch_plane"===e.userData.type||"work_plane"===e.userData.type){t.userData.hasSketch=e.userData.hasSketch||!1,t.userData.sketchElementsCount=e.userData.sketchElementsCount||0;const r=e=>e?Array.isArray(e)?e:e.isVector3?[e.x,e.y,e.z]:[0,0,1]:[0,0,1];t.userData.normal=r(e.userData.normal),t.userData.up=r(e.userData.up),t.userData.right=r(e.userData.right)}return"stl"===e.userData.type&&(t.userData.filename=e.userData.filename,t.userData.originalGeometry=null),"boolean_result"===e.userData.type&&(t.userData.operation=e.userData.operation,t.userData.sourceObjects=e.userData.sourceObjects||[]),t}serializeGroup(e){const t={uuid:e.uuid,type:"Group",userData:this.cleanUserData(e.userData),position:e.position.toArray(),rotation:[e.rotation.x,e.rotation.y,e.rotation.z],scale:e.scale.toArray(),visible:e.visible,children:[]};return e.children.forEach(r=>{if(r!==e){const e=this.serializeObject(r);e&&t.children.push(e)}}),t.userData.type||(t.userData.type="group"),t}serializeSketchElement(e){if(!e)return null;const t={uuid:e.uuid,type:e.type,userData:this.cleanUserData(e.userData),position:e.position.toArray(),rotation:[e.rotation.x,e.rotation.y,e.rotation.z],scale:e.scale.toArray(),visible:void 0===e.visible||e.visible};if(e.material?(t.material=this.serializeMaterial(e.material),console.log("serializeMaterial",e.material)):t.material={type:"LineBasicMaterial",color:1118481,linewidth:2,transparent:!1},e.geometry){const r=this.serializeGeometry(e.geometry);if(r.isLine=!0,e.geometry.attributes&&e.geometry.attributes.position){const t=e.geometry.attributes.position.array;r.points=[];for(let e=0;e<t.length;e+=3)r.points.push([t[e],t[e+1],t[e+2]])}t.geometry=r}return e.userData.localPoints&&!t.userData.localPoints&&(t.userData.localPoints=e.userData.localPoints.map(e=>e.toArray?e.toArray():e)),"text"===e.userData.elementType&&(t.userData.content=e.userData.content,t.userData.fontSize=e.userData.fontSize,e.userData.localPosition&&(e.userData.localPosition.toArray&&"function"==typeof e.userData.localPosition.toArray?t.userData.localPosition=e.userData.localPosition.toArray():Array.isArray(e.userData.localPosition)&&(t.userData.localPosition=e.userData.localPosition)),e.userData.contours&&(t.userData.contours=e.userData.contours.map(e=>e.map(e=>e.toArray&&"function"==typeof e.toArray?e.toArray():e)))),console.log("Sketch element serialized:",{type:t.type,elementType:t.userData.elementType,points:t.geometry?.points?.length}),t}cleanUserData(e){if(!e)return{};const t={};for(const r in e){const a=e[r];"function"!=typeof a&&(a&&(a.isObject3D||a.isMaterial||a.isBufferGeometry||a.isTexture)||(a&&a.isVector3&&a.toArray&&"function"==typeof a.toArray?t[r]=a.toArray():a&&a.isEuler?t[r]=[a.x,a.y,a.z]:a&&a.isColor?t[r]=a.getHex():null!==a&&"string"!=typeof a&&"number"!=typeof a&&"boolean"!=typeof a?Array.isArray(a)?t[r]=a.map(e=>e&&e.isVector3&&e.toArray&&"function"==typeof e.toArray?e.toArray():e&&e.isEuler?[e.x,e.y,e.z]:e&&e.isColor?e.getHex():e):"object"==typeof a&&(t[r]=this.cleanUserData(a)):t[r]=a))}return!t.type&&e.type&&(t.type=e.type),t}serializeMaterial(e){if(!e)return null;try{const t={type:e.type,uuid:e.uuid||THREE.MathUtils.generateUUID(),color:8421504,opacity:void 0!==e.opacity?e.opacity:1,transparent:e.transparent||!1};if(e.color)try{if(e.color.isColor)t.color=e.color.getHex();else if("number"==typeof e.color)t.color=e.color;else if(Array.isArray(e.color)){const[r,a,o]=e.color,s=new THREE.Color(r,a,o);t.color=s.getHex()}}catch(e){console.warn("Не удалось сериализовать цвет материала:",e),t.color=8421504}return"LineBasicMaterial"===e.type?(t.linewidth=e.linewidth||1,("number"!=typeof t.linewidth||isNaN(t.linewidth))&&(t.linewidth=1)):"LineDashedMaterial"===e.type&&(t.linewidth=e.linewidth||1,t.dashSize=e.dashSize||3,t.gapSize=e.gapSize||1,["linewidth","dashSize","gapSize"].forEach(e=>{("number"!=typeof t[e]||isNaN(t[e]))&&(t[e]="linewidth"===e?1:"dashSize"===e?3:1)})),t.opacity&&("number"!=typeof t.opacity||isNaN(t.opacity))&&(t.opacity=1),t}catch(t){return console.error("Error serializing material:",t),e&&"LineBasicMaterial"===e.type?{type:"LineBasicMaterial",color:1118481,linewidth:2,transparent:!1}:{type:"MeshPhongMaterial",color:8421504,opacity:1,transparent:!1}}}serializeGeometry(e){if(!e)return null;try{if(e.isBufferGeometry){const t=e.attributes.position,r=e.attributes.normal,a=e.index;if(!t)return console.warn("Geometry has no position attribute"),null;const o={type:"BufferGeometry",uuid:e.uuid||THREE.MathUtils.generateUUID(),positions:Array.from(t.array),normals:r?Array.from(r.array):[],indices:a?Array.from(a.array):[]};if(e.userData&&e.userData.isLine){const e=[];for(let r=0;r<t.array.length;r+=3)e.push([t.array[r],t.array[r+1],t.array[r+2]]);o.points=e}return e.boundingBox&&(o.boundingBox={min:e.boundingBox.min.toArray(),max:e.boundingBox.max.toArray()}),e.boundingSphere&&(o.boundingSphere={center:e.boundingSphere.center.toArray(),radius:e.boundingSphere.radius}),o}if(e.parameters)return{type:e.type,uuid:e.uuid||THREE.MathUtils.generateUUID(),parameters:this.cleanParameters(e.parameters)}}catch(e){console.error("Error serializing geometry:",e)}return null}cleanParameters(e){const t={};for(const r in e){const a=e[r];"function"!=typeof a&&(a&&a.isVector3?t[r]=a.toArray():null!==a&&"string"!=typeof a&&"number"!=typeof a&&"boolean"!=typeof a?Array.isArray(a)?t[r]=a.map(e=>e&&e.isVector3?e.toArray():e):"object"==typeof a&&(t[r]=this.cleanParameters(a)):t[r]=a)}return t}serializeAllSketches(){const e=[],t=this.editor.objects.filter(e=>"sketch_plane"===e.userData.type||"work_plane"===e.userData.type);return console.log(`Serializing sketches from ${t.length} planes`),t.forEach(t=>{const r=this.serializeSketch(t);r&&(e.push(r),console.log(`Sketch on plane ${t.uuid}: ${r.elements?.length||0} elements`))}),e}serializeSketch(e){if(!e||!e.children)return console.log("Plane has no children or not found"),null;const t=[];return e.children.forEach(e=>{if(e.userData&&"sketch_element"===e.userData.type){const r=this.serializeObject(e);r&&t.push(r)}}),0!==t.length||e.userData.hasSketch?{planeId:e.uuid,planeType:e.userData.type,planeData:this.serializeObject(e),elements:t,id:e.userData.sketchId||`sketch_${Date.now()}`,name:e.userData.name||"Чертеж",created:e.userData.createdAt||(new Date).toISOString()}:(console.log("Plane has no sketch elements"),null)}restoreAllSketches(e){if(!e||!Array.isArray(e))return void console.log("No sketches to restore");console.log(`Restoring ${e.length} sketches`);let t=0,r=0;e.forEach(e=>{const a=this.restoreSketch(e);if(a){t++;const e=a.children.filter(e=>e.userData&&"sketch_element"===e.userData.type);r+=e.length}}),console.log(`Sketches restored: ${t} planes, ${r} elements`),this.editor.objectsManager&&(this.editor.objectsManager.updateSceneStats(),this.editor.objectsManager.updateSceneList())}openProject(){const e=document.createElement("input");e.type="file",e.accept=".cadproj,.json,.cad",e.onchange=e=>{const t=e.target.files[0];if(!t)return;const r=new FileReader;r.onload=e=>{try{const t=JSON.parse(e.target.result);this.loadProject(t)}catch(e){alert("Ошибка при загрузке проекта: "+e.message)}},r.readAsText(t)},e.click()}loadProject(e){if(!e||!e.scene)return void alert("Неверный формат проекта");this.newProject();let t=0,r=0;e.scene.objects&&Array.isArray(e.scene.objects)&&e.scene.objects.forEach(e=>{try{const r=e.userData||{};if("sketch_element"===r.type||"sketch_plane"===r.type||"work_plane"===r.type||r.elementType)return void console.log("Skipping sketch-related object:",r.type);const a=this.deserializeObject(e);a&&(this.editor.objectsGroup.add(a),this.editor.objects.push(a),t++)}catch(t){console.error("Ошибка при загрузке объекта:",t,e),r++}}),e.scene.sketches&&Array.isArray(e.scene.sketches)&&(console.log("Loading sketches from project..."),this.restoreAllSketches(e.scene.sketches)),e.history&&this.editor.history&&this.editor.history.importHistory(e.history),this.currentProject=e,document.getElementById("projectName").textContent=e.name||"Проект",this.editor.objectsManager&&(this.editor.objectsManager.updateSceneStats(),this.editor.objectsManager.updateSceneList()),this.editor.updateStatus();const a=`Проект "${e.name||"Проект"}" загружен (${t} объектов`;r>0?this.editor.showStatus(`${a}, ошибок: ${r})`,"warning"):this.editor.showStatus(`${a})`,"success")}deserializeObject(e){if(!e||!e.userData)return console.warn("Invalid object data for deserialization:",e),null;if(console.log("Deserializing object:",{type:e.type,elementType:e.userData.elementType,uuid:e.uuid}),"group"===e.userData.type||"Group"===e.type)return this.deserializeGroup(e);if("Line"===e.type||"LineLoop"===e.type||e.userData.elementType||"sketch_element"===e.userData.type)return this.deserializeSketchElement(e);let t=null,r=null,a=null;if(e.material)r=this.deserializeMaterial(e.material),a=r.clone();else{const t=e.userData.materialColor||e.userData.color||8421504,o=e.userData.currentOpacity||e.userData.opacity||1;r=new THREE.MeshPhongMaterial({color:new THREE.Color(t),transparent:o<1,opacity:o,shininess:30,specular:new THREE.Color(1118481)}),a=r.clone()}if(e.geometry&&(t=this.deserializeGeometry(e.geometry)),t&&"BufferGeometry"!==t.type||!e.userData.geometryType||!e.userData.geometryParams||(console.log("Creating geometry from userData parameters:",e.userData.geometryType),t=this.createGeometryFromParameters({type:e.userData.geometryType,parameters:e.userData.geometryParams})),t||(t=this.createDefaultGeometry(e.userData.type)),!t||!r)return console.error("Failed to create object:",e.userData.type),null;const o=new THREE.Mesh(t,r);o.uuid=e.uuid||THREE.MathUtils.generateUUID(),e.userData.originalPosition?o.position.fromArray(e.userData.originalPosition):e.position&&o.position.fromArray(e.position),e.userData.originalScale?o.scale.fromArray(e.userData.originalScale):e.scale&&o.scale.fromArray(e.scale),e.rotation&&3===e.rotation.length&&o.rotation.set(e.rotation[0],e.rotation[1],e.rotation[2]),o.userData={...e.userData};const s=e=>e?e.isVector3?e:Array.isArray(e)&&e.length>=3?new THREE.Vector3(e[0],e[1],e[2]):new THREE.Vector3(0,0,1):new THREE.Vector3(0,0,1);return o.userData.normal&&(o.userData.normal=s(o.userData.normal)),o.userData.up&&(o.userData.up=s(o.userData.up)),o.userData.right&&(o.userData.right=s(o.userData.right)),o.userData.localPoints&&Array.isArray(o.userData.localPoints)&&(o.userData.localPoints=o.userData.localPoints.map(e=>Array.isArray(e)?(new THREE.Vector3).fromArray(e):e)),o.userData.needsAnimation&&(o.scale.set(1,1,1),o.userData.needsAnimation=!1),a&&(o.userData.originalMaterial=a),e.userData.currentColor&&(o.userData.currentColor=e.userData.currentColor),e.userData.currentOpacity&&(o.userData.currentOpacity=e.userData.currentOpacity),void 0!==e.visible&&(o.visible=e.visible),void 0!==e.castShadow&&(o.castShadow=e.castShadow),void 0!==e.receiveShadow&&(o.receiveShadow=e.receiveShadow),console.log("Mesh deserialized with userData:",o.userData),o}deserializeSketchElement(e){console.log("Deserializing sketch element:",e.type,e.userData?.elementType);let t,r=null;if(e.geometry)r=this.deserializeGeometry(e.geometry);else if(e.userData.localPoints){const t=[];e.userData.localPoints.forEach(e=>{Array.isArray(e)?t.push(...e):e&&void 0!==e.x&&t.push(e.x||0,e.y||0,e.z||0)}),t.length>0&&(r=new THREE.BufferGeometry,r.setAttribute("position",new THREE.Float32BufferAttribute(t,3)))}r||(r=new THREE.BufferGeometry,r.setAttribute("position",new THREE.Float32BufferAttribute([0,0,0,1,0,0],3)));const a=e.userData?.originalColor||e.material&&e.material.color||1118481;let o;return t=e.material&&"LineDashedMaterial"===e.material.type?new THREE.LineDashedMaterial({color:a,linewidth:e.material.linewidth||2,dashSize:e.material.dashSize||2,gapSize:e.material.gapSize||2}):new THREE.LineBasicMaterial({color:a,linewidth:e.material?.linewidth||2}),o="LineLoop"===e.type||e.userData&&e.userData.isClosed?new THREE.LineLoop(r,t):new THREE.Line(r,t),o.uuid=e.uuid||THREE.MathUtils.generateUUID(),e.position&&o.position.fromArray(e.position),e.rotation&&3===e.rotation.length&&o.rotation.set(e.rotation[0],e.rotation[1],e.rotation[2]),e.scale&&o.scale.fromArray(e.scale),void 0!==e.visible&&(o.visible=e.visible),o.userData={...e.userData||{}},o.userData.type="sketch_element",o.userData.elementType||(e.userData&&e.userData.elementType?o.userData.elementType=e.userData.elementType:"LineLoop"===e.type?o.userData.elementType="polygon":o.userData.elementType="line"),e.userData&&e.userData.localPoints&&(o.userData.localPoints=e.userData.localPoints.map(e=>Array.isArray(e)?(new THREE.Vector3).fromArray(e):e&&void 0!==e.x?new THREE.Vector3(e.x,e.y,e.z||0):new THREE.Vector3)),"circle"===o.userData.elementType&&e.userData&&(e.userData.center&&(Array.isArray(e.userData.center)?o.userData.center=(new THREE.Vector3).fromArray(e.userData.center):void 0!==e.userData.center.x&&(o.userData.center=new THREE.Vector3(e.userData.center.x,e.userData.center.y,e.userData.center.z||0))),e.userData.radius&&(o.userData.radius=e.userData.radius)),o.userData.originalColor||(o.userData.originalColor=a),o.userData.isSelected=!1,"LineDashedMaterial"===e.material?.type&&o.computeLineDistances(),console.log("Element deserialized with unified format:",{type:o.userData.elementType,points:o.userData.localPoints?.length,hasCenter:!!o.userData.center,radius:o.userData.radius}),o}deserializeGeometry(e){if(!e)return console.warn("No geometry data provided"),this.createBoxGeometry();console.log("Deserializing geometry:",e.type,e.isLine?"(line)":"");try{if("BufferGeometry"===e.type){const t=new THREE.BufferGeometry;if(e.positions&&e.positions.length>0){const r=new Float32Array(e.positions);t.setAttribute("position",new THREE.BufferAttribute(r,3))}else{if(!(e.points&&e.points.length>0))return console.warn("No positions in geometry data"),this.createBoxGeometry();{const r=[];e.points.forEach(e=>{r.push(...e)}),t.setAttribute("position",new THREE.Float32BufferAttribute(r,3))}}if(!e.isLine&&e.normals&&e.normals.length>0){const r=new Float32Array(e.normals);t.setAttribute("normal",new THREE.BufferAttribute(r,3))}else e.isLine||t.computeVertexNormals();if(e.indices&&e.indices.length>0){const r=new Uint32Array(e.indices);t.setIndex(new THREE.BufferAttribute(r,1))}return e.boundingBox?t.boundingBox=new THREE.Box3((new THREE.Vector3).fromArray(e.boundingBox.min),(new THREE.Vector3).fromArray(e.boundingBox.max)):t.computeBoundingBox(),e.boundingSphere?t.boundingSphere=new THREE.Sphere((new THREE.Vector3).fromArray(e.boundingSphere.center),e.boundingSphere.radius):t.computeBoundingSphere(),t}return this.createGeometryFromParameters(e)}catch(e){return console.error("Error deserializing geometry:",e),this.createBoxGeometry()}}deserializeGroup(e){const t=new THREE.Group;return t.uuid=e.uuid||THREE.MathUtils.generateUUID(),e.position&&t.position.fromArray(e.position),e.scale&&t.scale.fromArray(e.scale),e.rotation&&3===e.rotation.length&&t.rotation.set(e.rotation[0],e.rotation[1],e.rotation[2]),void 0!==e.visible&&(t.visible=e.visible),t.userData={...e.userData},t.userData.type||(t.userData.type="group"),e.children&&Array.isArray(e.children)&&e.children.forEach(e=>{const r=this.deserializeObject(e);r&&t.add(r)}),t}createGeometryFromParameters(e){if(!e.parameters)return console.warn("No parameters in geometry data"),this.createBoxGeometry();const t=e.parameters;switch(e.type){case"BoxGeometry":return new THREE.BoxGeometry(t.width||25,t.height||25,t.depth||25,t.widthSegments||1,t.heightSegments||1,t.depthSegments||1);case"SphereGeometry":return new THREE.SphereGeometry(t.radius||12.5,t.widthSegments||32,t.heightSegments||32,t.phiStart||0,t.phiLength||2*Math.PI,t.thetaStart||0,t.thetaLength||Math.PI);case"CylinderGeometry":return new THREE.CylinderGeometry(t.radiusTop||12.5,t.radiusBottom||12.5,t.height||25,t.radialSegments||32,t.heightSegments||1,t.openEnded||!1,t.thetaStart||0,t.thetaLength||2*Math.PI);case"ConeGeometry":return new THREE.ConeGeometry(t.radius||12.5,t.height||25,t.radialSegments||32,t.heightSegments||1,t.openEnded||!1,t.thetaStart||0,t.thetaLength||2*Math.PI);case"TorusGeometry":return new THREE.TorusGeometry(t.radius||25,t.tube||5,t.radialSegments||16,t.tubularSegments||100,t.arc||2*Math.PI);case"PlaneGeometry":return new THREE.PlaneGeometry(t.width||100,t.height||100,t.widthSegments||1,t.heightSegments||1);case"CircleGeometry":return new THREE.CircleGeometry(t.radius||10,t.segments||32,t.thetaStart||0,t.thetaLength||2*Math.PI);case"TorusKnotGeometry":return new THREE.TorusKnotGeometry(t.radius||10,t.tube||3,t.tubularSegments||64,t.radialSegments||8,t.p||2,t.q||3);default:return console.warn("Unknown geometry type:",e.type),this.createBoxGeometry()}}createDefaultGeometry(e){if(!e)return this.createBoxGeometry();switch(e.toLowerCase()){case"cube":case"box":return this.createBoxGeometry();case"sphere":return this.createSphereGeometry();case"cylinder":return this.createCylinderGeometry();case"cone":return this.createConeGeometry();case"torus":return this.createTorusGeometry();case"stl":case"boolean":case"boolean_result":const t=this.createBoxGeometry();return t.userData={fallback:!0,originalType:e},t;default:return console.warn("Unknown geometry type for default:",e),this.createBoxGeometry()}}createBoxGeometry(e=25,t=25,r=25){const a=new THREE.BoxGeometry(e,t,r);return a.computeBoundingBox(),a.computeBoundingSphere(),a}createSphereGeometry(e=12.5,t=32){const r=new THREE.SphereGeometry(e,t,t);return r.computeBoundingBox(),r.computeBoundingSphere(),r}createCylinderGeometry(e=12.5,t=12.5,r=25,a=32){const o=new THREE.CylinderGeometry(e,t,r,a);return o.computeBoundingBox(),o.computeBoundingSphere(),o}createConeGeometry(e=12.5,t=25,r=32){const a=new THREE.ConeGeometry(e,t,r);return a.computeBoundingBox(),a.computeBoundingSphere(),a}createTorusGeometry(e=25,t=5,r=16,a=100){const o=new THREE.TorusGeometry(e,t,r,a);return o.computeBoundingBox(),o.computeBoundingSphere(),o}deserializeMaterial(e){if(!e)return null;let t;try{switch(e.type){case"MeshBasicMaterial":t=new THREE.MeshBasicMaterial;break;case"MeshPhongMaterial":default:t=new THREE.MeshPhongMaterial;break;case"MeshStandardMaterial":t=new THREE.MeshStandardMaterial;break;case"LineBasicMaterial":t=new THREE.LineBasicMaterial;break;case"LineDashedMaterial":t=new THREE.LineDashedMaterial}const r=e=>{if("number"==typeof e)return new THREE.Color(e);if(Array.isArray(e)){if(e.length>=3)return new THREE.Color(e[0],e[1],e[2]);if(e[0]>1||e[1]>1||e[2]>1)return new THREE.Color(e[0]/255,e[1]/255,e[2]/255)}else if(e&&e.isColor)return e;return new THREE.Color(8421504)};if(void 0!==e.color)try{t.color=r(e.color)}catch(e){console.warn("Error setting material color:",e),t.color=new THREE.Color(8421504)}else t.color=new THREE.Color(8421504);if(void 0!==e.opacity){const r=parseFloat(e.opacity);t.opacity=isNaN(r)?1:Math.max(0,Math.min(1,r))}else t.opacity=1;if(void 0!==e.transparent&&(t.transparent=Boolean(e.transparent)),t instanceof THREE.LineBasicMaterial||t instanceof THREE.LineDashedMaterial){if(void 0!==e.linewidth){const r=parseFloat(e.linewidth);t.linewidth=isNaN(r)?1:Math.max(.1,r)}if(void 0!==e.dashSize){const r=parseFloat(e.dashSize);t.dashSize=isNaN(r)?1:Math.max(.1,r)}if(void 0!==e.gapSize){const r=parseFloat(e.gapSize);t.gapSize=isNaN(r)?1:Math.max(.1,r)}}if(t instanceof THREE.MeshPhongMaterial){if(void 0!==e.shininess){const r=parseFloat(e.shininess);t.shininess=isNaN(r)?30:Math.max(0,r)}if(void 0!==e.specular)try{t.specular=r(e.specular)}catch(e){t.specular=new THREE.Color(1118481)}}if(t instanceof THREE.MeshStandardMaterial){if(void 0!==e.metalness){const r=parseFloat(e.metalness);t.metalness=isNaN(r)?.5:Math.max(0,Math.min(1,r))}if(void 0!==e.roughness){const r=parseFloat(e.roughness);t.roughness=isNaN(r)?.5:Math.max(0,Math.min(1,r))}}return t.needsUpdate=!0,t}catch(t){return console.error("Error deserializing material:",t),e&&"LineBasicMaterial"===e.type?new THREE.LineBasicMaterial({color:1118481,linewidth:2}):new THREE.MeshPhongMaterial({color:8421504,shininess:30,specular:new THREE.Color(1118481)})}}restoreSketch(e){if(!e)return void console.warn("Invalid sketch data");console.log("Restoring sketch:",e);let t=null;if(e.planeData?t=this.deserializeObject(e.planeData):e.planeId&&(t=this.editor.findObjectByUuid(e.planeId)),!t)return void console.warn("Failed to restore sketch plane");t.parent||(this.editor.objectsGroup.add(t),this.editor.objects.push(t),"sketch_plane"===t.userData.type?this.editor.sketchPlanes.push(t):"work_plane"===t.userData.type&&this.editor.workPlanes.push(t));const r=[];t.children.forEach(e=>{e.userData&&"sketch_element"===e.userData.type&&r.push(e)}),r.forEach(e=>{t.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()});let a=0;return e.elements&&Array.isArray(e.elements)&&e.elements.forEach(e=>{this.restoreSketchElement(t,e)&&a++}),t.userData.hasSketch=!0,t.userData.sketchElementsCount=a,t.userData.sketchId=e.id||`sketch_${Date.now()}`,t.userData.name=e.name||"Чертеж",t.userData.createdAt=e.created||(new Date).toISOString(),console.log(`Sketch restored: ${a} elements`),t}restoreSketchElement(e,t){if(!e||!t)return null;console.log("Restoring sketch element:",t.userData?.elementType);const r=this.deserializeObject(t);if(!r)return console.warn("Failed to deserialize sketch element"),null;r.userData&&"sketch_element"===r.userData.type&&this.normalizeSketchElement(r,t);try{e.add(r);const t=this.createSketchElementObject(r,e);if(this.editor.sketchManager&&this.editor.sketchManager.elementManager){const e=this.editor.sketchManager.elementManager.elements.findIndex(e=>e.mesh&&e.mesh.uuid===r.uuid);-1===e?this.editor.sketchManager.elementManager.elements.push(t):this.editor.sketchManager.elementManager.elements[e]=t}return console.log("Element restored in normalized format:",t.type),r}catch(e){return console.error("Error adding sketch element to plane:",e),r.geometry&&r.geometry.dispose(),r.material&&r.material.dispose(),null}}normalizeSketchElement(e,t){const r=e.userData;if(!r.elementType&&t.userData?.elementType?r.elementType=t.userData.elementType:r.elementType||("LineLoop"===e.type?(r.elementType="polygon",r.isClosed=!0):"Line"===e.type&&(r.elementType="line",r.isClosed=!1)),r.localPoints&&Array.isArray(r.localPoints)?r.localPoints=r.localPoints.map(e=>Array.isArray(e)?(new THREE.Vector3).fromArray(e):e&&void 0!==e.x&&void 0!==e.y?new THREE.Vector3(e.x,e.y,e.z||0):e).filter(e=>e instanceof THREE.Vector3):r.localPoints=this.extractPointsFromElement(e),r.originalColor||(e.material&&e.material.color?r.originalColor=e.material.color.getHex():r.originalColor=1118481),"circle"===r.elementType&&t.userData){if(t.userData.center)if(Array.isArray(t.userData.center))r.center=(new THREE.Vector3).fromArray(t.userData.center);else if(!(t.userData.center instanceof THREE.Vector3)){const e=t.userData.center;r.center=new THREE.Vector3(e.x,e.y,e.z||0)}t.userData.radius&&!r.radius&&(r.radius=t.userData.radius)}r.isSelected=!1}extractPointsFromElement(e){const t=[];if(e.geometry&&e.geometry.attributes&&e.geometry.attributes.position){const r=e.geometry.attributes.position.array;for(let e=0;e<r.length;e+=3)t.push(new THREE.Vector3(r[e],r[e+1],r[e+2]))}return t}createSketchElementObject(e,t){return{type:e.userData.elementType||"unknown",mesh:e,originalColor:e.userData.originalColor||1118481,color:e.userData.originalColor||1118481,localPoints:e.userData.localPoints||[],localPosition:e.userData.localPosition||new THREE.Vector3,isClosed:e.userData.isClosed||!1,sketchPlaneId:t.uuid,userData:e.userData,center:e.userData.center,radius:e.userData.radius,points:e.userData.points||e.userData.localPoints}}downloadProjectFile(e){const t=JSON.stringify(e,null,2),r=new Blob([t],{type:"application/json"}),a=`${e.name.replace(/[^a-z0-9а-яё\s]/gi,"_").toLowerCase()}.cadproj`;this.downloadFile(r,a)}downloadFile(e,t){const r=document.createElement("a");r.href=URL.createObjectURL(e),r.download=t,document.body.appendChild(r),r.click(),document.body.removeChild(r)}findObjectByUuid(e){return this.editor.objects.find(t=>t.uuid===e)||null}showExportModal(){document.getElementById("exportModal").classList.add("active"),document.getElementById("exportFileName").value=document.getElementById("projectName").textContent.replace(/\s+/g,"_")}exportModel(){const e=document.getElementById("exportFormat").value,t=document.getElementById("exportSelected").checked,r=document.getElementById("exportFileName").value||"model";let a;if(a=t&&this.editor.selectedObjects.length>0?this.editor.selectedObjects:this.editor.objects.filter(e=>"sketch_plane"!==e.userData.type&&"work_plane"!==e.userData.type&&"sketch_element"!==e.userData.type),0!==a.length)switch(e){case"stl":case"stl-ascii":this.exportSTL(a,r,"stl-ascii"===e);break;case"json":this.exportJSON(a,r)}else alert("Нет объектов для экспорта!")}exportSTL(e,t,r=!1){const a=new THREE.STLExporter;let o;1===e.length?o=e[0]:(o=new THREE.Group,e.forEach(e=>{const t=e.clone();o.add(t)})),o.traverse(e=>{e.isMesh&&e.geometry.rotateX(Math.PI/2)});const s=a.parse(o,{binary:!r});o.traverse(e=>{e.isMesh&&e.geometry.rotateX(Math.PI/2)});const i=new Blob([s],{type:r?"text/plain":"application/octet-stream"});this.downloadFile(i,t+".stl"),this.editor.showStatus("Экспорт STL завершен","success"),o.traverse(e=>{e.isMesh&&e.geometry.rotateX(Math.PI)})}exportJSON(e,t){const r={metadata:{version:"4.0",type:"cad-export",exportDate:(new Date).toISOString(),appVersion:this.editor.APP_VERSION},name:t,objects:e.map(e=>this.serializeObject(e)).filter(e=>e)},a=JSON.stringify(r,null,2),o=new Blob([a],{type:"application/json"});this.downloadFile(o,t+".json"),this.editor.showStatus("Экспорт JSON завершен","success")}exportSVG(){this.editor.showStatus("Экспорт SVG в разработке","info")}openSTL(){const e=document.createElement("input");e.type="file",e.accept=".stl",e.onchange=e=>{const t=e.target.files[0];if(!t)return;const r=new FileReader;r.onload=e=>{this.loadSTLFromBuffer(e.target.result,t.name)},r.readAsArrayBuffer(t)},e.click()}loadSTLFromBuffer(e,t){try{const r=this.isBinarySTL(e)?this.parseBinarySTL(e):this.parseASCIISTL(e);if(!r)return void this.editor.showStatus("Ошибка при чтении STL файла","error");r.computeBoundingBox();const a=r.boundingBox,o=new THREE.Vector3;a.getCenter(o);const s=r.attributes.position.array;for(let e=0;e<s.length;e+=3)s[e]-=o.x,s[e+1]-=o.y,s[e+2]-=o.z;r.attributes.position.needsUpdate=!0,r.computeBoundingBox(),r.rotateX(-Math.PI/2);const i=new THREE.MeshPhongMaterial({color:new THREE.Color("#AAAAAA"),transparent:!0,opacity:.9,side:THREE.DoubleSide,shininess:30}),n=new THREE.Mesh(r,i);n.castShadow=!0,n.receiveShadow=!0,r.computeBoundingBox();const l=r.boundingBox,c=new THREE.Vector3;l.getSize(c),n.position.y=c.y/2,n.userData={id:"stl_"+Date.now(),name:t.replace(".stl",""),type:"stl",createdAt:(new Date).toISOString(),unit:"mm",filename:t,originalGeometry:r},this.editor.objectsGroup.add(n),this.editor.objects.push(n),this.editor.clearSelection(),this.editor.selectSingleObject(n),this.editor.objectsManager&&(this.editor.objectsManager.updateSceneStats(),this.editor.objectsManager.updateSceneList()),this.editor.showStatus(`Загружен STL: ${t}`,"success"),this.editor.history&&this.editor.history.addAction({type:"import",format:"stl",object:n.uuid,data:this.serializeObjectForHistory(n)})}catch(e){console.error("STL loading error:",e),this.editor.showStatus(`Ошибка загрузки STL: ${e.message}`,"error")}}isBinarySTL(e){const t=84+50*new DataView(e).getUint32(80,!0);return e.byteLength===t}parseBinarySTL(e){const t=new THREE.BufferGeometry,r=[],a=[],o=new DataView(e),s=o.getUint32(80,!0);let i=84;for(let e=0;e<s;e++){const e=[o.getFloat32(i,!0),o.getFloat32(i+4,!0),o.getFloat32(i+8,!0)];i+=12;for(let t=0;t<3;t++)r.push(o.getFloat32(i,!0),o.getFloat32(i+4,!0),o.getFloat32(i+8,!0)),a.push(...e),i+=12;i+=2}return t.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),t.setAttribute("normal",new THREE.Float32BufferAttribute(a,3)),t.computeBoundingBox(),t.computeBoundingSphere(),t}parseASCIISTL(e){const t=(new TextDecoder).decode(e),r=new THREE.BufferGeometry,a=[],o=[],s=t.split("\n");let i=null;for(const e of s){const t=e.trim();if(t.startsWith("facet normal")){const e=t.split(/\s+/);i=[parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])]}else if(t.startsWith("vertex")){const e=t.split(/\s+/);a.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),i&&o.push(...i)}}return 0===a.length?null:(r.setAttribute("position",new THREE.Float32BufferAttribute(a,3)),o.length===a.length?r.setAttribute("normal",new THREE.Float32BufferAttribute(o,3)):r.computeVertexNormals(),r.computeBoundingBox(),r.computeBoundingSphere(),r)}serializeObjectForHistory(e){return this.serializeObject(e)}deserializeObjectOptimized(e){return this.deserializeObject(e)}}