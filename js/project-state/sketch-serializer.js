class SketchSerializer{constructor(e){this.editor=e}serializeAllSketches(){const e=[],t=this.editor.objects.filter(e=>"sketch_plane"===e.userData.type||"work_plane"===e.userData.type);return console.log(`Serializing sketches from ${t.length} planes`),t.forEach(t=>{const r=this.serializeSketch(t);r&&(e.push(r),console.log(`Sketch on plane ${t.uuid}: ${r.elements?.length||0} elements`))}),e}serializeSketch(e){if(!e||!e.children)return console.log("Plane has no children or not found"),null;const t=[];return e.children.forEach(e=>{if(e.userData&&"sketch_element"===e.userData.type){const r=this.serializeSketchElement(e);r&&t.push(r)}}),0!==t.length||e.userData.hasSketch?{planeId:e.uuid,planeType:e.userData.type,planeData:this.editor.projectManager.serializeObject(e),elements:t,id:e.userData.sketchId||`sketch_${Date.now()}`,name:e.userData.name||"Чертеж",created:e.userData.createdAt||(new Date).toISOString()}:(console.log("Plane has no sketch elements"),null)}serializeSketchElement(e){if(!e)return null;console.log("Serializing sketch element:",{type:e.type,elementType:e.userData?.elementType,uuid:e.uuid});const t={uuid:e.uuid,type:e.type,userData:this.cleanSketchUserData(e.userData),position:e.position.toArray(),rotation:[e.rotation.x,e.rotation.y,e.rotation.z],scale:e.scale.toArray(),visible:void 0===e.visible||e.visible};if(e.material?t.material=this.serializeSketchMaterial(e.material):t.material={type:"LineBasicMaterial",color:1118481,linewidth:2,transparent:!1},e.geometry){const r=this.serializeSketchGeometry(e.geometry);t.geometry=r}return t}cleanSketchUserData(e){if(!e)return{};const t={};for(const r in e){const a=e[r];"function"!=typeof a&&(a&&(a.isObject3D||a.isMaterial||a.isBufferGeometry||a.isTexture)||(a&&a.isVector3&&a.toArray&&"function"==typeof a.toArray?t[r]=a.toArray():a&&a.isEuler?t[r]=[a.x,a.y,a.z]:a&&a.isColor?t[r]=a.getHex():null!==a&&"string"!=typeof a&&"number"!=typeof a&&"boolean"!=typeof a?Array.isArray(a)?t[r]=a.map(e=>e&&e.isVector3&&e.toArray&&"function"==typeof e.toArray?e.toArray():e&&e.isEuler?[e.x,e.y,e.z]:e&&e.isColor?e.getHex():e):"object"==typeof a&&(t[r]=this.cleanSketchUserData(a)):t[r]=a))}return!t.type&&e.type&&(t.type=e.type),t}serializeSketchMaterial(e){if(!e)return null;try{const t={type:e.type,uuid:e.uuid||THREE.MathUtils.generateUUID(),color:1118481,linewidth:2};if(e.color)try{e.color.isColor?t.color=e.color.getHex():"number"==typeof e.color&&(t.color=e.color)}catch(e){console.warn("Не удалось сериализовать цвет материала:",e),t.color=1118481}return"LineBasicMaterial"===e.type?t.linewidth=e.linewidth||1:"LineDashedMaterial"===e.type&&(t.linewidth=e.linewidth||1,t.dashSize=e.dashSize||3,t.gapSize=e.gapSize||1),t}catch(e){return console.error("Error serializing sketch material:",e),{type:"LineBasicMaterial",color:1118481,linewidth:2,transparent:!1}}}serializeSketchGeometry(e){if(!e)return null;try{const t={type:"BufferGeometry",uuid:e.uuid||THREE.MathUtils.generateUUID(),positions:[],normals:[],indices:[],isLine:!0};if(e.attributes&&e.attributes.position){const r=e.attributes.position.array;t.positions=Array.from(r);const a=[];for(let e=0;e<r.length;e+=3)a.push([r[e],r[e+1],r[e+2]]);t.points=a}if(e.attributes&&e.attributes.normal){const r=e.attributes.normal.array;t.normals=Array.from(r)}if(e.index){const r=e.index.array;t.indices=Array.from(r)}return t}catch(e){return console.error("Error serializing sketch geometry:",e),null}}restoreAllSketches(e){if(!e||!Array.isArray(e))return void console.log("No sketches to restore");console.log(`Restoring ${e.length} sketches`);let t=0,r=0;e.forEach(e=>{const a=this.restoreSketch(e);if(a){t++;const e=a.children.filter(e=>e.userData&&"sketch_element"===e.userData.type);r+=e.length}}),console.log(`Sketches restored: ${t} planes, ${r} elements`)}restoreSketch(e){if(!e)return console.warn("Invalid sketch data"),null;console.log("Restoring sketch:",e.id);let t=null;if(e.planeData?t=this.editor.projectManager.deserializeObject(e.planeData):e.planeId&&(t=this.editor.findObjectByUuid(e.planeId)),!t)return console.warn("Failed to restore sketch plane"),null;t.parent||(this.editor.objectsGroup.add(t),this.editor.objects.push(t),"sketch_plane"===t.userData.type?this.editor.sketchPlanes.push(t):"work_plane"===t.userData.type&&this.editor.workPlanes.push(t));const r=[];t.children.forEach(e=>{e.userData&&"sketch_element"===e.userData.type&&r.push(e)}),r.forEach(e=>{t.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()});let a=0;return e.elements&&Array.isArray(e.elements)&&e.elements.forEach(e=>{this.restoreSketchElement(t,e)&&a++}),t.userData.hasSketch=!0,t.userData.sketchElementsCount=a,t.userData.sketchId=e.id||`sketch_${Date.now()}`,t.userData.name=e.name||"Чертеж",t.userData.createdAt=e.created||(new Date).toISOString(),console.log(`Sketch restored: ${a} elements`),t}restoreSketchElement(e,t){if(!e||!t)return null;console.log("Restoring sketch element:",t.userData?.elementType);const r=this.deserializeSketchElement(t);if(!r)return console.warn("Failed to deserialize sketch element"),null;this.normalizeSketchElement(r,t);try{e.add(r);const t=this.createSketchElementObject(r,e);if(this.editor.sketchManager&&this.editor.sketchManager.elementManager){const e=this.editor.sketchManager.elementManager.elements.findIndex(e=>e.mesh&&e.mesh.uuid===r.uuid);-1===e?this.editor.sketchManager.elementManager.elements.push(t):this.editor.sketchManager.elementManager.elements[e]=t}return console.log("Element restored in normalized format:",t.type),r}catch(e){return console.error("Error adding sketch element to plane:",e),r.geometry&&r.geometry.dispose(),r.material&&r.material.dispose(),null}}deserializeSketchElement(e){if(!e||!e.userData)return console.warn("Invalid sketch element data for deserialization:",e),null;console.log("Deserializing sketch element:",e.type,e.userData.elementType);let t,r=null;if(e.geometry)r=this.deserializeSketchGeometry(e.geometry);else if(e.userData.localPoints){const t=[];e.userData.localPoints.forEach(e=>{Array.isArray(e)?t.push(...e):e&&void 0!==e.x&&t.push(e.x||0,e.y||0,e.z||0)}),t.length>0&&(r=new THREE.BufferGeometry,r.setAttribute("position",new THREE.Float32BufferAttribute(t,3)))}r||(r=new THREE.BufferGeometry,r.setAttribute("position",new THREE.Float32BufferAttribute([0,0,0,1,0,0],3)));const a=e.userData?.originalColor||e.material&&e.material.color||1118481;let o;return t=e.material&&"LineDashedMaterial"===e.material.type?new THREE.LineDashedMaterial({color:a,linewidth:e.material.linewidth||2,dashSize:e.material.dashSize||2,gapSize:e.material.gapSize||2}):new THREE.LineBasicMaterial({color:a,linewidth:e.material?.linewidth||2}),o="LineLoop"===e.type||e.userData&&e.userData.isClosed?new THREE.LineLoop(r,t):new THREE.Line(r,t),o.uuid=e.uuid||THREE.MathUtils.generateUUID(),e.position&&o.position.fromArray(e.position),e.rotation&&3===e.rotation.length&&o.rotation.set(e.rotation[0],e.rotation[1],e.rotation[2]),e.scale&&o.scale.fromArray(e.scale),void 0!==e.visible&&(o.visible=e.visible),o.userData={...e.userData||{}},o.userData.type="sketch_element","LineDashedMaterial"===e.material?.type&&o.computeLineDistances(),o}deserializeSketchGeometry(e){if(!e)return console.warn("No geometry data provided"),null;try{if("BufferGeometry"===e.type){const t=new THREE.BufferGeometry;if(e.positions&&e.positions.length>0){const r=new Float32Array(e.positions);t.setAttribute("position",new THREE.BufferAttribute(r,3))}else{if(!(e.points&&e.points.length>0))return console.warn("No positions in geometry data"),null;{const r=[];e.points.forEach(e=>{r.push(...e)}),t.setAttribute("position",new THREE.Float32BufferAttribute(r,3))}}if(!e.isLine&&e.normals&&e.normals.length>0){const r=new Float32Array(e.normals);t.setAttribute("normal",new THREE.BufferAttribute(r,3))}if(e.indices&&e.indices.length>0){const r=new Uint32Array(e.indices);t.setIndex(new THREE.BufferAttribute(r,1))}return t.computeBoundingBox(),t.computeBoundingSphere(),t}}catch(e){console.error("Error deserializing sketch geometry:",e)}return null}normalizeSketchElement(e,t){const r=e.userData;if(!r.elementType&&t.userData?.elementType?r.elementType=t.userData.elementType:r.elementType||("LineLoop"===e.type?(r.elementType="polygon",r.isClosed=!0):"Line"===e.type&&(r.elementType="line",r.isClosed=!1)),r.localPoints&&Array.isArray(r.localPoints)?r.localPoints=r.localPoints.map(e=>Array.isArray(e)?(new THREE.Vector3).fromArray(e):e&&void 0!==e.x&&void 0!==e.y?new THREE.Vector3(e.x,e.y,e.z||0):e).filter(e=>e instanceof THREE.Vector3):r.localPoints=this.extractPointsFromElement(e),r.originalColor||(e.material&&e.material.color?r.originalColor=e.material.color.getHex():r.originalColor=1118481),"circle"===r.elementType&&t.userData){if(t.userData.center)if(Array.isArray(t.userData.center))r.center=(new THREE.Vector3).fromArray(t.userData.center);else if(!(t.userData.center instanceof THREE.Vector3)){const e=t.userData.center;r.center=new THREE.Vector3(e.x,e.y,e.z||0)}t.userData.radius&&!r.radius&&(r.radius=t.userData.radius)}r.isSelected=!1}extractPointsFromElement(e){const t=[];if(e.geometry&&e.geometry.attributes&&e.geometry.attributes.position){const r=e.geometry.attributes.position.array;for(let e=0;e<r.length;e+=3)t.push(new THREE.Vector3(r[e],r[e+1],r[e+2]))}return t}createSketchElementObject(e,t){const r={type:e.userData.elementType||"unknown",mesh:e,originalColor:e.userData.originalColor||1118481,color:e.userData.originalColor||1118481,localPoints:e.userData.localPoints||[],localPosition:e.userData.localPosition||new THREE.Vector3,isClosed:e.userData.isClosed||!1,sketchPlaneId:t.uuid,userData:e.userData,centerLocal:e.userData.centerLocal};return"circle"===e.userData.elementType&&(e.userData.centerLocal?r.centerLocal=e.userData.centerLocal:e.userData.center&&(r.centerLocal=t.worldToLocal(e.userData.center.clone())),r.radius=e.userData.radius),r}serializeSketchState(e){if(!e)return null;const t={planeId:e.uuid,planeData:this.editor.projectManager.serializeObject(e),elements:[]};return e.children.forEach(e=>{if(e.userData&&"sketch_element"===e.userData.type){const r=this.serializeSketchElement(e);r&&t.elements.push({uuid:e.uuid,data:r})}}),t}restoreSketchState(e){if(!e||!e.planeId)return console.error("Invalid sketch state:",e),!1;const t=this.editor.findObjectByUuid(e.planeId);if(!t)return console.error("Plane not found:",e.planeId),!1;const r=[];t.children.forEach(e=>{e.userData&&"sketch_element"===e.userData.type&&r.push(e)}),r.forEach(e=>{t.remove(e),e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()});let a=0;return e.elements&&Array.isArray(e.elements)&&e.elements.forEach(e=>{if(e.data){this.restoreSketchElement(t,e.data)&&a++}}),this.editor.sketchManager?.elementManager&&(this.editor.sketchManager.elementManager.updateElementsFromPlane(),this.editor.sketchManager.elementManager.clearSelection()),this.editor.sketchManager&&this.editor.sketchManager.onUndoRedo(),console.log(`Restored ${a} sketch elements`),a>0}}