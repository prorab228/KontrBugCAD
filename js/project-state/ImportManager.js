import*as THREE from"three";import{ThreeMFLoader}from"three/addons/loaders/3MFLoader.js";import{OBJLoader}from"three/addons/loaders/OBJLoader.js";import{ParametricOperation}from"../core/parametric/ParametricOperation.js";export class ImportManager{constructor(e){this.editor=e,this.geometryCache=new Map,this._objLoader=null,this._3mfLoader=null}_getOBJLoader(){if(!this._objLoader){if(void 0===THREE.OBJLoader)throw new Error("OBJLoader не доступен. Подключите examples/js/loaders/OBJLoader.js");this._objLoader=new THREE.OBJLoader}return this._objLoader}_get3MFLoader(){if(!this._3mfLoader){if(void 0===THREE.ThreeMFLoader)throw new Error("ThreeMFLoader не доступен. Подключите examples/js/loaders/3MFLoader.js");this._3mfLoader=new THREE.ThreeMFLoader}return this._3mfLoader}import(){this._openFileDialog(".stl, .obj, .3mf",(e,t)=>{this.importFromBuffer(t,e.name,[0,0,0])})}_openFileDialog(e,t){const r=document.createElement("input");r.type="file",r.accept=e,r.onchange=e=>{const r=e.target.files[0];if(!r)return;const o=new FileReader;o.onload=e=>{const o=e.target.result;t(r,o)},o.readAsArrayBuffer(r)},r.click()}importFromBuffer(e,t,r=[0,0,0],o=9159498){const s=t.split(".").pop().toLowerCase();let i;try{switch(s){case"stl":i=this.loadSTLGeometry(e);break;case"obj":i=this.loadOBJGeometry(e);break;case"3mf":i=this.load3MFGeometry(e);break;default:throw new Error(`Неподдерживаемый формат: ${s}`)}return i instanceof Promise?i.then(e=>this._finalizeImport(e,t,r,o)):this._finalizeImport(i,t,r,o)}catch(e){return console.error("Import error:",e),this.editor.showStatus(`Ошибка импорта: ${e.message}`,"error"),[]}}_finalizeImport({geometry:e,originalSize:t},r,o,s){const i=this.serializeGeometry(e),a=new ParametricOperation("import_mesh",{filePath:"file://"+r,color:s,position:o instanceof THREE.Vector3?o.toArray():o,geometryData:i},[]),n=this.editor.parametricModel.addOperation(a,!0),l="file://"+r;return this.geometryCache.set(l,{geometry:e.clone(),originalSize:t}),this.editor.showStatus(`Загружена модель: ${r}`,"success"),n}loadSTLGeometry(e){if(!e||0===e.byteLength)throw new Error("Empty STL file");let t;if(t=this.isBinarySTL(e)?this.parseBinarySTL(e):this.parseASCIISTL(e),!t)throw new Error("Failed to parse STL");return t.rotateX(-Math.PI/2),this._postProcessGeometry(t)}loadOBJGeometry(e){const t=this._getOBJLoader(),r=(new TextDecoder).decode(e),o=t.parse(r),s=[];if(o.traverse(e=>{e.isMesh&&s.push(e.geometry.clone())}),0===s.length)throw new Error("No meshes found in OBJ");const i=this.mergeGeometries(s);return i.rotateX(-Math.PI/2),this._postProcessGeometry(i)}load3MFGeometry(e){const t=this._get3MFLoader();return new Promise((r,o)=>{t.parse(e,e=>{const t=[];e.traverse(e=>{e.isMesh&&t.push(e.geometry.clone())}),0===t.length&&o(new Error("No meshes in 3MF"));const s=this.mergeGeometries(t);r(this._postProcessGeometry(s))},e=>{o(e)})})}_postProcessGeometry(e){e.computeBoundingBox();const t=e.boundingBox,r=new THREE.Vector3;t.getCenter(r);const o=e.attributes.position.array;for(let e=0;e<o.length;e+=3)o[e]-=r.x,o[e+1]-=r.y,o[e+2]-=r.z;e.attributes.position.needsUpdate=!0,e.computeBoundingBox();const s=e.boundingBox,i=new THREE.Vector3;return s.getSize(i),{geometry:e,originalSize:i}}mergeGeometries(e){const t=new THREE.BufferGeometry,r=[],o=[];return e.forEach(e=>{const t=e.attributes.position,s=e.attributes.normal;for(let e=0;e<t.count;e++)r.push(t.getX(e),t.getY(e),t.getZ(e)),s&&o.push(s.getX(e),s.getY(e),s.getZ(e))}),t.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),o.length>0?t.setAttribute("normal",new THREE.Float32BufferAttribute(o,3)):t.computeVertexNormals(),t}isBinarySTL(e){const t=84+50*new DataView(e).getUint32(80,!0);return e.byteLength===t}parseBinarySTL(e){const t=new THREE.BufferGeometry,r=[],o=[],s=new DataView(e),i=s.getUint32(80,!0);let a=84;for(let e=0;e<i;e++){const e=[s.getFloat32(a,!0),s.getFloat32(a+4,!0),s.getFloat32(a+8,!0)];a+=12;for(let t=0;t<3;t++)r.push(s.getFloat32(a,!0),s.getFloat32(a+4,!0),s.getFloat32(a+8,!0)),o.push(...e),a+=12;a+=2}return t.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),t.setAttribute("normal",new THREE.Float32BufferAttribute(o,3)),t}parseASCIISTL(e){const t=(new TextDecoder).decode(e),r=new THREE.BufferGeometry,o=[],s=[],i=t.split("\n");let a=null;for(const e of i){const t=e.trim();if(t.startsWith("facet normal")){const e=t.split(/\s+/);a=[parseFloat(e[2]),parseFloat(e[3]),parseFloat(e[4])]}else if(t.startsWith("vertex")){const e=t.split(/\s+/);o.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),a&&s.push(...a)}}return 0===o.length?null:(r.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),s.length===o.length?r.setAttribute("normal",new THREE.Float32BufferAttribute(s,3)):r.computeVertexNormals(),r)}serializeGeometry(e){const t=e.attributes.position.array,r=e.index?e.index.array:null;return{positions:Array.from(t),indices:r?Array.from(r):null,boundingBox:e.boundingBox?{min:e.boundingBox.min.toArray(),max:e.boundingBox.max.toArray()}:null}}handleDrop(e){e.preventDefault(),e.stopPropagation();const t=e.dataTransfer.files;if(0===t.length)return;const r=t[0],o=r.name.split(".").pop().toLowerCase();if(!["stl","obj","3mf"].includes(o))return void this.editor.showStatus(`Неподдерживаемый формат файла: ${o}`,"warning");const s=this.editor.libraryManager.getDropPosition(e),i=new FileReader;i.onload=e=>{const t=e.target.result,o=this.importFromBuffer(t,r.name,s);if(o instanceof Promise)o.then(e=>{if(e.length>0){const t=this.editor.parametricModel.objectMap.get(e[0]);t&&this.editor.selectSingleObject(t)}});else if(o.length>0){const e=this.editor.parametricModel.objectMap.get(o[0]);e&&this.editor.selectSingleObject(e)}},i.readAsArrayBuffer(r)}}