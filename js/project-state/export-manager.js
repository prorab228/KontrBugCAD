class ExportManager{constructor(e){this.editor=e}showExportModal(){document.getElementById("exportModal").classList.add("active"),document.getElementById("exportFileName").value=document.getElementById("projectName").textContent.replace(/\s+/g,"_")}exportModel(){const e=document.getElementById("exportFormat").value,t=document.getElementById("exportSelected").checked,o=document.getElementById("exportFileName").value||"model";let r;if(r=t&&this.editor.selectedObjects.length>0?this.editor.selectedObjects:this.editor.objects.filter(e=>"sketch_plane"!==e.userData.type&&"work_plane"!==e.userData.type&&"sketch_element"!==e.userData.type),0!==r.length){switch(e){case"stl":case"stl-ascii":this.exportSTL(r,o,"stl-ascii"===e);break;case"obj":this.exportOBJ(r,o)}document.getElementById("exportModal").classList.remove("active")}else alert("Нет объектов для экспорта!")}exportSTL(e,t,o=!1){const r=new THREE.STLExporter,s=[],n=e=>{e.isMesh&&s.push(e),e.children&&e.children.length>0&&e.children.forEach(t=>{t!==e&&n(t)})};if(e.forEach(e=>{n(e)}),0===s.length)return void this.editor.showStatus("Нет мешей для экспорта","error");const a=new THREE.Group;s.forEach(e=>{const t=e.clone();e.updateMatrixWorld(!0),t.geometry=t.geometry.clone(),t.geometry.applyMatrix4(e.matrixWorld),this.fixNormalsAndOrientation(t.geometry),t.position.set(0,0,0),t.rotation.set(0,0,0),t.scale.set(1,1,1),t.updateMatrix(),a.add(t)}),a.rotation.x=Math.PI/2,a.updateMatrixWorld(!0);const i=r.parse(a,{binary:!o}),l=new Blob([i],{type:o?"text/plain":"application/octet-stream"});this.downloadFile(l,t+".stl"),this.editor.showStatus(`Экспорт STL завершен (${s.length} мешей)`,"success")}fixNormalsSimple(e){e=e.clone(),(e=THREE.BufferGeometryUtils.mergeVertices(e,.001)).computeVertexNormals(),e.computeBoundingBox();const t=e.boundingBox,o=new THREE.Vector3;t.getCenter(o);const r=e.index.array,s=e.attributes.position.array;let n=0;const a=r.length/3;for(let e=0;e<r.length;e+=3){const t=3*r[e],a=3*r[e+1],i=3*r[e+2],l=new THREE.Vector3(s[t],s[t+1],s[t+2]),c=new THREE.Vector3(s[a],s[a+1],s[a+2]),d=new THREE.Vector3(s[i],s[i+1],s[i+2]),p=(new THREE.Vector3).subVectors(c,l),m=(new THREE.Vector3).subVectors(d,l),h=(new THREE.Vector3).crossVectors(p,m).normalize(),u=(new THREE.Vector3).add(l).add(c).add(d).multiplyScalar(1/3),E=(new THREE.Vector3).subVectors(o,u).normalize();h.dot(E)>0&&([r[e+1],r[e+2]]=[r[e+2],r[e+1]],n++)}return console.log(`Перевернуто ${n} треугольников из ${a}`),e.computeVertexNormals(),e}exportOBJ(e,t){try{if(void 0===THREE.OBJExporter)return void this.editor.showStatus("OBJExporter не найден. Подключите three/examples/jsm/exporters/OBJExporter.js","error");const o=new THREE.OBJExporter,r=new THREE.Group;e.forEach(e=>{const t=e.clone();t.isMesh&&(t.geometry=t.geometry.clone(),t.geometry.applyMatrix4(t.matrixWorld),this.fixNormalsAndOrientation(t.geometry),t.position.set(0,0,0),t.rotation.set(0,0,0),t.scale.set(1,1,1),t.updateMatrix()),r.add(t)}),r.rotation.x=Math.PI/2,r.updateMatrixWorld(!0);const s=o.parse(r),n=this.createMTLContent(),a=`# Экспортировано из CAD приложения\nmtllib ${t}.mtl\n\n`+s,i=new JSZip;i.file(`${t}.obj`,a),i.file(`${t}.mtl`,n),i.generateAsync({type:"blob"}).then(e=>{this.downloadFile(e,`${t}.zip`),this.editor.showStatus("Экспорт OBJ завершен (включая материалы)","success")}).catch(e=>{console.error("Ошибка создания ZIP:",e);const o=new Blob([a],{type:"text/plain"});this.downloadFile(o,t+".obj"),this.editor.showStatus("Экспорт OBJ завершен (без материалов)","success")})}catch(e){console.error("Ошибка экспорта OBJ:",e),this.editor.showStatus("Ошибка экспорта OBJ","error")}}createMTLContent(){return"# Material file for CAD export\nnewmtl Material\nKa 0.2 0.2 0.2\nKd 0.8 0.8 0.8\nKs 0.5 0.5 0.5\nNs 32\nd 1.0\nillum 2\n"}exportSVG(){this.editor.showStatus("Экспорт SVG в разработке","info")}downloadFile(e,t){const o=document.createElement("a");o.href=URL.createObjectURL(e),o.download=t,document.body.appendChild(o),o.click(),document.body.removeChild(o)}}