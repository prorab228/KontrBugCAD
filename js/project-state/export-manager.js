class ExportManager{constructor(e){this.editor=e}showExportModal(){document.getElementById("exportModal").classList.add("active"),document.getElementById("exportFileName").value=document.getElementById("projectName").textContent.replace(/\s+/g,"_")}exportModel(){const e=document.getElementById("exportFormat").value,t=document.getElementById("exportSelected").checked,o=document.getElementById("exportFileName").value||"model";let r;if(r=t&&this.editor.selectedObjects.length>0?this.editor.selectedObjects:this.editor.objects.filter(e=>"sketch_plane"!==e.userData.type&&"work_plane"!==e.userData.type&&"sketch_element"!==e.userData.type),0!==r.length){switch(e){case"stl":case"stl-ascii":this.exportSTL(r,o,"stl-ascii"===e);break;case"obj":this.exportOBJ(r,o)}document.getElementById("exportModal").classList.remove("active")}else alert("Нет объектов для экспорта!")}fixNormalsAndOrientation(e){(e=e.clone()).index||(e=THREE.BufferGeometryUtils.mergeVertices(e,.01)),e.computeVertexNormals();const t=e.index?e.index.array:null,o=e.attributes.position.array,r=e.attributes.normal.array;let n=0,s=0;if(t){s=t.length/3;for(let e=0;e<t.length;e+=3){const s=3*t[e],a=3*t[e+1],c=3*t[e+2],l=new THREE.Vector3(o[s],o[s+1],o[s+2]),i=new THREE.Vector3(o[a],o[a+1],o[a+2]),d=new THREE.Vector3(o[c],o[c+1],o[c+2]),E=(new THREE.Vector3).subVectors(i,l),m=(new THREE.Vector3).subVectors(d,l),p=(new THREE.Vector3).crossVectors(E,m).normalize(),u=(new THREE.Vector3).add(l).add(i).add(d).multiplyScalar(1/3),h=new THREE.Vector3(r[s],r[s+1],r[s+2]),w=new THREE.Vector3(r[a],r[a+1],r[a+2]),x=new THREE.Vector3(r[c],r[c+1],r[c+2]),V=(new THREE.Vector3).add(h).add(w).add(x).multiplyScalar(1/3).normalize(),T=p.dot(V),y=p.dot(u.normalize());(T<-.5||y>0)&&([t[e+1],t[e+2]]=[t[e+2],t[e+1]],n++)}e.index&&(e.index.needsUpdate=!0)}else{s=o.length/9;for(let e=0;e<o.length;e+=9){const t=new THREE.Vector3(o[e],o[e+1],o[e+2]),s=new THREE.Vector3(o[e+3],o[e+4],o[e+5]),a=new THREE.Vector3(o[e+6],o[e+7],o[e+8]),c=(new THREE.Vector3).subVectors(s,t),l=(new THREE.Vector3).subVectors(a,t),i=(new THREE.Vector3).crossVectors(c,l).normalize(),d=(new THREE.Vector3).add(t).add(s).add(a).multiplyScalar(1/3),E=new THREE.Vector3(r[e],r[e+1],r[e+2]),m=new THREE.Vector3(r[e+3],r[e+4],r[e+5]),p=new THREE.Vector3(r[e+6],r[e+7],r[e+8]),u=(new THREE.Vector3).add(E).add(m).add(p).multiplyScalar(1/3).normalize(),h=i.dot(u),w=i.dot(d.normalize());if(h<-.5||w>0){const t=o[e+3],s=o[e+4],a=o[e+5];o[e+3]=o[e+6],o[e+4]=o[e+7],o[e+5]=o[e+8],o[e+6]=t,o[e+7]=s,o[e+8]=a;const c=r[e+3],l=r[e+4],i=r[e+5];r[e+3]=r[e+6],r[e+4]=r[e+7],r[e+5]=r[e+8],r[e+6]=c,r[e+7]=l,r[e+8]=i,n++}}e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0}return console.log(`Исправлено ${n} из ${s} треугольников`),e.computeVertexNormals(),e}exportSTL(e,t,o=!1){const r=new THREE.STLExporter,n=[],s=e=>{e.isMesh&&n.push(e),e.children&&e.children.length>0&&e.children.forEach(t=>{t!==e&&s(t)})};if(e.forEach(e=>{s(e)}),0===n.length)return void this.editor.showStatus("Нет мешей для экспорта","error");const a=new THREE.Group;n.forEach(e=>{const t=e.clone();e.updateMatrixWorld(!0),t.geometry=t.geometry.clone(),t.geometry.applyMatrix4(e.matrixWorld),this.fixNormalsAndOrientation(t.geometry),t.position.set(0,0,0),t.rotation.set(0,0,0),t.scale.set(1,1,1),t.updateMatrix(),a.add(t)}),a.rotation.x=Math.PI/2,a.updateMatrixWorld(!0);const c=r.parse(a,{binary:!o}),l=new Blob([c],{type:o?"text/plain":"application/octet-stream"});this.downloadFile(l,t+".stl"),this.editor.showStatus(`Экспорт STL завершен (${n.length} мешей)`,"success")}fixNormalsSimple(e){e=e.clone(),(e=THREE.BufferGeometryUtils.mergeVertices(e,.001)).computeVertexNormals(),e.computeBoundingBox();const t=e.boundingBox,o=new THREE.Vector3;t.getCenter(o);const r=e.index.array,n=e.attributes.position.array;let s=0;const a=r.length/3;for(let e=0;e<r.length;e+=3){const t=3*r[e],a=3*r[e+1],c=3*r[e+2],l=new THREE.Vector3(n[t],n[t+1],n[t+2]),i=new THREE.Vector3(n[a],n[a+1],n[a+2]),d=new THREE.Vector3(n[c],n[c+1],n[c+2]),E=(new THREE.Vector3).subVectors(i,l),m=(new THREE.Vector3).subVectors(d,l),p=(new THREE.Vector3).crossVectors(E,m).normalize(),u=(new THREE.Vector3).add(l).add(i).add(d).multiplyScalar(1/3),h=(new THREE.Vector3).subVectors(o,u).normalize();p.dot(h)>0&&([r[e+1],r[e+2]]=[r[e+2],r[e+1]],s++)}return console.log(`Перевернуто ${s} треугольников из ${a}`),e.computeVertexNormals(),e}exportOBJ(e,t){try{if(void 0===THREE.OBJExporter)return void this.editor.showStatus("OBJExporter не найден. Подключите three/examples/jsm/exporters/OBJExporter.js","error");const o=new THREE.OBJExporter,r=new THREE.Group;e.forEach(e=>{const t=e.clone();t.isMesh&&(t.geometry=t.geometry.clone(),t.geometry.applyMatrix4(t.matrixWorld),this.fixNormalsAndOrientation(t.geometry),t.position.set(0,0,0),t.rotation.set(0,0,0),t.scale.set(1,1,1),t.updateMatrix()),r.add(t)}),r.rotation.x=Math.PI/2,r.updateMatrixWorld(!0);const n=o.parse(r),s=this.createMTLContent(),a=`# Экспортировано из CAD приложения\nmtllib ${t}.mtl\n\n`+n,c=new JSZip;c.file(`${t}.obj`,a),c.file(`${t}.mtl`,s),c.generateAsync({type:"blob"}).then(e=>{this.downloadFile(e,`${t}.zip`),this.editor.showStatus("Экспорт OBJ завершен (включая материалы)","success")}).catch(e=>{console.error("Ошибка создания ZIP:",e);const o=new Blob([a],{type:"text/plain"});this.downloadFile(o,t+".obj"),this.editor.showStatus("Экспорт OBJ завершен (без материалов)","success")})}catch(e){console.error("Ошибка экспорта OBJ:",e),this.editor.showStatus("Ошибка экспорта OBJ","error")}}createMTLContent(){return"# Material file for CAD export\nnewmtl Material\nKa 0.2 0.2 0.2\nKd 0.8 0.8 0.8\nKs 0.5 0.5 0.5\nNs 32\nd 1.0\nillum 2\n"}exportSVG(){this.editor.showStatus("Экспорт SVG в разработке","info")}downloadFile(e,t){const o=document.createElement("a");o.href=URL.createObjectURL(e),o.download=t,document.body.appendChild(o),o.click(),document.body.removeChild(o)}}