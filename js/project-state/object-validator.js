class ObjectValidator{constructor(){console.log("ObjectValidator initialized")}deepCleanAndValidateObject(e){if(!e)return e;try{const i={};for(const t in e)if(e.hasOwnProperty(t)){const r=e[t];if("function"==typeof r||void 0===r)continue;if(null===r){i[t]=null;continue}if("string"==typeof r||"number"==typeof r||"boolean"==typeof r){"number"!=typeof r||isFinite(r)?i[t]=r:i[t]=0;continue}if(Array.isArray(r)){const e=r.map(e=>e&&"object"==typeof e?this.deepCleanAndValidateObject(e):"number"!=typeof e||isFinite(e)?e:0).filter(e=>void 0!==e);i[t]=e;continue}"object"==typeof r&&(i[t]=this.deepCleanAndValidateObject(r))}return i}catch(e){return console.warn("Error in deepCleanAndValidateObject:",e),{}}}validateVector3(e){try{return e?e.isVector3?new THREE.Vector3(isFinite(e.x)?e.x:0,isFinite(e.y)?e.y:0,isFinite(e.z)?e.z:0):Array.isArray(e)?new THREE.Vector3(isFinite(e[0])?e[0]:0,isFinite(e[1])?e[1]:0,isFinite(e[2])?e[2]:0):void 0!==e.x&&void 0!==e.y?new THREE.Vector3(isFinite(e.x)?e.x:0,isFinite(e.y)?e.y:0,isFinite(e.z)?e.z:0):new THREE.Vector3(0,0,0):new THREE.Vector3(0,0,0)}catch(i){return console.warn("Error validating Vector3:",i,e),new THREE.Vector3(0,0,0)}}validateColor(e){try{if(!e)return new THREE.Color(8421504);if(e.isColor)return new THREE.Color(e.r,e.g,e.b);if("number"==typeof e)return new THREE.Color(e);if("string"==typeof e)return new THREE.Color(e);if(Array.isArray(e)&&e.length>=3){const[i,t,r]=e;return i>1||t>1||r>1?new THREE.Color(i/255,t/255,r/255):new THREE.Color(i,t,r)}return new THREE.Color(8421504)}catch(i){return console.warn("Error validating color:",i,e),new THREE.Color(8421504)}}validateAndFixMesh(e){if(e)try{e.position&&e.position.isVector3?(e.position.x=isFinite(e.position.x)?e.position.x:0,e.position.y=isFinite(e.position.y)?e.position.y:0,e.position.z=isFinite(e.position.z)?e.position.z:0):e.position=new THREE.Vector3(0,0,0),e.scale&&e.scale.isVector3?(e.scale.x=isFinite(e.scale.x)?Math.max(.001,e.scale.x):1,e.scale.y=isFinite(e.scale.y)?Math.max(.001,e.scale.y):1,e.scale.z=isFinite(e.scale.z)?Math.max(.001,e.scale.z):1):e.scale=new THREE.Vector3(1,1,1),e.quaternion&&e.quaternion.isQuaternion?e.quaternion.length()>0&&e.quaternion.normalize():e.quaternion=new THREE.Quaternion,e.material&&this.validateAndFixMaterial(e.material),e.geometry&&this.validateAndFixGeometry(e.geometry),e.updateMatrix(),e.updateMatrixWorld(!0)}catch(i){console.warn("Error validating mesh:",i,e)}}validateAndFixMaterial(e){if(e)try{e.color&&!e.color.isColor&&(e.color=this.validateColor(e.color)),void 0!==e.opacity&&(e.opacity=Math.max(0,Math.min(1,isFinite(e.opacity)?e.opacity:1))),e.opacity<1&&(e.transparent=!0),(e.isLineBasicMaterial||e.isLineDashedMaterial)&&void 0!==e.linewidth&&(e.linewidth=Math.max(.1,isFinite(e.linewidth)?e.linewidth:1)),e.needsUpdate=!0}catch(i){console.warn("Error validating material:",i,e)}}validateAndFixGeometry(e){if(e)try{if(e.attributes&&e.attributes.position){const i=e.attributes.position.array;for(let e=0;e<i.length;e++)isFinite(i[e])||(i[e]=0);e.attributes.position.needsUpdate=!0}if(e.attributes&&e.attributes.normal){const i=e.attributes.normal.array;for(let e=0;e<i.length;e++)isFinite(i[e])||(i[e]=0);for(let e=0;e<i.length;e+=3){const t=i[e],r=i[e+1],n=i[e+2],a=Math.sqrt(t*t+r*r+n*n);a>0&&(i[e]=t/a,i[e+1]=r/a,i[e+2]=n/a)}e.attributes.normal.needsUpdate=!0}e.computeBoundingBox(),e.computeBoundingSphere()}catch(i){console.warn("Error validating geometry:",i,e)}}cleanWebGLFields(e){if(!e||"object"!=typeof e)return e;const i=["__webglActive","__webglInit","__webglColorCache","program","shader","uniforms","attributes","frame","onBeforeCompile","customProgramCacheKey"];for(const t of i)delete e[t];for(const i in e)e.hasOwnProperty(i)&&e[i]&&"object"==typeof e[i]&&(e[i]=this.cleanWebGLFields(e[i]));return e}clearWebGLCache(){try{THREE.Cache&&THREE.Cache.clear&&THREE.Cache.clear(),THREE.UniformsLib&&THREE.UniformsLib.clear&&THREE.UniformsLib.clear(),console.log("WebGL cache cleared")}catch(e){console.warn("Error clearing WebGL cache:",e)}}prepareObjectForSerialization(e){try{const i=this.deepCleanAndValidateObject(e),t=this.cleanWebGLFields(i);return this.validateNumericValues(t),t}catch(e){return console.warn("Error preparing object for serialization:",e),{}}}validateNumericValues(e){if(e&&"object"==typeof e)for(const i in e)if(e.hasOwnProperty(i)){const t=e[i];"number"!=typeof t||isFinite(t)?Array.isArray(t)?e[i]=t.map(e=>"number"!=typeof e||isFinite(e)?e:0):t&&"object"==typeof t&&this.validateNumericValues(t):e[i]=0}}validateTransform(e){if(!e)return!1;try{return[()=>e.position&&e.position.isVector3,()=>isFinite(e.position.x)&&isFinite(e.position.y)&&isFinite(e.position.z),()=>e.scale&&e.scale.isVector3,()=>isFinite(e.scale.x)&&isFinite(e.scale.y)&&isFinite(e.scale.z),()=>e.scale.x>0&&e.scale.y>0&&e.scale.z>0,()=>e.quaternion&&e.quaternion.isQuaternion,()=>isFinite(e.quaternion.x)&&isFinite(e.quaternion.y)&&isFinite(e.quaternion.z)&&isFinite(e.quaternion.w)].every(e=>e())}catch(e){return console.warn("Error validating transform:",e),!1}}createDefaultMaterial(e="MeshPhongMaterial"){try{switch(e){case"LineBasicMaterial":return new THREE.LineBasicMaterial({color:1118481,linewidth:2});case"LineDashedMaterial":return new THREE.LineDashedMaterial({color:1118481,linewidth:2,dashSize:3,gapSize:1,scale:1});case"MeshBasicMaterial":return new THREE.MeshBasicMaterial({color:8421504});case"MeshStandardMaterial":return new THREE.MeshStandardMaterial({color:8421504,metalness:.5,roughness:.5});default:return new THREE.MeshPhongMaterial({color:8421504,shininess:30,specular:new THREE.Color(1118481)})}}catch(e){return console.warn("Error creating default material:",e),new THREE.MeshPhongMaterial({color:8421504})}}}