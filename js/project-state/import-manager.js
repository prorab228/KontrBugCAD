class ImportManager{constructor(t){this.editor=t,this.projectManager=t.projectManager}openSTL(){const t=document.createElement("input");t.type="file",t.accept=".stl",t.onchange=t=>{const e=t.target.files[0];if(!e)return;const o=new FileReader;o.onload=t=>{this.loadSTLFromBuffer(t.target.result,e.name)},o.readAsArrayBuffer(e)},t.click()}loadSTLFromBuffer(t,e){try{const o=this.isBinarySTL(t)?this.parseBinarySTL(t):this.parseASCIISTL(t);if(!o)return void this.editor.showStatus("Ошибка при чтении STL файла","error");o.computeBoundingBox();const r=o.boundingBox,s=new THREE.Vector3;r.getCenter(s);const i=o.attributes.position.array;for(let t=0;t<i.length;t+=3)i[t]-=s.x,i[t+1]-=s.y,i[t+2]-=s.z;o.attributes.position.needsUpdate=!0,o.computeBoundingBox(),o.rotateX(-Math.PI/2);const n=new THREE.MeshPhongMaterial({color:new THREE.Color("#AAAAAA"),transparent:!0,opacity:.9,side:THREE.DoubleSide,shininess:30}),a=new THREE.Mesh(o,n);a.castShadow=!0,a.receiveShadow=!0,o.computeBoundingBox();const c=o.boundingBox,l=new THREE.Vector3;c.getSize(l),a.position.y=l.y/2,a.userData={id:"stl_"+Date.now(),name:e.replace(".stl",""),type:"stl",createdAt:(new Date).toISOString(),unit:"mm",filename:e,originalGeometry:o},this.editor.objectsGroup.add(a),this.editor.objects.push(a),this.editor.clearSelection(),this.editor.selectSingleObject(a),this.editor.objectsManager&&(this.editor.objectsManager.updateSceneStats(),this.editor.objectsManager.updateSceneList()),this.editor.showStatus(`Загружен STL: ${e}`,"success"),this.editor.history&&this.editor.history.addAction({type:"import",format:"stl",object:a.uuid,data:this.editor.projectManager.serializeObjectForHistory(a)})}catch(t){console.error("STL loading error:",t),this.editor.showStatus(`Ошибка загрузки STL: ${t.message}`,"error")}}isBinarySTL(t){const e=84+50*new DataView(t).getUint32(80,!0);return t.byteLength===e}parseBinarySTL(t){const e=new THREE.BufferGeometry,o=[],r=[],s=new DataView(t),i=s.getUint32(80,!0);let n=84;for(let t=0;t<i;t++){const t=[s.getFloat32(n,!0),s.getFloat32(n+4,!0),s.getFloat32(n+8,!0)];n+=12;for(let e=0;e<3;e++)o.push(s.getFloat32(n,!0),s.getFloat32(n+4,!0),s.getFloat32(n+8,!0)),r.push(...t),n+=12;n+=2}return e.setAttribute("position",new THREE.Float32BufferAttribute(o,3)),e.setAttribute("normal",new THREE.Float32BufferAttribute(r,3)),e.computeBoundingBox(),e.computeBoundingSphere(),e}parseASCIISTL(t){const e=(new TextDecoder).decode(t),o=new THREE.BufferGeometry,r=[],s=[],i=e.split("\n");let n=null;for(const t of i){const e=t.trim();if(e.startsWith("facet normal")){const t=e.split(/\s+/);n=[parseFloat(t[2]),parseFloat(t[3]),parseFloat(t[4])]}else if(e.startsWith("vertex")){const t=e.split(/\s+/);r.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),n&&s.push(...n)}}return 0===r.length?null:(o.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),s.length===r.length?o.setAttribute("normal",new THREE.Float32BufferAttribute(s,3)):o.computeVertexNormals(),o.computeBoundingBox(),o.computeBoundingSphere(),o)}}