THREE.SimplifyModifier=function(){class t{constructor(t=0,e=0,o=0,n=0,i=0,r=0,s=0,l=0,f=0,c=0){this.m=new Float32Array(10),this.set(t,e,o,n,i,r,s,l,f,c)}set(t,e,o,n,i,r,s,l,f,c){const m=this.m;m[0]=t,m[1]=e,m[2]=o,m[3]=n,m[4]=i,m[5]=r,m[6]=s,m[7]=l,m[8]=f,m[9]=c}determinant(){const t=this.m;return t[0]*t[4]*t[7]+t[1]*t[5]*t[8]+t[2]*t[6]*t[9]-t[2]*t[4]*t[9]-t[1]*t[6]*t[7]-t[0]*t[5]*t[8]}}class e{constructor(){this.p=new THREE.Vector3,this.t=new Array,this.q=new t,this.border=!1,this.index=0}}class o{constructor(t,e,o){this.v=[t,e,o],this.err=new Array(4),this.deleted=!1,this.dirty=!1,this.normal=new THREE.Vector3}}function n(){}return n.prototype.modify=function(t,n){if(!0===t.isGeometry)return void console.error("THREE.SimplifyModifier no longer supports Geometry. Use BufferGeometry instead.");const i=(t=t.clone()).attributes;if(void 0===i.position||3!==i.position.itemSize)return console.error("THREE.SimplifyModifier: position attribute of size 3 is required."),t;const r=new Array(i.position.count),s=new Array(t.index?t.index.count/3:i.position.count/3);for(let t=0;t<i.position.count;t++){const o=new e;o.p.fromBufferAttribute(i.position,t),o.index=t,r[t]=o}let l=t.index;if(null===l){const e=new Uint32Array(i.position.count);for(let t=0;t<e.length;t++)e[t]=t;l=new THREE.BufferAttribute(e,1),t.setIndex(l)}for(let t=0;t<l.count;t+=3){const e=l.getX(t),n=l.getX(t+1),i=l.getX(t+2),f=new o(r[e],r[n],r[i]);s[t/3]=f}this.computeEdgeCostAtVertex(r[0]);const f=s.length;for(let t=0;t<f-n;t++){let t=null,e=1/0;for(let o=0;o<r.length;o++){const n=r[o];if(n.border)continue;const i=n.q.determinant();i<e&&(e=i,t=n)}if(null===t)break;this.collapse(s,r,t,t.collapseNeighbor)}return this.toBufferGeometry(s,r,t)},n.prototype.computeEdgeCostAtVertex=function(t){if(0!==t.t.length){t.q.set(0,0,0,0,0,0,0,0,0,0);for(let e=0;e<t.t.length;e++){const o=t.t[e];o.q.set(0,0,0,0,0,0,0,0,0,0);const n=o.v[0].p,i=o.v[1].p,r=o.v[2].p,s=i.x-n.x,l=i.y-n.y,f=i.z-n.z,c=r.x-n.x,m=r.y-n.y,u=r.z-n.z;o.q.m[0]=s*s+l*l+f*f,o.q.m[1]=s*c+l*m+f*u,o.q.m[2]=s,o.q.m[3]=c,o.q.m[4]=c*c+m*m+u*u,o.q.m[5]=l,o.q.m[6]=m,o.q.m[7]=1,o.q.m[8]=0,o.q.m[9]=0,t.q.m[0]+=o.q.m[0],t.q.m[1]+=o.q.m[1],t.q.m[2]+=o.q.m[2],t.q.m[3]+=o.q.m[3],t.q.m[4]+=o.q.m[4],t.q.m[5]+=o.q.m[5],t.q.m[6]+=o.q.m[6],t.q.m[7]+=o.q.m[7],t.q.m[8]+=o.q.m[8],t.q.m[9]+=o.q.m[9]}}},n.prototype.collapse=function(t,e,o,n){if(!n){for(let t=0;t<o.t.length;t++){o.t[t].deleted=!0}return}o.p.copy(n.p);let i=new Array;for(let t=0;t<o.t.length;t++){const e=o.t[t];e.v[0]!==n&&e.v[1]!==n&&e.v[2]!==n||(e.deleted=!0,i.push(e))}for(let t=0;t<n.t.length;t++){const e=n.t[t];if(!e.deleted){for(let t=0;t<3;t++)e.v[t]===n&&(e.v[t]=o);o.t.push(e)}}for(let t=0;t<i.length;t++){const e=o.t.indexOf(i[t]);e>-1&&o.t.splice(e,1)}const r=e.indexOf(n);r>-1&&e.splice(r,1)},n.prototype.toBufferGeometry=function(t,e,o){const n=new Uint32Array(3*t.length);let i=0;for(let e=0;e<t.length;e++){const o=t[e];if(!o.deleted)for(let t=0;t<3;t++)n[i++]=o.v[t].index}const r=new Float32Array(3*e.length);for(let t=0;t<e.length;t++){const o=e[t];r[3*t]=o.p.x,r[3*t+1]=o.p.y,r[3*t+2]=o.p.z}const s=new THREE.BufferGeometry;s.setIndex(new THREE.BufferAttribute(n.slice(0,i),1)),s.setAttribute("position",new THREE.BufferAttribute(r,3));const l=o.attributes;for(const t in l)if("position"!==t&&"index"!==t){const o=l[t],n=new THREE.BufferAttribute(new Float32Array(e.length*o.itemSize),o.itemSize);for(let t=0;t<e.length;t++){const i=e[t].index;for(let e=0;e<o.itemSize;e++)n.array[t*o.itemSize+e]=o.array[i*o.itemSize+e]}s.setAttribute(t,n)}return s.computeVertexNormals(),s.computeBoundingBox(),s.computeBoundingSphere(),s},n}(),"undefined"!=typeof window&&(window.SimplifyModifier=THREE.SimplifyModifier);