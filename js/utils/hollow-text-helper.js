class HollowTextHelper{constructor(){}static createHollowTextWithCSG(e,t,r){const{size:n=10,depth:s=2,wallThickness:l=1,bottomEnabled:a=!0,bottomThickness:o=1,outerBevel:u=!1,innerBevel:i=!1,curveSegments:h=12,bevelThickness:c=.1,bevelSize:E=.05}=r,m=t.generateShapes(e,n),p={depth:s,bevelEnabled:u,bevelThickness:c,bevelSize:E,curveSegments:h,steps:1},b=new THREE.ExtrudeGeometry(m,p),y=1-l/n*2,f=this.scaleShapes(m,y),v={depth:a?s-o:s,bevelEnabled:i,bevelThickness:.5*c,bevelSize:.5*E,curveSegments:h,steps:1},g=new THREE.ExtrudeGeometry(f,v);if(a&&g.translate(0,0,o),"undefined"==typeof ThreeCSG)return this.mergeGeometries(b,g);try{const e=new THREE.Mesh(b),t=new THREE.Mesh(g),r=new ThreeCSG(e),n=new ThreeCSG(t),s=r.subtract(n);return s.toGeometry()}catch(e){return console.error("Ошибка при использовании ThreeCSG:",e),this.mergeGeometries(b,g)}}static scaleShapes(e,t){const r=[];return e.forEach(e=>{const n=e.clone();n.curves.forEach(e=>{e.v0&&e.v0.multiplyScalar(t),e.v1&&e.v1.multiplyScalar(t),e.v2&&e.v2.multiplyScalar(t),e.v3&&e.v3.multiplyScalar(t)}),r.push(n)}),r}static mergeGeometries(e,t){const r=new THREE.BufferGeometry,n=e.attributes.position.array,s=e.attributes.normal?e.attributes.normal.array:null,l=e.index?e.index.array:null,a=t.attributes.position.array,o=t.attributes.normal?t.attributes.normal.array:null,u=t.index?t.index.array:null,i=new Float32Array(n.length+a.length);i.set(n,0),i.set(a,n.length);let h=null;s&&o&&(h=new Float32Array(s.length+o.length),h.set(s,0),h.set(o,s.length));let c=null;if(l&&u){const e=n.length/3;c=new Uint32Array(l.length+u.length),c.set(l,0);for(let t=0;t<u.length;t++)c[l.length+t]=u[t]+e}return r.setAttribute("position",new THREE.BufferAttribute(i,3)),h&&r.setAttribute("normal",new THREE.BufferAttribute(h,3)),c&&r.setIndex(new THREE.BufferAttribute(c,1)),r.computeBoundingSphere(),r}static createWallGeometry(e,t,r,n=12){const s=new THREE.BufferGeometry,l=[],a=[],o=[];return e.forEach(e=>{e.curves.forEach((e,r)=>{const s=this.sampleCurve(e,n);for(let e=0;e<s.length-1;e++){const r=s[e],n=s[e+1];l.push(r.x,r.y,0),l.push(n.x,n.y,0),l.push(n.x,n.y,t),l.push(r.x,r.y,t);const u=n.x-r.x,i=n.y-r.y,h=Math.sqrt(u*u+i*i),c=-i/h,E=u/h;for(let e=0;e<4;e++)a.push(c,E,0);const m=l.length/3-4;o.push(m,m+1,m+2,m,m+2,m+3)}})}),s.setAttribute("position",new THREE.Float32BufferAttribute(l,3)),s.setAttribute("normal",new THREE.Float32BufferAttribute(a,3)),s.setIndex(o),s}static sampleCurve(e,t){const r=[];for(let n=0;n<=t;n++){const s=n/t,l=e.getPoint(s);r.push(l)}return r}}